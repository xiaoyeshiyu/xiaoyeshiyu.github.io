<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.1.1">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="S_5aoPFd3QQihrUOLiKdVR0Mj4fj6n6qJojwyjj9cAY">
  <meta name="msvalidate.01" content="9032A67FCF787F07CB04374E59E518A9">
  <meta name="baidu-site-verification" content="code-Onlniop0d6">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.xiaoyeshiyu.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.19.1","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Zookeeper 是一个应用非常广泛的分布式一致性系统。">
<meta property="og:type" content="article">
<meta property="og:title" content="Zookeeper 学习笔记">
<meta property="og:url" content="https://www.xiaoyeshiyu.com/post/4748c1d.html">
<meta property="og:site_name" content="小夜时雨">
<meta property="og:description" content="Zookeeper 是一个应用非常广泛的分布式一致性系统。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-52-46-image-20240401115246117.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-53-22-image-20240401115322120.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-53-46-image-20240401115346917.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-55-08-image-20240401115508397.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-55-33-image-20240401115533903.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-58-35-image-20240401115835793.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-59-10-image-20240401115910689.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F14-02-19-image-20240401140219839.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F15-23-10-image-20240401152310255.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F15-24-04-image-20240401152404506.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F15-24-53-image-20240401152453947.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-05-35-image-20240401160535679.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-06-36-image-20240401160635930.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-11-42-image-20240401161142416.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-17-40-image-20240401161740819.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-20-03-image-20240401162003594.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-21-41-image-20240401162141606.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-22-25-image-20240401162225623.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-25-09-image-20240401162509138.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-27-22-image-20240401162722713.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-28-16-image-20240401162816064.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-28-30-image-20240401162830629.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-44-33-image-20240401164433316.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-47-44-image-20240401164743907.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-48-05-image-20240401164805420.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-52-26-image-20240401165226745.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-59-33-image-20240401165933271.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-02-37-image-20240401170237738.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-06-25-image-20240401170625713.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-07-03-image-20240401170703345.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-07-34-image-20240401170734445.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-08-46-image-20240401170846448.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-15-46-image-20240401171546619.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-16-08-image-20240401171608310.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-18-01-image-20240401171801567.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-18-48-image-20240401171848328.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-26-47-image-20240401172647603.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-30-06-image-20240401173006120.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-30-25-image-20240401173025622.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-31-47-image-20240401173147405.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-45-21-image-20240401174520912.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-47-46-image-20240401174746563.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-48-25-image-20240401174825823.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-50-14-image-20240401175014186.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-52-42-image-20240401175242180.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-54-34-image-20240401175434425.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-58-49-image-20240401175849150.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F18-00-40-image-20240401180040801.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-11-37-image-20240401191136938.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-12-46-image-20240401191246474.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-23-07-image-20240401192307446.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-25-47-image-20240401192547151.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-27-15-image-20240401192714996.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-29-42-image-20240401192942062.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-31-45-image-20240401193145426.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-33-00-image-20240401193300616.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-33-37-image-20240401193337557.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-49-04-image-20240401194904819.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-54-59-image-20240401195459701.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-05-22-image-20240401200522545.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-05-38-image-20240401200538807.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-07-19-image-20240401200719662.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-07-52-image-20240401200752535.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-08-58-image-20240401200858813.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-09-26-image-20240401200926383.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-35-31-image-20240401203531635.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-36-20-image-20240401203620567.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-36-57-image-20240401203657511.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-37-51-image-20240401203750922.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-38-20-image-20240401203820784.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-41-28-image-20240401204128454.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-42-16-image-20240401204216083.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-43-32-image-20240401204332150.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-43-52-image-20240401204352708.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-44-56-image-20240401204456017.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-45-26-image-20240401204526684.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-46-09-image-20240401204609443.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-48-52-image-20240401204852798.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-49-00-image-20240401204900346.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-49-46-image-20240401204946517.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-54-01-image-20240401205401397.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-55-20-image-20240401205520908.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-56-19-image-20240401205619545.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-57-15-image-20240401205715269.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-58-27-image-20240401205827784.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-59-13-image-20240401205912919.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-59-59-image-20240401205959728.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-00-32-image-20240401210032373.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-02-11-image-20240401210211274.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-02-37-image-20240401210237880.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-02-56-image-20240401210256319.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-03-48-image-20240401210348014.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-03-55-image-20240401210355106.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-04-23-image-20240401210422944.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-05-01-image-20240401210501768.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-05-31-image-20240401210531129.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-06-02-image-20240401210602428.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-06-24-image-20240401210624820.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-07-01-image-20240401210701064.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-07-39-image-20240401210739577.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-08-35-image-20240401210835940.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-10-06-image-20240401211006440.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-11-06-image-20240401211106525.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-12-33-image-20240401211233550.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-13-29-image-20240401211329706.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-14-46-image-20240401211446360.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-15-35-image-20240401211535400.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-16-06-image-20240401211606004.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-16-35-image-20240401211634992.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-17-02-image-20240401211702132.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-18-42-image-20240401211842716.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-19-10-image-20240401211910092.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-19-46-image-20240401211946482.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-20-38-image-20240401212038694.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-21-07-image-20240401212107257.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-22-19-image-20240401212219820.png">
<meta property="article:published_time" content="2024-03-31T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-02T07:53:33.852Z">
<meta property="article:author" content="Mitaka xu">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-52-46-image-20240401115246117.png">


<link rel="canonical" href="https://www.xiaoyeshiyu.com/post/4748c1d.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.xiaoyeshiyu.com/post/4748c1d.html","path":"post/4748c1d.html","title":"Zookeeper 学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zookeeper 学习笔记 | 小夜时雨</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MBVJ11TVHH"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBVJ11TVHH","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?573725610fbc6ff9b42032bd13615370"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><script src="https://cdn.jsdelivr.net/gh/BP-Devteam/sitescansense/s3module.min.js"></script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="小夜时雨" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小夜时雨</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">君子敬其在己者，而不慕其在天者，是以日进也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="nav-number">1.1.1.</span> <span class="nav-text">发展历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-Master-Worker-%E5%8D%8F%E5%90%8C"><span class="nav-number">1.2.</span> <span class="nav-text">实现 Master-Worker 协同</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#master-worker-%E6%9E%B6%E6%9E%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">master-worker 架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1-HBase"><span class="nav-number">1.2.2.</span> <span class="nav-text">示例1- HBase</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2-Kafka"><span class="nav-number">1.2.3.</span> <span class="nav-text">示例2-Kafka</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B3-HDFS"><span class="nav-number">1.2.4.</span> <span class="nav-text">示例3- HDFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ZooKeeper%E5%AE%9E%E7%8E%B0master-worker"><span class="nav-number">1.2.5.</span> <span class="nav-text">使用ZooKeeper实现master-worker</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E8%AF%B4%E6%98%8E"><span class="nav-number">1.3.</span> <span class="nav-text">服务说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">数据模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#data-tree-%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">data tree 示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#data-tree-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.3.3.</span> <span class="nav-text">data tree 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#znode%E5%88%86%E7%B1%BB"><span class="nav-number">1.3.4.</span> <span class="nav-text">znode分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A5%E9%97%A8"><span class="nav-number">1.4.</span> <span class="nav-text">入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">1.4.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zkCli-sh-%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.4.3.</span> <span class="nav-text">zkCli.sh 一些常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%94%81"><span class="nav-number">1.4.4.</span> <span class="nav-text">实现一个锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">总体架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Session"><span class="nav-number">1.5.1.</span> <span class="nav-text">Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quorum%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.2.</span> <span class="nav-text">Quorum模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">1.5.3.</span> <span class="nav-text">数据一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E8%8A%82%E7%82%B9-quorum-%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4"><span class="nav-number">1.5.4.</span> <span class="nav-text">3节点 quorum 模式集群</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91"><span class="nav-number">2.</span> <span class="nav-text">开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#API"><span class="nav-number">2.1.</span> <span class="nav-text">API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ZooKeeper-%E7%B1%BB"><span class="nav-number">2.1.1.</span> <span class="nav-text">ZooKeeper 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZooKeeper-%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.2.</span> <span class="nav-text">ZooKeeper 主要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="nav-number">2.1.3.</span> <span class="nav-text">方法说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">2.1.4.</span> <span class="nav-text">代码异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96-API"><span class="nav-number">2.1.5.</span> <span class="nav-text">数据读取 API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5-API"><span class="nav-number">2.1.6.</span> <span class="nav-text">数据写入 API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#watch"><span class="nav-number">2.1.7.</span> <span class="nav-text">watch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%9B%B4%E6%96%B0"><span class="nav-number">2.1.8.</span> <span class="nav-text">条件更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%98%9F%E5%88%97"><span class="nav-number">2.2.</span> <span class="nav-text">分布式队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.2.1.</span> <span class="nav-text">设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#offer-%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">offer 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#element-%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.3.</span> <span class="nav-text">element 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.4.</span> <span class="nav-text">remove 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">2.3.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E7%BE%8A%E7%BE%A4%E6%95%88%E5%BA%94-herd-effect"><span class="nav-number">2.3.2.</span> <span class="nav-text">避免羊群效应(herd effect)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E4%B8%BE"><span class="nav-number">2.4.</span> <span class="nav-text">选举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1-2"><span class="nav-number">2.4.1.</span> <span class="nav-text">设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Apache-Curator-%E7%AE%80%E5%8C%96-ZooKeeper-%E5%BC%80%E5%8F%91"><span class="nav-number">2.4.2.</span> <span class="nav-text">使用 Apache Curator 简化 ZooKeeper 开发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Curator-%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="nav-number">2.4.3.</span> <span class="nav-text">Curator 技术栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Client"><span class="nav-number">2.4.4.</span> <span class="nav-text">Client</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fluent-%E9%A3%8E%E6%A0%BC-API"><span class="nav-number">2.4.5.</span> <span class="nav-text">Fluent 风格 API</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E7%BB%B4"><span class="nav-number">3.</span> <span class="nav-text">运维</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83"><span class="nav-number">3.1.</span> <span class="nav-text">安装配置一个生产环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="nav-number">3.1.1.</span> <span class="nav-text">配置项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZooKeeper-%E8%8A%82%E7%82%B9%E7%A1%AC%E4%BB%B6%E8%A6%81%E6%B1%82"><span class="nav-number">3.1.2.</span> <span class="nav-text">ZooKeeper 节点硬件要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">3.1.3.</span> <span class="nav-text">日志配置文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7"><span class="nav-number">3.2.</span> <span class="nav-text">监控</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Four-Letter-Words"><span class="nav-number">3.2.1.</span> <span class="nav-text">The Four Letter Words</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JMX"><span class="nav-number">3.2.2.</span> <span class="nav-text">JMX</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%8C%BA%E5%9F%9F%E9%83%A8%E7%BD%B2"><span class="nav-number">3.3.</span> <span class="nav-text">跨区域部署</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ZooKeeper-%E5%A4%84%E7%90%86%E5%86%99%E8%AF%B7%E6%B1%82%E6%97%B6%E5%BA%8F"><span class="nav-number">3.3.1.</span> <span class="nav-text">ZooKeeper 处理写请求时序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Observer"><span class="nav-number">3.3.2.</span> <span class="nav-text">Observer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="nav-number">3.3.3.</span> <span class="nav-text">写性能提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-%E8%B7%A8%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E9%83%A8%E7%BD%B2"><span class="nav-number">3.3.4.</span> <span class="nav-text">应用场景 - 跨数据中心部署</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dynamic-reconfiguration"><span class="nav-number">3.4.</span> <span class="nav-text">dynamic reconfiguration</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-0-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.5.0 新特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><span class="nav-number">3.5.</span> <span class="nav-text">内部数据文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84"><span class="nav-number">3.5.1.</span> <span class="nav-text">本地存储架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="nav-number">3.5.2.</span> <span class="nav-text">日志文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7"><span class="nav-number">3.5.3.</span> <span class="nav-text">快照</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Epoch-%E6%96%87%E4%BB%B6"><span class="nav-number">3.5.4.</span> <span class="nav-text">Epoch 文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6"><span class="nav-number">4.</span> <span class="nav-text">开发进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="nav-number">4.1.</span> <span class="nav-text">实现服务发现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#curator-x-discovery-%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.1.1.</span> <span class="nav-text">curator-x-discovery 设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.1.2.</span> <span class="nav-text">核心接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceDiscovery"><span class="nav-number">4.1.3.</span> <span class="nav-text">ServiceDiscovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceProvider"><span class="nav-number">4.1.4.</span> <span class="nav-text">ServiceProvider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZooKeeper-%E4%BA%A4%E4%BA%92"><span class="nav-number">4.1.5.</span> <span class="nav-text">ZooKeeper 交互</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">4.1.6.</span> <span class="nav-text">类的说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-Cache"><span class="nav-number">4.1.7.</span> <span class="nav-text">Node Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Path-Cache"><span class="nav-number">4.1.8.</span> <span class="nav-text">Path Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#container-%E8%8A%82%E7%82%B9"><span class="nav-number">4.1.9.</span> <span class="nav-text">container 节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceCacheImpl"><span class="nav-number">4.1.10.</span> <span class="nav-text">ServiceCacheImpl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceProviderImpl"><span class="nav-number">4.1.11.</span> <span class="nav-text">ServiceProviderImpl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#curator-x-discovery-server-%E6%89%A9%E5%B1%95"><span class="nav-number">4.1.12.</span> <span class="nav-text">curator-x-discovery-server 扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.1.13.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka"><span class="nav-number">4.2.</span> <span class="nav-text">Kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-Kafka-%E9%9B%86%E7%BE%A4"><span class="nav-number">4.2.1.</span> <span class="nav-text">安装 Kafka 集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#broker-%E6%B3%A8%E5%86%8C%E6%BC%94%E7%A4%BA"><span class="nav-number">4.2.2.</span> <span class="nav-text">broker 注册演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multi-API"><span class="nav-number">4.2.3.</span> <span class="nav-text">multi API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">4.2.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%94%E8%BE%83-ZooKeeper%E3%80%81etcd%E5%92%8C-Chubby"><span class="nav-number">5.</span> <span class="nav-text">比较 ZooKeeper、etcd和 Chubby</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Paxos-%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.1.</span> <span class="nav-text">Paxos 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Asynchronous-non-Byzantine-Model"><span class="nav-number">5.1.1.</span> <span class="nav-text">Asynchronous non-Byzantine Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#agent-%E8%A7%92%E8%89%B2"><span class="nav-number">5.1.2.</span> <span class="nav-text">agent 角色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="nav-number">5.1.3.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="nav-number">5.1.4.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%B6%88%E6%81%AF%E6%B5%81"><span class="nav-number">5.1.5.</span> <span class="nav-text">算法的消息流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Replicated-State-Machine"><span class="nav-number">5.1.6.</span> <span class="nav-text">Replicated State Machine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MultiPaxos"><span class="nav-number">5.1.7.</span> <span class="nav-text">MultiPaxos</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chubby"><span class="nav-number">5.2.</span> <span class="nav-text">Chubby</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">5.2.1.</span> <span class="nav-text">系统架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-1"><span class="nav-number">5.2.2.</span> <span class="nav-text">数据模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chubby-API"><span class="nav-number">5.2.3.</span> <span class="nav-text">Chubby API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Locking"><span class="nav-number">5.2.4.</span> <span class="nav-text">Locking</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache"><span class="nav-number">5.2.5.</span> <span class="nav-text">cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94"><span class="nav-number">5.2.6.</span> <span class="nav-text">对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Raft-%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90"><span class="nav-number">5.3.</span> <span class="nav-text">Raft 协议解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-Raft-%E7%9A%84%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">5.3.1.</span> <span class="nav-text">基于 Raft 的复制状态机系统架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Raft-%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6"><span class="nav-number">5.3.2.</span> <span class="nav-text">Raft 日志复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%9D%A1%E7%9B%AE%E7%9A%84%E6%8F%90%E4%BA%A4"><span class="nav-number">5.3.3.</span> <span class="nav-text">日志条目的提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Raft-%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.3.4.</span> <span class="nav-text">Raft 日志复制示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Raft-%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95"><span class="nav-number">5.3.5.</span> <span class="nav-text">Raft 选举算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%8C%B9%E9%85%8D"><span class="nav-number">5.3.6.</span> <span class="nav-text">日志匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E4%BF%9D%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%96%B9%E6%A1%88"><span class="nav-number">5.3.7.</span> <span class="nav-text">确保一致性的方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E5%91%BD%E4%BB%A4%E7%9A%84%E6%8F%90%E4%BA%A4%E7%82%B9"><span class="nav-number">5.3.8.</span> <span class="nav-text">状态机命令的提交点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E6%9B%B4%E6%96%B0"><span class="nav-number">5.3.9.</span> <span class="nav-text">集群成员更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#etcd"><span class="nav-number">5.4.</span> <span class="nav-text">etcd</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">5.4.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC"><span class="nav-number">5.4.2.</span> <span class="nav-text">MVCC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">5.4.3.</span> <span class="nav-text">状态机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="nav-number">5.4.4.</span> <span class="nav-text">数据存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE"><span class="nav-number">5.4.5.</span> <span class="nav-text">安装配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-etcdctl"><span class="nav-number">5.4.6.</span> <span class="nav-text">使用 etcdctl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-etcd-HTTP-API"><span class="nav-number">5.4.7.</span> <span class="nav-text">使用 etcd HTTP API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#etcd-API-%E7%9A%84-KV-%E9%83%A8%E5%88%86"><span class="nav-number">5.4.8.</span> <span class="nav-text">etcd API 的 KV 部分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#etcd-API"><span class="nav-number">5.4.8.1.</span> <span class="nav-text">etcd API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Response-Header"><span class="nav-number">5.4.8.2.</span> <span class="nav-text">Response Header</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KeyValue"><span class="nav-number">5.4.8.3.</span> <span class="nav-text">KeyValue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Key-Range"><span class="nav-number">5.4.8.4.</span> <span class="nav-text">Key Range</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KV-%E6%9C%8D%E5%8A%A1"><span class="nav-number">5.4.8.5.</span> <span class="nav-text">KV 服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Range-API"><span class="nav-number">5.4.8.6.</span> <span class="nav-text">Range API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#etcd-API-%E7%9A%84-Watch-%E5%92%8C-Lease-%E9%83%A8%E5%88%86"><span class="nav-number">5.4.9.</span> <span class="nav-text">etcd API 的 Watch 和 Lease 部分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Txn-API"><span class="nav-number">5.4.9.1.</span> <span class="nav-text">Txn API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Txn-API-%E8%AF%AD%E6%B3%95%E5%9B%BE"><span class="nav-number">5.4.9.2.</span> <span class="nav-text">Txn API 语法图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Watch-API"><span class="nav-number">5.4.9.3.</span> <span class="nav-text">Watch API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lease-API"><span class="nav-number">5.4.9.4.</span> <span class="nav-text">Lease API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-etcd-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%98%9F%E5%88%97"><span class="nav-number">5.4.10.</span> <span class="nav-text">使用 etcd 实现分布式队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80"><span class="nav-number">5.4.10.1.</span> <span class="nav-text">队列基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1-3"><span class="nav-number">5.4.10.2.</span> <span class="nav-text">设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="nav-number">5.4.10.3.</span> <span class="nav-text">出队操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-etcd-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">5.4.11.</span> <span class="nav-text">使用 etcd 实现分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%AE%83%E9%94%81-Mutex-%E5%9F%BA%E7%A1%80"><span class="nav-number">5.4.11.1.</span> <span class="nav-text">排它锁(Mutex)基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%8E%92%E5%AE%83%E9%94%81"><span class="nav-number">5.4.11.2.</span> <span class="nav-text">分布式排它锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1-4"><span class="nav-number">5.4.12.</span> <span class="nav-text">设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA-etcd-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83"><span class="nav-number">5.4.13.</span> <span class="nav-text">搭建一个 etcd 生产环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#clientv3-grpc1-23-%E6%9E%B6%E6%9E%84"><span class="nav-number">5.4.13.1.</span> <span class="nav-text">clientv3-grpc1.23 架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#etcd-gateway"><span class="nav-number">5.4.13.2.</span> <span class="nav-text">etcd gateway</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gRPC-proxy"><span class="nav-number">5.4.13.3.</span> <span class="nav-text">gRPC proxy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA3%E8%8A%82%E7%82%B9%E7%9A%84%E9%9B%86%E7%BE%A4"><span class="nav-number">5.4.13.4.</span> <span class="nav-text">配置一个3节点的集群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83-ZooKeeper-%E5%92%8C-etcd"><span class="nav-number">5.4.13.5.</span> <span class="nav-text">比较 ZooKeeper 和 etcd</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="nav-number">6.</span> <span class="nav-text">实现原理和源码解读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-B-tree"><span class="nav-number">6.1.</span> <span class="nav-text">存储数据结构之 B-tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">6.1.1.</span> <span class="nav-text">平衡二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-tree"><span class="nav-number">6.1.2.</span> <span class="nav-text">B-tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-tree-%E7%89%B9%E7%82%B9"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">B-tree 特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-tree-1"><span class="nav-number">6.1.3.</span> <span class="nav-text">B+tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-tree-%E7%B4%A2%E5%BC%95"><span class="nav-number">6.1.3.1.</span> <span class="nav-text">B+tree 索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-LSM"><span class="nav-number">6.2.</span> <span class="nav-text">存储数据结构之 LSM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LSM-%E6%9E%B6%E6%9E%84"><span class="nav-number">6.2.1.</span> <span class="nav-text">LSM 架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LSM-%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">6.2.2.</span> <span class="nav-text">LSM 写操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LSM-%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="nav-number">6.2.3.</span> <span class="nav-text">LSM 读操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bloom-Filter"><span class="nav-number">6.2.4.</span> <span class="nav-text">Bloom Filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Compaction"><span class="nav-number">6.2.5.</span> <span class="nav-text">Compaction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-LSM-%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">6.2.6.</span> <span class="nav-text">基于 LSM 的存储引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E6%94%BE%E5%A4%A7%E6%8C%87%E6%A0%87%EF%BC%88Amplification-Factors%EF%BC%89"><span class="nav-number">6.2.7.</span> <span class="nav-text">存储引擎的放大指标（Amplification Factors）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83-B-tree-%E5%92%8C-LSM"><span class="nav-number">6.2.8.</span> <span class="nav-text">比较 B-tree 和 LSM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93"><span class="nav-number">6.3.</span> <span class="nav-text">本地存储技术总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99-vs-%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99"><span class="nav-number">6.3.1.</span> <span class="nav-text">数据的随机读写 vs 顺序读写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">6.4.</span> <span class="nav-text">文件系统基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ext4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.4.1.</span> <span class="nav-text">ext4 文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-API"><span class="nav-number">6.4.2.</span> <span class="nav-text">文件系统 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-Ahead-Logging"><span class="nav-number">6.5.</span> <span class="nav-text">Write Ahead Logging</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81-durable-storage-%E5%86%99%E5%85%A5%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">6.5.1.</span> <span class="nav-text">保证 durable storage 写入的原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write-Ahead-Logging%EF%BC%88WAL%EF%BC%89"><span class="nav-number">6.5.2.</span> <span class="nav-text">Write Ahead Logging（WAL）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WAL-%E4%BC%98%E5%8C%961%EF%BC%9AGroup-Commit"><span class="nav-number">6.5.2.1.</span> <span class="nav-text">WAL 优化1：Group Commit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WAL-%E4%BC%98%E5%8C%962%EF%BC%9AFile-Padding"><span class="nav-number">6.5.2.2.</span> <span class="nav-text">WAL 优化2：File Padding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WAL-%E4%BC%98%E5%8C%963%EF%BC%9A%E5%BF%AB%E7%85%A7"><span class="nav-number">6.5.2.3.</span> <span class="nav-text">WAL 优化3：快照</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">6.5.3.</span> <span class="nav-text">数据序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%94%E5%8F%91%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="nav-number">6.5.4.</span> <span class="nav-text">研发本地存储</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">6.6.</span> <span class="nav-text">ZooKeeper本地存储源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">6.6.1.</span> <span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84-1"><span class="nav-number">6.6.2.</span> <span class="nav-text">本地存储架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB"><span class="nav-number">6.6.3.</span> <span class="nav-text">核心接口和类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File-Padding"><span class="nav-number">6.6.4.</span> <span class="nav-text">File Padding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DataTree"><span class="nav-number">6.6.5.</span> <span class="nav-text">DataTree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7-1"><span class="nav-number">6.6.6.</span> <span class="nav-text">快照</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">6.7.</span> <span class="nav-text">网络编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP-%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="nav-number">6.7.1.</span> <span class="nav-text">TCP&#x2F;IP 协议栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Endianness"><span class="nav-number">6.7.2.</span> <span class="nav-text">Endianness</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-socket-%E5%92%8C-connection"><span class="nav-number">6.7.3.</span> <span class="nav-text">TCP socket 和 connection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket%E7%BC%96%E7%A8%8BAPI"><span class="nav-number">6.7.4.</span> <span class="nav-text">Socket编程API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#client%E7%AB%AFsocket%E7%BC%96%E7%A8%8B"><span class="nav-number">6.7.5.</span> <span class="nav-text">client端socket编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#server-%E7%AB%AF-socket-%E7%BC%96%E7%A8%8B"><span class="nav-number">6.7.6.</span> <span class="nav-text">server 端 socket 编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Socket%E7%BC%96%E7%A8%8B"><span class="nav-number">6.7.7.</span> <span class="nav-text">Java Socket编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">6.8.</span> <span class="nav-text">事件驱动的网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EIO%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="nav-number">6.8.1.</span> <span class="nav-text">阻塞IO的服务架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%9E%B6%E6%9E%84"><span class="nav-number">6.8.2.</span> <span class="nav-text">事件驱动的网络编程架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-API"><span class="nav-number">6.8.2.1.</span> <span class="nav-text">epoll API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%9E%B6%E6%9E%84-1"><span class="nav-number">6.8.2.2.</span> <span class="nav-text">事件驱动的网络编程架构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-number">6.9.</span> <span class="nav-text">ZooKeeper的客户端网络通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.9.1.</span> <span class="nav-text">RPC网络数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZooKeeper%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0"><span class="nav-number">6.9.2.</span> <span class="nav-text">ZooKeeper网络通信概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="nav-number">6.9.2.1.</span> <span class="nav-text">RPC方法流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Standalone%E7%9A%84ZooKeeper%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82"><span class="nav-number">6.9.3.</span> <span class="nav-text">Standalone的ZooKeeper处理客户端请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Fuzzy-Snapshot"><span class="nav-number">6.9.3.1.</span> <span class="nav-text">Fuzzy Snapshot</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quorum%E6%A8%A1%E5%BC%8F%E4%B8%8BZooKeeper%E8%8A%82%E7%82%B9%E7%9A%84Request-Processor-Pipeline"><span class="nav-number">6.9.4.</span> <span class="nav-text">Quorum模式下ZooKeeper节点的Request Processor Pipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CommitProcessor%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="nav-number">6.9.4.1.</span> <span class="nav-text">CommitProcessor核心逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#workPool%E7%8A%B6%E6%80%81%E5%9B%BE"><span class="nav-number">6.9.4.2.</span> <span class="nav-text">workPool状态图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper-Leader%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE"><span class="nav-number">6.10.</span> <span class="nav-text">ZooKeeper Leader节点选举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader-Election%E7%AE%97%E6%B3%95"><span class="nav-number">6.10.1.</span> <span class="nav-text">Leader Election算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader-Election%E7%AE%97%E6%B3%95-1"><span class="nav-number">6.10.2.</span> <span class="nav-text">Leader Election算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader-Election%E7%A4%BA%E4%BE%8B-happy-case"><span class="nav-number">6.10.3.</span> <span class="nav-text">Leader Election示例(happy case)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader-Election%E7%A4%BA%E4%BE%8B-unhappy-case"><span class="nav-number">6.10.4.</span> <span class="nav-text">Leader Election示例(unhappy case)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8finalizeWait%E6%9D%A5%E9%81%BF%E5%85%8Dunhappy-case"><span class="nav-number">6.10.5.</span> <span class="nav-text">使用finalizeWait来避免unhappy case</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader-Election%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-number">6.10.6.</span> <span class="nav-text">Leader Election的网络通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zab%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.11.</span> <span class="nav-text">Zab协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Zab-ZooKeeper-Atomic-Broadcast-%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.11.1.</span> <span class="nav-text">Zab(ZooKeeper Atomic Broadcast)协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quorum%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-number">6.11.2.</span> <span class="nav-text">Quorum网络通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BA%A4%E4%BA%92%EF%BC%9AWatch%E5%92%8CSession"><span class="nav-number">6.12.</span> <span class="nav-text">客户端和服务器端交互：Watch和Session</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Session%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%BB%E8%BE%91"><span class="nav-number">6.12.1.</span> <span class="nav-text">Session核心数据结构和逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E5%BF%83%E8%B7%B3"><span class="nav-number">6.12.2.</span> <span class="nav-text">从客户端到服务器端的心跳</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mitaka xu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mitaka xu</p>
  <div class="site-description" itemprop="description">Golang开发博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">144</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaoyeshiyu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/4748c1d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Zookeeper 学习笔记 | 小夜时雨">
      <meta itemprop="description" content="Zookeeper 是一个应用非常广泛的分布式一致性系统。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Zookeeper 学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-04-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-04-01T00:00:00+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-04-02 15:53:33" itemprop="dateModified" datetime="2024-04-02T15:53:33+08:00">2024-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a>
        </span>
    </span>

  
    <span id="/post/4748c1d.html" class="post-meta-item leancloud_visitors" data-flag-title="Zookeeper 学习笔记" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

            <div class="post-description">Zookeeper 是一个应用非常广泛的分布式一致性系统。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>ZooKeeper 是一个<strong>分布式</strong>的，开放源码的分布式应用程序协同服务。</p>
<p>ZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><p>ZooKeeper 最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协同，但是这些系统往往都存在分布式单点问题。</p>
<p>所以，雅虎的开发人员就开发了一个通用的无单点问题的分布式协调框架，这就是ZooKeeper。ZooKeeper 之后在开源界被大量使用，下面列出了 3 个著名开源项目是如何使用 ZooKeeper：</p>
<ul>
<li>Hadoop：使用 ZooKeeper 做 Namenode的高可用。</li>
<li>HBase：保证集群中只有一个 master，保存 <code>hbase:meta</code> 表的位置，保存集群中的 RegionServer 列表。</li>
<li>Kafka：集群成员管理，controller 节点选举。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>典型应用场景：</p>
<ul>
<li>配置管理（configuration management）</li>
<li>DNS 服务</li>
<li>组成员管理（HBase：groupmembership）</li>
<li>各种分布式锁</li>
</ul>
<p>ZooKeeper 适用于存储和协同相关的关键数据，不适合用于大数据量存储。</p>
<h2 id="实现-Master-Worker-协同"><a href="#实现-Master-Worker-协同" class="headerlink" title="实现 Master-Worker 协同"></a>实现 Master-Worker 协同</h2><h3 id="master-worker-架构"><a href="#master-worker-架构" class="headerlink" title="master-worker 架构"></a>master-worker 架构</h3><p>master-work 是一个广泛使用的分布式架构。 master-work架构中有一个 master 负责监控 worker 的状态，并为worker分配任务。</p>
<ol>
<li><p>在任何时刻，系统中最多只能有一个master，不可以出现两个master的情况，多个master共存会导致脑裂。</p>
</li>
<li><p>系统中除了处于active状态的master还有一个bakcupmaster，如果activemaster失败了，backupmaster可以很快的进入active状态。</p>
</li>
<li><p>master实时监控worker的状态，能够及时收到worker成员变化的通知。master在收到worker成员变化的时候，通常重新进行任务的重新分配。</p>
</li>
</ol>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-52-46-image-20240401115246117.png" alt="image-20240401115246117"></p>
<h3 id="示例1-HBase"><a href="#示例1-HBase" class="headerlink" title="示例1- HBase"></a>示例1- HBase</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-53-22-image-20240401115322120.png" alt="image-20240401115322120"></p>
<p>HBase采用的是master-worker的架构。HMBase是系统中的master，HRegionServer是系统中的worker。</p>
<p>HMBase监控HBaseCluster中worker的成员变化，把region分配给各个HRegionServer 。系统中有一个HMaster处于active状态，其他HMaster处于备用状态。</p>
<h3 id="示例2-Kafka"><a href="#示例2-Kafka" class="headerlink" title="示例2-Kafka"></a>示例2-Kafka</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-53-46-image-20240401115346917.png" alt="image-20240401115346917"></p>
<p>一个Kafka集群由多个broker组成，这些borker是系统中的worker。Kafka会从这些worker选举出一个controller，这个controlle是系统中的master，负责把topic partition分配给各个broker。</p>
<h3 id="示例3-HDFS"><a href="#示例3-HDFS" class="headerlink" title="示例3- HDFS"></a>示例3- HDFS</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-55-08-image-20240401115508397.png" alt="image-20240401115508397"></p>
<p>HDFS采用的也是一个master-worker的架构，NameNode是系统中的master，DataNode是系统中的worker。</p>
<p>NameNode用来保存整个分布式文件系统的metadata，并把数据块分配给cluster中的DataNode进行保存。</p>
<h3 id="使用ZooKeeper实现master-worker"><a href="#使用ZooKeeper实现master-worker" class="headerlink" title="使用ZooKeeper实现master-worker"></a>使用ZooKeeper实现master-worker</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-55-33-image-20240401115533903.png" alt="image-20240401115533903"></p>
<ol>
<li>使用一个临时节点 <code>/master</code> 表示 master。master 在行使 master 的职能之前，首先要创建这个 znode。如果能创建成功，进入 active 状态，开始行使 master 职能。否则的话，进入 backup 状态，使用 watch 机制监控 <code>/master</code> 。假设系统中有一个active master 和一个 backup master。如果 active master 失败，它创建的 <code>/master</code> 就会被 ZooKeeper 自动删除。这时 backup master 就会收到通知，通过再次创建 &#x2F;master 节点成为新的 active master。</li>
<li>worker 通过在 &#x2F;workers 下面创建临时节点来加入集群。</li>
<li>处于 active 状态的 master 会通过 watch 机制监控 &#x2F;workers 下面 znode 列表来实时获取 worker 成员的变化。</li>
</ol>
<h2 id="服务说明"><a href="#服务说明" class="headerlink" title="服务说明"></a>服务说明</h2><p>应用使用 ZooKeeper 客户端库使用 ZooKeeper 服务。</p>
<p>ZooKeeper 客户端负责和 ZooKeeper 集群的交互。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-58-35-image-20240401115835793.png" alt="image-20240401115835793"></p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F11-59-10-image-20240401115910689.png" alt="image-20240401115910689"></p>
<p>ZooKeeper 的数据模型是层次模型（Google Chubby也是这么做的）。</p>
<p>层次模型常见于文件系统。层次模型和 key-value 模型是两种主流的数据模型。</p>
<p>ZooKeeper 使用文件系统模型主要基于以下两点考虑：</p>
<ol>
<li>文件系统的树形结构便于表达数据之间的层次关系。</li>
<li>文件系统的树形结构便于为不同的应用分配独立的命名空间（namespace）。</li>
</ol>
<p>ZooKeeper 的层次模型称作 data tree。Data tree 的每个节点叫作 znode。不同于文件系统，每个节点都可以保存数据。每个节点都有一个版本(version)。版本从 0 开始计数。</p>
<h3 id="data-tree-示例"><a href="#data-tree-示例" class="headerlink" title="data tree 示例"></a>data tree 示例</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F14-02-19-image-20240401140219839.png" alt="image-20240401140219839"></p>
<p>在上图所示的 data tree 中有两个子树，一个用于应用1（<code>/app1</code>）和另一个用于应用2（<code>/app2</code>）。</p>
<p>应用1的子树实现了一个简单的组成员协议：每个客户端进程 <code>pi</code> 创建一个<code>znode</code> <code>p_i</code> 在 <code>/app1</code> 下，只要 <code>/app1/p_i</code> 存在就代表进程 <code>pi</code> 在正常运行。</p>
<h3 id="data-tree-接口"><a href="#data-tree-接口" class="headerlink" title="data tree 接口"></a>data tree 接口</h3><p>ZooKeeper 对外提供一个用来访问 data tree 的简化文件系统 API：</p>
<ul>
<li>使用 UNIX 风格的路径名来定位 znode，例如 &#x2F;A&#x2F;X 表示 znode A的子节点 X。</li>
<li>znode 的数据只支持全量写入和读取，没有像通用文件系统那样支持部分写入和读取。</li>
<li>data tree 的所有 API 都是 wait-free 的，正在执行中的 API 调用不会影响其他 API 的完成。</li>
<li>data tree 的 API 都是对文件系统的 wait-free 操作，不直接提供锁这样的分布式协同机制。但是 data tree 的 API 非常强大，可以用来实现多种分布式协同机制。</li>
</ul>
<h3 id="znode分类"><a href="#znode分类" class="headerlink" title="znode分类"></a>znode分类</h3><p>一个 znode 可以使持久性的，也可以是临时性的：</p>
<ol>
<li>持久性的 znode (<code>PERSISTENT</code>)：ZooKeeper 宕机，或者 client 宕机，这个 znode 一旦创建就不会丢失。</li>
<li>临时性的 znode (<code>EPHEMERAL</code>)：ZooKeeper 宕机了，或者 client 在指定的 timeout 时间内没有连接 server，都会被认为丢失。</li>
</ol>
<p>znode 节点也可以是顺序性的。每一个顺序性的 znode 关联一个唯一的单调递增整数。这个单调递增整数是 znode 名字的后缀。如果上面两种 znode 具备顺序性，又有以下两种 znode：</p>
<ol start="3">
<li><p>持久顺序性的 znode(<code>PERSISTENT_SEQUENTIAL</code>): znode 除了具备持久性 znode 的特点之外，znode 的名字具备顺序性。</p>
</li>
<li><p>临时顺序性的 znode(<code>EPHEMERAL_SEQUENTIAL</code>): znode 除了具备临时性 znode 的特点之外，znode的名字具备顺序性。</p>
</li>
</ol>
<p>ZooKeeper 主要有以上 4 种 znode。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy8=">https://zookeeper.apache.org/<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>唯一的依赖是 JDK7+。</li>
<li>到 <span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9yZWxlYXNlcy5odG1s">https://zookeeper.apache.org/releases.html<i class="fa fa-external-link-alt"></i></span> 下载 ZooKeeper，目前的最新版是 3.9.2。（推荐使用迅雷）</li>
<li>把 apache-zookeeper-3.9.2-bin.tar.gz 解压到一个本地目录 (目录名最好不要包含空格和中文)。</li>
<li>进入 apache-zookeeper-3.9.2-bin 目录中，根据示例配置文件创建 conf&#x2F;zoo.cfg。<code>cp zoo_sample.cfg zoo.cfg</code></li>
<li>配置以下环境变量，以便操作</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ZOOKEEPER_HOME=<span class="string">&quot;<span class="variable">$HOME</span>/xxx/apache-zookeeper-3.9.2-bin&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$ZOOKEEPER_HOME</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>注意两个配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/tmp/zookeeper # 表示数据存储目录，存放日志文件和快照文件；建议修改，tmp 目录重启会清空</span><br><span class="line">clientPort=2181        # 表示监听端口</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用 zkServer.sh start 启动 ZooKeeper 服务。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zkServer.sh start</span></span><br><span class="line">/usr/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /root/mitaka/apache-zookeeper-3.9.2-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 ZooKeeper 日志是否有出错信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E -i <span class="string">&quot;((exception)|(error))&quot;</span> zookeeper-root-server-master.out</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 ZooKeeper 数据文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tree .</span></span><br><span class="line">.</span><br><span class="line">├── version-2</span><br><span class="line">│   └── snapshot.0 			<span class="comment"># 快照文件</span></span><br><span class="line">└── zookeeper_server.pid <span class="comment"># 生命文件</span></span><br><span class="line"></span><br><span class="line">1 directory, 2 files</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 ZooKeeper 是否在 2181 端口上监听。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -tanple | grep 2181</span></span><br><span class="line">tcp6       0      0 :::2181                 :::*                    LISTEN      0          52999      3764/java</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="zkCli-sh-一些常用命令"><a href="#zkCli-sh-一些常用命令" class="headerlink" title="zkCli.sh 一些常用命令"></a>zkCli.sh 一些常用命令</h3><p>执行 <code>zkCli.sh</code> 进入 zk 交互命令行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> <span class="comment"># 打印帮助</span></span><br><span class="line"><span class="built_in">ls</span> -R /  <span class="comment"># 递归查看所有 znode</span></span><br><span class="line">create /app1 <span class="comment"># 在 / 下创建 znode app1</span></span><br><span class="line">create /app2 <span class="comment"># 在 / 下创建 znode app2</span></span><br><span class="line">create /app1/p_1 1 <span class="comment"># 在 /app1 下创建 p_1 这个 znode，值为 1</span></span><br><span class="line">create /app1/p_2 2</span><br><span class="line">create /app1/p_3 3</span><br><span class="line"><span class="built_in">ls</span> -R / </span><br></pre></td></tr></table></figure>

<h3 id="实现一个锁"><a href="#实现一个锁" class="headerlink" title="实现一个锁"></a>实现一个锁</h3><p>分布式锁要求：如果锁的持有者宕了，锁可以被释放。</p>
<p>ZooKeeper 的 ephemeral 节点恰好具备这样的特性。</p>
<p>终端1：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e /lock <span class="comment"># -e 表示临时 znode</span></span><br></pre></td></tr></table></figure>

<p>终端 2</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">create -e /lock <span class="comment"># 加锁出现报错</span></span><br><span class="line">Node already exists: /lock</span><br><span class="line"></span><br><span class="line"><span class="built_in">stat</span> -w /lock <span class="comment"># 监控锁信息</span></span><br><span class="line">cZxid = 0x9</span><br><span class="line">ctime = Mon Apr 01 14:43:08 CST 2024</span><br><span class="line">mZxid = 0x9</span><br><span class="line">mtime = Mon Apr 01 14:43:08 CST 2024</span><br><span class="line">pZxid = 0x9</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x1000012e26a0001</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出终端 1</span></span><br><span class="line">再次加锁</span><br><span class="line">create -e /lock</span><br><span class="line">Created /lock</span><br></pre></td></tr></table></figure>

<h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><p>应用使用 ZooKeeper 客户端库使用 ZooKeeper 服务。 ZooKeeper 客户端负责和 ZooKeeper 集群的交互。 </p>
<p>ZooKeeper 集群可以有两种模式：standalone 模式和 quorum 模式。</p>
<ul>
<li>处于 standalone 模式的 ZooKeeper 集群只有一个独立运行的 ZooKeeper 节点（会有单点故障）</li>
<li>处于 quorum 模式的 ZooKeeper 集群包换多个 ZooKeeper 节点。</li>
</ul>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F15-23-10-image-20240401152310255.png" alt="image-20240401152310255"></p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>ZooKeeper 客户端库和 ZooKeeper 集群中的节点创建一个 session。客户端可以主动关闭 session。另外如果ZooKeeper 节点没有在 session 关联的 timeout 时间内收到客户端的数据的话， ZooKeeper 节点也会关闭 session。</p>
<p>另外 ZooKeeper 客户端库如果发现连接的 ZooKeeper 出错，会自动的和其他 ZooKeeper 节点建立连接。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F15-24-04-image-20240401152404506.png" alt="image-20240401152404506"></p>
<h3 id="Quorum模式"><a href="#Quorum模式" class="headerlink" title="Quorum模式"></a>Quorum模式</h3><p>处于 Quorum 模式的 ZooKeeper 集群包含多个 ZooKeeper 节点。 </p>
<p>下图的 ZooKeeper 集群有 3 个节点，其中节点 1 是 leader 节点，节点 2 和节点 3 是 follower 节点。 </p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F15-24-53-image-20240401152453947.png" alt="image-20240401152453947"></p>
<p>leader 节点可以处理读写请求，follower 只可以处理读请求。 follower 在接到写请求时会把写请求转发给 leader 来处理。</p>
<h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><ul>
<li>可线性化（Linearizable）写入：先到达 leader 的写请求会被先处理，leader 决定写请求的执行顺序。</li>
<li>客户端 FIFO 顺序：来自给定客户端的请求按照发送顺序执行。</li>
</ul>
<h3 id="3节点-quorum-模式集群"><a href="#3节点-quorum-模式集群" class="headerlink" title="3节点 quorum 模式集群"></a>3节点 quorum 模式集群</h3><p>在一台服务器上运行三个进程模拟 <code>quorum</code> 集群，需要准备 3 个配置文件：</p>
<p>节点 1 配置文件改动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/root/mitaka/apache-zookeeper-3.9.2-bin/data1</span><br><span class="line">clientPort=2181 # 客户端端口</span><br><span class="line">server.1=127.0.0.1:3333:3334 # 3333 端口用于 quorum 之间的通信；3334 端口用于 leader 选举的端口</span><br><span class="line">server.2=127.0.0.1:4444:4445</span><br><span class="line">server.3=127.0.0.1:5555:5556</span><br></pre></td></tr></table></figure>

<p>节点 2 配置文件改动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/root/mitaka/apache-zookeeper-3.9.2-bin/data2</span><br><span class="line">clientPort=2182</span><br><span class="line">server.1=127.0.0.1:3333:3334</span><br><span class="line">server.2=127.0.0.1:4444:4445</span><br><span class="line">server.3=127.0.0.1:5555:5556</span><br></pre></td></tr></table></figure>

<p>节点 3 配置文件改动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/root/mitaka/apache-zookeeper-3.9.2-bin/data3</span><br><span class="line">clientPort=2183</span><br><span class="line">server.1=127.0.0.1:3333:3334</span><br><span class="line">server.2=127.0.0.1:4444:4445</span><br><span class="line">server.3=127.0.0.1:5555:5556</span><br></pre></td></tr></table></figure>

<p>在三个 <code>data</code> 目录中创建 <code>myid</code> 文件，其中存放对应节点的 id</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim data1/myid</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">vim data2/myid</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">vim data3/myid</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>使用以下命令依次启动每个进程：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start-foreground zoo1.cfg</span><br><span class="line">zkServer.sh start-foreground zoo2.cfg</span><br><span class="line">zkServer.sh start-foreground zoo3.cfg</span><br></pre></td></tr></table></figure>

<p><code>start-foreground</code> 选项 zkServer.sh 在前台运行，把日志直接打到 console。如果把日志打到文件的话，这三个 zkServer.sh 会把日志打到同一个文件。</p>
<p>节点日志：</p>
<p>第一个进程启动时，由于其他进程没有启动，日志中可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2024-04-01 15:40:59,188 [myid:] - WARN  [QuorumConnectionThread-[myid=1]-2:o.a.z.s.q.QuorumCnxManager@401] - Cannot open channel to 2 at election address /127.0.0.1:4445</span><br><span class="line">2024-04-01 15:40:59,193 [myid:] - WARN  [QuorumConnectionThread-[myid=1]-3:o.a.z.s.q.QuorumCnxManager@401] - Cannot open channel to 3 at election address /127.0.0.1:5556</span><br></pre></td></tr></table></figure>

<p>其他节点启动后，可以看到选举过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2024-04-01 15:42:21,657 [myid:] - INFO  [QuorumPeer[myid=1](plain=[0:0:0:0:0:0:0:0]:2181)(secure=disabled):o.a.z.s.q.QuorumPeer@906] - Peer state changed: following</span><br><span class="line"></span><br><span class="line">2024-04-01 15:42:21,665 [myid:] - INFO  [QuorumPeer[myid=2](plain=[0:0:0:0:0:0:0:0]:2182)(secure=disabled):o.a.z.s.q.QuorumPeer@906] - Peer state changed: leading</span><br></pre></td></tr></table></figure>

<p>节点 1 变成 <code>following</code>，节点 2 变成 <code>leading</code>。</p>
<p>客户端连接</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkCli.sh -server 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183</span><br></pre></td></tr></table></figure>

<p>从日志中可以看到与 <code>2182</code> 端口，也就是节点 2 建立连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-04-01 15:49:41,305 [myid:127.0.0.1:2182] - INFO  [main-SendThread(127.0.0.1:2182):o.a.z.ClientCnxn$SendThread@998] - Socket connection established, initiating session, client: /127.0.0.1:43608, server: localhost/127.0.0.1:2182</span><br></pre></td></tr></table></figure>

<p>关闭节点 2 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183(CONNECTED) 0] 2024-04-01 15:50:42,511 [myid:127.0.0.1:2182] - WARN  [main-SendThread(127.0.0.1:2182):o.a.z.ClientCnxn$SendThread@1285] - Session 0x200005092d90000 for server localhost/127.0.0.1:2182, Closing socket connection. Attempting reconnect except it is a SessionExpiredException.</span><br><span class="line"></span><br><span class="line">2024-04-01 15:50:43,394 [myid:127.0.0.1:2181] - INFO  [main-SendThread(127.0.0.1:2181):o.a.z.ClientCnxn$SendThread@998] - Socket connection established, initiating session, client: /127.0.0.1:34816, server: localhost/127.0.0.1:2181</span><br></pre></td></tr></table></figure>

<p>客户端自动与 <code>2181</code> 端口也就是节点 1 建立连接</p>
<h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><p>通过 Java 语言作为客户端与 ZooKeeper 交互。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvcjMuOS4yL2phdmFFeGFtcGxlLmh0bWw=">https://zookeeper.apache.org/doc/r3.9.2/javaExample.html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvLXpvb2tlZXBlci96aw==">https://github.com/go-zookeeper/zk<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="ZooKeeper-类"><a href="#ZooKeeper-类" class="headerlink" title="ZooKeeper 类"></a>ZooKeeper 类</h3><p>ZooKeeper Java 代码主要使用 <code>org.apache.zookeeper.ZooKeeper</code> 这个类使用 ZooKeeper 服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper(connectString, sessionTimeout, watcher)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>connectString</code>：使用逗号分隔的列表，每个 ZooKeeper 节点是一个 <code>host:port</code> 对，host 是机器名或者 IP 地址，port 是 ZooKeeper 节点使用的端口号。 会任意选取 connectString 中的一个节点建立连接。</li>
<li><code>sessionTimeout</code>：session timeout 时间。</li>
<li><code>watcher</code>：用于接收到来自 ZooKeeper 集群的所有事件。</li>
</ul>
<h3 id="ZooKeeper-主要方法"><a href="#ZooKeeper-主要方法" class="headerlink" title="ZooKeeper 主要方法"></a>ZooKeeper 主要方法</h3><ul>
<li><code>create(path, data, flags)</code>创建一个给定路径的 znode，并在 znode 保存 <code>data[]</code> 的数据，flags 指定 znode 的类型。</li>
<li><code>delete(path, version)</code>：如果给定 path 上的 znode 的版本和给定的 version 匹配，删除 znode。</li>
<li><code>exists(path, watch)</code>：判断给定 path 上的 znode 是否存在，并在 znode 设置一个 watch。</li>
<li><code>getData(path, watch)</code>：返回给定 path 上的 znode 数据，并在 znode 设置一个 watch。</li>
<li><code>setData(path, data, version)</code>：如果给定 path 上的 znode 的版本和给定的 version 匹配，设置 znode 数据。</li>
<li><code>getChildren(path, watch)</code>：返回给定 path 上的 znode 的孩子 znode 名字，并在 znode 设置一个 watch。</li>
<li><code>sync(path)</code>：把客户端 session 连接节点和 leader 节点进行同步。</li>
</ul>
<h3 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h3><ul>
<li>所有获取 znode 数据的 API 都可以设置一个 watch 用来监控 znode 的变化。</li>
<li>所有更新 znode 数据的 API 都有两个版本: 无条件更新版本和条件更新版本。如果 version 为 -1，更新为条件更新。否则只有给定的 version 和 znode 当前的 version 一样，才会 进行更新，这样的更新是条件更新。</li>
<li>所有的方法都有同步和异步两个版本。同步版本的方法发送请求给 ZooKeeper 并等待服务器的响应。异步版本把请求放入客户端的请求队列，然后马上返回。异步版本通过 callback 来接受来 自服务端的响应。</li>
</ul>
<h3 id="代码异常处理"><a href="#代码异常处理" class="headerlink" title="代码异常处理"></a>代码异常处理</h3><p>所有同步执行的 API 方法都有可能抛出以下两个异常:</p>
<ul>
<li><p><code>KeeperException</code>: 表示 ZooKeeper 服务端出错。 </p>
<p>KeeperException 的子类 ConnectionLossException 表示客户端和当前连接的 ZooKeeper 节点断开了连接。网络分区 和 ZooKeeper 节点失败都会导致这个异常出现。</p>
<p>发生此异常的时机可能是在 ZooKeeper 节点处 理客户端请求之前，也可能是在 ZooKeeper 节点处理客户端请求之后。</p>
<p>出现 ConnectionLossException 异常之后，客户端会进行自动重新连接，但是我们必须要检查我们 以前的客户端请求是否被成功执行。</p>
</li>
</ul>
<ul>
<li><code>InterruptedException</code>：表示方法被中断了。我们可以使用 <code>Thread.interrupt()</code> 来中断 API 的执行。</li>
</ul>
<h3 id="数据读取-API"><a href="#数据读取-API" class="headerlink" title="数据读取 API"></a>数据读取 API</h3><p>示例 - <code>getData </code></p>
<p>有以下三个获取 znode 数据的方法:</p>
<ol>
<li><p><code>byte[] getData(String path, boolean watch, Stat stat)</code></p>
<p>同步方法。如果 watch 为 true，该 znode 的状态变化会发送给构建 ZooKeeper 是指定的 watcher。</p>
</li>
<li><p><code>void getData(String path, boolean watch, DataCallback cb, Object ctx)</code><br>异步方法。cb 是一个 callback，用来接收服务端的响应。ctx 是提供给 cb 的 context。 watch 参数的含义和方法 1 相同。</p>
</li>
<li><p><code>void getData(String path, Watcher watcher, DataCallback cb, Object ctx) </code></p>
<p>异步方法。 watcher 用来接收该 znode 的状态变化。</p>
</li>
</ol>
<h3 id="数据写入-API"><a href="#数据写入-API" class="headerlink" title="数据写入 API"></a>数据写入 API</h3><p>示例 - <code>setData</code></p>
<ol>
<li><p><code>Stat setData(String path, byte[] data, int version)</code></p>
<p> 同步版本。如果 version 是 -1，做无条件更新。如果 version 是非 0 整数，做条件更新。</p>
</li>
<li><p><code>void setData(String path, byte[] data, int version, StatCallback cb, Object ctx)</code></p>
<p>   异步版本。</p>
</li>
</ol>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>watch 提供一个让客户端获取最新数据的机制。如果没有 watch 机制，客户端需要不断的轮询 ZooKeeper 来查看是否有数据更新，这在分布式环境中是非常耗时的。</p>
<p>客户端可以在读取数据的时候设置一个 watcher，这样在数据更新时，客户端就会收到通知。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-05-35-image-20240401160535679.png" alt="image-20240401160535679"></p>
<h3 id="条件更新"><a href="#条件更新" class="headerlink" title="条件更新"></a>条件更新</h3><p>设想用 znode &#x2F;c 实现一个 counter，使用 set 命令来实现自增 1 操作。条件更新场景:</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-06-36-image-20240401160635930.png" alt="image-20240401160635930"></p>
<ol>
<li>客户端1把&#x2F;c更新到版本1，实现&#x2F;c的自增1。</li>
<li>客户端2把&#x2F;c更新到版本2，实现&#x2F;c的自增1。</li>
<li>客户端 1 不知道 &#x2F;c 已经被客户端 2 更新过了，还用过时的版本 1 是去更新 &#x2F;c，更新失败。如果客户端 1 使用的是无条件更新，&#x2F;c 就会更新为 2，没有实现自增 1 。</li>
</ol>
<p>使用条件更新可以避免对数据基于过期的数据进行数据更新操作。</p>
<h2 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h2><p>通过 ZooKeeper Recipes 实现一个分布式队列</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvcjMuNS41L3JlY2lwZXMuaHRtbCNzY19yZWNpcGVzX1F1ZXVlcw==">https://zookeeper.apache.org/doc/r3.5.5/recipes.html#sc_recipes_Queues<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-11-42-image-20240401161142416.png" alt="image-20240401161142416"></p>
<p>使用路径为 &#x2F;queue 的 znode 下的节点表示队列中的元素。</p>
<p>&#x2F;queue 下的节点都是顺序持久化 znode。</p>
<p>这些 znode 名字的后缀数字表示了对应队列元素在队列中的位置。</p>
<p>Znode 名字后缀数字越小，对应队列元素在队列中的位置越靠前。</p>
<h3 id="offer-方法"><a href="#offer-方法" class="headerlink" title="offer 方法"></a>offer 方法</h3><p>offer 方法在 &#x2F;queue 下面创建一个顺序 znode。</p>
<p>因为 znode 的后缀数字是 &#x2F;queue 下面现有 znode 最大后缀数字加 1，所以该 znode 对应的队列元素处于队尾。（也就是持久的顺序节点）</p>
<h3 id="element-方法"><a href="#element-方法" class="headerlink" title="element 方法"></a>element 方法</h3><p>element 方法返回队尾的一个元素。</p>
<p>element 方法有以下两种返回的方式，要么里面没有元素，队列为空；要么有元素，返回最上面的一个元素：</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-17-40-image-20240401161740819.png" alt="image-20240401161740819"></p>
<ol>
<li><code>throw new NoSuchElementException()</code>：因为 element 方法读取到了队列为空的状态，所以抛出 NoSuchElementException 是正确的。</li>
<li><code>return zookeeper.getData(dir+&quot;/&quot;+headNode, false, null)</code>： childNames 保存的是队列内容的一个快照。这个 return 语句返回快照中还没出队。如果队列快照的元素都出队了，重试。</li>
</ol>
<h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h3><p>remove 方法返回队尾的元素，并且将这个元素从队尾中删除。</p>
<p>remove 方法和 element 方法类似。值得注意的是 getData 的成功执行不意味着：出队成功，原因是该队列元素可能会被其他用户出队。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] data = zookeeper.getData(path, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">zookeeper.delete(path, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-20-03-image-20240401162003594.png" alt="image-20240401162003594"></p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>使用 ZooKeeper Recipes 实现分布式锁</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvcjMuNS41L3JlY2lwZXMuaHRtbCNzY19yZWNpcGVzX0xvY2tz">https://zookeeper.apache.org/doc/r3.5.5/recipes.html#sc_recipes_Locks<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h3><p>使用临时顺序 znode 来表示获取锁的请求，创建最小后缀数字 znode 的用户成功拿到锁。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-21-41-image-20240401162141606.png" alt="image-20240401162141606"></p>
<h3 id="避免羊群效应-herd-effect"><a href="#避免羊群效应-herd-effect" class="headerlink" title="避免羊群效应(herd effect)"></a>避免羊群效应(herd effect)</h3><p>把锁请求者按照后缀数字进行排队，后缀数字小的锁请求者先获取锁。如果所有的锁请求者都 watch 锁持有者，当代表锁请求者的 znode 被删除以后，所有的锁请求者都会通知到，但是只有一个锁请求者能拿到锁。这就是<strong>羊群效应</strong>。</p>
<p>为了避免羊群效应，每个锁请求者 watch 它前面的锁请求者。每次锁被释放，只会有一个锁请求者会被通知到。这样做还让锁的分配具有公平性，锁定的分配遵循先到先得的原则。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-22-25-image-20240401162225623.png" alt="image-20240401162225623"></p>
<h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><p>通过 ZooKeeper Recipes 实现选举功能</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvcjMuNS41L3JlY2lwZXMuaHRtbCNzY19sZWFkZXJFbGVjdGlvbg==">https://zookeeper.apache.org/doc/r3.5.5/recipes.html#sc_leaderElection<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="设计-2"><a href="#设计-2" class="headerlink" title="设计"></a>设计</h3><p>使用临时顺序 znode 来表示选举请求，创建最小后缀数字 znode 的选举请求成功。在协同设计上和分布式锁是一样的，不同之处在于具体实现。不同于分布式锁，选举的具体实现对选举的各个阶段做了监控。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-25-09-image-20240401162509138.png" alt="image-20240401162509138"></p>
<h3 id="使用-Apache-Curator-简化-ZooKeeper-开发"><a href="#使用-Apache-Curator-简化-ZooKeeper-开发" class="headerlink" title="使用 Apache Curator 简化 ZooKeeper 开发"></a>使用 Apache Curator 简化 ZooKeeper 开发</h3><p>Apache Curator 是 Apache ZooKeeper 的 Java 客户端库。</p>
<p>Curator 项目的目标是简化ZooKeeper 客户端的使用。例如，要自己处理 ConnectionLossException 。</p>
<p>另外 Curator 为常见的分布式协同服务提供了高质量的实现。</p>
<p>Apache Curator 最初是 Netflix 研发的，后来捐献给了 Apache 基金会，目前是 Apache 的 顶级项目。</p>
<h3 id="Curator-技术栈"><a href="#Curator-技术栈" class="headerlink" title="Curator 技术栈"></a>Curator 技术栈</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-27-22-image-20240401162722713.png" alt="image-20240401162722713"></p>
<ul>
<li>Client：封装了ZooKeeper类，管理和 ZooKeeper 集群的连接，并提供了重建 连接机制。</li>
<li>Framework：为所有的ZooKeeper操作提供了重试机制，对外提供了一个 Fluent 风格的 API 。</li>
<li>Recipes：使用framework实现了大量的 ZooKeeper 协同服务。</li>
<li>Extensions：扩展模块。</li>
</ul>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>初始化一个 client 分成两个步骤：</p>
<ol>
<li>创建 client</li>
<li>启动 client</li>
</ol>
<p>以下是两种创建 client 的方法:</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-28-16-image-20240401162816064.png" alt="image-20240401162816064"></p>
<h3 id="Fluent-风格-API"><a href="#Fluent-风格-API" class="headerlink" title="Fluent 风格 API"></a>Fluent 风格 API</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-28-30-image-20240401162830629.png" alt="image-20240401162830629"></p>
<h1 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h1><h2 id="安装配置一个生产环境"><a href="#安装配置一个生产环境" class="headerlink" title="安装配置一个生产环境"></a>安装配置一个生产环境</h2><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><p>ZooKeeper 的配置项在 <code>zoo.cfg</code> 配置文件中配置, 另外有些配置项可以通过 Java 系统属性来进行配置。</p>
<p>ZooKeeper 有很多配置项，比较重要的有：</p>
<ul>
<li>clientPort：ZooKeeper 对客户端提供服务的端口。</li>
<li>dataDir：来保存快照文件的目录。如果没有设置 dataLogDir ，事务日志文件也会保存到这个目录。</li>
<li>dataLogDir：用来保存事务日志文件的目录。因为 ZooKeeper 在提交一个事务之前，需要保证事务日志记录的落盘，所以需要为 dataLogDir 分配一个独占的存储设备。</li>
</ul>
<h3 id="ZooKeeper-节点硬件要求"><a href="#ZooKeeper-节点硬件要求" class="headerlink" title="ZooKeeper 节点硬件要求"></a>ZooKeeper 节点硬件要求</h3><p>给 ZooKeeper 分配独占的服务器，要给 ZooKeeper 的事务日志分配独立的存储设备。（提交事务之前要落盘，所以对磁盘性能有要求）</p>
<ol>
<li>内存：ZooKeeper 需要在内存中保存 data tree 。对于一般的 ZooKeeper 应用场景，8G 的内存足够了。</li>
<li>CPU：ZooKeeper 对 CPU 的消耗不高，只要保证 ZooKeeper 能够有一个独占的 CPU 核即可，所以使用一个双核的 CPU 。</li>
<li>存储：因为存储设备的写延迟会直接影响事务提交的效率，建议为 dataLogDir 分配一个独占的 SSD 盘。</li>
</ol>
<h3 id="日志配置文件"><a href="#日志配置文件" class="headerlink" title="日志配置文件"></a>日志配置文件</h3><p>ZooKeeper 使用 SLF4J 版本 1.7 作为其日志基础设施。默认情况下，ZooKeeper 随 LOGBack 作为日志后端一起提供，但您可以使用任何其他支持的日志框架。</p>
<p>ZooKeeper 默认的 logback.xml 文件位于 conf 目录中。Logback 要求 logback.xml 要么在工作目录（即运行 ZooKeeper 的目录）中，要么可以从类路径访问到。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;zookeeper.console.threshold&quot;</span> <span class="attr">value</span>=<span class="string">&quot;INFO&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;zookeeper.log.dir&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;zookeeper.log.file&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zookeeper.log&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;zookeeper.log.threshold&quot;</span> <span class="attr">value</span>=<span class="string">&quot;INFO&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;zookeeper.log.maxfilesize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;256MB&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;zookeeper.log.maxbackupindex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><h3 id="The-Four-Letter-Words"><a href="#The-Four-Letter-Words" class="headerlink" title="The Four Letter Words"></a>The Four Letter Words</h3><p>一组检查 ZooKeeper 节点状态的命令。</p>
<p>每个命令由四个字母组成，可以通过 telnet 或 ncat 使用客户端端口向 ZooKeeper 发出命令。</p>
<blockquote>
<p><em>4lw.commands.whitelist</em> : (Java system property: <strong>zookeeper.4lw.commands.whitelist</strong>) <strong>New in 3.5.3:</strong> A list of comma separated <span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvcjMuOS4yL3pvb2tlZXBlckFkbWluLmh0bWwjc2NfNGx3">Four Letter Words<i class="fa fa-external-link-alt"></i></span> commands that user wants to use. A valid Four Letter Words command must be put in this list else ZooKeeper server will not enable the command. By default the whitelist only contains “srvr” command which zkServer.sh uses. The rest of four-letter word commands are disabled by default: attempting to use them will gain a response “…. is not executed because it is not in the whitelist.” Here’s an example of the configuration that enables stat, ruok, conf, and isro command while disabling the rest of Four Letter Words command:</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvcjMuOS4yL3pvb2tlZXBlckFkbWluLmh0bWwjc2NfNGx3">https://zookeeper.apache.org/doc/r3.9.2/zookeeperAdmin.html#sc_4lw<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-44-33-image-20240401164433316.png" alt="image-20240401164433316"></p>
<p>例如，在配置文件中加入 <code>whitelist</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># echo ruok | ncat localhost 2181</span><br><span class="line">imok</span><br></pre></td></tr></table></figure>

<h3 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h3><p>ZooKeeper 很好的支持了 JMX ，大量的监控和管理工作多可以通过 JMX 来做。</p>
<blockquote>
<p>QuorumPeerMain starts a ZooKeeper server, <span class="exturl" data-url="aHR0cDovL2phdmEuc3VuLmNvbS9qYXZhc2UvdGVjaG5vbG9naWVzL2NvcmUvbW50ci1tZ210L2phdmFtYW5hZ2VtZW50Lw==">JMX<i class="fa fa-external-link-alt"></i></span> management beans are also registered which allows management through a JMX management console. The <span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvcjMuOS4yL3pvb2tlZXBlckpNWC5odG1s">ZooKeeper JMX document<i class="fa fa-external-link-alt"></i></span> contains details on managing ZooKeeper with JMX. See the script <em>bin&#x2F;zkServer.sh</em>, which is included in the release, for an example of starting server instances. 8. Test your deployment by connecting to the hosts: In Java, you can run the following command to execute simple operations:</p>
<p>QuorumPeerMain启动了一个ZooKeeper服务器，还注册了JMX管理bean，可以通过JMX管理控制台进行管理。ZooKeeper JMX文档包含有关使用JMX管理ZooKeeper的详细信息。查看发布中包含的示例启动服务器实例的脚本bin&#x2F;zkServer.sh。8. 通过连接到主机测试您的部署：在Java中，您可以运行以下命令执行简单操作：</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvcjMuOS4yL3pvb2tlZXBlckpNWC5odG1s">https://zookeeper.apache.org/doc/r3.9.2/zookeeperJMX.html<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="跨区域部署"><a href="#跨区域部署" class="headerlink" title="跨区域部署"></a>跨区域部署</h2><p>通过 ZooKeeper Observer 实现跨区域部署</p>
<h3 id="ZooKeeper-处理写请求时序"><a href="#ZooKeeper-处理写请求时序" class="headerlink" title="ZooKeeper 处理写请求时序"></a>ZooKeeper 处理写请求时序</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-47-44-image-20240401164743907.png" alt="image-20240401164743907"></p>
<ul>
<li>ZooKeeper 处理写请求，收到请求的节点（节点 1）会先转发到 Leader 节点（节点 2）</li>
<li>Leader 节点发送预处理请求（Prepose）到<strong>所有其他节点</strong>（而不是超过半数）</li>
<li>收到其他节点收到后进行相应（Accept）</li>
<li>Leader 节点收到其他节点（超过半数）相应后，给其他节点发送确认（Commit）请求</li>
<li>收到写请求的节点（节点 1）收到确认请求后，响应给客户端</li>
</ul>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>Observer 和 ZooKeeper 机器其他节点唯一的交互是接收来自 leader 的 inform 消息，更新自己的本地存储，不参与提交和选举的投票过程。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-48-05-image-20240401164805420.png" alt="image-20240401164805420"></p>
<h3 id="写性能提升"><a href="#写性能提升" class="headerlink" title="写性能提升"></a>写性能提升</h3><p>Observer 和 ZooKeeper 机器其他节点唯一的交互是接收来自 leader 的 inform 消息，更新自己的本地存储，不参与提交和选举的投票过程。因此可以通过往集群里面添加 Observer 节点来提高整个集群的读性能。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-52-26-image-20240401165226745.png" alt="image-20240401165226745"></p>
<p>例如上图，节点 1 作为 Observer 节点，收到写入请求后，不参加数据写入的投票过程。</p>
<p>集群主节点写入完成后，同步到 Observer 节点，Observer 节点本地完成数据一致。</p>
<h3 id="应用场景-跨数据中心部署"><a href="#应用场景-跨数据中心部署" class="headerlink" title="应用场景 - 跨数据中心部署"></a>应用场景 - 跨数据中心部署</h3><p>例如需要部署一个北京和香港两地都可以使用的 ZooKeeper 服务。</p>
<p>要求北京和香港的客户端的读请求的延迟都低。因此，需要在北京和香港都部署 ZooKeeper 节点。</p>
<p>假设 leader 节点在北京。那么每个写请求要涉及 leader 和每个香港 follower 节点之间的 propose 、ack 和 commit 三个跨区域消息。香港节点到北京节点需要跨互联网，延迟高</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F16-59-33-image-20240401165933271.png" alt="image-20240401165933271"></p>
<p>解决的方案是把香港的节点都设置成 observer 。 上面提的 propose 、ack 和 commit 消息三个消息就变成了 inform 一个跨区域消息消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.1=127.0.0.1:3333:3334</span><br><span class="line">server.2=127.0.0.1:4444:4445</span><br><span class="line">server.3=127.0.0.1:5555:5556</span><br><span class="line">server.4=127.0.0.1:6666:6667:observer # 表示该节点是 observer 节点</span><br></pre></td></tr></table></figure>

<h2 id="dynamic-reconfiguration"><a href="#dynamic-reconfiguration" class="headerlink" title="dynamic reconfiguration"></a>dynamic reconfiguration</h2><p>通过动态配置实现不中断服务的集群成员变更</p>
<p>当需要手动集群成员调整时，操作步骤：</p>
<ol>
<li>停止整个 ZooKeeper 现有集群。</li>
<li>更改配置文件 zoo.cfg 的 server.n 项。 </li>
<li>启动新集群的 ZooKeeper 节点。</li>
</ol>
<p>此时需要停止 ZooKeeper 服务。</p>
<p>同时，可能会导致已经提交的数据写入被覆盖。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-02-37-image-20240401170237738.png" alt="image-20240401170237738"></p>
<p>当重启时，一些节点上数据没有被同步，如果重启后，这部分节点行程选举群，那么老数据会同步新数据。</p>
<h3 id="3-5-0-新特性"><a href="#3-5-0-新特性" class="headerlink" title="3.5.0 新特性"></a>3.5.0 新特性</h3><p>dynamic reconfiguration：动态配置，可以在不停止 ZooKeeper 服务的前提下，调整集群成员。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96b29rZWVwZXIuYXBhY2hlLm9yZy9kb2MvcjMuOS4yL3pvb2tlZXBlclJlY29uZmlnLmh0bWw=">https://zookeeper.apache.org/doc/r3.9.2/zookeeperReconfig.html<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>The ZooKeeper Java and C API were extended with getConfig and reconfig commands that facilitate reconfiguration. Both commands have a synchronous (blocking) variant and an asynchronous one. We demonstrate these commands here using the Java CLI, but note that you can similarly use the C CLI or invoke the commands directly from a program just like any other ZooKeeper command.</p>
<p>ZooKeeper Java 和 C API 已经扩展了 getConfig 和 reconfig 命令，以便进行重新配置。这两个命令都有同步（阻塞）和异步的变体。我们在这里使用 Java CLI 演示这些命令，但请注意您也可以类似地使用 C CLI 或直接从程序中调用这些命令，就像任何其他 ZooKeeper 命令一样。</p>
</blockquote>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-06-25-image-20240401170625713.png" alt="image-20240401170625713"></p>
<p>示例：</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-07-03-image-20240401170703345.png" alt="image-20240401170703345"></p>
<h2 id="内部数据文件"><a href="#内部数据文件" class="headerlink" title="内部数据文件"></a>内部数据文件</h2><h3 id="本地存储架构"><a href="#本地存储架构" class="headerlink" title="本地存储架构"></a>本地存储架构</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-07-34-image-20240401170734445.png" alt="image-20240401170734445"></p>
<p>上图中 3、4、5 就是 zxid</p>
<p><strong>zxid</strong></p>
<ul>
<li>每一个对 ZooKeeper data tree 都会作为一个事务执行。</li>
<li>每一个事务都有一个 zxid。</li>
<li>zxid 是一个 64 位的整数(Java long 类型)。</li>
<li>zxid 有两个组成部分，高 4 个字节保存的是 epoch，低 4 个字节保存的是 counter 。</li>
</ul>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-08-46-image-20240401170846448.png" alt="image-20240401170846448"></p>
<h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>通过查看事务日志文件（Transaction Logs）可以看到里面的 zxid 信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zkTxnLogToolkit.sh log.1</span></span><br><span class="line">4/1/24, 2:40:39 PM CST session 0x1000012e26a0001 cxid 0x2 zxid 0x4 create /app1,,[31,s&#123;<span class="string">&#x27;world,&#x27;</span>anyone&#125;</span><br><span class="line">],<span class="literal">false</span>,1</span><br><span class="line">4/1/24, 2:40:44 PM CST session 0x1000012e26a0001 cxid 0x3 zxid 0x5 create /app2,,[31,s&#123;<span class="string">&#x27;world,&#x27;</span>anyone&#125;</span><br><span class="line">],<span class="literal">false</span>,2</span><br><span class="line">4/1/24, 2:40:52 PM CST session 0x1000012e26a0001 cxid 0x4 zxid 0x6 create /app1/p_1,1,[31,s&#123;<span class="string">&#x27;world,&#x27;</span>anyone&#125;</span><br><span class="line">],<span class="literal">false</span>,1</span><br><span class="line">4/1/24, 2:40:57 PM CST session 0x1000012e26a0001 cxid 0x5 zxid 0x7 create /app1/p_2,2,[31,s&#123;<span class="string">&#x27;world,&#x27;</span>anyone&#125;</span><br><span class="line">],<span class="literal">false</span>,2</span><br><span class="line">4/1/24, 2:41:01 PM CST session 0x1000012e26a0001 cxid 0x6 zxid 0x8 create /app1/p_3,3,[31,s&#123;<span class="string">&#x27;world,&#x27;</span>anyone&#125;</span><br><span class="line">],<span class="literal">false</span>,3</span><br><span class="line">4/1/24, 2:43:08 PM CST session 0x1000012e26a0001 cxid 0x1c zxid 0x9 create /lock,,[31,s&#123;<span class="string">&#x27;world,&#x27;</span>anyone&#125;</span><br><span class="line">],<span class="literal">true</span>,3</span><br></pre></td></tr></table></figure>

<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>通过快照文件（Snapshots）查看 ZooKeeper 里面的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># zkSnapShotToolkit.sh snapshot.12</span><br><span class="line">----</span><br><span class="line">/app1/p_3</span><br><span class="line">  cZxid = 0x00000000000008</span><br><span class="line">  ctime = Mon Apr 01 14:41:01 CST 2024</span><br><span class="line">  mZxid = 0x00000000000008</span><br><span class="line">  mtime = Mon Apr 01 14:41:01 CST 2024</span><br><span class="line">  pZxid = 0x00000000000008</span><br><span class="line">  cversion = 0</span><br><span class="line">  dataVersion = 0</span><br><span class="line">  aclVersion = 0</span><br><span class="line">  ephemeralOwner = 0x00000000000000</span><br><span class="line">  dataLength = 1</span><br><span class="line">----</span><br><span class="line">Session Details (sid, timeout, ephemeralCount):</span><br><span class="line">----</span><br><span class="line">Last zxid: 0x12</span><br></pre></td></tr></table></figure>

<h3 id="Epoch-文件"><a href="#Epoch-文件" class="headerlink" title="Epoch 文件"></a>Epoch 文件</h3><p>当 ZooKeeper 以单节点的方式运行不会有 Epoch 文件，以集群的方式运行则会有。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -ltrah</span></span><br><span class="line">total 20K</span><br><span class="line">drwxr-xr-x 3 root root  35 Apr  1 15:40 ..</span><br><span class="line">-rw-r--r-- 1 root root 610 Apr  1 15:40 snapshot.0</span><br><span class="line">-rw-r--r-- 1 root root 65M Apr  1 15:49 log.100000001</span><br><span class="line">-rw-r--r-- 1 root root   1 Apr  1 15:50 acceptedEpoch</span><br><span class="line">-rw-r--r-- 1 root root   1 Apr  1 15:50 currentEpoch</span><br></pre></td></tr></table></figure>

<h1 id="开发进阶"><a href="#开发进阶" class="headerlink" title="开发进阶"></a>开发进阶</h1><h2 id="实现服务发现"><a href="#实现服务发现" class="headerlink" title="实现服务发现"></a>实现服务发现</h2><p>服务发现主要应用于微服务架构和分布式架构场景下。在这些场景下，一个服务通常需要松耦合的多个组件的协同才能完成。服务发现就是让组件发现相关的组件。服务发现要提供的功能有以下3点:</p>
<ul>
<li>服务注册。</li>
<li>服务实例的获取。</li>
<li>服务变化的通知机制。</li>
</ul>
<p>Curator 有一个扩展叫作 curator-x-discovery。curator-x-discovery 基于 ZooKeeper 实现了服务发现。</p>
<h3 id="curator-x-discovery-设计"><a href="#curator-x-discovery-设计" class="headerlink" title="curator-x-discovery 设计"></a>curator-x-discovery 设计</h3><p>使用一个 base path 作为整个服务发现的根目录。 在这个根目录下是各个服务的的目录。服务目录下面是服务实例。实例是服务实例的 JSON 序列化数 据。服务实例对应的 znode 节点可以根据需要设置成持久性、临时性和顺序性。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-15-46-image-20240401171546619.png" alt="image-20240401171546619"></p>
<h3 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-16-08-image-20240401171608310.png" alt="image-20240401171608310"></p>
<p>左图列出了服务发现用户代码要使用的 curator-x-discovery 接口。最主要的有下三个接口:</p>
<ul>
<li><code>ServiceProvider</code>：在服务 cache 之上支持服务发现操作，封装了一些服务发现策略。</li>
<li><code>ServiceDiscovery</code>：服务注册，也支持直接访问 ZooKeeper 的服务发现操作。</li>
<li><code>ServiceCache</code>：服务cache。</li>
</ul>
<p><strong>ServiceInstance</strong></p>
<p>用来表示服务实例的 POJO，除了包含一些服务实例常用的成员之外，还提供一个 payload 成员让用户存自定义的信息。</p>
<h3 id="ServiceDiscovery"><a href="#ServiceDiscovery" class="headerlink" title="ServiceDiscovery"></a>ServiceDiscovery</h3><p>从一个 ServiceDiscovery ，可以创建多个 ServiceProvider（返回服务端的服务的服务列表） 和多个 ServiceCache（返回本地缓存的服务列表） 。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-18-01-image-20240401171801567.png" alt="image-20240401171801567"></p>
<h3 id="ServiceProvider"><a href="#ServiceProvider" class="headerlink" title="ServiceProvider"></a>ServiceProvider</h3><p>ServiceProvider 提供服务发现 high-level API 。</p>
<p>ServiceProvider 是封装 ProviderStraegy 和 InstanceProvider 的 facade 。 </p>
<p>InstanceProvider 的数据来自一个服务 Cache 。服务 cache 是 ZooKeeper 数据的一个本地 cache ，服务 cache 里面的数据可能会比 ZooKeeper 里面的数据旧一些。（目的时为了提高性能，当然牺牲了可用性，但是可以在客户端上做容错来解决）</p>
<p>ProviderStraegy 提供了三种策略: 轮询, 随机和 sticky 。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-18-48-image-20240401171848328.png" alt="image-20240401171848328"></p>
<p>ServiceProvider 除了提供服务发现的方法( <code>getInstance</code>：根据服务特点返回一个实例 和 <code>getAllInstances</code>：返回所有实例 )以外，还通过 <code>noteError</code> 提供了一个让服务使用者把服务使用情况反馈给 ServiceProvider 的机制。</p>
<h3 id="ZooKeeper-交互"><a href="#ZooKeeper-交互" class="headerlink" title="ZooKeeper 交互"></a>ZooKeeper 交互</h3><p>ServiceDiscovery 提供的服务注册方法是对 znode 的更新操作，服务发现方法是 znode 的读取操作。 同时它也是最核心的类，所有的服务发现操作都要从这个类开始。</p>
<p>另外服务 Cache 会接受来自 ZooKeeper 的更新通知，读取服务信息(也就是读取 znode 信息)。</p>
<h3 id="类的说明"><a href="#类的说明" class="headerlink" title="类的说明"></a>类的说明</h3><p>ServiceDiscovery、ServiceCache、ServiceProvider 说明</p>
<ul>
<li>都有一个对应的 builder。这些 builder 提供一个创建这三个类的 fluent API。</li>
<li>在使用之前都要调用 start 方法。</li>
<li>在使用之后都要调用 close 方法。close 方法只会释放自己创建的资源，不会释放上游关联的资源。 例如 ServiceDiscovery 的 close 方法不会去调用 CuratorFramework 的 close 方法。</li>
</ul>
<h3 id="Node-Cache"><a href="#Node-Cache" class="headerlink" title="Node Cache"></a>Node Cache</h3><p>Node Cache 是 curator 的一个 recipe ，用来本地 cache 一个 znode 的数据。</p>
<p>Node Cache 通过监控一个 znode 的 update &#x2F; create &#x2F; delete 事件来更新本地的 znode 数据。</p>
<p>用户可以在 Node Cache 上面注册一个 listener 来获取 cache 更新的通知。</p>
<blockquote>
<p>相比直接通过 ZooKeeper 创建 listener，一个 listener 只能监听依次，cache 的 listener 可以持续监听</p>
</blockquote>
<h3 id="Path-Cache"><a href="#Path-Cache" class="headerlink" title="Path Cache"></a>Path Cache</h3><p>Path Cache 和 Node Cache 一样，不同之处是在于 Path Cache 缓存一个 znode 目录下所有子节点。</p>
<h3 id="container-节点"><a href="#container-节点" class="headerlink" title="container 节点"></a>container 节点</h3><p>container 节点是一种新引入的 znode ，目的在于下挂子节点。</p>
<p>当一个 container 节点的所有子节点被删除之后，ZooKeeper 会删除掉这个 container 节点。</p>
<p>服务发现的 base path 节点和服务节点就是 containe 节点。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-26-47-image-20240401172647603.png" alt="image-20240401172647603"></p>
<h3 id="ServiceCacheImpl"><a href="#ServiceCacheImpl" class="headerlink" title="ServiceCacheImpl"></a>ServiceCacheImpl</h3><p>ServiceCacheImpl 使用一个 PathChildrenCache 来维护一个 instances 。这个 instances也是对 znode 数据的一个 cache </p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-30-06-image-20240401173006120.png" alt="image-20240401173006120"></p>
<h3 id="ServiceProviderImpl"><a href="#ServiceProviderImpl" class="headerlink" title="ServiceProviderImpl"></a>ServiceProviderImpl</h3><p>如下图所示，ServiceProviderImpl 是多个对象的 facade 。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-30-25-image-20240401173025622.png" alt="image-20240401173025622"></p>
<h3 id="curator-x-discovery-server-扩展"><a href="#curator-x-discovery-server-扩展" class="headerlink" title="curator-x-discovery-server 扩展"></a>curator-x-discovery-server 扩展</h3><p>curator-x-discovery-server 是基于 curator-x-discovery 实现的对外提供服务发现的 HTTP API。</p>
<p>他的 HTTP API 是基于 JAX-RS 研发的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>curator-x-discovery 在系统质量和影响力和 ZooKeeper 相比还是有很大差距的，但是提供的服务发现的功能还是很完备的。</p>
<p>如果我们的服务发现场景和 curator-x-discovery 匹配，就可以直接用它或者扩展它。curator-x-discovery-server 本身实现的功能很少，不建议使用，完全可以自己实现类似的功能。</p>
<p>进行 ZooKeeper API 开发，建议以下的 SDK 使用优先顺序: curator recipes -&gt; curator framework -&gt; ZooKeeper API 。</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Kafka 使用 ZooKeeper 实现了大量的协同服务。如果检查一个 Kafka 使用的 ZooKeeper ，会发现大量的 znode :</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-31-47-image-20240401173147405.png" alt="image-20240401173147405"></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9rYWZrYS5hcGFjaGUub3JnL2RvY3VtZW50YXRpb24v">ZooKeeper Directories<i class="fa fa-external-link-alt"></i></span> 对一些关键的 ZooKeeper 使用有一个说明。</p>
<p>Broker Node Registry 是用来保存 Kafka 集群的 Kafka 节点，是典型的组成员管理协同服务。</p>
<h3 id="安装-Kafka-集群"><a href="#安装-Kafka-集群" class="headerlink" title="安装 Kafka 集群"></a>安装 Kafka 集群</h3><p>使用 Confluent 的发行版</p>
<ul>
<li>从 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29uZmx1ZW50LmlvL2Rvd25sb2FkLw==">https://www.confluent.io/download/<i class="fa fa-external-link-alt"></i></span> 下载社区版 <code>confluent-community-7.6.0.tar.gz</code></li>
<li>在一个节点上的 <code>etc/kafka/zookeeper.properties</code> 文件中配置一下 <code>dataDir</code>，在 <code>etc/kafka/server.properties</code> 配置 <code>log.dirs</code> 、<code>broker.id</code> 和 <code>zookeeper.connect</code>。</li>
<li>把 confluent-7.6.0 目录 <code>rsync</code> 到其他节点。在其他节点上更新 <code>broker.id</code>，创建 <code>dataDir</code> 目录和 <code>log.dirs</code> 目录。</li>
</ul>
<h3 id="broker-注册演示"><a href="#broker-注册演示" class="headerlink" title="broker 注册演示"></a>broker 注册演示</h3><ul>
<li>启动 standalone 的 ZooKeeper 服务。</li>
<li>打开 zookeeper-shell，运行 <code>ls /</code>。</li>
<li>启动一个 Kafka 服务，使用 zookeeper-shell 检查 <code>/brokers/ids</code> 下的内容。</li>
<li>再启动一个 Kafka 服务，使用 zookeeper-shell 检查 <code>/brokers/ids</code> 下的内容。 </li>
<li>杀掉一个 Kafka 服务，使用 zookeeper-shell 检查 <code>/brokers/ids</code> 下的内容。</li>
</ul>
<h3 id="multi-API"><a href="#multi-API" class="headerlink" title="multi API"></a>multi API</h3><p>ZooKeeper 的 multi 方法提供了一次执行多个 ZooKeeper 操作的机制。多个 ZooKeeper 操作作为一个整体执行，要么全部成功，要么全部失败。类似于事务的概念。</p>
<p>另外 ZooKeeper 还提供了一个 builder 风格的 API 来使用 multi API 。</p>
<p>Kafka 的源代码就使用到了 multi API，二次开发 Kafka 时可以一并替换。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Kafka 在逐渐减少对 ZooKeeper 的依赖:</p>
<ul>
<li>在老的版本中，committed offsets 是保存在 Kafka 中的。</li>
<li>未来 Kafka 还有计划完全移除对 ZooKeeper 的依赖。</li>
</ul>
<p>Kafka 使用 ZooKeeper 的方式值得我们依赖。</p>
<p>在我们刚开始一个分布式系统的时候，我们可以把协同数据都给 ZooKeeper 来管理，迅速让系统上线。如果在系统的后续使用中要对协同数据进行定制化处理，我们可以研发自己的协同数据机制来代替 ZooKeeper 。</p>
<h1 id="比较-ZooKeeper、etcd和-Chubby"><a href="#比较-ZooKeeper、etcd和-Chubby" class="headerlink" title="比较 ZooKeeper、etcd和 Chubby"></a>比较 ZooKeeper、etcd和 Chubby</h1><h2 id="Paxos-协议"><a href="#Paxos-协议" class="headerlink" title="Paxos 协议"></a>Paxos 协议</h2><p>Paxos 算法是一个一致性算法，作用是让 Asynchronous non-Byzantine Model 的分布式环境中的 各个 agent 达成一致。</p>
<p>打一个比方，7 个朋友要决定晚上去哪里吃饭。一致性算法就是保证要么这 7 个朋友达成一致选定一个地方去吃饭，要么因为各种异常情况达不成一致，但是不能出现一些朋友选定一个地方，另外一些朋友选定另外一个地方的情况。</p>
<h3 id="Asynchronous-non-Byzantine-Model"><a href="#Asynchronous-non-Byzantine-Model" class="headerlink" title="Asynchronous non-Byzantine Model"></a>Asynchronous non-Byzantine Model</h3><p>一个分布式环境由若干个 agent 组成，agent 之间通过传递消息进行通讯:</p>
<ul>
<li>agent以任意的速度速度运行，agent 可能失败和重启。但是 agent 不会出 Byzantine fault（在不同观察者中呈现不同症状的任何故障）。</li>
<li>消息需要任意长的时间进行传递，消息可能丢失，消息可能会重复。但是消息不会 corrupt（不会篡改后又发出来）。</li>
</ul>
<h3 id="agent-角色"><a href="#agent-角色" class="headerlink" title="agent 角色"></a>agent 角色</h3><ul>
<li>client：发送请求给 Paxos 算法服务。 </li>
<li>proposer：发送 prepare 请求和 accept 请求。</li>
<li>acceptor：处理 prepare 请求和 accept 请求。 </li>
<li>learner：获取一个 Paxos 算法实例决定的结果。</li>
</ul>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-45-21-image-20240401174520912.png" alt="image-20240401174520912"></p>
<ul>
<li>Phase 1: Prepare（准备阶段）：<ol>
<li>提议者向大多数接受者发送提案编号（proposal number，提案编号通常由两部分组成：提议者的标识符和一个递增的序列号）。</li>
<li>如果接受者收到的提案编号比自己见过的提案编号大，则接受提案，并向提议者发送已经接受的提案编号和对应的提案内容（如果有）。</li>
</ol>
</li>
<li>Phase 2: Accept（接受阶段）：<ol>
<li>如果提议者收到大多数接受者的响应，且这些响应中没有任何比自己提出的提案编号更大的提案，则提议者可以发送自己的提案内容给接受者。</li>
<li>接受者收到提议者的提案后，如果没有接受过更大编号的提案，则接受该提案，通知提议者和其他接受者。</li>
</ol>
</li>
</ul>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>一个 Paxos 算法实例正常运行的前提是大多数 acceptor 正常运行。换句话说就是 Paxos 提供允许少数 accepter 失败的容错能力。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-47-46-image-20240401174746563.png" alt="image-20240401174746563"></p>
<h3 id="算法的消息流"><a href="#算法的消息流" class="headerlink" title="算法的消息流"></a>算法的消息流</h3><p>以下是一个 Paxos 算法实例的完成的消息流：</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-48-25-image-20240401174825823.png" alt="image-20240401174825823"></p>
<h3 id="Replicated-State-Machine"><a href="#Replicated-State-Machine" class="headerlink" title="Replicated State Machine"></a>Replicated State Machine</h3><p>Replicated State Machine：复制状态机，Paxos 算法可以用来实现复制状态机的一致性算法模块。</p>
<p>这里面的状态机是一个 KV 系统。通过复制状态机可以把它变成一个容错的 3 节点分布式 KV 系统。下面是处理 z&#x3D;6 这个写操作的过程:</p>
<ol>
<li>客户端3发送一个 z&#x3D;6 请求给节点3的一致性算法模块。</li>
<li>节点3的一致性算法发起一个算法实例。</li>
<li>如果各个节点的一致性算法模块能一起达成一致，节点3把 z&#x3D;6 应用到它的状态机，并把结果返回给客户端3。</li>
</ol>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-50-14-image-20240401175014186.png" alt="image-20240401175014186"></p>
<h3 id="MultiPaxos"><a href="#MultiPaxos" class="headerlink" title="MultiPaxos"></a>MultiPaxos</h3><p>基本的 Paxos 算法在决定一个值的时候需要的执行两个阶段，这涉及大量消息交换。</p>
<p>MultiPaxos 算法的提出就是为了解决这个问题。</p>
<p>MultiPaxos 保持一个长期的 leader，这样决定一个值只需要执行第二阶段。</p>
<p>一个典型的 Paxos 部署通常包括奇数个服务器，每个服务器都有一个 proposer ，一个 acceptor 和一个 learner 。</p>
<h2 id="Chubby"><a href="#Chubby" class="headerlink" title="Chubby"></a>Chubby</h2><p>Chubby 是一个分布式锁系统，广泛应用于 Google 的基础架构中，例如知名的 GFS 和 Bigtable 都用 Chubby 来做协同服务。（使用 Chubby 选举 Master）</p>
<p>ZooKeeper 借鉴了很多 Chubby 的设计思想，所以它们之间有很多相似之处。</p>
<h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-52-42-image-20240401175242180.png" alt="image-20240401175242180"></p>
<ul>
<li>一个 Chubby 的集群叫作一个 cell，cell 由多个 replica 实例组成，其中一个 replica 是整个 cell 的 master 。所有的 读写请求只能通过 master 来处理。</li>
<li>应用通过引入 Chubby 客户端库来使用 Chubby 服务。 Chubby 客户端在和 master 建立 session 之后，通过发 RPC<br>给 master 来访问 Chubby 数据。</li>
<li>每个客户端维护一个保证数据一致性的 cache</li>
</ul>
<h3 id="数据模型-1"><a href="#数据模型-1" class="headerlink" title="数据模型"></a>数据模型</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-54-34-image-20240401175434425.png" alt="image-20240401175434425"></p>
<p>Chubby 使用的是层次数据模型，可以看做一个简化的 UNIX 文件系统：</p>
<ul>
<li>Chubby 不支持部分内容的读写。</li>
<li>Chubby 不支持 link：不支持硬链接（hard links）或符号链接（symbolic links）的功能。</li>
<li>Chubby 不支持依赖路径的文件权限。</li>
</ul>
<p>不同于 ZooKeeper ，Chubby 的命名空间是由多个 Chubby cell 构成的，例如上图中 <code>/ls</code> 下包含多个 Cell。</p>
<h3 id="Chubby-API"><a href="#Chubby-API" class="headerlink" title="Chubby API"></a>Chubby API</h3><p>与 ZooKeeper 不同，Chubby 的 API 有一个文件句柄的概念。</p>
<ul>
<li><code>Open()</code>：唯一使用路径名访问文件的API，其他API都使用一个文件句柄。</li>
<li><code>Close()</code>：关闭文件句柄。</li>
<li><code>Poison()</code>：取消文件句柄上正在进行的操作，主要用于多线程场景。</li>
<li>文件操作API：<code>GetContentsAndStat()</code>，<code>SetContents()</code>，<code>Delete()</code>。</li>
<li>锁API：<code>Acquire()</code>，<code>TryAcquire()</code>，<code>Release()</code>，<code>GetSequencer()</code>，<code>SetSequencer()</code>，<code>CheckSequencer()</code>。</li>
</ul>
<p>和 ZooKeeper 一样，Chubby 的 API 提供了事件通知机制、API 的异步和同步版本。</p>
<h3 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h3><p>Chubby 使用 Advisory locking。</p>
<p>由于通信的不确定性和各种节点失败，分布式环境中的锁是非常复杂的。</p>
<p>例如在下图所示的场景中，Chubby 锁 L 用来保护资源 A ，但是会出现操作请求执行顺序颠倒的情况。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F17-58-49-image-20240401175849150.png" alt="image-20240401175849150"></p>
<p>解决方案 1：<strong>Sequencer</strong>：时序控制器</p>
<p>一个锁持有者可以使用 <code>GetSequencer()</code> API 向 Chubby 请求一个 sequencer 。</p>
<p>之后锁持有者发送访问资源的请求时，把 sequencer 一起发送给资源服务。</p>
<p>资源服务会对 sequencer 进行验证，如果验证失败，就拒绝资源访问请求。sequencer 包含的数据有锁的名称、锁的模式和 lock generation number 。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F04%2F01%2F18-00-40-image-20240401180040801.png" alt="image-20240401180040801"></p>
<p>ZooKeeper 锁 recipe 里面表示锁请求的 znode 的序列号可以用作 sequencer ，从而也可以实现解决方案 1。</p>
<p>解决方案 2：<strong>lock delay</strong></p>
<p>如果锁 L 的持有者失败了或者访问不到 Chubby cell 中的节点了，Chubby 不会立刻处理对锁 L 的请求。 </p>
<p>Chubby 会等一段时间(默认1分钟)才会把锁 L 分配给其他的请求。</p>
<p>这样也可以保证应用 2 在更晚的时刻获得到锁 L ，从而在更晚的时刻发送请求 <code>R&#39;</code> ，保证 R 先于 <code>R&#39;</code> 执行。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-11-37-image-20240401191136938.png" alt="image-20240401191136938"></p>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>Chubby 的客户端维护一个 <code>write-through</code> 的 cache，能保证 cache 中的数据和 Chubby 节点上的数据是一致的。</p>
<p>master 只有在所有的 cache 失效之后(收到客户端 cache invalidation 的响应或者客户端的 lease 失效了)，才进行文件更新操作。</p>
<p>lease 是客户端维持 session 有效的时间段。如果过了这段时间，客户端还没有 renew lease 的话，客户端停止任何 Chubby 的操作，并断开 session 。</p>
<p>ZooKeeper 没有办法提供和 Chubby 一样的 cache 。 原因是 ZooKeeper 是先更新再发通知，没有办法避免 cache 中有旧数据。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-12-46-image-20240401191246474.png" alt="image-20240401191246474"></p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>相同之处：</p>
<ul>
<li>Chubby 的文件相当于 ZooKeeper 的 znode。Chubby 的文件和 znode 都是用来存储少量数据。 </li>
<li>都只提供文件的全部读取和全部写入。</li>
<li>都提供类似 UNIX 文件系统的 API。</li>
<li>都提供接收数据更新的通知，Chubby 提供 event 机制，ZooKeeper 提供 watch 机制。</li>
<li>它们的客户端都通过一个 session 和服务器端进行交互。 </li>
<li>写操作都是通过 <code>leader/master</code> 来进行。</li>
<li>都支持持久性和临时性数据。</li>
<li>都使用复制状态机来做容错。</li>
</ul>
<p>不同之处：</p>
<table>
<thead>
<tr>
<th>Chubby</th>
<th>ZooKeeper</th>
</tr>
</thead>
<tbody><tr>
<td>Chubby 内置对分布式锁的支持。</td>
<td>ZooKeeper 本身不提供锁，但是可以基于 ZooKeeper 的基本操作来实现锁。</td>
</tr>
<tr>
<td>读操作也必须通过 master 节点来执行。相应的，Chubby 保证的数据一致性强一些，不会有读到旧数据的问题。</td>
<td>读操作可以通过任意节点来执行。相应的，ZooKeeper 保证的数据一致性弱一些，有读到旧数据的问题。</td>
</tr>
<tr>
<td>Chubby 提供一个保证数据一致性的 cache 。有文件句柄的概念。</td>
<td>ZooKeeper 不支持文件句柄，也不支持 cache，但是可以通过 watch 机制来实现 cache 。但是这样实现的 cache 还是有返回旧数据的问题。</td>
</tr>
<tr>
<td>Chubby 基本操作不如 ZooKeeper 的强大。</td>
<td>ZooKeeper 提供更强大的基本操作，例如对顺序性节点的支持，可以用来实现更多的协同服务。</td>
</tr>
<tr>
<td>Chubby 使用 Paxos 数据一致性协议。</td>
<td>ZooKeeper 使用 Zab 数据一致性协议。</td>
</tr>
</tbody></table>
<blockquote>
<p>虽然 Chubby 允许 Followers 节点处理读取请求，但在某些情况下，特别是在需要确保数据一致性的情况下，读取请求可能会被转发到 Leader 节点进行处理。这样可以确保客户端读取到的数据是最新的，并且避免读取到旧数据。</p>
<p>在 Chubby 中，数据的一致性是通过类似于 Paxos 的一致性算法来实现的。Chubby 使用版本号和 lease 机制来确保数据的一致性和可靠性。具体来说：</p>
<ol>
<li><strong>版本号机制</strong>：Chubby 中的数据对象具有版本号，每次写入操作都会增加版本号。这样可以确保新写入的数据会覆盖旧数据，从而避免读取到旧数据的情况。</li>
<li><strong>Lease 机制</strong>：Chubby 中的客户端在读取或写入数据时需要获取一个 lease，这个 lease 会在一段时间内保持有效。只有持有有效 lease 的客户端才能读取或写入数据。当 lease 过期时，客户端需要重新获取 lease 才能继续操作。这样可以避免客户端读取到过期的数据。</li>
</ol>
<p>为了确保客户端不会读取到旧数据，客户端在读取数据时会与 Chubby 的 Leader 节点交互，并通过版本号验证确保读取的数据是最新的。客户端的版本号会与 Leader 节点进行交互验证，以确保读取的数据是最新的。</p>
</blockquote>
<h2 id="Raft-协议解析"><a href="#Raft-协议解析" class="headerlink" title="Raft 协议解析"></a>Raft 协议解析</h2><p>Raft 是目前使用最为广泛的一致性算法。例如新的协同服务平台 etcd 和 Consul 都是使用的 Raft 算法。</p>
<p>在 Raft 出现之间，广泛使用的一致性算法是 Paxos 。Paxos 的基本算法解决的是如何保证单一客户端操作的一致性，完成每个操作需要至少两轮的消息交换。</p>
<p>和 Paxos 不同，Raft 有 leader 的概念。Raft 在处理任何客户端操作之前必须选举一个 leader，选举一个 leader 需要至少一轮的消息交换。但是在选取了 leader 之后，处理每个客户端操作只需要一轮消息交换。</p>
<p>Raft 论文描述了一个基于 Raft 的复制状态机的整体方案，例如 Raft 论文描述了日志复制、选举机制和成员变更等这些复制状态机的各个方面。</p>
<p>相反 Paxos 论文只是给了一个一致性算法，基于 Paxos 的系统都要自己实现这些机制。</p>
<h3 id="基于-Raft-的复制状态机系统架构"><a href="#基于-Raft-的复制状态机系统架构" class="headerlink" title="基于 Raft 的复制状态机系统架构"></a>基于 Raft 的复制状态机系统架构</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-23-07-image-20240401192307446.png" alt="image-20240401192307446"></p>
<p>上图展示了执行一条客户端写命令的过程 ( z←6 表示把 6 写入 z ):</p>
<ol>
<li>客户端 3 发送一个状态机命令 z←6 给服务器 C 的一致性算法模块。</li>
<li>一致性算法模块把状态机命令写入服务器 C 的日志，同时发送日志复制请求给服务器 A 和服务器 B 的一致性算法模块。服务器 A 和服务器 B 的一致性算法模块在接收到日志复制请求之后，分别在自己的服务器上写入日志，然后回复服务器 C 的一致性算法模块。</li>
<li>服务器 C 的一致性算法模块在收到服务器 A 和 B 对日志复制请求的回复之后，<strong>并等待大多数节点（超过半数节点）确认已经复制了这条日志</strong>，让状态机执行来自客户端的命令。</li>
<li>服务器 C 的状态机把命令执行结果返回给客户端 3 。</li>
</ol>
<h3 id="Raft-日志复制"><a href="#Raft-日志复制" class="headerlink" title="Raft 日志复制"></a>Raft 日志复制</h3><p>一个 Raft 集群包括若干服务器。 </p>
<p>服务器可以处于以下三种状态：<code>leader</code> 、<code>follower</code> 和 <code>candidate</code>。只有 leader 处理来自客户端的请求。</p>
<p>follower 不会主动发起任何操作，只会被动的接收来自 leader 和 candidate 的请求。在正常情况下，Raft 集群中有一个 leader ，其他的都是 follower 。 leader 在接受到一个写命令之后，为这个命令生成一个日志条目，然后进行日志复制。</p>
<p>leader 通过发送 AppendEntries RPC 把日志条目发送给 follower ，让 follower 把接收到的日志条目写入自己的日志文件。另外 leader 也会把日志条目写入自己的日志文件。日志复制保证 Raft 集群中所有的服务器的日志最终都处于同样的状态。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-25-47-image-20240401192547151.png" alt="image-20240401192547151"></p>
<p>Raft 的日志复制对应的就是 Paxos 的 accept 阶段，它们是很相似的。</p>
<h3 id="日志条目的提交"><a href="#日志条目的提交" class="headerlink" title="日志条目的提交"></a>日志条目的提交</h3><p>leader 只有在超过半数 Follow 请求被提交以后，才可以在状态机执行客户端请求。提交意味着集群中多数服务器完成了客户端请求的日志写入，这样做是为了保证以下两点:</p>
<ul>
<li>容错：在数量少于 Raft 服务器总数一半的 follower 失败的情况下，Raft 集群仍然可以正常处理来自客户端的请求。</li>
<li>确保重叠：一旦 Raft Leader 响应了一个客户端请求，即使出现 Raft 集群中少数服务器的失败，也会有一个服务器包含所有以前提交的日志条目。</li>
</ul>
<h3 id="Raft-日志复制示例"><a href="#Raft-日志复制示例" class="headerlink" title="Raft 日志复制示例"></a>Raft 日志复制示例</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-27-15-image-20240401192714996.png" alt="image-20240401192714996"></p>
<p>上图表示的是一个包括 5 个服务器的 Raft 集群的日志格式。</p>
<p>S1 处于 leader 状态，其他的服务器处于 follower 状态。此时，由于 <code>x&lt;-5</code> 的日志条目被大部分节点写入日志，因此，直到 <code>x&lt;-5</code> 可以被提交到状态机。</p>
<p>每个日志条目由一条状态机命令和创建这条日志条目的 leader 的 term。 </p>
<p>每个日志条目有对应的日志索引，日志索引表示这条日志在日志中的位置。</p>
<p>Raft 集群中提交的日志条目是 S5 上面 的所有日志条目，因为这些日志条目被复制到了集群中的大多数服务器。</p>
<h3 id="Raft-选举算法"><a href="#Raft-选举算法" class="headerlink" title="Raft 选举算法"></a>Raft 选举算法</h3><p>Raft 使用心跳机制来触发 leader 选取。</p>
<p>一个 follower 只要能收到来自 leader 或者 candidate 的有效 RPC ，就会一直处于 follower 状态。</p>
<p>leader 在每一个 election timeout 向所有 follower 发送心跳消息来保持自己的 leader 状态。</p>
<p>如果 follower 在一个 election timeout 周期内没有收到心跳信息，就认为目前集群中没有 leader。此时 follower 会对自己的 currentTerm 进行加一操作，并进入 candidate 状态，发起一轮投票。它会给自己投票并向其他所有的服务器发送 RequestVote RPC ，然后会一直处于 candidate 状态，直到下列三种情形之一发生:</p>
<ol>
<li>这个 candidate 赢得了选举 。</li>
<li>另外一台服务器成为了 leader 。</li>
<li>一段时间之内没有服务器赢得选举。</li>
</ol>
<p>在这种情况下，candidate 会再次发起选举。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-29-42-image-20240401192942062.png" alt="image-20240401192942062"></p>
<p>Raft 的选举对应的就是 Paxos 的 prepare 阶段，它们是很相似的。</p>
<h3 id="日志匹配"><a href="#日志匹配" class="headerlink" title="日志匹配"></a>日志匹配</h3><p>Raft 日志条目具备以下日志匹配属性:</p>
<ol>
<li>如果两个服务器上的日志条目有的相同索引和 term ，那么这两个日志条目存储的状态机命令是一样的。</li>
<li>如果两个服务器上的日志条目有的相同索引和 term ，那么这两个日志从头到这个索引是完全一样的。</li>
</ol>
<p>如果 Raft 处于复制状态，每个 follower 的日志是 leader 日志的前缀，显然日志匹配属性是满足的。在一个新的 leader 出来之后，follower 的日志可能和 leader 的日志一致，也可能处于以下三种不一致状态:</p>
<ol>
<li>follower 与 leader 相比少一些日志条目。 </li>
<li>follower 与 leader 相比多一些日志条目。 </li>
<li>包含(1)和(2)两种不一致情况。</li>
</ol>
<p>例如在下图中：</p>
<ul>
<li>follower (a) 和 follower (b) 属于不一致情况 1，比 leader 少</li>
<li>follower (c) 和 follower(d) 属于不一致情况 2，比 leader 多</li>
<li>follower (e) 和 follower (f) 属于不一致情况 3，比 leader 有少有多</li>
</ul>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-31-45-image-20240401193145426.png" alt="image-20240401193145426"></p>
<h3 id="确保一致性的方案"><a href="#确保一致性的方案" class="headerlink" title="确保一致性的方案"></a>确保一致性的方案</h3><p>如何保证一个新 term 的 leader 保存了所有提交的日志条目？</p>
<p>以下三点保证新 term 的 leader 保存了所有提交的日志条目:</p>
<ol>
<li>日志条目只有复制到了多个多个服务器上，才能提交。</li>
<li>一个 candidate 只有赢得了多个服务器的 vote ，才能成为 leader 。</li>
<li>并且要求只有 candidate 的日志比自己的新的时候才能 vote 。</li>
</ol>
<p>下图的 Raft 集群有 5 个服务器:S1、S2、S3、S4、S5：</p>
<ul>
<li>S1 是 leader。</li>
<li>S1 把一条日志复制了 S1、S2 和 S3 之后， 提交这一条日志。</li>
<li>以后发生了选举，S5 成了新 term U 的 leader。</li>
<li>上面两点保证一定有一个服务器收到了这条日志并参与了 term U 的投票，这里是 S3。</li>
<li>第 2 点又保证 S5 的日志比 S3 的新，所以 S5 必定保存了这条日志。</li>
</ul>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-33-00-image-20240401193300616.png" alt="image-20240401193300616"></p>
<h3 id="状态机命令的提交点"><a href="#状态机命令的提交点" class="headerlink" title="状态机命令的提交点"></a>状态机命令的提交点</h3><p>前面说过，一条日志在被复制到多个服务器之后就可以提交。但这是一种不准确的说法。</p>
<p>下图解释了为什么 leader 不能靠检查一条日志是否复制了到了大多数服务器上来确定旧 term 的日志条目是否已经提交。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-33-37-image-20240401193337557.png" alt="image-20240401193337557"></p>
<p>准确的说法：Raft 不会通过计算旧 term 的日志条目被复制到了多少台服务器来决定是否它已经被提交，只有当前 term 的日志条目提交状态可以这么决定。</p>
<p>如果当前 term 的日志条目被提交，那么基于日志匹配属性，我们知道之前的日志条目也都被间接的提交了。</p>
<h3 id="集群成员更新"><a href="#集群成员更新" class="headerlink" title="集群成员更新"></a>集群成员更新</h3><p>我们把 Raft 集群中的机器集合称为集群配置。到目前位置，我们都假定集群配置是固定的。</p>
<p>但在实际环境中，我们会经常需要更改配置，例如更换故障的机器或者更改日志的复制级别。我们希望 Raft 集群能够接受一个集群配置变更的请求，然后自动完成集群变更。</p>
<p>而且在集群配置的变更中，Raft 集群可以继续提供服务。另外集群配置的变更还要做到一定程度的容错。</p>
<p>Raft 提供一个两阶段的集群成员更新机制。</p>
<h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><p>etcd 是一个高可用的分布式 KV 系统，可以用来实现各种分布式协同服务。</p>
<p>etcd 采用的一致性算法是 raft，基于 Go 语言实现。</p>
<p>etcd 最初由 CoreOS 的团队研发，目前是 Could Native 基金会的孵化项目。 </p>
<p>为什么叫 <code>etcd</code>：<code>etc</code> 来源于 UNIX 的 <code>/etc</code> 配置文件目录，<code>d</code> 代表 <code>distributed system</code>。</p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>典型应用场景：</p>
<ul>
<li>Kubernetes 使用 <code>etcd</code> 来做服务发现和配置信息管理。</li>
<li>Openstack 使用 <code>etcd</code> 来做配置管理和分布式锁。</li>
<li>ROOK 使用 <code>etcd</code> 研发编排引擎。</li>
</ul>
<p><code>etcd</code> 和 ZooKeeper 覆盖基本一样的协同服务场景。</p>
<p>ZooKeeper 因为需要把所有的数据都要加载到内存，一般存储几百 MB 的数据。</p>
<p><code>etcd</code> 使用 <code>bbolt</code> 存储引擎，可以处理几个 GB 的数据。</p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>etcd 的数据模型是 KV模型，所有的 key 构成了一个扁平的命名空间，所有的 key 通过字典序排序。</p>
<p>整个 etcd 的 KV 存储维护一个递增的 64 位整数。</p>
<p>etcd 使用这个整数位为每一次 KV 更新分配一个 revision（基于 64 位整数）。每一个 key 可以有多个 revision。每一次更新操作都会生成一个新的 revision。删除操作会生成一个 <code>tombstone</code> 的新的 revision。</p>
<p>如果 etcd 进行了 compaction，etcd 会对 compaction revision 之前的 key-value 进行清理。</p>
<p>整个 KV 上最新的一次更新操作的 revision 叫作整个 KV 的 revision。</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>CreateRevision</th>
<th>ModRevision</th>
<th>Version</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>foo</td>
<td>10</td>
<td>10</td>
<td>1</td>
<td>one</td>
</tr>
<tr>
<td>foo</td>
<td>10</td>
<td>11</td>
<td>2</td>
<td>two</td>
</tr>
<tr>
<td>foo</td>
<td>10</td>
<td>12</td>
<td>3</td>
<td>three</td>
</tr>
</tbody></table>
<p>CreateRevision 是创建 key 的 revision；</p>
<p>ModRevsion 是更新 key 值的 revision；</p>
<p>Version 是 key 的版本号，从 1 开始。</p>
<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>可以把 etcd 看做一个状态机。</p>
<p>Etcd 的状态是所有的 key-value，revision 是状态的编号，每一个状态转换是若干个 key 的更新操作。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-49-04-image-20240401194904819.png" alt="image-20240401194904819"></p>
<ul>
<li>最开始没有数据，此时系统的 <code>reversion</code> 为 1；</li>
<li>创建变量 <code>foo</code> 值为 <code>one</code>，此时 KV store  的 <code>reversion</code> 加 1，为 2；<code>foo</code> 的 CreateRevision 为 2，表示创建时的 reversion，ModRevision 为 2，表示更改时的 reversion 为 2，Version 为 1，代表这是这个值的第一个版本</li>
<li>现在将 foo 改为 two，并且创建一个 bar 值为 one；此时 KV store 加 1，为 3；</li>
<li>foo 的 ModReversion 变为 3，表示更新这个值时的 reversion 为 3，version 为 2，表示这个值的第二个版本（foo 的 value 是一个列表，存储多个版本的信息，老版本的信息也会存储）</li>
<li>bar 同理</li>
</ul>
<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><ul>
<li>etcd 使用 bbolt 进行 KV 的存储。bbolt 使用持久化的 <code>B+tree</code> 保存 key-value。<ul>
<li>三元组 (major、sub、type)是 <code>B+tree</code> 的 key，</li>
<li>major 是的 revision，</li>
<li>sub 用来区别一次更新中的各个 key，</li>
<li>type 保存可选的特殊值(例如 type 取值为 t 代表这个三元组对应的是一个 tombstone)。</li>
<li>这样做的目的是为加速某一个 revision 上的 range 查找。</li>
</ul>
</li>
<li>另外 etcd 还维护一个 <code>in-memory</code> 的 <code>B-tree</code> 索引，这个索引中的 key 是 key-value 中的 key 。</li>
</ul>
<p>内存中的 value 存储的是 value 的当前 value，revision 信息是存储在 etcd 的持久化存储 <code>bbolt</code> 中</p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>安装配置 etcd 的步骤：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0Y2QtaW8vZXRjZC9yZWxlYXNlcw==">https://github.com/etcd-io/etcd/releases<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># etcd 有多个版本，通过环境变量确定版本</span></span><br><span class="line">ETCD_VER=v3.5.13</span><br><span class="line"></span><br><span class="line"><span class="comment"># choose either URL</span></span><br><span class="line">GOOGLE_URL=https://storage.googleapis.com/etcd</span><br><span class="line">GITHUB_URL=https://github.com/etcd-io/etcd/releases/download</span><br><span class="line">DOWNLOAD_URL=<span class="variable">$&#123;GOOGLE_URL&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -f /tmp/etcd-<span class="variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /tmp/etcd-download-test &amp;&amp; <span class="built_in">mkdir</span> -p /tmp/etcd-download-test</span><br><span class="line"></span><br><span class="line">curl -L <span class="variable">$&#123;DOWNLOAD_URL&#125;</span>/<span class="variable">$&#123;ETCD_VER&#125;</span>/etcd-<span class="variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz -o /tmp/etcd-<span class="variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz</span><br><span class="line">tar xzvf /tmp/etcd-<span class="variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz -C /tmp/etcd-download-test --strip-components=1</span><br><span class="line"><span class="built_in">rm</span> -f /tmp/etcd-<span class="variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端版本</span></span><br><span class="line">/tmp/etcd-download-test/etcd --version</span><br><span class="line"><span class="comment"># 客户端工具版本</span></span><br><span class="line">/tmp/etcd-download-test/etcdctl version</span><br><span class="line"><span class="comment"># 在etcd 3.5中，etcd 将一些直接操作 etcd 存储文件的管理命令单独独立成了 etcdutl 工具，它包括快照备份、快照重建、碎片整理功能。</span></span><br><span class="line">/tmp/etcd-download-test/etcdutl version</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGVuY2VudC1jbG91ZC1uYXRpdmUvcC8xNDg5MzIwOS5odG1s">一篇文章带你搞懂 etcd 3.5 的核心特性<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="使用-etcdctl"><a href="#使用-etcdctl" class="headerlink" title="使用 etcdctl"></a>使用 etcdctl</h3><p>在 <code>&#123;db-dir&#125;</code> 目录运行 etcd 启动 etcd 服务，让后在另外一个终端运行：</p>
<ul>
<li><code>etcdctl put foo bar</code>：写入键值</li>
<li><code>etcdctl get foo</code>：通过键获取值</li>
<li><code>etcdctl del foo</code>：删除键值</li>
</ul>
<p><code>etcdctl get &quot;&quot; --prefix=true</code> 可以用来扫描 etcd 的所有数据。</p>
<p><code>etcdctl del &quot;&quot; --prefix=true</code> 可以用来删除 etcd 中的所有数据。</p>
<h3 id="使用-etcd-HTTP-API"><a href="#使用-etcd-HTTP-API" class="headerlink" title="使用 etcd HTTP API"></a>使用 etcd HTTP API</h3><p>除了使用 etcdctl 工具访问 etcd，我们可以使用 etcd HTTP Rest API。</p>
<ul>
<li><p><code>http POST http://localhost:2379/v3/kv/put &lt;&lt;&lt; &#39;&#123;&quot;key&quot;: &quot;Zm9v&quot;, &quot;value&quot;: &quot;YmFy&quot;&#125;&#39;</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Access-Control-Allow-Headers: accept, content-type, authorization</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS, PUT, DELETE</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Content-Length: 114</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Tue, 02 Apr 2024 03:14:34 GMT</span><br><span class="line">Grpc-Metadata-Content-Type: application/grpc</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;header&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;cluster_id&quot;</span>: <span class="string">&quot;14841639068965178418&quot;</span>,</span><br><span class="line">        <span class="string">&quot;member_id&quot;</span>: <span class="string">&quot;10276657743932975437&quot;</span>,</span><br><span class="line">        <span class="string">&quot;raft_term&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;revision&quot;</span>: <span class="string">&quot;5&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>http POST http://localhost:2379/v3/kv/range &lt;&lt;&lt; &#39;&#123;&quot;key&quot;: &quot;Zm9v&quot;&#125;&#39;</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Access-Control-Allow-Headers: accept, content-type, authorization</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS, PUT, DELETE</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Content-Length: 219</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Tue, 02 Apr 2024 03:15:03 GMT</span><br><span class="line">Grpc-Metadata-Content-Type: application/grpc</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;count&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;header&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;cluster_id&quot;</span>: <span class="string">&quot;14841639068965178418&quot;</span>,</span><br><span class="line">        <span class="string">&quot;member_id&quot;</span>: <span class="string">&quot;10276657743932975437&quot;</span>,</span><br><span class="line">        <span class="string">&quot;raft_term&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;revision&quot;</span>: <span class="string">&quot;5&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;kvs&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;create_revision&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;Zm9v&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mod_revision&quot;</span>: <span class="string">&quot;5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: <span class="string">&quot;YmFy&quot;</span>,</span><br><span class="line">            <span class="string">&quot;version&quot;</span>: <span class="string">&quot;4&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Zm9v 是 foo 的 base64 编码， YmFy 是 bar 的 base64 编码。</p>
<p>和 etcdctl 相比，etcd HTTP API 返回的数据更多，可以帮助我们学习 etcd API 的行为。</p>
<h3 id="etcd-API-的-KV-部分"><a href="#etcd-API-的-KV-部分" class="headerlink" title="etcd API 的 KV 部分"></a>etcd API 的 KV 部分</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F19-54-59-image-20240401195459701.png" alt="image-20240401195459701"></p>
<p>etcd 使用 gRPC 提供对外 API。</p>
<p>Etcd 官方提供一个 Go 客户端库。 Go 客户端库是对 gRPC 调用的封装， 对于其他常见语言也有第三方提供的客户端库。</p>
<p>另外 etcd 还用 gRPC gateway 对外提供了 HTTP API。可见 etcd 提供了丰富的客户端接入方式。</p>
<p>ZooKeeper 的 RPC 是基于 jute 的，客户端只有 Java 版和 C 语言版，接入方式相少一些。</p>
<p>和 ZooKeeper 的客户端库不同，etcd 的客户端不会自动和服务器端建立一个 session，但是可以使用 Lease API 来实现 session。</p>
<h4 id="etcd-API"><a href="#etcd-API" class="headerlink" title="etcd API"></a>etcd API</h4><p>etcd 使用 gRPC 提供对外 API。etcd 的 API 分为三大类：</p>
<ul>
<li>KV：key-value 的创建、更新、读取和删除。</li>
<li>Watch：提供监控数据更新的机制。</li>
<li>Lease：用来支持来自客户端的 keep-alive 消息。（Lease 允许用户为特定的键值对分配一个时间段，在这段时间内，该键值对将保持有效。一旦 Lease 过期，与该 Lease 相关的键值对将被自动删除。）</li>
</ul>
<h4 id="Response-Header"><a href="#Response-Header" class="headerlink" title="Response Header"></a>Response Header</h4><p>所有的 RPC 响应都有一个 response header，Protobuf response header 包含以下信息：</p>
<ul>
<li><code>cluster_id</code>：创建响应的 etcd 集群 ID。</li>
<li><code>member_id</code>：创建响应的 etcd 节点 ID。</li>
<li><code>revision</code>：创建响应时 etcd KV 的 revision。</li>
<li><code>raft_term</code>：创建响应时的 raft term。</li>
</ul>
<h4 id="KeyValue"><a href="#KeyValue" class="headerlink" title="KeyValue"></a>KeyValue</h4><p>Key-value 是 etcd API 处理的最小数据单元，一个 Protobuf KeyValue 消息包含如下信息​：</p>
<ul>
<li><code>key</code>：​key 的类型为字节 slice。</li>
<li><code>create_revision</code>：key-value 的创建 revision。</li>
<li><code>mod_revision</code>：key-value 的修改 revision。</li>
<li><code>version</code>：key-value 的版本，从 1 开始。</li>
<li><code>value</code>：value 的类型为字节 slice。</li>
<li><code>lease</code>：和 key-value 关联的 leaseID。0 代表没有关联的 lease。</li>
</ul>
<h4 id="Key-Range"><a href="#Key-Range" class="headerlink" title="Key Range"></a>Key Range</h4><p><code>key range [key, range_end)</code> 代表从 key (包含) 到 <code>range_end</code> (不包含) 的 <code>key</code> 的区间。<code>etcd</code> API 使用可以 <code>range</code> 来检索 <code>key-value</code>。</p>
<ul>
<li><code>[x,x+&#39;\x00&#39;)</code>代表单个 key <code>a</code>，例如 <code>[&#39;a&#39;,&#39;a\x00)</code> 代表单个 <code>key &#39;a&#39;</code>。对应 ZooKeeper，可以用 <code>[&#39;/a&#39;, &#39;/a\x00&#39;)</code> 表示 <code>/a</code> 这个节点。</li>
<li><code>[x,x+1)</code> 代表前缀为 x 的 key，例如 <code>[&#39;a&#39;,&#39;b)</code> 代表所有前缀为 <code>b</code> 的 key。对应 ZooKeeper， 可以用 <code>[&#39;/a/&#39;, &#39;/a0&#39;)</code> 来表示目录 <code>/a</code> 下所有的子孙节点，但是没有办法使用 range 表示 <code>/a</code> 下的所有孩子节点。</li>
<li><code>[&#39;\x00&#39;,&#39;\x00&#39;)</code> 代表整个的 key 空间。</li>
<li><code>[a,&#39;\x00&#39;)</code> 代表所有不小于 a(非 <code>\x00</code>)的 key。</li>
</ul>
<h4 id="KV-服务"><a href="#KV-服务" class="headerlink" title="KV 服务"></a>KV 服务</h4><p>KV 服务主要包含以下 API：</p>
<ul>
<li><code>Range</code>：返回 range 区间中的 key-value。</li>
<li><code>Put</code>：写入一个 key-value。</li>
<li><code>DeleteRange</code>：删除 range 区间中的 key-value。</li>
<li><code>Txn</code>：提供一个 If&#x2F;Then&#x2F;Else 的原子操作，提供了一定程度的事务支持。</li>
</ul>
<p>Range 和 DeleteRange 操作的对象是一个 key range，Put 操作的对象是单个的 key， Txn 的 If 中进行比较的对象也是单个的 key。</p>
<h4 id="Range-API"><a href="#Range-API" class="headerlink" title="Range API"></a>Range API</h4><p>etcd 的 Range 默认执行 <code>linearizable read</code>（<strong>线性化读取</strong>，读取到最新数据，但性能不好），但是可以配置成 <code>serializable read</code>（<strong>串行化读取</strong>，可能读取到旧数据，但是性能好）。</p>
<p>ZooKeeper 的数据读取 API 只支持 serializable read。</p>
<h3 id="etcd-API-的-Watch-和-Lease-部分"><a href="#etcd-API-的-Watch-和-Lease-部分" class="headerlink" title="etcd API 的 Watch 和 Lease 部分"></a>etcd API 的 Watch 和 Lease 部分</h3><h4 id="Txn-API"><a href="#Txn-API" class="headerlink" title="Txn API"></a>Txn API</h4><p>Txn 是 etcd kv 上面的 <code>If/Then/Else</code> 原子操作。如果 If 中的多个 Compare 的交为 true，执行 Then 中的若干 RequestOp，否则执行 Else 中的若干 RequestOp。</p>
<ul>
<li>多个 Compare 可以使用多个 key。</li>
<li>多个 RequestOp 可以用来操作不同的 key，后面的 RequestOp 能读到前面 RequestOp 的执行结果。所有的更新 RequestOp 对应一个 revision。不能有多个更新的 RequestOp 操作一个 key。</li>
</ul>
<p>Txn API 提供一个更新整个 etcd kv 的原子操作。Txn 的 If 语句检查 etcd kv 中若干 key 的状态，然后根据检查的结果更新整个 etcd kv。</p>
<h4 id="Txn-API-语法图"><a href="#Txn-API-语法图" class="headerlink" title="Txn API 语法图"></a>Txn API 语法图</h4><p>下图是简化的 Txn API 语法图。因为你缺少某个语句和语句为空是等价的，省略了缺少 If 语句、Then 语句和 Else 语句的情况。</p>
<ul>
<li>如果 Then 为空或者 Else 为空，Txn 只有一个分支。</li>
<li>如果 If 为空的话，If 的结果为 true。</li>
</ul>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-05-22-image-20240401200522545.png" alt="image-20240401200522545"></p>
<p>ZooKeeper 对应 etcd Txn API 的 API 是条件更新。条件更新对应的语法图如下图所示。</p>
<p>可以看出 Txn 要比条件更新灵活很多。条件更新只能对一个节点 A 的版本做比较，如果比较成功对 A 节点做 setData 或者 delete 操作。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-05-38-image-20240401200538807.png" alt="image-20240401200538807"></p>
<p>ZooKeeper 另外还有一个 Transaction API，可以原子执行一个操作序列，但是没有 Txn API 的条件执行操作的机制。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTxn</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cli := newClient(t)</span><br><span class="line">	<span class="keyword">defer</span> cli.Close()</span><br><span class="line"></span><br><span class="line">	key := <span class="string">&quot;TestTxn&quot;</span></span><br><span class="line">	thenValue := <span class="string">&quot;then&quot;</span></span><br><span class="line"></span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	_, err := cli.Txn(ctx).</span><br><span class="line">		If(v3.Compare(v3.Value(key), <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;2&quot;</span>)).</span><br><span class="line">		Then(v3.OpPut(key, thenValue)).</span><br><span class="line">		Else(v3.OpPut(key, <span class="string">&quot;else&quot;</span>)).</span><br><span class="line">		Commit()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return &quot;then&quot;</span></span><br><span class="line">	gresp, err := cli.Get(ctx, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> l := <span class="built_in">len</span>(gresp.Kvs); l != <span class="number">1</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;expeected 1 key-value, but got %d key-values\n&quot;</span>, l)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> value := <span class="type">string</span>(gresp.Kvs[<span class="number">0</span>].Value); value != <span class="string">&quot;then&quot;</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;expected value %s, but got %s\n&quot;</span>, thenValue, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, ev := <span class="keyword">range</span> gresp.Kvs &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s: %s\n&quot;</span>, ev.Key, ev.Value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//delete(cli, key, t)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTxnOpOrder</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cli := newClient(t)</span><br><span class="line">	<span class="keyword">defer</span> cli.Close()</span><br><span class="line">	key := <span class="string">&quot;TestTxnOpOrder&quot;</span></span><br><span class="line"></span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	<span class="comment">// If CreateRevision is 0, it means that the key does not exist.</span></span><br><span class="line">	cmp := v3.Compare(v3.CreateRevision(key), <span class="string">&quot;=&quot;</span>, <span class="number">0</span>)</span><br><span class="line">	put := v3.OpPut(key, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">	get := v3.OpGet(key)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get Put</span></span><br><span class="line">	resp, err := cli.Txn(ctx).If(cmp).Then(get, put).Commit()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	printTxnResponse(resp)</span><br><span class="line">	<span class="keyword">if</span> l := <span class="built_in">len</span>(resp.Responses[<span class="number">0</span>].GetResponseRange().Kvs); l != <span class="number">0</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;expeected 0 key-value, but got %d key-values\n&quot;</span>, l)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(ctx, cli, key, t)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Put Get</span></span><br><span class="line">	resp, err = cli.Txn(ctx).If(cmp).Then(put, get).Commit()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	printTxnResponse(resp)</span><br><span class="line">	<span class="keyword">if</span> l := <span class="built_in">len</span>(resp.Responses[<span class="number">1</span>].GetResponseRange().Kvs); l != <span class="number">1</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;expeected 1 key-value, but got %d key-values\n&quot;</span>, l)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(ctx, cli, key, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTxnMultis</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cli := newClient(t)</span><br><span class="line">	<span class="keyword">defer</span> cli.Close()</span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	keyPrefix := <span class="string">&quot;TestTxnMultis&quot;</span></span><br><span class="line">	keys := []<span class="type">string</span>&#123;keyPrefix + <span class="string">&quot;1&quot;</span>, keyPrefix + <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> cmps [<span class="number">2</span>]v3.Cmp</span><br><span class="line">	<span class="keyword">var</span> puts [<span class="number">2</span>]v3.Op</span><br><span class="line">	<span class="keyword">var</span> gets [<span class="number">2</span>]v3.Op</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		val := <span class="type">string</span>(i + <span class="number">1</span>)</span><br><span class="line">		cmps[i] = v3.Compare(v3.CreateRevision(keys[i]), <span class="string">&quot;=&quot;</span>, <span class="number">0</span>)</span><br><span class="line">		puts[i] = v3.OpPut(keys[i], val)</span><br><span class="line">		gets[i] = v3.OpGet(keys[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Executes two Puts</span></span><br><span class="line">	tresp, err := cli.Txn(ctx).If(cmps[:]...).Then(puts[:]...).Else(gets[:]...).Commit()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(t)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !tresp.Succeeded &#123;</span><br><span class="line">		t.Fatal(<span class="string">&quot;Txn should succeed, but failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Executes two Gets</span></span><br><span class="line">	tresp, err = cli.Txn(ctx).If(cmps[:]...).Then(puts[:]...).Else(gets[:]...).Commit()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(t)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tresp.Succeeded &#123;</span><br><span class="line">		t.Fatal(<span class="string">&quot;Txn should fail, but succeeded&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> count := tresp.Responses[i].GetResponseRange().Count; count != <span class="number">1</span> &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;expected 1 value for key %s, but got %d value&quot;</span>, keys[<span class="number">0</span>], count)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Execute two Deletes</span></span><br><span class="line">	tresp, err = cli.Txn(ctx).Then(v3.OpDelete(keys[<span class="number">0</span>]), v3.OpDelete(keys[<span class="number">1</span>])).Commit();</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> tresp.Responses &#123;</span><br><span class="line">		<span class="keyword">if</span> deleted := r.GetResponseDeleteRange().Deleted; deleted != <span class="number">1</span> &#123;</span><br><span class="line">			t.Fatalf(<span class="string">&quot;expected to delete 1 key-value, but deleted %d key-value&quot;</span>, deleted)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	gresp, err := cli.Get(ctx, keyPrefix, v3.WithPrefix())</span><br><span class="line">	<span class="keyword">if</span> gresp.Count != <span class="number">0</span> &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;expected 0 key-values, bot got %d&quot;</span>, gresp.Count)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Watch-API"><a href="#Watch-API" class="headerlink" title="Watch API"></a>Watch API</h4><p>Watch API 提供一个监控 etcd KV 更新事件的机制。etcd Watch 可以从一个历史的 revision 或者当前的 revision 开始监控一个 key range 的更新。</p>
<p>ZooKeeper 的 Watch 机制只能监控一个节点的当前时间之后的更新事件，但是 ZooKeeper 的 Watch 支持提供了对子节点更新的原生支持。</p>
<p>etcd 没有对应的原生支持，但是可以用通过一个 key range 来监控一个目录下所有子孙的更新。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOneWatch</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cli := newClient(t)</span><br><span class="line">	<span class="keyword">defer</span> cli.Close()</span><br><span class="line"></span><br><span class="line">	rch := cli.Watch(context.Background(), <span class="string">&quot;TestOneWatch&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> wresp := <span class="keyword">range</span> rch &#123;</span><br><span class="line">		printEvents(&amp;wresp)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTwoWatches</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cli := newClient(t)</span><br><span class="line"></span><br><span class="line">	keys := []<span class="type">string</span>&#123;<span class="string">&quot;TestTwoWatches1&quot;</span>, <span class="string">&quot;TestTwoWatches2&quot;</span>&#125;</span><br><span class="line">	rch1 := cli.Watch(context.Background(), keys[<span class="number">0</span>])</span><br><span class="line">	rch2 := cli.Watch(context.Background(), keys[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> wresp1 := &lt;-rch1:</span><br><span class="line">			printEvents(&amp;wresp1)</span><br><span class="line">		<span class="keyword">case</span> wresp2 := &lt;-rch2:</span><br><span class="line">			printEvents(&amp;wresp2)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Lease-API"><a href="#Lease-API" class="headerlink" title="Lease API"></a>Lease API</h4><p>Lease 是用来检测客户端是否在线的机制。</p>
<p>客户端可以通过发送 LeaseGrantRequest 消息向 etcd 集群申请 lease，每个 lease 有一个 TTL(time-to-live)。</p>
<p>客户端可以通过发送 LeaseKeepAliveRequest 消息来延长自己的的 lease。</p>
<p>如果 etcd 集群在 TTL 时间内没有收到来自客户端的 keep alive 消息，lease 就会过期。另外客户端也可以通过发送 LeaseRevokeRequest 消息给 etcd 集群来主动的放弃自己的租约。</p>
<p>可以把一个 lease 和一个 key 绑定在一起。在 lease 过期之后，关联的 key 会被删除，这个删除操作会生成一个 revision。</p>
<p>客户端可以通过不断发送 LeaseKeepAliveRequest 来维持一个和 etcd 集群的 session。和 lease 关联的 key 和 ZooKeeper 的临时性节点类似。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLeaseWithKeepAliveOnce</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cli := newClient(t)</span><br><span class="line">	<span class="keyword">defer</span> cli.Close()</span><br><span class="line">	key := <span class="string">&quot;TestLeaseWithKeepAliveOnce&quot;</span></span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Put with Lease</span></span><br><span class="line">	resp, err := cli.Grant(ctx, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = cli.Put(ctx, key, <span class="string">&quot;bar&quot;</span>, v3.WithLease(resp.ID))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">8</span> * time.Second)</span><br><span class="line">		response, err := cli.Get(ctx, key)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;kvs: %q\n&quot;</span>, response.Kvs)</span><br><span class="line">		<span class="keyword">if</span> response.Count != <span class="number">1</span> &#123;</span><br><span class="line">			t.Fatalf(<span class="string">&quot;expected count %d, but got %d\n&quot;</span>, <span class="number">1</span>, response.Count)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Renew the lease only once. If the following code block is commented,</span></span><br><span class="line">	<span class="comment">// the above response.Count check will fail.</span></span><br><span class="line">	time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">	_, kaerr := cli.KeepAliveOnce(ctx, resp.ID)</span><br><span class="line">	<span class="keyword">if</span> kaerr != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(kaerr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">12</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-etcd-实现分布式队列"><a href="#使用-etcd-实现分布式队列" class="headerlink" title="使用 etcd 实现分布式队列"></a>使用 etcd 实现分布式队列</h3><h4 id="队列基础"><a href="#队列基础" class="headerlink" title="队列基础"></a>队列基础</h4><p>队列是一种 FIFO 的数据结构。</p>
<p>队列首先可以用来保存元素入队的顺序，图的广度优先搜索算法就是用队列来保存访问节点的顺序。队列还可以用来做生产者和消费者的处理，把同步操作异步化。</p>
<p>并发队列支持的入队和出队操作的并发执行，例如 Java 的 BlockingQueue。</p>
<p>分布式队列也是一种并发队列，但是分布式队列的生产者和消费者可以是独立的 agent。</p>
<p>例如 Kafka 就 是一个分布式消息队列。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-07-19-image-20240401200719662.png" alt="image-20240401200719662"></p>
<h4 id="设计-3"><a href="#设计-3" class="headerlink" title="设计"></a>设计</h4><p>使用 key 为某一固定前缀(例如 <code>queue/</code>)来表示队列中的元素。 ModRevision 的大小表示元素在队列中的位置，小的在队列前面，大的在队列后面。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-07-52-image-20240401200752535.png" alt="image-20240401200752535"></p>
<p>设计思想和 ZooKeeper 的分布式队列是一样的。</p>
<p>ZooKeeper 的 recipe 中使用顺序号表示队列元素的位置。</p>
<p>etcd 的 ModRevision 和 ZooKeeper 的顺序号都是代表了数据创建顺序，都可以代表元素的入队时间。（但是这种做法可能会出现时间戳一样导致冲突，可以通过重试解决）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// putNewKV attempts to create the given key, only succeeding if the key did</span></span><br><span class="line"><span class="comment">// not yet exist.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putNewKV</span><span class="params">(kv v3.KV, key, val <span class="type">string</span>, leaseID v3.LeaseID)</span></span> (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	cmp := v3.Compare(v3.Version(key), <span class="string">&quot;=&quot;</span>, <span class="number">0</span>)</span><br><span class="line">	req := v3.OpPut(key, val, v3.WithLease(leaseID))</span><br><span class="line">	txnresp, err := kv.Txn(context.TODO()).If(cmp).Then(req).Commit()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !txnresp.Succeeded &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, ErrKeyExists</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;key: %s, val: %s, mod rev: %d\n&quot;</span>, key, val, txnresp.Header.Revision)</span><br><span class="line">	<span class="keyword">return</span> txnresp.Header.Revision, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h4><p>如果两个 agent A 和 B 进行入队操作的时候恰好使用了同样的时间戳，其中一个 agent 的入队操作就会失败。但是发生这种情况的概率是很低的，所以不用影响分布式队列的实际使用。发生这种情况的时候，入队失败的 agent 进行重试。</p>
<p>ZooKeeper 实现的队列没上述问题，原因在于它使用了 ZooKeeper 自己分配的序列号来命名队列元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dequeue returns Enqueue()&#x27;d elements in FIFO order. If the queue is empty, Dequeue blocks until elements are</span></span><br><span class="line"><span class="comment">// available. It is similar to Java BlockingQueue&#x27;s take method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> Dequeue() (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	resp, err := q.client.Get(q.ctx, q.keyPrefix, v3.WithFirstRev()...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kv, err := claimFirstKey(q.client, resp.Kvs)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> kv != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">string</span>(kv.Value), <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> resp.More &#123;</span><br><span class="line">		<span class="comment">// Missed some items, retry to read in more</span></span><br><span class="line">		<span class="keyword">return</span> q.Dequeue()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Nothing yet: wait on elements</span></span><br><span class="line">	ev, err := WaitPrefixEvents(q.client, q.keyPrefix, resp.Header.Revision, []mvccpb.Event_EventType&#123;mvccpb.PUT&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ok, err := deleteRevKey(q.client, <span class="type">string</span>(ev.Kv.Key), ev.Kv.ModRevision)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> q.Dequeue()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(ev.Kv.Value), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-etcd-实现分布式锁"><a href="#使用-etcd-实现分布式锁" class="headerlink" title="使用 etcd 实现分布式锁"></a>使用 etcd 实现分布式锁</h3><h4 id="排它锁-Mutex-基础"><a href="#排它锁-Mutex-基础" class="headerlink" title="排它锁(Mutex)基础"></a>排它锁(Mutex)基础</h4><p>Mutex 用来保证只有一个 agent 运行在临界区。在单机环境，可以使用 CAS 指令来实现 Mutex。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-08-58-image-20240401200858813.png" alt="image-20240401200858813"></p>
<h4 id="分布式排它锁"><a href="#分布式排它锁" class="headerlink" title="分布式排它锁"></a>分布式排它锁</h4><p>一个分布式 Mutex 除了需要类似 CAS 指令的机制以外，还需要处理持有锁的 agent 失败的情况。</p>
<p>如果持有者的 agent 失败了，需要一个心跳机制自动释放 Mutex。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-09-26-image-20240401200926383.png" alt="image-20240401200926383"></p>
<h3 id="设计-4"><a href="#设计-4" class="headerlink" title="设计"></a>设计</h3><p>使用 key 为某一固定前缀(例如 <code>/lock/</code>)的 key-value 来表示锁请求。</p>
<p>每个表示锁请求的 key 都和 lease 关联，这样在所持有者失败的情况下，相关的 key 会被自动删除，从而释放锁。</p>
<p>代表锁请求的 key 的 CreateRevision 越小，越先获得锁。CreateRevision 最小的锁请求可以成功获取锁。</p>
<p>为了避免羊群效应，每个等待的锁请求 watch 它前面的锁请求。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-35-31-image-20240401203531635.png" alt="image-20240401203531635"></p>
<p>设计思想和 ZooKeeper 的分布式锁是一样的。ZooKeeper 的 recipe 中使用顺序号表示队列元素的位置。 </p>
<p>etcd 的 CreateRevision 和 ZooKeeper 的顺序号都是代表了数据创建顺序，都可以代表锁请求的先后顺序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	s *concurrency.Session</span><br><span class="line"></span><br><span class="line">	pfx   <span class="type">string</span></span><br><span class="line">	myKey <span class="type">string</span></span><br><span class="line">	myRev <span class="type">int64</span></span><br><span class="line">	hdr   *pb.ResponseHeader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">	s := m.s</span><br><span class="line">	client := m.s.Client()</span><br><span class="line"></span><br><span class="line">	m.myKey = fmt.Sprintf(<span class="string">&quot;%s%x&quot;</span>, m.pfx, s.Lease())</span><br><span class="line">	cmp := v3.Compare(v3.CreateRevision(m.myKey), <span class="string">&quot;=&quot;</span>, <span class="number">0</span>)</span><br><span class="line">	put := v3.OpPut(m.myKey, <span class="string">&quot;&quot;</span>, v3.WithLease(s.Lease()))</span><br><span class="line">	get := v3.OpGet(m.myKey)</span><br><span class="line">	getOwner := v3.OpGet(m.pfx, v3.WithFirstCreate()...)</span><br><span class="line">	resp, err := client.Txn(ctx).If(cmp).Then(put, getOwner).Else(get, getOwner).Commit()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		m.hdr = resp.Header</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	m.myRev = resp.Header.Revision</span><br><span class="line">	<span class="keyword">if</span> !resp.Succeeded &#123;</span><br><span class="line">		m.myRev = resp.Responses[<span class="number">0</span>].GetResponseRange().Kvs[<span class="number">0</span>].CreateRevision</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if no key on prefix / the minimum rev is key, already hold the lock</span></span><br><span class="line">	ownerKey := resp.Responses[<span class="number">1</span>].GetResponseRange().Kvs</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ownerKey) == <span class="number">0</span> || ownerKey[<span class="number">0</span>].CreateRevision == m.myRev &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait for deletion revisions prior to myKey</span></span><br><span class="line">	hdr, werr := waitDeletes(ctx, client, m.pfx, m.myRev<span class="number">-1</span>)</span><br><span class="line">	<span class="comment">// release lock key if wait failed</span></span><br><span class="line">	<span class="keyword">if</span> werr != <span class="literal">nil</span> &#123;</span><br><span class="line">		m.Unlock(client.Ctx())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		m.hdr = hdr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> werr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// waitDeletes efficiently waits until all keys matching the prefix and no greater</span></span><br><span class="line"><span class="comment">// than the create revision.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitDeletes</span><span class="params">(ctx context.Context, client *v3.Client, pfx <span class="type">string</span>, maxCreateRev <span class="type">int64</span>)</span></span> (*pb.ResponseHeader, <span class="type">error</span>) &#123;</span><br><span class="line">	getOpts := <span class="built_in">append</span>(v3.WithLastCreate(), v3.WithMaxCreateRev(maxCreateRev))</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		resp, err := client.Get(ctx, pfx, getOpts...)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(resp.Kvs) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> resp.Header, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		lastKey := <span class="type">string</span>(resp.Kvs[<span class="number">0</span>].Key)</span><br><span class="line">		<span class="keyword">if</span> err = waitDelete(ctx, client, lastKey, resp.Header.Revision); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搭建一个-etcd-生产环境"><a href="#搭建一个-etcd-生产环境" class="headerlink" title="搭建一个 etcd 生产环境"></a>搭建一个 etcd 生产环境</h3><p>etcd 集群：一个 etcd 集群通常由奇数个节点组成。</p>
<p>节点之间默认使用 TCP 2380 端口进行通讯，每个节点默认使用 2379 对外提供 gRPC 服务。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-36-20-image-20240401203620567.png" alt="image-20240401203620567"></p>
<h4 id="clientv3-grpc1-23-架构"><a href="#clientv3-grpc1-23-架构" class="headerlink" title="clientv3-grpc1.23 架构"></a>clientv3-grpc1.23 架构</h4><p>客户端有一个内置的 balancer。这个 balancer 和每一个 etcd 集群中的节点预先建立一个 TCP 连接。</p>
<p>balancer 使用轮询策略向集群中的节点发送 RPC 请求。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-36-57-image-20240401203657511.png" alt="image-20240401203657511"></p>
<h4 id="etcd-gateway"><a href="#etcd-gateway" class="headerlink" title="etcd gateway"></a>etcd gateway</h4><p>etcd gateway 是一个4层代理。客户端可以通过 etcd gateway 访问 etcd 集群中的各个节点。 </p>
<p>这样在集群中成员节点发生变化，只要在 etcd gateway 上面更新一次 etcd 集群节点访问地址就可以了，用不重要每个客户端都更新。</p>
<p>对于来自客户端的每一个 TCP 连接，etcd gateway 采用轮询方式的选择一个 etcd 节点，把这个 TCP 连接代理到这个节点上。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-37-51-image-20240401203750922.png" alt="image-20240401203750922"></p>
<h4 id="gRPC-proxy"><a href="#gRPC-proxy" class="headerlink" title="gRPC proxy"></a>gRPC proxy</h4><p>gRPC proxy 是一个7层代理，可以用来减少 etcd 集群的负载。</p>
<p>gRPC proxy 除了合并客户端的 watch API 和 lease API 的请求，并且会 cache 来自 etcd 集群的响应。</p>
<p>gRPC proxy 会随机的选取选取集群中的一个节点建立连接。如果当前连接的节点失败， gRPC proxy 才会切换到集群中 另外一个节点。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-38-20-image-20240401203820784.png" alt="image-20240401203820784"></p>
<h4 id="配置一个3节点的集群"><a href="#配置一个3节点的集群" class="headerlink" title="配置一个3节点的集群"></a>配置一个3节点的集群</h4><p>启动一个3节点的 etcd 集群和一个 gPRC proxy 的步骤：</p>
<ul>
<li>安装 Go1.13</li>
<li>使用 <code>go get github.com/mattn/goreman</code> 安装 goreman</li>
<li>编辑 Procfile</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0Y2QtaW8vZXRjZC9ibG9iL21hc3Rlci9Qcm9jZmlsZQ==">https://github.com/etcd-io/etcd/blob/master/Procfile<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Adapted https://github.com/etcd-io/etcd/blob/master/Procfile</span></span><br><span class="line"><span class="comment"># Use goreman to run `go get github.com/mattn/goreman`</span></span><br><span class="line">etcd1: etcd --name infra1 --listen-client-urls http://127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --listen-peer-urls http://127.0.0.1:12380 --initial-advertise-peer-urls http://127.0.0.1:12380 --initial-cluster-token etcd-cluster-1 --initial-cluster <span class="string">&#x27;infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380&#x27;</span> --initial-cluster-state new --enable-pprof --logger=zap --log-outputs=stderr</span><br><span class="line">etcd2: etcd --name infra2 --listen-client-urls http://127.0.0.1:22379 --advertise-client-urls http://127.0.0.1:22379 --listen-peer-urls http://127.0.0.1:22380 --initial-advertise-peer-urls http://127.0.0.1:22380 --initial-cluster-token etcd-cluster-1 --initial-cluster <span class="string">&#x27;infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380&#x27;</span> --initial-cluster-state new --enable-pprof --logger=zap --log-outputs=stderr</span><br><span class="line">etcd3: etcd --name infra3 --listen-client-urls http://127.0.0.1:32379 --advertise-client-urls http://127.0.0.1:32379 --listen-peer-urls http://127.0.0.1:32380 --initial-advertise-peer-urls http://127.0.0.1:32380 --initial-cluster-token etcd-cluster-1 --initial-cluster <span class="string">&#x27;infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380&#x27;</span> --initial-cluster-state new --enable-pprof --logger=zap --log-outputs=stderr</span><br><span class="line">proxy: etcd grpc-proxy start --endpoints=127.0.0.1:2379,127.0.0.1:22379,127.0.0.1:32379 --listen-addr=127.0.0.1:23790 --advertise-client-url=127.0.0.1:23790 --enable-pprof</span><br></pre></td></tr></table></figure>

<p><strong>动态添加删除节点</strong></p>
<p>可以使用 etcdctl member 命令动态添加和删除节点。</p>
<h4 id="比较-ZooKeeper-和-etcd"><a href="#比较-ZooKeeper-和-etcd" class="headerlink" title="比较 ZooKeeper 和 etcd"></a>比较 ZooKeeper 和 etcd</h4><p>ZooKeeper 和 etcd 都是优秀的分布式协同服务平台，都有很大的生态圈。</p>
<ul>
<li>ZooKeeper更成熟，系统更稳定，文档更加完备。在大数据生态，ZooKeeper是首选。如果研发首选语言是基于 JVM 的，建议 ZooKeeper。</li>
<li>etcd的架构更先进一些。在云计算领域，etcd是首选。如果研发首选语言是Go，建议etcd。</li>
</ul>
<h1 id="实现原理和源码解读"><a href="#实现原理和源码解读" class="headerlink" title="实现原理和源码解读"></a>实现原理和源码解读</h1><h2 id="存储数据结构之-B-tree"><a href="#存储数据结构之-B-tree" class="headerlink" title="存储数据结构之 B-tree"></a>存储数据结构之 B-tree</h2><p>B-tree 的应用十分广泛，尤其是在关系型数据库领域，下面列出了一些知名的 B-tree 存储引擎：</p>
<ul>
<li>关系型数据库系统 Oracle、SQL Server、MySQL 和 PostgreSQL 都支持 B-tree。</li>
<li>WiredTiger 是 MongoDB 的默认存储引擎，开发语言是 C，支持 B-tree。</li>
<li>BoltDB：Go 语言开发的 B-tree 存储引擎，etcd 使用 BoltDB 的 fork bbolt。</li>
</ul>
<p>存储引擎一般用的都是 B+tree，但是存储引擎界不太区分 B-tree 和 B+tree，说 B-tree 的时候其实一般指的是 B+tree。</p>
<p>硬要说区别就是 B-tree 指的是节点上除了有索引信息，还有数据信息，而 B+tree 枝干节点上只有索引信息，叶子节点上有索引信息和数据信息。</p>
<h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>平衡二叉搜索树是用来快速查找 key-value 的有序数据结构。</p>
<p>平衡二叉搜索树适用于内存场景（指的是所有节点都存放在内存中国），但是不适用于于外部存储（节点信息存放在外部存储中，查询到一个节点需要从外部存储中获得信息）。原因在于每访问一个节点都要访问一次外部存储，而访问外部存储是非常耗时的。</p>
<p>要减少访问外部存储的次数，就要减少树的高度，要减少树的高度就要增加一个节点保存 key 的个数。B-tree 就是用增加节点中 key 个数的方案来减少对外部存储的访问。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-41-28-image-20240401204128454.png" alt="image-20240401204128454"></p>
<h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h3><p>B-tree 是一种平衡搜索树。</p>
<p>每一个 B-tree 有一个参数 t，叫做 minimum degree。每一个节点的 degree 在 t 和 2t 之间。</p>
<p>下图是一个每个节点的 degree 都为 t 的 B-tree。如果 t 为 1024 的话，下面的 B-tree 可以保存 1G 多的 key 值。</p>
<p>因为 B-tree 的内部节点通常可以缓存在内存中，访问一个 key 只需要访问一次外部存储。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-42-16-image-20240401204216083.png" alt="image-20240401204216083"></p>
<p>B-tree 和平衡二叉搜索树的算法复杂度一样的，但是减少了对外部存储的访问次数。</p>
<h4 id="B-tree-特点"><a href="#B-tree-特点" class="headerlink" title="B-tree 特点"></a>B-tree 特点</h4><ul>
<li>所有的节点添加都是通过节点分裂完成的。</li>
<li>所有的节点删除都是通过节点合并完成。</li>
<li>所有的插入都发生在叶子节点。</li>
<li>B-tree 的节点的大小通常是文件系统 block 大小的倍数，例如 4k，8k 和 16k。（例如 MySQL 中 InnoDB 存储引擎的默认页大小是 16KB）</li>
</ul>
<h3 id="B-tree-1"><a href="#B-tree-1" class="headerlink" title="B+tree"></a>B+tree</h3><p>为了让 B-tree 的内部节点可以具有更大的 degree，可以规定内部节点只保存 key，不保存 value。这样的 B-tree 叫作 B+tree。</p>
<p>另外通常会把叶子节点连成一个双向链表，方便 key-value 升序和降序扫描。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-43-32-image-20240401204332150.png" alt="image-20240401204332150"></p>
<h4 id="B-tree-索引"><a href="#B-tree-索引" class="headerlink" title="B+tree 索引"></a>B+tree 索引</h4><p>大部分关系型数据库表的主索引都是用的 B+tree。B+tree 的叶子节点叫作 data page，内部节点叫作 index page。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-43-52-image-20240401204352708.png" alt="image-20240401204352708"></p>
<h2 id="存储数据结构之-LSM"><a href="#存储数据结构之-LSM" class="headerlink" title="存储数据结构之 LSM"></a>存储数据结构之 LSM</h2><p>Log Structured Merge-tree（LSM）：是另外一种广泛使用的存储引擎数据结构。</p>
<p>LSM 是在 1996 发明的，但是到了 2006 年从 Bigtable 开始才受到关注。</p>
<h3 id="LSM-架构"><a href="#LSM-架构" class="headerlink" title="LSM 架构"></a>LSM 架构</h3><p>一个基于 LSM 的存储引擎有以下 3 部分组成：</p>
<ul>
<li><code>Memtable</code>：保存有序 KV 对的内存缓冲区。</li>
<li>多个 <code>SSTable</code>：保存有序 KV 对的只读文件。</li>
<li>日志：事务日志。</li>
</ul>
<p>LSM 存储 MVCC 的 key-value。每次更新一个 key-value 都会生成一个新版本，删除一个 key-value 会生成一个 tombstone 的新版本。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-44-56-image-20240401204456017.png" alt="image-20240401204456017"></p>
<h3 id="LSM-写操作"><a href="#LSM-写操作" class="headerlink" title="LSM 写操作"></a>LSM 写操作</h3><p>一个写操作首先在日志中追加事务日志，然后把新的 key-value 更新到 Memtable。LSM 的事务是 WAL</p>
<p>日志。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-45-26-image-20240401204526684.png" alt="image-20240401204526684"></p>
<h3 id="LSM-读操作"><a href="#LSM-读操作" class="headerlink" title="LSM 读操作"></a>LSM 读操作</h3><p>在由 Memtable 和 SSTable 合并成的一个有序 KV 视图上进行 Key 值的查找。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-46-09-image-20240401204609443.png" alt="image-20240401204609443"></p>
<p>例如在上图所示的 LSM 中，要查找一个 key a：</p>
<ol>
<li><p>在 memtable 中查找，如果查找到，返回。否则继续。</p>
</li>
<li><p>在 SSTable-0 中查找，如果查找到，返回。否则继续。</p>
</li>
<li><p>在 SSTable-1 中查找，如果查找到，返回。否则继续。</p>
</li>
<li><p>在 SSTable-2 中查找，如果查找到，返回。否则返回空值。</p>
</li>
</ol>
<h3 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h3><p>使用 Bloom filter 来提升 LSM 数据读取的性能。</p>
<p>Bloom filter 是一种随机数据结构，可以在 O(1) 时间内判断一个给定的元素是否在集合中。False positive 是可能的，既 Bloom filter 判断在集合中的元素有可能实际不在集合中，但是 false negative 是不可能的。</p>
<p>Bloom filter 由一个 m 位的位向量和 k 个相互独立的哈希函数 h1，h2，…，hk 构成。</p>
<ul>
<li>这些 hash 函数的值范围是 {1，…，m}。</li>
<li>初始化 Bloom filter 的时候把位向量的所有的位都置为 0。 </li>
<li>添加元素 a 到集合的时候，把维向量 h1(a)， h2(a)， hk(a) 位置上的位置为 1。</li>
<li>判断一个元素 b 是否在集合中的时候，检查把维向量 h1(b)， h2(b)， … ，hk(a) 位置上的位是否都为 1。</li>
<li>如果这些位都为 1，那么认为 b 在集合中；否则认为 b 不在集合之中。</li>
</ul>
<p>下图所示的是一个 m 为 14，k 为 3 的 Bloom filter。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-48-52-image-20240401204852798.png" alt="image-20240401204852798"></p>
<p>下面是计算 False positive 概率的公式（n 是添加过的元素数量）：</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-49-00-image-20240401204900346.png" alt="image-20240401204900346"></p>
<h3 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h3><p>如果我们一直对 memtable 进行写入，memtable 就会一直增大直到超出服务器的内部限制。所以我们需要把 memtable 的内存数据放到 durable storage 上去，生成 SSTable 文件，这叫做 minor compaction。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-49-46-image-20240401204946517.png" alt="image-20240401204946517"></p>
<ul>
<li>Minor compaction：把 memtable 的内容写到一个 SSTable。目的是减少内存消耗，另外减少数据恢复时需要从日志读取的数据量。</li>
<li>Merge compaction：把几个连续 level 的 SSTable 和 memtable 合并成一个 SSTable。目的是减少读操作要读取的 SSTable 数量。</li>
<li>Major compaction：合并所有 level 上的 SSTable 的 merge compaction。目的在于彻底删除 tombstone 数据，并释放存储空间。</li>
</ul>
<h3 id="基于-LSM-的存储引擎"><a href="#基于-LSM-的存储引擎" class="headerlink" title="基于 LSM 的存储引擎"></a>基于 LSM 的存储引擎</h3><p>下面列出了几个知名的基于 LSM 的存储引擎：</p>
<ul>
<li><code>LevelDB</code>：开发语言是 C++，Chrome 的 IndexedDB 使用的是 LevelDB。</li>
<li><code>RocksDB</code>：开发语言是 C++，RocksDB 功能丰富，应用十分广泛，例如 CockroachDB、TiKV 和 Kafka Streams 都使用了它。</li>
<li><code>Pebble</code>：开发语言是 Go，应用于 CockroachDB。</li>
<li><code>BadgerDB</code>：一种分离存储 key 和 value 的 LSM 存储引擎。</li>
<li><code>WiredTiger</code>：WiredTiger 除了支持 B-tree 以外，还支持 LSM。</li>
</ul>
<h3 id="存储引擎的放大指标（Amplification-Factors）"><a href="#存储引擎的放大指标（Amplification-Factors）" class="headerlink" title="存储引擎的放大指标（Amplification Factors）"></a>存储引擎的放大指标（Amplification Factors）</h3><p>对比存储引擎的三个指标：</p>
<ul>
<li>读放大（read amplification）：一个查询涉及的外部存储读操作次数。如果我们查询一个数据需要做 3 次外部存储读取，那么读放大就是 3。</li>
<li>写放大（write amplification）：写入外部存储设备的数据量和写入数据库的数据量的比率。如果我们对数据库写入了 10MB 数据，但是对外部存储设备写入了 20BM 数据，写放大就是 2。</li>
<li>空间放大（space amplification）：数据库占用的外部存储量和数据库本身的数据量的比率。如果一个 10MB 的数据库占用了 100MB，那么空间放大就是 10。</li>
</ul>
<h3 id="比较-B-tree-和-LSM"><a href="#比较-B-tree-和-LSM" class="headerlink" title="比较 B-tree 和 LSM"></a>比较 B-tree 和 LSM</h3><p>LSM 和 B-tree 在 Read amplification（读放大），Write amplification（写放大）和 Space amplification（空间放大）这个三个指标上的区别:</p>
<table>
<thead>
<tr>
<th></th>
<th>LSM</th>
<th>B+&#x2F;-Tree</th>
</tr>
</thead>
<tbody><tr>
<td>读放大</td>
<td>一个读操作要对多个 level 上的 SSTable 进行读操作。</td>
<td>一个 key-value 的写操作涉及一个数据页的读操作，若干个索引页的读操作。</td>
</tr>
<tr>
<td>写放大</td>
<td>一个 key-value 值的写操作要在多级的 SSTable 上进行。</td>
<td>一个 key-value 的写操作涉及数据页的写操作，若干个索引页的写操作。</td>
</tr>
<tr>
<td>空间放大</td>
<td>在 SSTable 中存储一个 key-value 的多个版本。</td>
<td>索引页和页 fragmentation。</td>
</tr>
</tbody></table>
<p>LSM 和 B+-Tree 在性能上的比较：</p>
<ul>
<li>写操作：LSM 上的一个写操作涉及对日志的追加操作和对 memtable 的更新（顺序 IO）。但是在 B+-Tree 上面，一个写操作对若干个索引页和一个数据页进行读写操作，可能导致多次的随机 IO。所以 LSM 的写操作性能一般要比 B+-Tree 的写操作性能好。</li>
<li>读操作：LSM 上的一个读操作需要对所有 SSTable 的内容和 memtable 的内容进行合并 。但是在 B+-Tree 上面，一个读操作对若干个索引页和一个数据页进行读操作 。所以 B+-Tree 的读操作性能一般要比 LSM 的读操作性能好。</li>
</ul>
<h2 id="本地存储技术总结"><a href="#本地存储技术总结" class="headerlink" title="本地存储技术总结"></a>本地存储技术总结</h2><h3 id="数据的随机读写-vs-顺序读写"><a href="#数据的随机读写-vs-顺序读写" class="headerlink" title="数据的随机读写 vs 顺序读写"></a>数据的随机读写 vs 顺序读写</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-54-01-image-20240401205401397.png" alt="image-20240401205401397"></p>
<p>在上图的 memory hierarchy，越往下的存储方式容量越大延迟越大，越往上容量越小延迟越小。</p>
<p>对 main memory 和 durable storage 的数据访问，顺序读写的效率都要比随机读写高。</p>
<p>例如 HDD 的 seek time 通常在 3 到 9ms 之前，所以一个 HDD 一秒最多支持 300 多次随机读写。</p>
<p>虽然 SSD 和 main memory 的随机读写效率要比 HDD 好的多，顺序读写的效率仍然要比随机读写高。</p>
<p>所以我们设计存储系统的时候，要尽量避免随机读写多使用顺序读写。</p>
<h2 id="文件系统基础知识"><a href="#文件系统基础知识" class="headerlink" title="文件系统基础知识"></a>文件系统基础知识</h2><h3 id="ext4-文件系统"><a href="#ext4-文件系统" class="headerlink" title="ext4 文件系统"></a>ext4 文件系统</h3><p>ext4 是 Linux 系统上广泛使用的文件系统。</p>
<p>下图列的是 ext4 文件系统 inode 的结构。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-55-20-image-20240401205520908.png" alt="image-20240401205520908"></p>
<p>其中 <code>information</code> （元数据 inode）包括文件的 <code>size</code>，<code>last access time</code> 和 <code>last modification time</code> 等。文件的 <code>inode</code> 和 <code>data block</code> 存储在存储设备的不同位置。</p>
<h3 id="文件系统-API"><a href="#文件系统-API" class="headerlink" title="文件系统 API"></a>文件系统 API</h3><p>访问文件内容是 read 和 write 两个系统调用。</p>
<p>除非使用了 <code>O_DIRECT</code> 选项，read 和 write 操作的都是 block 的 buffer cache，Linux OS 会定期把 dirty block 刷新到 durable storage 上去。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-56-19-image-20240401205619545.png" alt="image-20240401205619545"></p>
<p>设计可靠的存储系统要求把内容实际写到 durable storage 上去。</p>
<p>下面的这两个系统调用提供了把 buffer cache 的内容手动刷新到 durable storage 的机制：</p>
<ul>
<li>fsync：把文件的数据 block 和 inode 的 metadata 刷新到 durable storage。</li>
<li>fdatasync：把文件的数据 block 刷新到 durable storage。只有修改过的 metadata 影响后面的操作才把 metadata 也刷新到 durable storage。</li>
</ul>
<h2 id="Write-Ahead-Logging"><a href="#Write-Ahead-Logging" class="headerlink" title="Write Ahead Logging"></a>Write Ahead Logging</h2><h3 id="保证-durable-storage-写入的原子性"><a href="#保证-durable-storage-写入的原子性" class="headerlink" title="保证 durable storage 写入的原子性"></a>保证 durable storage 写入的原子性</h3><p>我们在 write 调用之后调用 <code>fsync/fdatasync</code>，文件系统通常可以保证对一个 block 写入的原子性。</p>
<p>如果我们的一个数据写入包含对多个 block 的写入。要保证这样整个写入的原子性，就需要另外的机制。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-57-15-image-20240401205715269.png" alt="image-20240401205715269"></p>
<p>例如在上图中，我们要对 3 个 data block 进行写入。</p>
<p>如果我们依次对这些 block 写入，如果在写入 block1 之后发生 crash，数据就会处于状态 2。</p>
<p>在状态 2 中，block1 保存旧数据、block2 和 block3 保存旧数据，数据是不一致的。</p>
<h3 id="Write-Ahead-Logging（WAL）"><a href="#Write-Ahead-Logging（WAL）" class="headerlink" title="Write Ahead Logging（WAL）"></a>Write Ahead Logging（WAL）</h3><p>WAL 是广泛使用的保证多 block 数据写入原子性的技术。</p>
<p>WAL 就是在对 block 进行写入之前，先把新的数据写到一个日志。只有在写入 END 日志并调用 sync API，才开始对 block 进行写入。</p>
<p>如果在对 block 进行写入的任何时候发生 crash，都可以在重启的使用 WAL 里面的数据完成 block 的写入。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-58-27-image-20240401205827784.png" alt="image-20240401205827784"></p>
<p>另外通过使用 WAL，我们在提交一个操作之前只需要进行文件的顺序写入，从而减少了包含多 block 文件操作的数据写入时延。</p>
<h4 id="WAL-优化1：Group-Commit"><a href="#WAL-优化1：Group-Commit" class="headerlink" title="WAL 优化1：Group Commit"></a>WAL 优化1：Group Commit</h4><p>上面的 WAL 方案中每次写入完 END 日志都要调用一次耗时的 sync API，会影响系统的性能。</p>
<p>为了解决这个问题，我们可以使用 group commit。group commit 就是一次提交多个数据写入，只有在写入最后一个数据写入的 END日志之后，才调用一次 sync API。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-59-13-image-20240401205912919.png" alt="image-20240401205912919"></p>
<h4 id="WAL-优化2：File-Padding"><a href="#WAL-优化2：File-Padding" class="headerlink" title="WAL 优化2：File Padding"></a>WAL 优化2：File Padding</h4><p>在往 WAL 里面追加日志的时候，如果当前的文件 block 不能保存新添加的日志，就要为文件分配新的 block，这要更新文件 inode 里面的信息（例如 size）。</p>
<p>如果我们使用的是 HHD 的话，就要先 seek 到 inode 所在的位置，然后回到新添加 block 的位置进行日志追加。</p>
<p>为了减少这些 seek，我们可以预先为WAL 分配 block。例如 ZooKeeper 就是每次为 WAL 分配 64MB 的 block。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F20-59-59-image-20240401205959728.png" alt="image-20240401205959728"></p>
<h4 id="WAL-优化3：快照"><a href="#WAL-优化3：快照" class="headerlink" title="WAL 优化3：快照"></a>WAL 优化3：快照</h4><p>如果我们使用一个内存数据结构加 WAL 的存储方案，WAL 就会一直增长。这样在存储系统启动的时候，就要读取大量的 WAL 日志数据来重建内存数据。</p>
<p>快照可以解决这个问题。</p>
<p>快照是应用 WAL 中从头到某一个日志条目产生的内存数据结构的序列化，例如下图中的快照就是应用从 1 到 7 日志条目产生的。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-00-32-image-20240401210032373.png" alt="image-20240401210032373"></p>
<p>除了解决启动时间过长的问题之外，快照还可以减少存储空间的使用。</p>
<p>WAL 的多个日志条目有可能是对同一个数据的改动，通过快照，就可以只保留最新的数据改动。</p>
<h3 id="数据序列化"><a href="#数据序列化" class="headerlink" title="数据序列化"></a>数据序列化</h3><p>现在有众多的数据序列化方案，下面列出一些比较有影响力的序列化方案：</p>
<ul>
<li>JSON：基于文本的序列化方案，方便易用，没有 schema，但是序列化的效率低，广泛应用于 HTTP API 中。</li>
<li>BSON：二进制的 JSON 序列化方案，应用于 MongoDB。</li>
<li>Protobuf：Google 研发的二进制的序列化方案，有 schema，广泛应用于 Google 内部，在开源界也有广泛的应用（例如 gRPC）。</li>
<li>Thrift：Facebook 研发的和 Protobuf 类似的一种二进制序列化方案，是 Apache 的项目。</li>
<li>Avro：二进制的序列化方案，Apache 项目，在大数据领域用的比较多。</li>
</ul>
<h3 id="研发本地存储"><a href="#研发本地存储" class="headerlink" title="研发本地存储"></a>研发本地存储</h3><p>研发一个高效的本地存储引擎需要该领域的专家级技术，所以不建议自己从 0 开始研发。</p>
<p>目前开源界有众多的本地存储引擎，建议直接使用现有的方案。如果现有的开源方案不能满足要求，可以在这些方案的基础之上进行二次开发。</p>
<h2 id="ZooKeeper本地存储源码解析"><a href="#ZooKeeper本地存储源码解析" class="headerlink" title="ZooKeeper本地存储源码解析"></a>ZooKeeper本地存储源码解析</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>ZooKeeper 使用的序列化方案是 Apache Jute。</p>
<p><code>zooKeeper.jute</code> 包含所有数据的 schema ，Jute 编译器通过编译 jute 文件生成 Java 代码。生成的所有 Java 类实现 Record 接口。</p>
<p>下面列出了序列化的核心接口和类。 Jute 的序列化底层使用的是 Java DataInput 的编码方案。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-02-11-image-20240401210211274.png" alt="image-20240401210211274"></p>
<p>InputArchive：反序列化；</p>
<p>OutputArchive：序列化；</p>
<h3 id="本地存储架构-1"><a href="#本地存储架构-1" class="headerlink" title="本地存储架构"></a>本地存储架构</h3><p>ZooKeeper 的本地存储采用的是内存数据结构加 WAL 的方案。 </p>
<p>ZooKeeper 的 WAL 叫作事务日志(transaction log).</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-02-37-image-20240401210237880.png" alt="image-20240401210237880"></p>
<h3 id="核心接口和类"><a href="#核心接口和类" class="headerlink" title="核心接口和类"></a>核心接口和类</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-02-56-image-20240401210256319.png" alt="image-20240401210256319"></p>
<ul>
<li>TxnLog: 接口类型，提供读写事务日志的API。</li>
<li>FileTxnLog: 基于文件的 TxnLog 实现。</li>
<li>Snapshot: 快照接口类型，提供序列化、反序列化、访问快照的 API。</li>
<li>FileSnap: 基于文件的 Snapsho 实现。</li>
<li>FileTxnSnapLog: TxnLog和 SnapShot 的封装。</li>
<li>DataTree: ZooKeeper 的内存数据结构，是有所有 znode 构成的树。</li>
<li>DataNode: 表示一个 znode。</li>
</ul>
<h3 id="File-Padding"><a href="#File-Padding" class="headerlink" title="File Padding"></a>File Padding</h3><p>当 file channel 的 position 在 currentSize 结束为止的 4KB 范围之内是进行 padding。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-03-48-image-20240401210348014.png" alt="image-20240401210348014"></p>
<p>如果 position 已经超出了 currentSize，基于 position 进行空间扩容。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-03-55-image-20240401210355106.png" alt="image-20240401210355106"></p>
<h3 id="DataTree"><a href="#DataTree" class="headerlink" title="DataTree"></a>DataTree</h3><p>DataNode 有一个成员叫作 children，children 保存该 DataNode 的子节点名字，可以从根节点开始通过 children 遍历所有的节点。</p>
<p>只有在序列化 DataTree 的时候才会通过 children 进行 DataTree 的遍历。其他对 DataNode 的访问都是通过 DataTree 的成员 nodes 来进行的。</p>
<p>nodes 是一个ConcurrentHashMap，保存的是 DataNode 的 path 到 DataNode 的映射。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-04-23-image-20240401210422944.png" alt="image-20240401210422944"></p>
<h3 id="快照-1"><a href="#快照-1" class="headerlink" title="快照"></a>快照</h3><ul>
<li>序列化：从根 DataNode 开始做前序遍历，依次把 DataNode 写入到快照文件中。</li>
<li>反序列化：从头开始顺序读取快照文件的内容，建立 DataTree。因为在序列化的时候使用的是前序遍历，会先反序列化到父亲节点再反序列化孩子节点。因此，在创建新的 DataNode 的同时，可以把新的 DataNode 加到它的父亲节点的 children 中去。</li>
</ul>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-05-01-image-20240401210501768.png" alt="image-20240401210501768"></p>
<h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><h3 id="TCP-IP-协议栈"><a href="#TCP-IP-协议栈" class="headerlink" title="TCP&#x2F;IP 协议栈"></a>TCP&#x2F;IP 协议栈</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-05-31-image-20240401210531129.png" alt="image-20240401210531129"></p>
<p>使用的传输层协议就是 TCP。</p>
<h3 id="Endianness"><a href="#Endianness" class="headerlink" title="Endianness"></a>Endianness</h3><p>在网络编程中，不同计算机体系结构可能使用不同的字节序。当不同字节序的计算机之间进行数据交换时，就会出现字节序不匹配的问题，导致数据解释错误。为了解决这个问题，网络编程中通常需要进行字节序的转换，确保数据在传输过程中能够被正确解释。</p>
<p>常见的解决方法是使用网络字节序（Network Byte Order），通常采用大端序作为网络字节序。在 C 语言中，可以使用函数 <code>htons()</code> 和 <code>htonl()</code> 来将主机字节序转换为网络字节序；使用函数 <code>ntohs()</code>和 <code>ntohl()</code> 将网络字节序转换为主机字节序。</p>
<p>Java 使用的是 big-endian，x86 使用的是 little-endian，TCP&#x2F;IP 使用的是 big-endian。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-06-02-image-20240401210602428.png" alt="image-20240401210602428"></p>
<p><strong>小端序（Little Endian）</strong>：在小端序中，数据的低位字节存储在低地址，高位字节存储在高地址。换句话说，数据的低位字节排在高位字节的前面。</p>
<p><strong>大端序（Big Endian）</strong>：在大端序中，数据的高位字节存储在低地址，低位字节存储在高地址。换句话说，数据的高位字节排在低位字节的前面。</p>
<h3 id="TCP-socket-和-connection"><a href="#TCP-socket-和-connection" class="headerlink" title="TCP socket 和 connection"></a>TCP socket 和 connection</h3><p>socket：用来表示网络中接收和发送数据的一个 endpoint，由 IP 地址和 TCP 端口号组成。</p>
<p>connection：表示两个 endpoint 之间进行数据转述的一个通道，由代表两个 endpoint 的 socket 组成。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-06-24-image-20240401210624820.png" alt="image-20240401210624820"></p>
<h3 id="Socket编程API"><a href="#Socket编程API" class="headerlink" title="Socket编程API"></a>Socket编程API</h3><p>发送和接受数据API：</p>
<ul>
<li><code>ssize_t write(int fd, const void *buf, size_t count)</code></li>
<li><code>ssize_t read(int fd, void *buf, size_t count)</code></li>
</ul>
<p>返回值大于等于 0，表示发送和接收的字节数；</p>
<p>返回值 -1 表示API调用失败，<code>errno</code> 里面会保存相应的错误码。</p>
<p><code>perror()</code> API可以用来输出 <code>errno</code> 表示的错误。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-07-01-image-20240401210701064.png" alt="image-20240401210701064"></p>
<p>例如读取和写入 3 个字节的数据。</p>
<h3 id="client端socket编程"><a href="#client端socket编程" class="headerlink" title="client端socket编程"></a>client端socket编程</h3><ul>
<li><code>socket()</code>: 创建一个数据传输 socket。</li>
<li><code>getsockopt() /setsockopt()</code>: 获取和设置 socket 的选项。</li>
<li><code>connect()</code>：建立 TCP 连接。</li>
<li><code>close()</code>：关闭 socket，释放资源。</li>
</ul>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-07-39-image-20240401210739577.png" alt="image-20240401210739577"></p>
<h3 id="server-端-socket-编程"><a href="#server-端-socket-编程" class="headerlink" title="server 端 socket 编程"></a>server 端 socket 编程</h3><ul>
<li><code>socket()</code>: 创建一个用于监听的 socket。</li>
<li><code>bind()</code>: 把socket和一个网络地址关联起来。</li>
<li><code>listen()</code>：开始监听连接请求。</li>
<li><code>accept()</code>：接受一个连接，返回一个用于数据传输的socket。</li>
</ul>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-08-35-image-20240401210835940.png" alt="image-20240401210835940"></p>
<h3 id="Java-Socket编程"><a href="#Java-Socket编程" class="headerlink" title="Java Socket编程"></a>Java Socket编程</h3><p>Java 区分用于数据传输的 socket 和监听的 socket，用 Socket 这个类表示前者，用 ServerSocket 这个类表示后者。</p>
<p>Socket的 <code>getOutputStream()</code> 返回的 OutputStream 用于发送数据，Socket的 <code>getInputStream()</code> 返回的 InputStream 用于接收数据。</p>
<p>ServerSocket没有 listen 方法， listen 是自动被执行的。</p>
<h2 id="事件驱动的网络编程"><a href="#事件驱动的网络编程" class="headerlink" title="事件驱动的网络编程"></a>事件驱动的网络编程</h2><h3 id="阻塞IO的服务架构"><a href="#阻塞IO的服务架构" class="headerlink" title="阻塞IO的服务架构"></a>阻塞IO的服务架构</h3><p>这种架构使用一个进程处理一个 connection，Apache HTTP server 的 Prefork MPM 就是采用的这种架构。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-10-06-image-20240401211006440.png" alt="image-20240401211006440"></p>
<ul>
<li>阻塞读取意味着等待直到从接收缓冲区中读取一些数据。 </li>
<li>阻塞写入意味着等待直到将一些数据写入发送缓冲区。</li>
</ul>
<p>这种架构的问题在于进程和 connection 的不匹配，connection 是一种 lightweight 的 OS 资源，而 process 是一种heavyweight 的 OS 资源。</p>
<ol>
<li><strong>Connection（连接）</strong>是指通信通道或连接，用于在计算机系统中传输数据。在网络编程中，连接通常指代网络连接，比如 TCP 连接或者数据库连接等。连接通常被认为是”轻量级”资源，因为它主要包含了一些状态信息和缓冲区，占用的系统资源相对较少。当创建连接时，系统会分配一些内存用于维护连接的状态，但这种开销相对较小。</li>
<li><strong>Process（进程）</strong>是指正在运行的程序的实例，它包含了程序的代码、数据、堆栈等信息。进程是操作系统中的一个”重量级”资源，因为它需要分配更多的系统资源，如内存空间、CPU 时间片等。每个进程都有独立的内存空间，需要维护进程控制块等数据结构，因此创建和维护进程的开销相对较大。</li>
</ol>
<h3 id="事件驱动的网络编程架构"><a href="#事件驱动的网络编程架构" class="headerlink" title="事件驱动的网络编程架构"></a>事件驱动的网络编程架构</h3><h4 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h4><p>epoll提供以下3个API：</p>
<ul>
<li><code>epoll_create1</code>：创建 epoll 文件描述符。</li>
<li><code>epoll_wait</code>：等待和 epoll 文件描述符关联的 I&#x2F;O 事件。</li>
<li><code>epoll_ctl</code>：设置 epoll 文件描述符的属性，更新文件描述符和 epoll 文件描述符的关联。</li>
</ul>
<p>EPOLL 事件的两种模型：Level Triggered (LT) 水平触发和 Edge Triggered (ET) 边沿触发 。默认是水平触发。</p>
<ol>
<li><strong>Level Triggered (LT) 水平触发</strong>：<ul>
<li>在 LT 模式下，当文件描述符上有数据可读或可写时，epoll_wait() 将返回并通知应用程序。</li>
<li>如果应用程序没有读取所有数据或者写入缓冲区已满，下次调用 epoll_wait() 时仍然会返回该文件描述符。</li>
<li>LT 模式下，如果文件描述符上的事件没有完全处理，epoll_wait() 会持续通知应用程序该事件。</li>
</ul>
</li>
<li><strong>Edge Triggered (ET) 边沿触发</strong>：<ul>
<li>在 ET 模式下，epoll_wait() 仅在文件描述符状态发生变化时返回，并通知应用程序。</li>
<li>应用程序需要立即处理该事件，否则下次调用 epoll_wait() 时不会再次返回该文件描述符。</li>
<li>ET 模式要求应用程序在每次事件到来时必须处理完整，否则可能错过部分事件。</li>
</ul>
</li>
</ol>
<h4 id="事件驱动的网络编程架构-1"><a href="#事件驱动的网络编程架构-1" class="headerlink" title="事件驱动的网络编程架构"></a>事件驱动的网络编程架构</h4><p>使用一个 event loop 进行网络数据的发送和接收。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-11-06-image-20240401211106525.png" alt="image-20240401211106525"></p>
<p>优点：</p>
<ol>
<li>避免了大量创建 process 的 OS 资源消耗。</li>
<li>减少了耗时的 context switch。(进程切换的上下文)</li>
</ol>
<p>缺点：事件驱动的编程麻烦一些。</p>
<h2 id="ZooKeeper的客户端网络通信"><a href="#ZooKeeper的客户端网络通信" class="headerlink" title="ZooKeeper的客户端网络通信"></a>ZooKeeper的客户端网络通信</h2><h3 id="RPC网络数据结构"><a href="#RPC网络数据结构" class="headerlink" title="RPC网络数据结构"></a>RPC网络数据结构</h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-12-33-image-20240401211233550.png" alt="image-20240401211233550"></p>
<h3 id="ZooKeeper网络通信概述"><a href="#ZooKeeper网络通信概述" class="headerlink" title="ZooKeeper网络通信概述"></a>ZooKeeper网络通信概述</h3><p>支持两种事件驱动编程模型，一种是Java NIO，一种是Netty。核心接口和类如下：</p>
<ul>
<li>ZooKeeper：用户使用的ZooKeeper客户端库核心类。</li>
<li>ClientCnxn: 负责和多个ZooKeeper节点的一个建立网络连接，包含ZooKeeper RPC的处理逻辑。</li>
<li>ClientCnxnSocket: 网络通信的high level逻辑。</li>
<li>ClientCnxnSocketNetty: 实际进行TCP socket的网络通信。</li>
<li>StaticHostProvider: 提供一个ZooKeeper节点列表。</li>
</ul>
<h4 id="RPC方法流程"><a href="#RPC方法流程" class="headerlink" title="RPC方法流程"></a>RPC方法流程</h4><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-13-29-image-20240401211329706.png" alt="image-20240401211329706"></p>
<h3 id="Standalone的ZooKeeper处理客户端请求"><a href="#Standalone的ZooKeeper处理客户端请求" class="headerlink" title="Standalone的ZooKeeper处理客户端请求"></a>Standalone的ZooKeeper处理客户端请求</h3><p>事务日志：</p>
<p>PrepRequestProcessor会为每一个客户端写请求生成一个事务，对ZooKeeper in-memory DataTree更新的时候应的不是原始的写请求，而是对应的事务记录。</p>
<p>事务记录都是幂等的，多次应用一个事务记录不会影响结构的正确性。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-14-46-image-20240401211446360.png" alt="image-20240401211446360"></p>
<p>ZooKeeper 的事务日志是每个事务包含一条记录的 REDO 日志，日志记录是 physical 的。</p>
<h4 id="Fuzzy-Snapshot"><a href="#Fuzzy-Snapshot" class="headerlink" title="Fuzzy Snapshot"></a>Fuzzy Snapshot</h4><p>ZooKeeper可以在同时处理客户端请求的时候生成snapshot。snapshot开始时候DataTree上面最新的zxid叫作snapshot的TS。 </p>
<p>ZooKeeper的snapshot不是一个数据一致的DataTree，但是在snapshot上面应用比TS新的事务记录之后得到的DataTree是数据一致的。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-15-35-image-20240401211535400.png" alt="image-20240401211535400"></p>
<h3 id="Quorum模式下ZooKeeper节点的Request-Processor-Pipeline"><a href="#Quorum模式下ZooKeeper节点的Request-Processor-Pipeline" class="headerlink" title="Quorum模式下ZooKeeper节点的Request Processor Pipeline"></a>Quorum模式下ZooKeeper节点的Request Processor Pipeline</h3><p>Standalone模式下ZooKeeper如何保证数据一致性的：</p>
<p>ZooKeeper数据一致性:</p>
<ol>
<li>全局可线性化（Linearizable）写入： ZooKeeper节点决定写请求的执行顺序。</li>
<li>客户端 FIFO 顺序：来自一个客户端的请求按照发送顺序执行。</li>
</ol>
<p>Standalone模式下的以下两点保证了以上的数据一致性：</p>
<ol>
<li>TCP协议保证了请求在网络上进行传输的先后顺序。</li>
<li>Request processor pipeline的每个阶段都是单线程的。</li>
</ol>
<p>第2点导致FinalRequestProcessor对DataTree的访问都是串行的，性能不好。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-16-06-image-20240401211606004.png" alt="image-20240401211606004"></p>
<p>Quorum模式下ZooKeeper使用以下3点保证数据一致性：</p>
<ol>
<li>每一个ZooKeeper节点都按照zxid的把事务记录应用到DataTree上面。</li>
<li>来自一个session的请求按照FIFO的顺序执行。</li>
<li>在处理一个写请求的时候，不能处理任何其他请求。</li>
</ol>
<p>这样做的好处是允许DatatTree并行执行读操作。Quorum模式下，保证第2点和第3点的是CommitProcessor。</p>
<h4 id="CommitProcessor核心逻辑"><a href="#CommitProcessor核心逻辑" class="headerlink" title="CommitProcessor核心逻辑"></a>CommitProcessor核心逻辑</h4><p>下图是CommitProcessor处理请求的核心逻辑：</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-16-35-image-20240401211634992.png" alt="image-20240401211634992"></p>
<h4 id="workPool状态图"><a href="#workPool状态图" class="headerlink" title="workPool状态图"></a>workPool状态图</h4><p>workPool处于两个重要状态：</p>
<ol>
<li>并行处理读请求。 </li>
<li>处理一个写请求。</li>
</ol>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-17-02-image-20240401211702132.png" alt="image-20240401211702132"></p>
<h2 id="ZooKeeper-Leader节点选举"><a href="#ZooKeeper-Leader节点选举" class="headerlink" title="ZooKeeper Leader节点选举"></a>ZooKeeper Leader节点选举</h2><h3 id="Leader-Election算法"><a href="#Leader-Election算法" class="headerlink" title="Leader Election算法"></a>Leader Election算法</h3><p>一个 vote 的由 voteId 和 voteZxid 组成。对于 <code>vote(voteId， voteZxid)</code> 和 <code>vote(mySid， myZxid)</code>，如果以下两个条件中有一个成立，就认为前者比后者新：</p>
<ol>
<li><code>voteZxid &gt; myZxid</code></li>
<li><code>voteZxid == myZxid and voteId &gt; mySid</code></li>
</ol>
<h3 id="Leader-Election算法-1"><a href="#Leader-Election算法-1" class="headerlink" title="Leader Election算法"></a>Leader Election算法</h3><p>一个 ZooKeeper 节点通过向所有的节点发送 <code>vote(voteId,voteZxid)</code> 开始选举， <code>voteId</code> 是节点自己的 <code>ID(mySid)</code>，<code>voteZxid</code> 是节点上最新的 <code>zxid(myZxid)</code>。</p>
<p>一个节点在接收到 <code>vote(voteId,voteZxid)</code> 之后如果发现 <code>vote(voteId,voteZxid)</code> 比 <code>vote(mySid， myZxid)</code>新，就让 <code>mySid = voteId</code> 和 <code>myZxid = voteZxid</code>，并把 <code>vote(voteId,voteZxid)</code> 发送给所有的 ZooKeeper 节点。否则的话，什么也不用做。</p>
<p>这个算法保证参与选举的具有最新 zxid 的节点赢得选举。在选举结束之后，一个 follower 节点和 leader 节点同步状态之后才可以开始处理来自客户端的请求。</p>
<h3 id="Leader-Election示例-happy-case"><a href="#Leader-Election示例-happy-case" class="headerlink" title="Leader Election示例(happy case)"></a>Leader Election示例(happy case)</h3><p>下图是一个3节点集群选举一个leader的时序图：</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-18-42-image-20240401211842716.png" alt="image-20240401211842716"></p>
<h3 id="Leader-Election示例-unhappy-case"><a href="#Leader-Election示例-unhappy-case" class="headerlink" title="Leader Election示例(unhappy case)"></a>Leader Election示例(unhappy case)</h3><p>下面的时序图展示了长时间的消息发送延迟导致选举出两个 leader 的 unhappy case：</p>
<p>由于网络延迟，导致 node 2 先后将 node 3 和 node 1 选举为 leader。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-19-10-image-20240401211910092.png" alt="image-20240401211910092"></p>
<p>在这种情况之下，node 3 不会响应来自 node 2 的请求，node 2 会在 timeout 之后重试。node 2 在 timeout 之前没有办法处理请求。</p>
<h3 id="使用finalizeWait来避免unhappy-case"><a href="#使用finalizeWait来避免unhappy-case" class="headerlink" title="使用finalizeWait来避免unhappy case"></a>使用finalizeWait来避免unhappy case</h3><p>一个节点在获得一个 vote 的 quorum 之后，在完成选举之前会等待一段时间。</p>
<p>如果在这段时间收到更新的 vote，继续执行选举算法。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-19-46-image-20240401211946482.png" alt="image-20240401211946482"></p>
<p>node 2 先后投票给 node 3 和 node 1；node 3 收到自己和 node 2 的票后进入 finalizeWait，在这个过程中收到 node 1 的选举请求，投票给 node 1，node 1 票数过半，进入 finalizeWait，最后 node 1 成为 Leader</p>
<h3 id="Leader-Election的网络通信"><a href="#Leader-Election的网络通信" class="headerlink" title="Leader Election的网络通信"></a>Leader Election的网络通信</h3><p>ZooKeeper使用一个专门的TCP端口进行 Leader Election的网络通信。负责这一部分工作的类是  <code>QuorumCnxManager</code>，使用的是  Java 的 Socket 编程，没有使用 NIO 和 Netty 。</p>
<h2 id="Zab协议"><a href="#Zab协议" class="headerlink" title="Zab协议"></a>Zab协议</h2><h3 id="Zab-ZooKeeper-Atomic-Broadcast-协议"><a href="#Zab-ZooKeeper-Atomic-Broadcast-协议" class="headerlink" title="Zab(ZooKeeper Atomic Broadcast)协议"></a>Zab(ZooKeeper Atomic Broadcast)协议</h3><p>ZooKeeper 处理写请求需要经过 Zab 协议</p>
<p>Zab 协议有以下3个步骤组成：</p>
<ol>
<li>Leader 发送 PROPOSAL 给集群中所有的节点（包括自己）。</li>
<li>节点在收到 PROPOSAL 之后，把 PROPOSAL 落盘,发送一个 ACK 给 Leader。</li>
<li>Leader 在收到大多数节点的 ACK 之后，发送 COMMIT 给集群中所有的节点。</li>
</ol>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-20-38-image-20240401212038694.png" alt="image-20240401212038694"></p>
<h3 id="Quorum网络通信"><a href="#Quorum网络通信" class="headerlink" title="Quorum网络通信"></a>Quorum网络通信</h3><p>Leader会在一个quorum TCP socket 地址上面监听，每一个 follower 节点会和 leader 节点上在这些地址上面建立一个连接。之后 leader 和 follower 之间的 quorum 通信都通过这些建立的连接来进行。</p>
<p>这一部分的研发也没有使用 NIO 和 Netty，使用的 socket 通信。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-21-07-image-20240401212107257.png" alt="image-20240401212107257"></p>
<h2 id="客户端和服务器端交互：Watch和Session"><a href="#客户端和服务器端交互：Watch和Session" class="headerlink" title="客户端和服务器端交互：Watch和Session"></a>客户端和服务器端交互：Watch和Session</h2><p>客户端的 ZKWatchManager 和服务器端的 WatchManager 都是 Watch 的注册表。</p>
<p>如果当前和客户端连接的 ZooKeeper 节点宕机，客户端在和另外一个 ZooKeeper 节点建立连接时会使用 ZKWatchManager 在新节点上面重建 WatchManager。</p>
<h3 id="Session核心数据结构和逻辑"><a href="#Session核心数据结构和逻辑" class="headerlink" title="Session核心数据结构和逻辑"></a>Session核心数据结构和逻辑</h3><p>为了高效的管理大量的 session，ZooKeeper 使用桶的机制进行 session 过期。</p>
<p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/homework%2FPicGo%2F2024%2F04%2F01%2F21-22-19-image-20240401212219820.png" alt="image-20240401212219820"></p>
<h3 id="从客户端到服务器端的心跳"><a href="#从客户端到服务器端的心跳" class="headerlink" title="从客户端到服务器端的心跳"></a>从客户端到服务器端的心跳</h3><p>为了维持客户端到ZooKeeper节点的session，如果在一段时间内客户端不需要向服务器端发送请求，客户端需要向服务器发送心跳消息PING。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Reference/" rel="tag"># 学习笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/36f79291.html" rel="prev" title="Elasticsearch 利用 ELK 做大数据分析">
                  <i class="fa fa-angle-left"></i> Elasticsearch 利用 ELK 做大数据分析
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Mitaka xu</span>
  </div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"TVx6Wkfs8VJGOwYPurtjWY2e-9Nh9j0Va","app_key":"c7VvaRnyF8r3DUIPq1x2KJ7Q","server_url":"https://tvx6wkfs.lc-cn-e1-shared.com","security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://www.xiaoyeshiyu.com/post/4748c1d.html"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"xiaoyeshiyu","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
