<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="S_5aoPFd3QQihrUOLiKdVR0Mj4fj6n6qJojwyjj9cAY">
  <meta name="msvalidate.01" content="9032A67FCF787F07CB04374E59E518A9">
  <meta name="baidu-site-verification" content="code-Onlniop0d6">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.xiaoyeshiyu.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Git是日常工作中很常用的工具，除了程序员，一些文字编辑工作者都可以通过Git加速工作效率。">
<meta property="og:type" content="article">
<meta property="og:title" content="Git学习笔记">
<meta property="og:url" content="https://www.xiaoyeshiyu.com/post/2148.html">
<meta property="og:site_name" content="小夜时雨">
<meta property="og:description" content="Git是日常工作中很常用的工具，除了程序员，一些文字编辑工作者都可以通过Git加速工作效率。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/local.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/centralized.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/distributed.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/deltas.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/snapshots.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/areas.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/lifecycle.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/commit-and-tree.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/commits-and-parents.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/branch-and-history.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/two-branches.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/head-to-master.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/head-to-testing.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/advance-testing.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/checkout-master.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/advance-master.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-branching-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-branching-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-branching-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-branching-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-branching-5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-branching-6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-merging-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-merging-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/lr-branches-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/lr-branches-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/topic-branches-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/remote-branches-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/remote-branches-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/remote-branches-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/remote-branches-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/remote-branches-5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-rebase-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-rebase-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-rebase-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-rebase-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/interesting-rebase-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/interesting-rebase-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/interesting-rebase-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/interesting-rebase-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/interesting-rebase-5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/perils-of-rebasing-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/perils-of-rebasing-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/perils-of-rebasing-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/perils-of-rebasing-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/perils-of-rebasing-5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/centralized_workflow.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/integration-manager.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/03/benevolent-dictator.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/git-diff-check.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-flow.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/managed-team-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/managed-team-2-20230403173417621.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/managed-team-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/managed-team-flow.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/public-small-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/public-small-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/public-small-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/merging-workflows-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/merging-workflows-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/merging-workflows-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/merging-workflows-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/merging-workflows-5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/large-merges-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/large-merges-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/rebasing-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/rebasing-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/account-settings.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/ssh-keys.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/your-profile.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/avatar-crop.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/email-settings.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/2fa-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/forkbutton.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-01-start.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-02-pr.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-03-pull-request-open.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-04-pr-comment.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-04-email.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-05-general-comment.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-06-final.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/pr-01-fail.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/pr-02-merge-fix.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/mentions-01-syntax.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/mentions-02-render.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/mentions-03-closed.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-01-example.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-02-tasks.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-03-task-summary.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-04-fenced-code.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-05-quote.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-06-emoji-complete.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-07-emoji.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-08-drag-drop.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/newrepo.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/new-repo.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/newrepoform.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/reposettingslink.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/collaborators.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-01-email.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/maint-03-email-resp.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-02-merge.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-04-target.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-05-mentions.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-06-unsubscribe.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-07-notifications.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-08-notifications-page.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-09-contrib.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-10-default-branch.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-11-transfer.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/neworg.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/orgs-01-page.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/orgs-02-teams.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/orgs-03-audit.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-01-services.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-02-email-service.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-03-webhook.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-04-webhook-debug.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-05-access-token.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-06-comment.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-07-status.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/double-dot.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-workflow.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-ex1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-ex2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-ex3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-ex4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-ex5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-ex6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-start.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-soft.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-mixed.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-hard.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-path1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-path2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-path3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-squash-r1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-squash-r2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-squash-r3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-checkout.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/06/undomerge-start-20230620161946970.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/06/undomerge-reset.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/06/undomerge-revert-20230620162105260.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/undomerge-revert2.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/undomerge-revert3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/06/rerere1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/06/rerere2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/06/rerere3.png">
<meta property="article:published_time" content="2023-02-20T16:00:00.000Z">
<meta property="article:modified_time" content="2023-07-24T07:09:28.874Z">
<meta property="article:author" content="Mitaka xu">
<meta property="article:tag" content="Golang, 微服务，数据库，中间件, 算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/local.png">


<link rel="canonical" href="https://www.xiaoyeshiyu.com/post/2148.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.xiaoyeshiyu.com/post/2148.html","path":"post/2148.html","title":"Git学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Git学习笔记 | 小夜时雨</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MBVJ11TVHH"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBVJ11TVHH","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?573725610fbc6ff9b42032bd13615370"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="小夜时雨" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小夜时雨</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">君子敬其在己者，而不慕其在天者，是以日进也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B5%B7%E6%AD%A5"><span class="nav-number">1.</span> <span class="nav-text">起步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="nav-number">1.1.</span> <span class="nav-text">版本管理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">本地版本控制系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E4%B8%AD%E5%8C%96%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">集中化的版本控制系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">分布式版本控制系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.</span> <span class="nav-text">Git简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%AE%B0%E5%BD%95%E5%BF%AB%E7%85%A7%EF%BC%8C%E8%80%8C%E9%9D%9E%E5%B7%AE%E5%BC%82%E6%AF%94%E8%BE%83"><span class="nav-number">1.2.1.</span> <span class="nav-text">直接记录快照，而非差异比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%91%E4%B9%8E%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E9%83%BD%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%89%A7%E8%A1%8C"><span class="nav-number">1.2.2.</span> <span class="nav-text">近乎所有操作都是本地执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-%E4%BF%9D%E8%AF%81%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-number">1.2.3.</span> <span class="nav-text">Git 保证完整性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-%E4%B8%80%E8%88%AC%E5%8F%AA%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.4.</span> <span class="nav-text">Git 一般只添加数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.5.</span> <span class="nav-text">三种状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="nav-number">1.2.6.</span> <span class="nav-text">命令行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">1.3.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">1.4.</span> <span class="nav-text">初次运行 Git 前的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="nav-number">1.4.1.</span> <span class="nav-text">用户信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="nav-number">1.4.2.</span> <span class="nav-text">检查配置信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%B8%AE%E5%8A%A9"><span class="nav-number">1.4.3.</span> <span class="nav-text">获取帮助</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Git%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">Git基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93"><span class="nav-number">2.1.</span> <span class="nav-text">获取 Git 仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.1.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%8B%E9%9A%86%E7%8E%B0%E6%9C%89%E7%9A%84%E4%BB%93%E5%BA%93"><span class="nav-number">2.1.2.</span> <span class="nav-text">克隆现有的仓库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93"><span class="nav-number">2.2.</span> <span class="nav-text">记录每次更新到仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="nav-number">2.2.1.</span> <span class="nav-text">检查当前文件状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9F%E8%B8%AA%E6%96%B0%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.2.</span> <span class="nav-text">跟踪新文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9A%82%E5%AD%98%E5%B7%B2%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.3.</span> <span class="nav-text">暂存已修改的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%AE%80%E8%A7%88"><span class="nav-number">2.2.4.</span> <span class="nav-text">状态简览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.5.</span> <span class="nav-text">忽略文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E6%9A%82%E5%AD%98%E5%92%8C%E6%9C%AA%E6%9A%82%E5%AD%98%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">2.2.6.</span> <span class="nav-text">查看已暂存和未暂存的修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0"><span class="nav-number">2.2.7.</span> <span class="nav-text">提交更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%BF%87%E4%BD%BF%E7%94%A8%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">2.2.8.</span> <span class="nav-text">跳过使用暂存区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.9.</span> <span class="nav-text">移除文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.10.</span> <span class="nav-text">移动文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2"><span class="nav-number">2.3.</span> <span class="nav-text">查看提交历史</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E8%BE%93%E5%87%BA%E9%95%BF%E5%BA%A6"><span class="nav-number">2.3.1.</span> <span class="nav-text">限制输出长度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%92%A4%E6%B6%88%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.</span> <span class="nav-text">撤消操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%96%E6%B6%88%E6%9A%82%E5%AD%98%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">2.4.1.</span> <span class="nav-text">取消暂存的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%92%A4%E6%B6%88%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">2.4.2.</span> <span class="nav-text">撤消对文件的修改</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.5.</span> <span class="nav-text">远程仓库的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">2.5.1.</span> <span class="nav-text">查看远程仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">2.5.2.</span> <span class="nav-text">添加远程仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%AD%E6%8A%93%E5%8F%96%E4%B8%8E%E6%8B%89%E5%8F%96"><span class="nav-number">2.5.3.</span> <span class="nav-text">从远程仓库中抓取与拉取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">2.5.4.</span> <span class="nav-text">推送到远程仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">2.5.5.</span> <span class="nav-text">查看某个远程仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%8E%E7%A7%BB%E9%99%A4"><span class="nav-number">2.5.6.</span> <span class="nav-text">远程仓库的重命名与移除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.</span> <span class="nav-text">打标签</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E5%87%BA%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.1.</span> <span class="nav-text">列出标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.2.</span> <span class="nav-text">创建标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%E6%B3%A8%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.3.</span> <span class="nav-text">附注标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.4.</span> <span class="nav-text">轻量标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E6%9C%9F%E6%89%93%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.5.</span> <span class="nav-text">后期打标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.6.</span> <span class="nav-text">共享标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.7.</span> <span class="nav-text">删除标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E5%87%BA%E6%A0%87%E7%AD%BE"><span class="nav-number">2.6.8.</span> <span class="nav-text">检出标签</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-%E5%88%AB%E5%90%8D"><span class="nav-number">2.7.</span> <span class="nav-text">Git 别名</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%94%AF"><span class="nav-number">3.</span> <span class="nav-text">分支</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B"><span class="nav-number">3.1.</span> <span class="nav-text">分支简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%88%9B%E5%BB%BA"><span class="nav-number">3.1.1.</span> <span class="nav-text">分支创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%88%87%E6%8D%A2"><span class="nav-number">3.1.2.</span> <span class="nav-text">分支切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6"><span class="nav-number">3.2.</span> <span class="nav-text">分支的新建与合并</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF"><span class="nav-number">3.2.1.</span> <span class="nav-text">新建分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-number">3.2.2.</span> <span class="nav-text">分支的合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%87%E5%88%B0%E5%86%B2%E7%AA%81%E6%97%B6%E7%9A%84%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6"><span class="nav-number">3.2.3.</span> <span class="nav-text">遇到冲突时的分支合并</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">分支管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">3.4.</span> <span class="nav-text">分支开发工作流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E6%9C%9F%E5%88%86%E6%94%AF"><span class="nav-number">3.4.1.</span> <span class="nav-text">长期分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF"><span class="nav-number">3.4.2.</span> <span class="nav-text">主题分支</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">3.5.</span> <span class="nav-text">远程分支</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E9%80%81"><span class="nav-number">3.5.1.</span> <span class="nav-text">推送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9F%E8%B8%AA%E5%88%86%E6%94%AF"><span class="nav-number">3.5.2.</span> <span class="nav-text">跟踪分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%89%E5%8F%96"><span class="nav-number">3.5.3.</span> <span class="nav-text">拉取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">3.5.4.</span> <span class="nav-text">删除远程分支</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA"><span class="nav-number">3.6.</span> <span class="nav-text">变基</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">3.6.1.</span> <span class="nav-text">变基的基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8F%98%E5%9F%BA%E4%BE%8B%E5%AD%90"><span class="nav-number">3.6.2.</span> <span class="nav-text">更有趣的变基例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="nav-number">3.6.3.</span> <span class="nav-text">变基的风险</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%8F%98%E5%9F%BA%E8%A7%A3%E5%86%B3%E5%8F%98%E5%9F%BA"><span class="nav-number">3.6.4.</span> <span class="nav-text">用变基解决变基</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA-vs-%E5%90%88%E5%B9%B6"><span class="nav-number">3.6.5.</span> <span class="nav-text">变基 vs. 合并</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git"><span class="nav-number">4.</span> <span class="nav-text">服务器上的 Git</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.</span> <span class="nav-text">协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.1.</span> <span class="nav-text">本地协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.2.</span> <span class="nav-text">HTTP 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD-HTTP-%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">智能 HTTP 协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%91%EF%BC%88Dumb%EF%BC%89-HTTP-%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">哑（Dumb） HTTP 协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-1"><span class="nav-number">4.1.2.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="nav-number">4.1.2.4.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSH-%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.3.</span> <span class="nav-text">SSH 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.4.</span> <span class="nav-text">Git 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-2"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="nav-number">4.1.4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%90%AD%E5%BB%BA-Git"><span class="nav-number">4.2.</span> <span class="nav-text">在服务器上搭建 Git</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A%E8%A3%B8%E4%BB%93%E5%BA%93%E6%94%BE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A"><span class="nav-number">4.2.1.</span> <span class="nav-text">把裸仓库放到服务器上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E5%9E%8B%E5%AE%89%E8%A3%85"><span class="nav-number">4.2.2.</span> <span class="nav-text">小型安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SSH-%E8%BF%9E%E6%8E%A5"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">SSH 连接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5"><span class="nav-number">4.3.</span> <span class="nav-text">生成 SSH 公钥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">4.4.</span> <span class="nav-text">配置服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%87%A0%E7%A7%8D%E6%90%AD%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">4.5.</span> <span class="nav-text">其他几种搭建方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">分布式工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-1"><span class="nav-number">5.1.</span> <span class="nav-text">分布式工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">5.1.1.</span> <span class="nav-text">集中式工作流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E6%88%90%E7%AE%A1%E7%90%86%E8%80%85%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">5.1.2.</span> <span class="nav-text">集成管理者工作流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E7%AE%A1%E4%B8%8E%E5%89%AF%E4%B8%BB%E7%AE%A1%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">5.1.3.</span> <span class="nav-text">主管与副主管工作流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E8%B4%A1%E7%8C%AE"><span class="nav-number">5.2.</span> <span class="nav-text">向一个项目贡献</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E5%87%86%E5%88%99"><span class="nav-number">5.2.1.</span> <span class="nav-text">提交准则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E5%B0%8F%E5%9E%8B%E5%9B%A2%E9%98%9F"><span class="nav-number">5.2.2.</span> <span class="nav-text">私有小型团队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E7%AE%A1%E7%90%86%E5%9B%A2%E9%98%9F"><span class="nav-number">5.2.3.</span> <span class="nav-text">私有管理团队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%9A%84%E5%85%AC%E5%BC%80%E9%A1%B9%E7%9B%AE"><span class="nav-number">5.2.4.</span> <span class="nav-text">派生的公开项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E9%82%AE%E4%BB%B6%E7%9A%84%E5%85%AC%E5%BC%80%E9%A1%B9%E7%9B%AE"><span class="nav-number">5.2.5.</span> <span class="nav-text">通过邮件的公开项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.2.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E9%A1%B9%E7%9B%AE"><span class="nav-number">5.3.</span> <span class="nav-text">维护项目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E4%B8%AD%E5%B7%A5%E4%BD%9C"><span class="nav-number">5.3.1.</span> <span class="nav-text">在主题分支中工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%9D%A5%E8%87%AA%E9%82%AE%E4%BB%B6%E7%9A%84%E8%A1%A5%E4%B8%81"><span class="nav-number">5.3.2.</span> <span class="nav-text">应用来自邮件的补丁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-apply-%E5%91%BD%E4%BB%A4%E5%BA%94%E7%94%A8%E8%A1%A5%E4%B8%81"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">使用 apply 命令应用补丁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-am-%E5%91%BD%E4%BB%A4%E5%BA%94%E7%94%A8%E8%A1%A5%E4%B8%81"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">使用 am 命令应用补丁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E5%87%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">5.3.3.</span> <span class="nav-text">检出远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E5%BC%95%E5%85%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF"><span class="nav-number">5.3.4.</span> <span class="nav-text">确定引入了哪些东西</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E8%B4%A1%E7%8C%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%95%B4%E5%90%88%E8%BF%9B%E6%9D%A5"><span class="nav-number">5.3.5.</span> <span class="nav-text">将贡献的工作整合进来</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">5.3.5.1.</span> <span class="nav-text">合并工作流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E9%A1%B9%E7%9B%AE%E5%90%88%E5%B9%B6%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">5.3.5.2.</span> <span class="nav-text">大项目合并工作流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E5%9F%BA%E4%B8%8E%E6%8B%A3%E9%80%89%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-number">5.3.5.3.</span> <span class="nav-text">变基与拣选工作流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rerere"><span class="nav-number">5.3.5.4.</span> <span class="nav-text">Rerere</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%8F%91%E5%B8%83%E6%89%93%E6%A0%87%E7%AD%BE"><span class="nav-number">5.3.6.</span> <span class="nav-text">为发布打标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E6%9E%84%E5%BB%BA%E5%8F%B7"><span class="nav-number">5.3.7.</span> <span class="nav-text">生成一个构建号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E4%B8%80%E6%AC%A1%E5%8F%91%E5%B8%83"><span class="nav-number">5.3.8.</span> <span class="nav-text">准备一次发布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%B6%E4%BD%9C%E6%8F%90%E4%BA%A4%E7%AE%80%E6%8A%A5"><span class="nav-number">5.3.9.</span> <span class="nav-text">制作提交简报</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GitHub"><span class="nav-number">6.</span> <span class="nav-text">GitHub</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%A6%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="nav-number">6.1.</span> <span class="nav-text">账户的创建和配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SSH-%E8%AE%BF%E9%97%AE"><span class="nav-number">6.1.1.</span> <span class="nav-text">SSH 访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E5%83%8F"><span class="nav-number">6.1.2.</span> <span class="nav-text">头像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80"><span class="nav-number">6.1.3.</span> <span class="nav-text">邮件地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%AD%A5%E9%AA%8C%E8%AF%81"><span class="nav-number">6.1.4.</span> <span class="nav-text">两步验证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E9%A1%B9%E7%9B%AE%E5%81%9A%E5%87%BA%E8%B4%A1%E7%8C%AE"><span class="nav-number">6.2.</span> <span class="nav-text">对项目做出贡献</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E9%A1%B9%E7%9B%AE"><span class="nav-number">6.2.1.</span> <span class="nav-text">派生项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GitHub-%E6%B5%81%E7%A8%8B"><span class="nav-number">6.2.2.</span> <span class="nav-text">GitHub 流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%8B%89%E5%8F%96%E8%AF%B7%E6%B1%82"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">创建拉取请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%8B%89%E5%8F%96%E8%AF%B7%E6%B1%82"><span class="nav-number">6.2.2.2.</span> <span class="nav-text">利用拉取请求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%89%E5%8F%96%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95"><span class="nav-number">6.2.3.</span> <span class="nav-text">拉取请求的进阶用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E6%8B%89%E5%8F%96%E8%AF%B7%E6%B1%82%E5%88%B6%E4%BD%9C%E6%88%90%E8%A1%A5%E4%B8%81"><span class="nav-number">6.2.3.1.</span> <span class="nav-text">将拉取请求制作成补丁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E4%B8%8A%E6%B8%B8%E4%BF%9D%E6%8C%81%E5%90%8C%E6%AD%A5"><span class="nav-number">6.2.3.2.</span> <span class="nav-text">与上游保持同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.2.3.3.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GitHub-%E9%A3%8E%E6%A0%BC%E7%9A%84-Markdown"><span class="nav-number">6.2.4.</span> <span class="nav-text">GitHub 风格的 Markdown</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GitHub-%E9%A3%8E%E6%A0%BC%E7%9A%84-Markdown-1"><span class="nav-number">6.2.4.1.</span> <span class="nav-text">GitHub 风格的 Markdown</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8"><span class="nav-number">6.2.4.1.0.1.</span> <span class="nav-text">任务列表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5"><span class="nav-number">6.2.4.2.</span> <span class="nav-text">代码片段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">6.2.4.3.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E6%83%85%E7%AC%A6%E5%8F%B7"><span class="nav-number">6.2.4.4.</span> <span class="nav-text">表情符号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%89%87"><span class="nav-number">6.2.4.5.</span> <span class="nav-text">图片</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A9%E4%BD%A0%E7%9A%84-GitHub-%E5%85%AC%E5%85%B1%E4%BB%93%E5%BA%93%E4%BF%9D%E6%8C%81%E6%9B%B4%E6%96%B0"><span class="nav-number">6.2.5.</span> <span class="nav-text">让你的 GitHub 公共仓库保持更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E9%A1%B9%E7%9B%AE-1"><span class="nav-number">6.3.</span> <span class="nav-text">维护项目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E7%89%88%E6%9C%AC%E5%BA%93"><span class="nav-number">6.3.1.</span> <span class="nav-text">创建新的版本库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%90%88%E4%BD%9C%E8%80%85"><span class="nav-number">6.3.2.</span> <span class="nav-text">添加合作者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E5%90%88%E5%B9%B6%E8%AF%B7%E6%B1%82"><span class="nav-number">6.3.3.</span> <span class="nav-text">管理合并请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5"><span class="nav-number">6.3.3.1.</span> <span class="nav-text">邮件通知</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%90%88%E5%B9%B6%E8%AF%B7%E6%B1%82%E4%B8%8A%E8%BF%9B%E8%A1%8C%E5%90%88%E4%BD%9C"><span class="nav-number">6.3.3.2.</span> <span class="nav-text">在合并请求上进行合作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E8%AF%B7%E6%B1%82%E5%BC%95%E7%94%A8"><span class="nav-number">6.3.3.3.</span> <span class="nav-text">合并请求引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E8%AF%B7%E6%B1%82%E4%B9%8B%E4%B8%8A%E7%9A%84%E5%90%88%E5%B9%B6%E8%AF%B7%E6%B1%82"><span class="nav-number">6.3.3.4.</span> <span class="nav-text">合并请求之上的合并请求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E9%86%92%E5%92%8C%E9%80%9A%E7%9F%A5"><span class="nav-number">6.3.4.</span> <span class="nav-text">提醒和通知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%9F%A5%E9%A1%B5%E9%9D%A2"><span class="nav-number">6.3.5.</span> <span class="nav-text">通知页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E9%80%9A%E7%9F%A5"><span class="nav-number">6.3.6.</span> <span class="nav-text">网页通知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5-1"><span class="nav-number">6.3.7.</span> <span class="nav-text">邮件通知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6"><span class="nav-number">6.3.8.</span> <span class="nav-text">特殊文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#README"><span class="nav-number">6.3.9.</span> <span class="nav-text">README</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%A1%E7%8C%AE-CONTRIBUTING"><span class="nav-number">6.3.10.</span> <span class="nav-text">贡献 CONTRIBUTING</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86"><span class="nav-number">6.3.11.</span> <span class="nav-text">项目管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E9%BB%98%E8%AE%A4%E5%88%86%E6%94%AF"><span class="nav-number">6.3.11.1.</span> <span class="nav-text">改变默认分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E4%BA%A4%E9%A1%B9%E7%9B%AE"><span class="nav-number">6.3.11.2.</span> <span class="nav-text">移交项目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E7%BB%84%E7%BB%87"><span class="nav-number">6.4.</span> <span class="nav-text">管理组织</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E7%BB%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-number">6.4.1.</span> <span class="nav-text">组织的基本知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%A2%E9%98%9F"><span class="nav-number">6.4.2.</span> <span class="nav-text">团队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97"><span class="nav-number">6.4.3.</span> <span class="nav-text">审计日志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC-GitHub"><span class="nav-number">6.5.</span> <span class="nav-text">脚本 GitHub</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%92%A9%E5%AD%90"><span class="nav-number">6.5.1.</span> <span class="nav-text">服务与钩子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1"><span class="nav-number">6.5.1.1.</span> <span class="nav-text">服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%92%A9%E5%AD%90"><span class="nav-number">6.5.1.2.</span> <span class="nav-text">钩子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GitHub-API"><span class="nav-number">6.5.2.</span> <span class="nav-text">GitHub API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E9%80%94"><span class="nav-number">6.5.3.</span> <span class="nav-text">基本用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E4%B8%8A%E8%AF%84%E8%AE%BA"><span class="nav-number">6.5.4.</span> <span class="nav-text">在一个问题上评论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-Pull-Request-%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">6.5.5.</span> <span class="nav-text">修改 Pull Request 的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Octokit"><span class="nav-number">6.5.6.</span> <span class="nav-text">Octokit</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Git-%E5%B7%A5%E5%85%B7"><span class="nav-number">7.</span> <span class="nav-text">Git 工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC"><span class="nav-number">7.1.</span> <span class="nav-text">选择修订版本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%AA%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC"><span class="nav-number">7.1.1.</span> <span class="nav-text">单个修订版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E7%9F%AD%E7%9A%84-SHA-1"><span class="nav-number">7.1.2.</span> <span class="nav-text">简短的 SHA-1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%BC%95%E7%94%A8"><span class="nav-number">7.1.3.</span> <span class="nav-text">分支引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%97%A5%E5%BF%97"><span class="nav-number">7.1.4.</span> <span class="nav-text">引用日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A5%96%E5%85%88%E5%BC%95%E7%94%A8"><span class="nav-number">7.1.5.</span> <span class="nav-text">祖先引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E5%8C%BA%E9%97%B4"><span class="nav-number">7.1.6.</span> <span class="nav-text">提交区间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E7%82%B9"><span class="nav-number">7.1.6.1.</span> <span class="nav-text">双点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%82%B9"><span class="nav-number">7.1.6.2.</span> <span class="nav-text">多点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%82%B9"><span class="nav-number">7.1.6.3.</span> <span class="nav-text">三点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98"><span class="nav-number">7.2.</span> <span class="nav-text">交互式暂存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9A%82%E5%AD%98%E4%B8%8E%E5%8F%96%E6%B6%88%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6"><span class="nav-number">7.2.1.</span> <span class="nav-text">暂存与取消暂存文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9A%82%E5%AD%98%E8%A1%A5%E4%B8%81"><span class="nav-number">7.2.2.</span> <span class="nav-text">暂存补丁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AE%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86"><span class="nav-number">7.3.</span> <span class="nav-text">贮藏与清理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AE%E8%97%8F%E5%B7%A5%E4%BD%9C"><span class="nav-number">7.3.1.</span> <span class="nav-text">贮藏工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AE%E8%97%8F%E7%9A%84%E5%88%9B%E6%84%8F%E6%80%A7%E4%BD%BF%E7%94%A8"><span class="nav-number">7.3.2.</span> <span class="nav-text">贮藏的创意性使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E8%B4%AE%E8%97%8F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF"><span class="nav-number">7.3.3.</span> <span class="nav-text">从贮藏创建一个分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%90%86%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="nav-number">7.3.4.</span> <span class="nav-text">清理工作目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%BE%E7%BD%B2%E5%B7%A5%E4%BD%9C"><span class="nav-number">7.4.</span> <span class="nav-text">签署工作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GPG-%E4%BB%8B%E7%BB%8D"><span class="nav-number">7.4.1.</span> <span class="nav-text">GPG 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%BE%E7%BD%B2%E6%A0%87%E7%AD%BE"><span class="nav-number">7.4.2.</span> <span class="nav-text">签署标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E6%A0%87%E7%AD%BE"><span class="nav-number">7.4.3.</span> <span class="nav-text">验证标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%BE%E7%BD%B2%E6%8F%90%E4%BA%A4"><span class="nav-number">7.4.4.</span> <span class="nav-text">签署提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E4%BA%BA%E5%BF%85%E9%A1%BB%E7%AD%BE%E7%BD%B2"><span class="nav-number">7.4.5.</span> <span class="nav-text">每个人必须签署</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2"><span class="nav-number">7.5.</span> <span class="nav-text">搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-Grep"><span class="nav-number">7.5.1.</span> <span class="nav-text">Git Grep</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-%E6%97%A5%E5%BF%97%E6%90%9C%E7%B4%A2"><span class="nav-number">7.5.2.</span> <span class="nav-text">Git 日志搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E6%97%A5%E5%BF%97%E6%90%9C%E7%B4%A2"><span class="nav-number">7.5.2.1.</span> <span class="nav-text">行日志搜索</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2"><span class="nav-number">7.6.</span> <span class="nav-text">重写历史</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4"><span class="nav-number">7.6.1.</span> <span class="nav-text">修改最后一次提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%A4%9A%E4%B8%AA%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF"><span class="nav-number">7.6.2.</span> <span class="nav-text">修改多个提交信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E6%8F%90%E4%BA%A4"><span class="nav-number">7.6.3.</span> <span class="nav-text">重新排序提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E6%8F%90%E4%BA%A4"><span class="nav-number">7.6.4.</span> <span class="nav-text">压缩提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%86%E5%88%86%E6%8F%90%E4%BA%A4"><span class="nav-number">7.6.5.</span> <span class="nav-text">拆分提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E6%AD%A6%E5%99%A8%E7%BA%A7%E9%80%89%E9%A1%B9%EF%BC%9Afilter-branch"><span class="nav-number">7.6.6.</span> <span class="nav-text">核武器级选项：filter-branch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%8F%90%E4%BA%A4%E4%B8%AD%E7%A7%BB%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">7.6.6.1.</span> <span class="nav-text">从每一个提交中移除一个文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E4%B8%80%E4%B8%AA%E5%AD%90%E7%9B%AE%E5%BD%95%E5%81%9A%E4%B8%BA%E6%96%B0%E7%9A%84%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="nav-number">7.6.6.2.</span> <span class="nav-text">使一个子目录做为新的根目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%BF%AE%E6%94%B9%E9%82%AE%E7%AE%B1%E5%9C%B0%E5%9D%80"><span class="nav-number">7.6.6.3.</span> <span class="nav-text">全局修改邮箱地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86"><span class="nav-number">7.7.</span> <span class="nav-text">重置揭密</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%A3%B5%E6%A0%91"><span class="nav-number">7.7.1.</span> <span class="nav-text">三棵树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HEAD"><span class="nav-number">7.7.1.1.</span> <span class="nav-text">HEAD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">7.7.1.2.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="nav-number">7.7.1.3.</span> <span class="nav-text">工作目录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">7.7.2.</span> <span class="nav-text">工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E7%BD%AE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">7.7.3.</span> <span class="nav-text">重置的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC-1-%E6%AD%A5%EF%BC%9A%E7%A7%BB%E5%8A%A8-HEAD"><span class="nav-number">7.7.3.1.</span> <span class="nav-text">第 1 步：移动 HEAD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC-2-%E6%AD%A5%EF%BC%9A%E6%9B%B4%E6%96%B0%E7%B4%A2%E5%BC%95%EF%BC%88%E2%80%93mixed%EF%BC%89"><span class="nav-number">7.7.3.2.</span> <span class="nav-text">第 2 步：更新索引（–mixed）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC-3-%E6%AD%A5%EF%BC%9A%E6%9B%B4%E6%96%B0%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%EF%BC%88%E2%80%93hard%EF%BC%89"><span class="nav-number">7.7.3.3.</span> <span class="nav-text">第 3 步：更新工作目录（–hard）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BE"><span class="nav-number">7.7.3.4.</span> <span class="nav-text">回顾</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E8%B7%AF%E5%BE%84%E6%9D%A5%E9%87%8D%E7%BD%AE"><span class="nav-number">7.7.4.</span> <span class="nav-text">通过路径来重置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9"><span class="nav-number">7.7.5.</span> <span class="nav-text">压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E5%87%BA"><span class="nav-number">7.7.6.</span> <span class="nav-text">检出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%B8%A6%E8%B7%AF%E5%BE%84"><span class="nav-number">7.7.6.1.</span> <span class="nav-text">不带路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E8%B7%AF%E5%BE%84"><span class="nav-number">7.7.6.2.</span> <span class="nav-text">带路径</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">7.7.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6"><span class="nav-number">7.8.</span> <span class="nav-text">高级合并</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81"><span class="nav-number">7.8.1.</span> <span class="nav-text">合并冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%80%E6%AC%A1%E5%90%88%E5%B9%B6"><span class="nav-number">7.8.1.1.</span> <span class="nav-text">中断一次合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5%E7%A9%BA%E7%99%BD"><span class="nav-number">7.8.1.2.</span> <span class="nav-text">忽略空白</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%96%87%E4%BB%B6%E5%86%8D%E5%90%88%E5%B9%B6"><span class="nav-number">7.8.1.3.</span> <span class="nav-text">手动文件再合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E5%87%BA%E5%86%B2%E7%AA%81"><span class="nav-number">7.8.1.4.</span> <span class="nav-text">检出冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E6%97%A5%E5%BF%97"><span class="nav-number">7.8.1.5.</span> <span class="nav-text">合并日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%BC%8F%E5%B7%AE%E5%BC%82%E6%A0%BC%E5%BC%8F"><span class="nav-number">7.8.1.6.</span> <span class="nav-text">组合式差异格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%92%A4%E6%B6%88%E5%90%88%E5%B9%B6"><span class="nav-number">7.8.2.</span> <span class="nav-text">撤消合并</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D%E5%BC%95%E7%94%A8"><span class="nav-number">7.8.2.1.</span> <span class="nav-text">修复引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%98%E5%8E%9F%E6%8F%90%E4%BA%A4"><span class="nav-number">7.8.2.2.</span> <span class="nav-text">还原提交</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-number">7.8.3.</span> <span class="nav-text">其他类型的合并</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E7%9A%84%E6%88%96%E4%BB%96%E4%BB%AC%E7%9A%84%E5%81%8F%E5%A5%BD"><span class="nav-number">7.8.3.1.</span> <span class="nav-text">我们的或他们的偏好</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E6%A0%91%E5%90%88%E5%B9%B6"><span class="nav-number">7.8.3.2.</span> <span class="nav-text">子树合并</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rerere-1"><span class="nav-number">7.9.</span> <span class="nav-text">Rerere</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mitaka xu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mitaka xu</p>
  <div class="site-description" itemprop="description">Golang开发博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">87</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaoyeshiyu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/2148.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Git学习笔记 | 小夜时雨">
      <meta itemprop="description" content="Git是日常工作中很常用的工具，除了程序员，一些文字编辑工作者都可以通过Git加速工作效率。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Git学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-02-21 00:00:00" itemprop="dateCreated datePublished" datetime="2023-02-21T00:00:00+08:00">2023-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-07-24 15:09:28" itemprop="dateModified" datetime="2023-07-24T15:09:28+08:00">2023-07-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/developer/" itemprop="url" rel="index"><span itemprop="name">开发技巧</span></a>
        </span>
    </span>

  
    <span id="/post/2148.html" class="post-meta-item leancloud_visitors" data-flag-title="Git学习笔记" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/post/2148.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="post/2148.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

            <div class="post-description">Git是日常工作中很常用的工具，除了程序员，一些文字编辑工作者都可以通过Git加速工作效率。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><h2 id="版本管理工具"><a href="#版本管理工具" class="headerlink" title="版本管理工具"></a>版本管理工具</h2><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/local.png" alt="本地版本控制图解"></p>
<p>其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9yY3Mv">RCS<i class="fa fa-external-link-alt"></i></span> 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p>
<h3 id="集中化的版本控制系统"><a href="#集中化的版本控制系统" class="headerlink" title="集中化的版本控制系统"></a>集中化的版本控制系统</h3><p>中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）可以让在不同系统上的开发者协同工作。这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/centralized.png" alt="集中化的版本控制图解"></p>
<p>缺点是中央服务器的单点故障，如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
<h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>分布式版本控制系统（Distributed Version Control System，简称 DVCS），像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/distributed.png" alt="分布式版本控制图解"></p>
<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>关于Git的历史这里不赘述，总结下来，Git的设计理念是：</p>
<ul>
<li>速度快</li>
<li>设计简单</li>
<li>对非线性开发模式的强力支持</li>
<li>完全分布式</li>
<li>有能力高效管理超大规模醒目</li>
</ul>
<p>理解了 Git 的思想和基本工作原理，用起来就会知其所以然，游刃有余。尽管 Git 用起来与其它的版本控制系统非常相似， 但它在对信息的存储和认知方式上却有很大差异，理解这些差异将有助于避免使用中的困惑。</p>
<h3 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h3><p>一些版本控制系统，统以文件变更列表的方式存储信息，这类系统将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 <strong>基于差异（delta-based）</strong> 的版本控制）。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/deltas.png" alt="存储每个文件与初始版本的差异。"></p>
<p>例如上图，版本2记录的是与版本1中的File A和File B的差异。版本3记录是与版本2中的File C的差异。</p>
<p>Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/snapshots.png" alt="Git 存储项目随时间改变的快照。"></p>
<p>例如上图，版本2保存的是变更后的A1和C1，以及没有变更的版本1中的File B。</p>
<p>这是 Git 与几乎所有其它版本控制系统的重要区别。 因此 Git 重新考虑了以前每一代版本控制系统延续下来的诸多方面。 Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 VCS。 </p>
<h3 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h3><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。Git在本地有仓库的完整克隆，因此基本上只需要在本地操作即可，本地操作完整，可以将本地仓库<code>push</code>到远端，此时才需要网络。</p>
<h3 id="Git-保证完整性"><a href="#Git-保证完整性" class="headerlink" title="Git 保证完整性"></a>Git 保证完整性</h3><p>Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p>
<p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中<strong>文件的内容（而不是文件名）</strong>或目录结构计算出来。</p>
<h3 id="Git-一般只添加数据"><a href="#Git-一般只添加数据" class="headerlink" title="Git 一般只添加数据"></a>Git 一般只添加数据</h3><p>你执行的 Git 操作，几乎只往 Git 数据库中 <strong>添加</strong> 数据。 你很难使用 Git 从数据库中删除数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。 同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容。</p>
<p>即使是删除数据，也只是将当前数据从当前分支中移除，而不是真正意义上的将文件删掉，在Git的其他分支，依然可以找回文件。</p>
<h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一： <strong>已提交（committed）</strong>、<strong>已修改（modified）</strong> 和 <strong>已暂存（staged）</strong>。</p>
<ul>
<li><code>committed</code>：已提交表示数据已经安全地保存在本地数据库中。</li>
<li><code>modified</code>：已修改表示修改了文件，但还没保存到数据库中。</li>
<li><code>staged</code>：已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
</ul>
<p>这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/areas.png" alt="工作区、暂存区以及 Git 目录。"></p>
<ul>
<li>工作区：是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
<li>暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</li>
<li>Git 仓库目录：是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</li>
</ul>
<p>基本的 Git 工作流程如下：</p>
<ol>
<li>在工作区中修改文件。</li>
<li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li>
<li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li>
</ol>
<p>如果 Git 目录中保存着特定版本的文件，就属于 <strong>已提交</strong> 状态。 如果文件已修改并放入暂存区，就属于 <strong>已暂存</strong> 状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 <strong>已修改</strong> 状态。</p>
<h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>Git的使用方式有很多种，可以使用原生的命令行模式，也可以使用 GUI 模式，这些 GUI 软件也能提供多种功能。 </p>
<p>学习过程中，应该先学会命令行，GUI是对命令行的封装，会了命令行，GUI也就自然学会了。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>按照官网的教程即可。</p>
<p>macOS建议通过homebrew安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure>

<h2 id="初次运行-Git-前的配置"><a href="#初次运行-Git-前的配置" class="headerlink" title="初次运行 Git 前的配置"></a>初次运行 Git 前的配置</h2><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ol>
<li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 <code>git config</code> 时带上 <code>--system</code> 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）</li>
<li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 你可以传递 <code>--global</code> 选项让 Git 读写此文件，这会对你系统上 <strong>所有</strong> 的仓库生效。</li>
<li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（即 <code>.git/config</code>）：针对该仓库。 你可以传递 <code>--local</code> 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）</li>
</ol>
<p>每一个级别会覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p>
<p>通过以下命令查看所有的配置以及它们所在的文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list --show-origin</span><br></pre></td></tr></table></figure>

<h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;John Doe&quot;</span><br><span class="line">git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure>

<p>如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次。</p>
<h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><p>获取所有配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<p>如果有重复的变量名，这种情况下，Git 会使用它找到的每一个变量的最后一个配置。也就是后面的覆盖前面的。</p>
<p>也可以获取某个配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure>

<h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git --help</span><br><span class="line">usage: git [-v | --version] [-h | --help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;]</span><br><span class="line">           [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]</span><br><span class="line">           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]</span><br><span class="line">           [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]</span><br><span class="line">           [--super-prefix=&lt;path&gt;] [--config-env=&lt;name&gt;=&lt;envvar&gt;]</span><br><span class="line">           &lt;command&gt; [&lt;args&gt;]</span><br></pre></td></tr></table></figure>

<p>以及二级命令的帮助</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init --help</span><br></pre></td></tr></table></figure>

<h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><h2 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h2><p>通常有两种获取 Git 项目仓库的方式：</p>
<ol>
<li>将尚未进行版本控制的本地目录转换为 Git 仓库；</li>
<li>从其它服务器 <strong>克隆</strong> 一个已存在的 Git 仓库。</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>将一个没有被git管理的目录纳入到仓库中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add *.c</span><br><span class="line">git add LICENSE</span><br><span class="line">git commit -m &#x27;initial project version&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h3><p>将远程的仓库克隆到本地</p>
<p>如果不指定目标目录，则会创建一个同名目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/libgit2/libgit2</span><br></pre></td></tr></table></figure>

<p>或者指定一个目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/libgit2/libgit2 mylibgit</span><br></pre></td></tr></table></figure>

<p>除了上面的<code>https</code>协议，也可以使用<code>git</code>协议</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com/libgit2/libgit2.git</span><br></pre></td></tr></table></figure>

<h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>将每次对文件的操作，都更新到仓库。工作目录下的每一个文件都不外乎这两种状态：<strong>已跟踪</strong> 或 <strong>未跟踪</strong>。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。</p>
<p>工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。</p>
<p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/lifecycle.png" alt="Git 下文件生命周期图。"></p>
<ul>
<li>Untracked：未追踪，例如新创建一个文件</li>
<li>Unmodified：未编辑，git clone之后，未编辑的文件</li>
<li>Modified：已编辑，将未编辑的文件编辑修改后的状态</li>
<li>Staged：已追踪，将未追踪的文件，add到git中</li>
</ul>
<h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>可以用 <code>git status</code> 命令查看哪些文件处于什么状态。</p>
<p>例如克隆仓库后立即使用此命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是“master”，这是默认的分支名。 </p>
<p>创建一个之前不存在的，新的 <code>README</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;My Project&#x27;</span> &gt; README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">    README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>

<p>在状态报告中可以看到新建的 <code>README</code> 文件出现在 <code>Untracked files</code> 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 </p>
<h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令 <code>git add</code> 开始跟踪一个文件。 所以，要跟踪 <code>README</code> 文件，运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure>

<p>此时再运行 <code>git status</code> 命令，会看到 <code>README</code> 文件已被跟踪，并处于暂存状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br></pre></td></tr></table></figure>

<p>只要在 <code>Changes to be committed</code> （待提交，也就是暂存）这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件在你运行 <code>git add</code> 时的版本将被留存在后续的历史记录中。 你可能会想起之前我们使用 <code>git init</code> 后就运行了 <code>git add &lt;files&gt;</code> 命令，开始跟踪当前目录下的文件。 <code>git add</code> 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p>
<h3 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h3><p>现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 <code>CONTRIBUTING.md</code> 的已被跟踪的文件，然后运行 <code>git status</code> 命令，会看到下面内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>

<p>文件 <code>CONTRIBUTING.md</code> 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令。 </p>
<p>这是个多功能命令：</p>
<ul>
<li>可以用它开始跟踪新文件</li>
<li>把已跟踪的文件放到暂存区</li>
<li>用于合并时把有冲突的文件标记为已解决状态等。</li>
</ul>
<p>将这个命令理解为<strong>精确地将内容添加到下一次提交中</strong>而不是<strong>将一个文件添加到项目中</strong>要更加合适。 现在让我们运行 <code>git add</code> 将<code>CONTRIBUTING.md</code>放到暂存区，然后再看看 <code>git status</code> 的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>

<p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 <code>CONTRIBUTING.md</code> 里再加条注释。 重新编辑存盘后，准备好提交。 不过且慢，再运行 <code>git status</code> 看看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>

<p>现在 <code>CONTRIBUTING.md</code> 文件同时出现在暂存区和非暂存区。实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本。 如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行 <code>git add</code> 命令时的那个版本，而不是你运行 <code>git commit</code> 时，在工作目录中的当前版本。 所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>

<h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种格式更为紧凑的输出。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure>

<p><code>??</code>：新添加的未跟踪文件</p>
<p><code>A</code>：新添加到暂存区中的文件</p>
<p><code>M</code>：修改过的文件</p>
<p>输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。</p>
<p>例如，上面的状态报告显示：</p>
<p><code>README</code>的输出栏是：<code>空M</code>，文件在工作区已修改但尚未暂存；</p>
<p><code>lib/simplegit.rb</code>的输出栏是：<code>M空</code>，文件已修改且已暂存；</p>
<p><code>Rakefile</code>的输出栏是：<code>MM</code>，文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p>
<h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。 来看一个实际的 <code>.gitignore</code> 例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure>

<p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 </p>
<p>第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p>
<p>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>**</code>）表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> 、 <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 忽略所有的 .a 文件</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># 忽略任何目录下名为 build 的文件夹</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GitHub 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表， 你可以在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9naXRpZ25vcmU=">https://github.com/github/gitignore<i class="fa fa-external-link-alt"></i></span> 找到它。</p>
</blockquote>
<blockquote>
<p>在最简单的情况下，一个仓库可能只根目录下有一个 <code>.gitignore</code> 文件，它递归地应用到整个仓库中。 然而，子目录下也可以有额外的 <code>.gitignore</code> 文件。子目录中的 <code>.gitignore</code> 文件中的规则只作用于它所在的目录中。 （Linux 内核的源码库拥有 206 个 <code>.gitignore</code> 文件。）</p>
<p>多个 <code>.gitignore</code> 文件的具体细节超出了本书的范围，更多详情见 <code>man gitignore</code> 。</p>
</blockquote>
<h3 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h3><p>如果 <code>git status</code> 命令的输出对于你来说过于简略，而你想知道具体修改了什么地方，可以用 <code>git diff</code> 命令。 当前做的哪些更新尚未暂存？ 有哪些更新已暂存并准备好下次提交？ 虽然 <code>git status</code> 已经通过在相应栏下列出文件名的方式回答了这个问题，但 <code>git diff</code> 能通过文件补丁的格式更加具体地显示哪些行发生了改变。</p>
<p>假如再次修改 README 文件后暂存，然后编辑 <code>CONTRIBUTING.md</code> 文件后先不暂存， 运行 <code>status</code> 命令将会看到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>

<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</span><br><span class="line">index 8ebb991..643e24f 100644</span><br><span class="line">--- a/CONTRIBUTING.md</span><br><span class="line">+++ b/CONTRIBUTING.md</span><br><span class="line">@@ -65,7 +65,8 @@ branch directly, things can get messy.</span><br><span class="line"> Please include a nice description of your changes when you submit your PR;</span><br><span class="line"> if we have to read the whole diff to figure out why you&#x27;re contributing</span><br><span class="line"> in the first place, you&#x27;re less likely to get feedback and have your change</span><br><span class="line">-merged in.</span><br><span class="line">+merged in. Also, split your changes into comprehensive chunks if your patch is</span><br><span class="line">+longer than a dozen lines.</span><br><span class="line"></span><br><span class="line"> If you are starting to work on a particular area, feel free to submit a PR</span><br><span class="line"> that highlights your work in progress (and note in the PR title that it&#x27;s</span><br></pre></td></tr></table></figure>

<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --staged</code> 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --staged</span></span><br><span class="line">diff --git a/README b/README</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..03902a1</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/README</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+My Project</span><br></pre></td></tr></table></figure>

<p>请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</p>
<p>像之前说的，暂存 <code>CONTRIBUTING.md</code> 后再编辑，可以使用 <code>git status</code> 查看已被暂存的修改或未被暂存的修改。 如果我们的环境（终端输出）看起来如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;# test line&#x27;</span> &gt;&gt; CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>

<p>现在运行 <code>git diff</code> 看暂存前后的变化：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</span><br><span class="line">index 643e24f..87f08c8 100644</span><br><span class="line">--- a/CONTRIBUTING.md</span><br><span class="line">+++ b/CONTRIBUTING.md</span><br><span class="line">@@ -119,3 +119,4 @@ at the</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash"><span class="comment"># Starter Projects</span></span></span><br><span class="line"></span><br><span class="line"> See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).</span><br><span class="line">+# test line</span><br></pre></td></tr></table></figure>

<p>然后用 <code>git diff --cached</code> 查看已经暂存起来的变化（ <code>--staged</code> 和 <code>--cached</code> 是同义词）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --cached</span></span><br><span class="line">diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md</span><br><span class="line">index 8ebb991..643e24f 100644</span><br><span class="line">--- a/CONTRIBUTING.md</span><br><span class="line">+++ b/CONTRIBUTING.md</span><br><span class="line">@@ -65,7 +65,8 @@ branch directly, things can get messy.</span><br><span class="line"> Please include a nice description of your changes when you submit your PR;</span><br><span class="line"> if we have to read the whole diff to figure out why you&#x27;re contributing</span><br><span class="line"> in the first place, you&#x27;re less likely to get feedback and have your change</span><br><span class="line">-merged in.</span><br><span class="line">+merged in. Also, split your changes into comprehensive chunks if your patch is</span><br><span class="line">+longer than a dozen lines.</span><br><span class="line"></span><br><span class="line"> If you are starting to work on a particular area, feel free to submit a PR</span><br><span class="line"> that highlights your work in progress (and note in the PR title that it&#x27;s</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在本书中，我们使用 <code>git diff</code> 来分析文件差异。 但是你也可以使用图形化的工具或外部 diff 工具来比较差异。 可以使用 <code>git difftool</code> 命令来调用 emerge 或 vimdiff 等软件（包括商业软件）输出 diff 的分析结果。 使用 <code>git difftool --tool-help</code> 命令来看你的系统支持哪些 Git Diff 插件。</p>
</blockquote>
<h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>现在的暂存区已经准备就绪，可以提交了。 在此之前，请务必确认还有什么已修改或新建的文件还没有 <code>git add</code> 过， 否则提交的时候不会记录这些尚未暂存的变化。 这些已修改但未暂存的文件只会保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br></pre></td></tr></table></figure>

<p>这样会启动你选择的文本编辑器来输入提交说明。</p>
<blockquote>
<p>启动的编辑器是通过 Shell 的环境变量 <code>EDITOR</code> 指定的，一般为 vim 或 emacs。 当然也可以按照 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gwMS1nZXR0aW5nLXN0YXJ0ZWQ=">起步<i class="fa fa-external-link-alt"></i></span> 介绍的方式， 使用 <code>git config --global core.editor</code> 命令设置你喜欢的编辑器。</p>
</blockquote>
<p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Please enter the commit message <span class="keyword">for</span> your <span class="keyword">changes</span>. Lines starting</span><br><span class="line"># with <span class="string">&#x27;#&#x27;</span> will <span class="keyword">be</span> ignored, <span class="built_in">and</span> <span class="keyword">an</span> <span class="built_in">empty</span> message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># Your branch <span class="keyword">is</span> <span class="keyword">up</span>-<span class="keyword">to</span>-date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line">#</span><br><span class="line"># Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span><br><span class="line">#	<span class="keyword">new</span> <span class="keyword">file</span>:   README</span><br><span class="line">#	modified:   CONTRIBUTING.md</span><br><span class="line">#</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line"><span class="string">&quot;.git/COMMIT_EDITMSG&quot;</span> <span class="number">9</span>L, <span class="number">283</span>C</span><br></pre></td></tr></table></figure>

<p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一个空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。</p>
<blockquote>
<p>更详细的内容修改提示可以用 <code>-v</code> 选项查看，这会将你所作的更改的 diff 输出呈现在编辑器中，以便让你知道本次提交具体作出哪些修改。</p>
</blockquote>
<p>退出编辑器时，Git 会丢弃注释行，用你输入的提交说明生成一次提交。</p>
<p>另外，你也可以在 <code>commit</code> 命令后添加 <code>-m</code> 选项，将提交信息与命令放在同一行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;Story 182: Fix benchmarks for speed&quot;</span></span></span><br><span class="line">[master 463dc4f] Story 182: Fix benchmarks for speed</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure>

<p>可以看到，提交后它会告诉你，当前是在哪个分支（<code>master</code>）提交的，本次提交的完整 SHA-1 校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过(2)，多少行添加和删改过(2)。</p>
<p>提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;added new benchmarks&#x27;</span></span></span><br><span class="line">[master 83e38c7] added new benchmarks</span><br><span class="line"> 1 file changed, 5 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>

<p>提交之前不再需要 <code>git add</code> 文件“CONTRIBUTING.md”了。 这是因为 <code>-a</code> 选项使本次提交包含了所有修改过的文件。 这很方便，但是要小心，有时这个选项会将不需要的文件添加到提交中。</p>
<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 <em>未暂存清单</em>）看到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> PROJECTS.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    PROJECTS.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> PROJECTS.md</span></span><br><span class="line">rm &#x27;PROJECTS.md&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    deleted:    PROJECTS.md</span><br></pre></td></tr></table></figure>

<p>下一次提交时，该文件就不再纳入版本管理了。 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> --cached README</span></span><br></pre></td></tr></table></figure>

<p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> <span class="built_in">log</span>/\*.<span class="built_in">log</span></span></span><br></pre></td></tr></table></figure>

<p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。 类似的比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> \*~</span></span><br></pre></td></tr></table></figure>

<p>该命令会删除所有名字以 <code>~</code> 结尾的文件。</p>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p>
<p>既然如此，当你看到 Git 的 <code>mv</code> 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">mv</span> file_from file_to</span></span><br></pre></td></tr></table></figure>

<p>它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure>

<p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> README.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure>

<p>如此分开操作，Git 也会意识到这是一次重命名，所以不管何种方式结果都一样。 两者唯一的区别在于，<code>git mv</code> 是一条命令而非三条命令，直接使用 <code>git mv</code> 方便得多。 不过在使用其他工具重命名文件时，记得在提交前 <code>git rm</code> 删除旧文件名，再 <code>git add</code> 添加新文件名。</p>
<h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。</p>
<p>运行下面的命令获取该项目：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/schacon/simplegit-progit</span></span><br></pre></td></tr></table></figure>

<p>当你在此项目中运行 <code>git log</code> 命令时，可以看到下面的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>

<p>不传入任何参数的默认情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<p><code>git log</code> 有许多选项可以帮助你搜寻你所要找的提交， 下面我们会介绍几个最常用的选项。</p>
<p>其中一个比较有用的选项是 <code>-p</code> 或 <code>--patch</code> ，它会显示每次提交所引入的差异（按 <strong>补丁</strong> 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 <code>-2</code> 选项来只显示最近的两次提交：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -p -2</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require &#x27;rake/gempackagetask&#x27;</span><br><span class="line"> spec = Gem::Specification.new do |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   &quot;simplegit&quot;</span><br><span class="line">-    s.version   =   &quot;0.1.0&quot;</span><br><span class="line">+    s.version   =   &quot;0.1.1&quot;</span><br><span class="line">     s.author    =   &quot;Scott Chacon&quot;</span><br><span class="line">     s.email     =   &quot;schacon@gee-mail.com&quot;</span><br><span class="line">     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index a0a60ae..47c6340 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -18,8 +18,3 @@ class SimpleGit</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line">-</span><br><span class="line">-if $0 == __FILE__</span><br><span class="line">-  git = SimpleGit.new</span><br><span class="line">-  puts git.show</span><br><span class="line">-end</span><br></pre></td></tr></table></figure>

<p>该选项除了显示基本信息之外，还附带了每次提交的变化。 当进行代码审查，或者快速浏览某个搭档的提交所带来的变化的时候，这个参数就非常有用了。 你也可以为 <code>git log</code> 附带一系列的总结性选项。 比如你想看到每次提交的简略统计信息，可以使用 <code>--stat</code> 选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line"> Rakefile | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test</span><br><span class="line"></span><br><span class="line"> lib/simplegit.rb | 5 -----</span><br><span class="line"> 1 file changed, 5 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> README           |  6 ++++++</span><br><span class="line"> Rakefile         | 23 +++++++++++++++++++++++</span><br><span class="line"> lib/simplegit.rb | 25 +++++++++++++++++++++++++</span><br><span class="line"> 3 files changed, 54 insertions(+)</span><br></pre></td></tr></table></figure>

<p><code>--stat</code> 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p>
<p>另一个非常有用的选项是 <code>--pretty</code>。 这个选项可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 <code>oneline</code> 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 选项，它们展示信息的格式基本一致，但是详尽程度不一：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949 changed the version number</span><br><span class="line">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test</span><br><span class="line">a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</span><br></pre></td></tr></table></figure>

<p>最有意思的是 <code>format</code> ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h - %an, %ar : %s&quot;</span></span></span><br><span class="line">ca82a6d - Scott Chacon, 6 years ago : changed the version number</span><br><span class="line">085bb3b - Scott Chacon, 6 years ago : removed unnecessary test</span><br><span class="line">a11bef0 - Scott Chacon, 6 years ago : first commit</span><br></pre></td></tr></table></figure>

<p><code>git log --pretty=format</code> <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvcHJldHR5X2Zvcm1hdA==">常用的选项<i class="fa fa-external-link-alt"></i></span> 列出了 <code>format</code> 接受的常用格式占位符的写法及其代表的意义。</p>
<p> <em>作者</em> 和 <em>提交者</em> 之间究竟有何差别， 其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。 所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 </p>
<p>当 <code>oneline</code> 或 <code>format</code> 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --graph</span></span><br><span class="line">* 2d3acf9 ignore errors from SIGCHLD on trap</span><br><span class="line">*  5e3ee11 Merge branch &#x27;master&#x27; of git://github.com/dustin/grit</span><br><span class="line">|\</span><br><span class="line">| * 420eac9 Added a method for getting the current branch.</span><br><span class="line">* | 30e367c timeout code and tests</span><br><span class="line">* | 5a09431 add timeout protection to grit</span><br><span class="line">* | e1193f8 support for heads with slashes in them</span><br><span class="line">|/</span><br><span class="line">* d6016bc require time for xmlschema</span><br><span class="line">*  11d191e Merge branch &#x27;defunkt&#x27; into local</span><br></pre></td></tr></table></figure>

<p><code>git log</code> 的<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvbG9nX29wdGlvbnM=">常用选项<i class="fa fa-external-link-alt"></i></span> 列出了我们目前涉及到的和没涉及到的选项，以及它们是如何影响 log 命令的输出的：</p>
<h3 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h3><p>除了定制输出格式的选项之外，<code>git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出一部分的提交。 之前你已经看到过 <code>-2</code> 选项了，它只会显示最近的两条提交， 实际上，你可以使用类似 <code>-&lt;n&gt;</code> 的选项，其中的 <code>n</code> 可以是任何整数，表示仅显示最近的 <code>n</code> 条提交。 不过实践中这个选项不是很常用，因为 Git 默认会将所有的输出传送到分页程序中，所以你一次只会看到一页的内容。</p>
<p>但是，类似 <code>--since</code> 和 <code>--until</code> 这种按照时间作限制的选项很有用。 例如，下面的命令会列出最近两周的所有提交：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --since=2.weeks</span></span><br></pre></td></tr></table></figure>

<p>该命令可用的格式十分丰富——可以是类似 <code>&quot;2008-01-15&quot;</code> 的具体的某一天，也可以是类似 <code>&quot;2 years 1 day 3 minutes ago&quot;</code> 的相对日期。</p>
<p>还可以过滤出匹配指定条件的提交。 用 <code>--author</code> 选项显示指定作者的提交，用 <code>--grep</code> 选项搜索提交说明中的关键字。</p>
<blockquote>
<p>你可以指定多个 <code>--author</code> 和 <code>--grep</code> 搜索条件，这样会只输出匹配 <strong>任意</strong> <code>--author</code> 模式和 <strong>任意</strong> <code>--grep</code> 模式的提交。然而，如果你添加了 <code>--all-match</code> 选项， 则只会输出匹配 <strong>所有</strong> <code>--grep</code> 模式的提交。</p>
</blockquote>
<p>另一个非常有用的过滤器是 <code>-S</code>（俗称“pickaxe”选项，取“用鹤嘴锄在土里捡石头”之意）， 它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。 假设你想找出添加或删除了对某一个特定函数的引用的提交，可以调用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -S function_name</span></span><br></pre></td></tr></table></figure>

<p>最后一个很实用的 <code>git log</code> 选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。</p>
<p>在限制 <code>git log</code> <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvbGltaXRfb3B0aW9ucw==">输出的选项<i class="fa fa-external-link-alt"></i></span> 中列出了常用的选项</p>
<p>来看一个实际的例子，如果要在 Git 源码库中查看 Junio Hamano 在 2008 年 10 月其间， 除了合并提交之外的哪一个提交修改了测试文件，可以使用下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=<span class="string">&quot;%h - %s&quot;</span> --author=<span class="string">&#x27;Junio C Hamano&#x27;</span> --since=<span class="string">&quot;2008-10-01&quot;</span> \</span></span><br><span class="line"><span class="language-bash">   --before=<span class="string">&quot;2008-11-01&quot;</span> --no-merges -- t/</span></span><br><span class="line">5610e3b - Fix testcase failure when extended attributes are in use</span><br><span class="line">acd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;() API</span><br><span class="line">f563754 - demonstrate breakage of detached checkout with symbolic link HEAD</span><br><span class="line">d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths</span><br><span class="line">51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEAD</span><br><span class="line">b0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch</span><br></pre></td></tr></table></figure>

<p>在近 40000 条提交中，上面的输出仅列出了符合条件的 6 条记录。</p>
<blockquote>
<p>按照你代码仓库的工作流程，记录中可能有为数不少的合并提交，它们所包含的信息通常并不多。 为了避免显示的合并提交弄乱历史记录，可以为 <code>log</code> 加上 <code>--no-merges</code> 选项。</p>
</blockquote>
<h2 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h2><p>注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令来重新提交：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure>

<p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。</p>
<p>文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。</p>
<p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;initial commit&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add forgotten_file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure>

<p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p>
<blockquote>
<p>当你在修补最后的提交时，与其说是修复旧提交，倒不如说是完全用一个 <strong>新的提交</strong> 替换旧的提交， 理解这一点非常重要。从效果上来说，就像是旧有的提交从未存在过一样，它并不会出现在仓库的历史中。</p>
<p>修补提交最明显的价值是可以稍微改进你最后的提交，而不会让“啊，忘了添加一个文件”或者 “小修补，修正笔误”这种提交信息弄乱你的仓库历史。</p>
</blockquote>
<h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>操作暂存区和工作目录中已修改的文件，这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交， 但是却意外地输入 <code>git add *</code> 暂存了它们两个。如何只取消暂存两个中的一个呢？ <code>git status</code> 命令提示了你：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add *</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>

<p>在 “Changes to be committed” 文字正下方，提示使用 <code>git reset HEAD &lt;file&gt;...</code> 来取消暂存。 所以，我们可以这样来取消暂存 <code>CONTRIBUTING.md</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD CONTRIBUTING.md</span></span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	CONTRIBUTING.md</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>

<p>这个命令有点儿奇怪，但是起作用了。 <code>CONTRIBUTING.md</code> 文件已经是修改未暂存的状态了。</p>
<blockquote>
<p><code>git reset</code> 确实是个危险的命令，如果加上了 <code>--hard</code> 选项则更是如此。 然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。</p>
</blockquote>
<h3 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h3><p>方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）。<code>git status</code> 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>

<p>它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure>

<p>可以看到那些修改已经被撤消了。</p>
<blockquote>
<p>请务必记得 <code>git checkout -- &lt;file&gt;</code> 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</p>
</blockquote>
<p>如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gwMy1naXQtYnJhbmNoaW5n">Git 分支<i class="fa fa-external-link-alt"></i></span> 介绍保存进度与分支，这通常是更好的做法。</p>
<p>记住，在 Git 中任何 <strong>已提交</strong> 的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 <code>--amend</code> 选项覆盖的提交也可以恢复 （阅读 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2RhdGFfcmVjb3Zlcnk=">数据恢复<i class="fa fa-external-link-alt"></i></span> 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。</p>
<h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 在本节中，我们将介绍一部分远程管理的技能。</p>
<blockquote>
<p>远程仓库可以在你的本地主机上</p>
<p>你完全可以在一个“远程”仓库上工作，而实际上它在你本地的主机上。 词语“远程”未必表示仓库在网络或互联网上的其它位置，而只是表示它在别处。 在这样的远程仓库上工作，仍然需要和其它远程仓库上一样的标准推送、拉取和抓取操作。</p>
</blockquote>
<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/schacon/ticgit</span></span><br><span class="line">Cloning into &#x27;ticgit&#x27;...</span><br><span class="line">remote: Reusing existing pack: 1857, done.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (772/772), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ticgit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin	https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure>

<p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> grit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (fetch)</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (push)</span><br><span class="line">cho45     https://github.com/cho45/grit (fetch)</span><br><span class="line">cho45     https://github.com/cho45/grit (push)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (fetch)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (push)</span><br><span class="line">koke      git://github.com/koke/grit.git (fetch)</span><br><span class="line">koke      git://github.com/koke/grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (push)</span><br></pre></td></tr></table></figure>

<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>我们在之前的章节中已经提到并展示了 <code>git clone</code> 命令是如何自行添加远程仓库的， 不过这里将告诉你如何自己来添加它。 运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add pb https://github.com/paulboone/ticgit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin	https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit (push)</span><br><span class="line">pb	https://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pb	https://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure>

<p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch pb</span></span><br><span class="line">remote: Counting objects: 43, done.</span><br><span class="line">remote: Compressing objects: 100% (36/36), done.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure>

<p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到——你可以将它合并到自己的某个分支中， 或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gwMy1naXQtYnJhbmNoaW5n">Git 分支<i class="fa fa-external-link-alt"></i></span> 中详细介绍什么是分支以及如何使用分支。）</p>
<h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>从远程仓库中获得数据，可以执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch &lt;remote&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 <strong>必须注意 <code>git fetch</code> 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。</strong> 当准备好时你必须手动将其合并入你的工作。</p>
<p>如果你的当前分支设置了跟踪远程分支（阅读下一节和 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gwMy1naXQtYnJhbmNoaW5n">Git 分支<i class="fa fa-external-link-alt"></i></span> 了解更多信息）， 那么可以用 <code>git pull</code> 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 <code>master</code> 分支（或其它名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p> 这个命令很简单：<code>git push &lt;remote&gt; &lt;branch&gt;</code>。 当你想要将 <code>master</code> 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字）， 那么运行这个命令就可以将你所做的备份到服务器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br></pre></td></tr></table></figure>

<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 阅读 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gwMy1naXQtYnJhbmNoaW5n">Git 分支<i class="fa fa-external-link-alt"></i></span> 了解如何推送到远程仓库服务器的详细信息。</p>
<h3 id="查看某个远程仓库"><a href="#查看某个远程仓库" class="headerlink" title="查看某个远程仓库"></a>查看某个远程仓库</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote&gt;</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                               tracked</span><br><span class="line">    dev-branch                           tracked</span><br><span class="line">  Local branch configured for &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure>

<p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 <code>master</code> 分支，并且如果运行 <code>git pull</code>， 就会抓取所有的远程引用，然后将远程 <code>master</code> 分支合并到本地 <code>master</code> 分支。 它也会列出拉取到的所有远程引用。</p>
<p>如果你是 Git 的重度使用者，那么还可以通过 <code>git remote show</code> 看到更多的信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  URL: https://github.com/my-org/complex-project</span><br><span class="line">  Fetch URL: https://github.com/my-org/complex-project</span><br><span class="line">  Push  URL: https://github.com/my-org/complex-project</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                           tracked</span><br><span class="line">    dev-branch                       tracked</span><br><span class="line">    markdown-strip                   tracked</span><br><span class="line">    issue-43                         new (next fetch will store in remotes/origin)</span><br><span class="line">    issue-45                         new (next fetch will store in remotes/origin)</span><br><span class="line">    refs/remotes/origin/issue-11     stale (use &#x27;git remote prune&#x27; to remove)</span><br><span class="line">  Local branches configured for &#x27;git pull&#x27;:</span><br><span class="line">    dev-branch merges with remote dev-branch</span><br><span class="line">    master     merges with remote master</span><br><span class="line">  Local refs configured for &#x27;git push&#x27;:</span><br><span class="line">    dev-branch                     pushes to dev-branch                     (up to date)</span><br><span class="line">    markdown-strip                 pushes to markdown-strip                 (up to date)</span><br><span class="line">    master                         pushes to master                         (up to date)</span><br></pre></td></tr></table></figure>

<p>这个命令列出了<strong>当你在特定的分支</strong>上执行 <code>git push</code> 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了， 还有当你执行 <code>git pull</code> 时哪些本地分支可以与它跟踪的远程分支自动合并。</p>
<h3 id="远程仓库的重命名与移除"><a href="#远程仓库的重命名与移除" class="headerlink" title="远程仓库的重命名与移除"></a>远程仓库的重命名与移除</h3><p>你可以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote rename pb paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>

<p>值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p>
<p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或者某一个贡献者不再贡献了——可以使用 <code>git remote remove</code> 或 <code>git remote rm</code> ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote remove paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p>
<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ <code>v1.0</code> 、 <code>v2.0</code> 等等）。 在本节中，你将会学习如何列出已有的标签、如何创建和删除新的标签、以及不同类型的标签分别是什么。</p>
<h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><p>在 Git 中列出已有的标签非常简单，只需要输入 <code>git tag</code> （可带上可选的 <code>-l</code> 选项 <code>--list</code>）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v1.0</span><br><span class="line">v2.0</span><br></pre></td></tr></table></figure>

<p>这个命令以字母顺序列出标签，但是它们显示的顺序并不重要。</p>
<p>你也可以按照特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -l <span class="string">&quot;v1.8.5*&quot;</span></span></span><br><span class="line">v1.8.5</span><br><span class="line">v1.8.5-rc0</span><br><span class="line">v1.8.5-rc1</span><br><span class="line">v1.8.5-rc2</span><br><span class="line">v1.8.5-rc3</span><br><span class="line">v1.8.5.1</span><br><span class="line">v1.8.5.2</span><br><span class="line">v1.8.5.3</span><br><span class="line">v1.8.5.4</span><br><span class="line">v1.8.5.5</span><br></pre></td></tr></table></figure>

<blockquote>
<p>按照通配符列出标签需要 <code>-l</code> 或 <code>--list</code> 选项</p>
<p>如果你只想要完整的标签列表，那么运行 <code>git tag</code> 就会默认假定你想要一个列表，它会直接给你列出来， 此时的 <code>-l</code> 或 <code>--list</code> 是可选的。</p>
<p>然而，如果你提供了一个匹配标签名的通配模式，那么 <code>-l</code> 或 <code>--list</code> 就是强制使用的。</p>
</blockquote>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。</p>
<p>轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。</p>
<p>而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。</p>
<h3 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h3><p>在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.4 -m <span class="string">&quot;my version 1.4&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure>

<p><code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。</p>
<p>通过使用 <code>git show</code> 命令可以看到标签信息和与之对应的提交信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.4</span></span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure>

<p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p>
<h3 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h3><p>另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag v1.4-lw</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br></pre></td></tr></table></figure>

<p>这时，如果在标签上运行 <code>git show</code>，你不会看到额外的标签信息。 命令只会显示出提交信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.4-lw</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure>

<h3 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h3><p>你也可以对过去的提交打标签。 假设提交历史是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#x27;experiment&#x27;</span><br><span class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#x27;experiment&#x27;</span><br><span class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function</span><br><span class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br></pre></td></tr></table></figure>

<p>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.2 9fceb02</span></span><br></pre></td></tr></table></figure>

<p>可以看到你已经在那次提交上打上标签了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.2</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.2</span></span><br><span class="line">tag v1.2</span><br><span class="line">Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Feb 9 15:32:16 2009 -0800</span><br><span class="line"></span><br><span class="line">version 1.2</span><br><span class="line">commit 9fceb02d0ae598e95dc970b74767f19372d61af8</span><br><span class="line">Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sun Apr 27 20:43:35 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated rakefile</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>默认情况下，<code>git push</code> 命令并<strong>不会传送标签到远程仓库服务器上</strong>。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 <code>git push origin &lt;tagname&gt;</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin v1.5</span></span><br><span class="line">Counting objects: 14, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (12/12), done.</span><br><span class="line">Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.</span><br><span class="line">Total 14 (delta 3), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure>

<p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --tags</span></span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</span><br></pre></td></tr></table></figure>

<p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p>
<blockquote>
<p><code>git push</code> 推送两种标签</p>
<p>使用 <code>git push &lt;remote&gt; --tags</code> 推送标签并不会区分轻量标签和附注标签， 没有简单的选项能够让你只选择推送一种标签。</p>
</blockquote>
<h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>要删除掉你本地仓库上的标签，可以使用命令 <code>git tag -d &lt;tagname&gt;</code>。 例如，可以使用以下命令删除一个轻量标签：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d v1.4-lw</span></span><br><span class="line">Deleted tag &#x27;v1.4-lw&#x27; (was e7d5add)</span><br></pre></td></tr></table></figure>

<p>注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 <code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> 来更新你的远程仓库：</p>
<p>第一种变体是 <code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin :refs/tags/v1.4-lw</span></span><br><span class="line">To /git@github.com:schacon/simplegit.git</span><br><span class="line"> - [deleted]         v1.4-lw</span><br></pre></td></tr></table></figure>

<p>上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。</p>
<p>第二种更直观的删除远程标签的方式是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;tagname&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>如果你想查看某个标签所指向的文件版本，可以使用 <code>git checkout</code> 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout 2.0.0</span></span><br><span class="line">Note: checking out &#x27;2.0.0&#x27;.</span><br><span class="line"></span><br><span class="line">You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout 2.0-beta-0.1</span></span><br><span class="line">Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final</span><br><span class="line">HEAD is now at df3f601... add atlas.json and cover image</span><br></pre></td></tr></table></figure>

<p><strong>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。</strong> 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b version2 v2.0.0</span></span><br><span class="line">Switched to a new branch &#x27;version2&#x27;</span><br></pre></td></tr></table></figure>

<p>如果在这之后又进行了一次提交，<code>version2</code> 分支就会因为这个改动向前移动， 此时它就会和 <code>v2.0.0</code> 标签稍微有些不同，这时就要当心了。</p>
<h2 id="Git-别名"><a href="#Git-别名" class="headerlink" title="Git 别名"></a>Git 别名</h2><p>有一个小技巧可以使你的 Git 体验更简单、容易、熟悉：别名。 我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。</p>
<p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.co checkout</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.br branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.ci commit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.st status</span></span><br></pre></td></tr></table></figure>

<p>这意味着，当要输入 <code>git commit</code> 时，只需要输入 <code>git ci</code>。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。</p>
<p>在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.unstage <span class="string">&#x27;reset HEAD --&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>这会使下面的两个命令等价：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git unstage fileA</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD -- fileA</span></span><br></pre></td></tr></table></figure>

<p>这样看起来更清楚一些。 通常也会添加一个 <code>last</code> 命令，像这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.last <span class="string">&#x27;log -1 HEAD&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>这样，可以轻松地看到最后一次提交：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git last</span></span><br><span class="line">commit 66938dae3329c7aebe598c2246a8e6af90d04646</span><br><span class="line">Author: Josh Goebel &lt;dreamer3@example.com&gt;</span><br><span class="line">Date:   Tue Aug 26 19:48:51 2008 +0800</span><br><span class="line"></span><br><span class="line">    test for current head</span><br><span class="line"></span><br><span class="line">    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</span><br></pre></td></tr></table></figure>

<p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 <code>!</code> 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 <code>git visual</code> 定义为 <code>gitk</code> 的别名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.visual <span class="string">&#x27;!gitk&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p>
<p>有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。 为何 Git 的分支模型如此出众呢？ Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。</p>
<h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 <strong>快照</strong> 。</p>
<p>在进行提交操作时，Git 会保存一个提交对象（commit object）。 知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象，</p>
<p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用我们在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gwMS1nZXR0aW5nLXN0YXJ0ZWQ=">起步<i class="fa fa-external-link-alt"></i></span> 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 <em>blob</em> 对象来保存它们），最终将校验和加入到暂存区域等待提交：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README test.rb LICENSE</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;The initial commit of my project&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。</p>
<p>现在，Git 仓库中有五个对象：三个 <em>blob</em> 对象（保存着文件快照）、一个 <strong>树</strong> 对象 （记录着目录结构和 blob 对象索引）以及一个 <strong>提交</strong> 对象（包含着指向前述树对象的指针和所有提交信息）。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/commit-and-tree.png" alt="首次提交对象及其树结构。"></p>
<p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/commits-and-parents.png" alt="提交对象及其父对象。"></p>
<p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 <code>master</code> 分支会在每次提交时自动向前移动。</p>
<blockquote>
<p>Git 的 <code>master</code> 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 <code>git init</code> 命令默认创建它，并且大多数人都懒得去改动它。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/branch-and-history.png" alt="分支及其提交历史。"></p>
<h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch testing</span></span><br></pre></td></tr></table></figure>

<p>这会在当前所在的提交对象上创建一个指针。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/two-branches.png" alt="两个指向相同提交历史的分支。"></p>
<p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <strong>创建</strong> 一个新分支，<strong>并不会自动切换到新分支中去</strong>。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/head-to-master.png" alt="HEAD 指向当前所在的分支。"></p>
<p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --decorate</span></span><br><span class="line">f30ab (HEAD -&gt; master, testing) add feature #32 - ability to add new formats to the central interface</span><br><span class="line">34ac2 Fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">98ca9 The initial commit of my project</span><br></pre></td></tr></table></figure>

<p>当前 <code>master</code> 和 <code>testing</code> 分支均指向校验和以 <code>f30ab</code> 开头的提交对象。</p>
<h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout testing</span></span><br></pre></td></tr></table></figure>

<p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/head-to-testing.png" alt="HEAD 指向当前所在的分支。"></p>
<p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim test.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;made a change&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/advance-testing.png" alt="HEAD 分支随着提交操作自动向前移动。"></p>
<p>如图所示，你的 <code>testing</code> 分支向前移动了，但是 <code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code> 时所指的对象。 这就有意思了，现在我们切换回 <code>master</code> 分支看看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/checkout-master.png" alt="检出时 HEAD 随之移动。"></p>
<p>这条命令做了两件事。 一是使 HEAD 指回 <code>master</code> 分支，二是将工作目录恢复成 <code>master</code> 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 <code>testing</code> 分支所做的修改，以便于向另一个方向进行开发。</p>
<blockquote>
<p>分支切换会改变你工作目录中的文件</p>
<p>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p>
</blockquote>
<p>我们不妨再稍微做些修改并提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim test.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;made other changes&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>现在，这个项目的提交历史已经产生了分叉（参见 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvZGl2ZXJnZW50X2hpc3Rvcnk=">项目分叉历史<i class="fa fa-external-link-alt"></i></span>）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/advance-master.png" alt="项目分叉历史。"></p>
<p>你可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --decorate --graph --all</span></span><br><span class="line">* c2b9e (HEAD, master) made other changes</span><br><span class="line">| * 87ab2 (testing) made a change</span><br><span class="line">|/</span><br><span class="line">* f30ab add feature #32 - ability to add new formats to the</span><br><span class="line">* 34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure>

<p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？</p>
<p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 <strong>而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。</strong> 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p>
<blockquote>
<p>创建新分支的同时切换过去</p>
<p>通常我们会在创建一个新分支后立即切换过去，这可以用 <code>git checkout -b &lt;newbranchname&gt;</code> 一条命令搞定。</p>
</blockquote>
<h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p>
<ol>
<li>开发某个网站。</li>
<li>为实现某个新的用户需求，创建一个分支。</li>
<li>在这个分支上开展工作。</li>
</ol>
<p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p>
<ol>
<li>切换到你的线上分支（production branch）。</li>
<li>为这个紧急任务新建一个分支，并在其中修复它。</li>
<li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li>
<li>切换回你最初工作的分支上，继续工作。</li>
</ol>
<h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><p>首先，我们假设你正在你的项目上工作，并且在 <code>master</code> 分支上已经有了一些提交。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-branching-1.png" alt="一个简单的提交历史。"></p>
<p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b iss53</span></span><br><span class="line">Switched to a new branch &quot;iss53&quot;</span><br></pre></td></tr></table></figure>

<p>它是下面两条命令的简写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch iss53</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout iss53</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-branching-2.png" alt="创建一个新分支指针。"></p>
<p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经检出到该分支 （也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim index.html</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;added a new footer [issue 53]&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-branching-3.png" alt="`iss53` 分支随着工作的进展向前推进。"></p>
<p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起， 你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 <code>master</code> 分支。</p>
<p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改， 它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，暂存（stashing） 和 修补提交（commit amending））， 我们会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2dpdF9zdGFzaGluZw==">贮藏与清理<i class="fa fa-external-link-alt"></i></span> 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 <code>master</code> 分支了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure>

<p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p>
<p>接下来，你要修复这个紧急问题。 我们来建立一个 <code>hotfix</code> 分支，在该分支上工作直到问题解决：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b hotfix</span></span><br><span class="line">Switched to a new branch &#x27;hotfix&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim index.html</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;fixed the broken email address&#x27;</span></span></span><br><span class="line">[hotfix 1fb7853] fixed the broken email address</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-branching-4.png" alt="基于 `master` 分支的紧急问题分支（hotfix branch）。"></p>
<p>你可以运行你的测试，确保你的修改是正确的，然后将 <code>hotfix</code> 分支合并回你的 <code>master</code> 分支来部署到线上。 你可以使用 <code>git merge</code> 命令来达到上述目的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge hotfix</span></span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>

<p>在合并的时候，你应该注意到了“快进（fast-forward）”这个词。 由于你想要合并的分支 <code>hotfix</code> 所指向的提交 <code>C4</code> 是你所在的提交 <code>C2</code> 的直接后继， 因此 Git 会直接将指针向前移动。换句话说，当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p>
<p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-branching-5.png" alt="`master` 被快进到 `hotfix`。"></p>
<p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 <code>hotfix</code> 分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。 你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d hotfix</span></span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure>

<p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout iss53</span></span><br><span class="line">Switched to branch &quot;iss53&quot;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim index.html</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&#x27;finished the new footer [issue 53]&#x27;</span></span></span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-branching-6.png" alt="继续在 `iss53` 分支上的工作。"></p>
<p>你在 <code>hotfix</code> 分支上所做的工作并没有包含到 <code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code> 所做的修改，你可以使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到 <code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code> 分支。</p>
<h3 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h3><p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>这和你之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的公共祖先（<code>C2</code>），做一个简单的三方合并。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-merging-1.png" alt="一次典型合并中所用到的三个快照。"></p>
<p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-merging-2.png" alt="一个合并提交。"></p>
<p>既然你的修改已经合并进来了，就不再需要 <code>iss53</code> 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d iss53</span></span><br></pre></td></tr></table></figure>

<h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 <code>hotfix</code> 分支的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge iss53</span></span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line"> please contact us at support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure>

<p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p>
<p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git mergetool</span></span><br><span class="line"></span><br><span class="line">This message is displayed because &#x27;merge.tool&#x27; is not configured.</span><br><span class="line">See &#x27;git mergetool --tool-help&#x27; or &#x27;git help config&#x27; for more details.</span><br><span class="line">&#x27;git mergetool&#x27; will now attempt to use one of the following tools:</span><br><span class="line">opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge</span><br><span class="line">Merging:</span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line">Normal merge conflict for &#x27;index.html&#x27;:</span><br><span class="line">  &#123;local&#125;: modified file</span><br><span class="line">  &#123;remote&#125;: modified file</span><br><span class="line">Hit return to start merge resolution tool (opendiff):</span><br></pre></td></tr></table></figure>

<p>如果你想使用除默认工具（在这里 Git 使用 <code>opendiff</code> 做为默认的合并工具，因为作者在 Mac 上运行该程序） 外的其他合并工具，你可以在 “下列工具中（one of the following tools）” 这句后面看到所有支持的合并工具。 然后输入你喜欢的工具名字就可以了。</p>
<blockquote>
<p>如果你需要更加高级的工具来解决复杂的合并冲突，我们会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2FkdmFuY2VkX21lcmdpbmc=">高级合并<i class="fa fa-external-link-alt"></i></span> 介绍更多关于分支合并的内容。</p>
</blockquote>
<p>等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use &quot;git commit&quot; to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line">    modified:   index.html</span><br></pre></td></tr></table></figure>

<p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#x27;iss53&#x27;</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">    index.html</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># It looks like you may be committing a merge.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If this is not correct, please remove the file</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	.git/MERGE_HEAD</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and try again.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with <span class="string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">All conflicts fixed but you are still merging.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Changes to be committed:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	modified:   index.html</span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure>

<p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息， 添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>

<p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。 这意味着如果在这时候提交，<code>master</code> 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -v</span></span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &#x27;iss53&#x27;</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure>

<p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --merged</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --no-merged</span></span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>

<p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d testing</span></span><br><span class="line">error: The branch &#x27;testing&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D testing&#x27;.</span><br></pre></td></tr></table></figure>

<p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p>
<blockquote>
<p>上面描述的选项 <code>--merged</code> 和 <code>--no-merged</code> 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 <strong>当前</strong> 分支的分支。</p>
<p>你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。 例如，尚未合并到 <code>master</code> 分支的有哪些？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout testing</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --no-merged master</span></span><br><span class="line">  topicA</span><br><span class="line">  featureB</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。</p>
<p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 <code>master</code> 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 <code>develop</code> 或者 <code>next</code> 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 <code>master</code> 分支了。 这样，在确保这些已完成的主题分支（短期分支，比如之前的 <code>iss53</code> 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。</p>
<p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/lr-branches-1.png" alt="趋于稳定分支的线性图。"></p>
<p>通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/lr-branches-2.png" alt="趋于稳定分支的工作流（“silo”）视图。"></p>
<p>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 <code>proposed</code>（建议） 或 <code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 <code>next</code> 或者 <code>master</code> 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p>
<h3 id="主题分支"><a href="#主题分支" class="headerlink" title="主题分支"></a>主题分支</h3><p>主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。 也许你从来没有在其他的版本控制系统（<code>VCS</code>）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。 然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。</p>
<p>你已经在上一节中你创建的 <code>iss53</code> 和 <code>hotfix</code> 主题分支中看到过这种用法。 你在上一节用到的主题分支（<code>iss53</code> 和 <code>hotfix</code> 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p>
<p>考虑这样一个例子，你在 <code>master</code> 分支上工作到 <code>C1</code>，这时为了解决一个问题而新建 <code>iss91</code> 分支，在 <code>iss91</code> 分支上工作到 <code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个 <code>iss91v2</code> 分支试图用另一种方法解决那个问题，接着你回到 <code>master</code> 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 <code>C10</code> 的时候新建一个 <code>dumbidea</code> 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/topic-branches-1.png" alt="拥有多个主题分支的提交历史。"></p>
<p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 <code>iss91v2</code> 分支中方案。 另外，你将 <code>dumbidea</code> 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 <code>iss91</code> 分支（即丢弃 <code>C5</code> 和 <code>C6</code> 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：</p>
<p>我们将会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gwNS1kaXN0cmlidXRlZC1naXQ=">分布式 Git<i class="fa fa-external-link-alt"></i></span> 中向你揭示更多有关分支工作流的细节， 因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。</p>
<p>请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。</p>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 <code>git ls-remote &lt;remote&gt;</code> 来显式地获得远程引用的完整列表， 或者通过 <code>git remote show &lt;remote&gt;</code> 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p>
<p>远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。</p>
<p>它们以 <code>&lt;remote&gt;/&lt;branch&gt;</code> 的形式命名。 例如，如果你想要看你最后一次与远程仓库 <code>origin</code> 通信时 <code>master</code> 分支的状态，你可以查看 <code>origin/master</code> 分支。 你与同事合作解决一个问题并且他们推送了一个 <code>iss53</code> 分支，你可能有自己的本地 <code>iss53</code> 分支， 然而在服务器上的分支会以 <code>origin/iss53</code> 来表示。</p>
<p>这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 <code>git.ourcompany.com</code> 的 Git 服务器。 如果你从这里克隆，Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据， 创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code>。 Git 也会给你一个与 origin 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支，这样你就有工作的基础。</p>
<blockquote>
<p>“origin” 并无特殊含义</p>
<p>远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 <code>git init</code> 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 <code>git clone</code> 时默认的远程仓库名字。 如果你运行 <code>git clone -o booyah</code>，那么你默认的远程分支名字将会是 <code>booyah/master</code>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/remote-branches-1.png" alt="克隆之后的服务器与本地仓库。"></p>
<p>如果你在本地的 <code>master</code> 分支做了一些工作，在同一段时间内有其他人推送提交到 <code>git.ourcompany.com</code> 并且更新了它的 <code>master</code> 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 <code>origin</code> 服务器连接（并拉取数据），你的 <code>origin/master</code> 指针就不会移动。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/remote-branches-2.png" alt="本地与远程的工作可以分叉。"></p>
<p>如果要与给定的远程仓库同步数据，运行 <code>git fetch &lt;remote&gt;</code> 命令（在本例中为 <code>git fetch origin</code>）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>）， 从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针到更新之后的位置。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/remote-branches-3.png" alt="`git fetch` 更新你的远程仓库引用。"></p>
<p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 <code>git.team1.ourcompany.com</code>。 你可以运行 <code>git remote add</code> 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gwMi1naXQtYmFzaWNzLWNoYXB0ZXI=">Git 基础<i class="fa fa-external-link-alt"></i></span> 中详细说明。 将这个远程仓库命名为 <code>teamone</code>，将其作为完整 URL 的缩写。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/remote-branches-4.png" alt="添加另一个远程仓库。"></p>
<p>现在，可以运行 <code>git fetch teamone</code> 来抓取远程仓库 <code>teamone</code> 有而本地没有的数据。 因为那台服务器上现有的数据是 <code>origin</code> 服务器上的一个子集， 所以 Git 并不会抓取数据而是会设置远程跟踪分支 <code>teamone/master</code> 指向 <code>teamone</code> 的 <code>master</code> 分支。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/remote-branches-5.png" alt="远程跟踪分支 `teamone/master`。"></p>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p>
<p>如果希望和别人一起在名为 <code>serverfix</code> 的分支上工作，你可以像推送第一个分支那样推送它。 运行 <code>git push &lt;remote&gt; &lt;branch&gt;</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin serverfix</span></span><br><span class="line">Counting objects: 24, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure>

<p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code> 分支名字展开为 <code>refs/heads/serverfix:refs/heads/serverfix</code>， 那意味着，“推送本地的 <code>serverfix</code> 分支来更新远程仓库上的 <code>serverfix</code> 分支（前一个serverfix是本地分支，后一个serverfix是远程分支）。” 我们将会详细学习 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gxMC1naXQtaW50ZXJuYWxz">Git 内部原理<i class="fa fa-external-link-alt"></i></span> 的 <code>refs/heads/</code> 部分， 但是现在可以先把它放在儿。你也可以运行 <code>git push origin serverfix:serverfix</code>， 它会做同样的事——也就是说“推送本地的 <code>serverfix</code> 分支，将其作为远程仓库的 <code>serverfix</code> 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行 <code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。</p>
<blockquote>
<p>如何避免每次输入密码</p>
<p>如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。</p>
<p>如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 <code>git config --global credential.helper cache</code> 来设置它。（适用于HTTP&#x2F;HTTPS协议，不适用于通过SSH的方式）</p>
<p>想要了解更多关于不同验证缓存的可用选项，查看 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2NyZWRlbnRpYWxfY2FjaGluZw==">凭证存储<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
<p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 <code>origin/serverfix</code>，指向服务器的 <code>serverfix</code> 分支的引用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch origin</span></span><br><span class="line">remote: Counting objects: 7, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix    -&gt; origin/serverfix</span><br></pre></td></tr></table></figure>

<p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 <code>serverfix</code> 分支——只有一个不可以修改的 <code>origin/serverfix</code> 指针。</p>
<p>可以运行 <code>git merge origin/serverfix</code> 将这些工作合并到当前所在的分支。 如果想要在自己的 <code>serverfix</code> 分支上工作，可以将其建立在远程跟踪分支之上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b serverfix origin/serverfix</span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure>

<p>这会给你一个用于工作的本地分支，并且起点位于 <code>origin/serverfix</code>。</p>
<h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 <code>master</code> 分支。 最简单的实例就是像之前看到的那样，运行 <code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout --track origin/serverfix</span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure>

<p>由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout serverfix</span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;serverfix&#x27;</span><br></pre></td></tr></table></figure>

<p>如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b sf origin/serverfix</span></span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#x27;sf&#x27;</span><br></pre></td></tr></table></figure>

<p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p>
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -u origin/serverfix</span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上游快捷方式</p>
<p>当设置好跟踪分支后，可以通过简写 <code>@&#123;upstream&#125;</code> 或 <code>@&#123;u&#125;</code> 来引用它的上游分支。 所以在 <code>master</code> 分支时并且它正在跟踪 <code>origin/master</code> 时，如果愿意的话可以使用 <code>git merge @&#123;u&#125;</code> 来取代 <code>git merge origin/master</code>。</p>
</blockquote>
<p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -vv</span></span><br><span class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure>

<p>这里可以看到:</p>
<ul>
<li><code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 </li>
<li><code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 </li>
<li><code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的 <code>server-fix-good</code> 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 </li>
<li><code>testing</code> 分支并没有跟踪任何远程分支。</li>
</ul>
<p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 <strong>这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。</strong> 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch --all; git branch -vv</span></span><br></pre></td></tr></table></figure>

<h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会<strong>查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。</strong></p>
<p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 <code>master</code> 分支（或任何其他稳定代码分支）。 可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 （删除了本地仓库和远程仓库的分支，但是没有删掉本地的分支）如果想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete serverfix</span></span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure>

<p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。</p>
<h3 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h3><p>请回顾之前在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2Jhc2ljX21lcmdpbmc=">分支的合并<i class="fa fa-external-link-alt"></i></span> 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-rebase-1.png" alt="分叉的提交历史。"></p>
<p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-rebase-2.png" alt="通过合并操作来整合分叉了的历史。"></p>
<p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。 在 Git 中，这种操作就叫做 <strong>变基（rebase）</strong>。 你可以使用 <code>rebase</code> 命令<strong>将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</strong></p>
<p>在这个例子中，你可以检出 <code>experiment</code> 分支，然后将它变基到 <code>master</code> 分支上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout experiment</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master</span></span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure>

<p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>） 的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-rebase-3.png" alt="将 `C4` 中的修改变基到 `C3` 上。"></p>
<p>现在回到 <code>master</code> 分支，进行一次快进合并。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge experiment</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/basic-rebase-4.png" alt="`master` 分支的快进合并。"></p>
<p>此时，<code>C4&#39;</code> 指向的快照就和 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvZWJhc2luZy1tZXJnaW5nLWV4YW1wbGU=">the merge example<i class="fa fa-external-link-alt"></i></span> 中 <code>C5</code> 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是<strong>变基使得提交历史更加整洁。</strong> 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，<strong>提交历史是一条直线没有分叉</strong>。</p>
<p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 <strong>这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</strong></p>
<p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>
<h3 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="headerlink" title="更有趣的变基例子"></a>更有趣的变基例子</h3><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvYmRpYWdfZQ==">从一个主题分支里再分出一个主题分支的提交历史<i class="fa fa-external-link-alt"></i></span> 中的例子那样。 你创建了一个主题分支 <code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了主题分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和 <code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/interesting-rebase-1.png" alt="从一个主题分支里再分出一个主题分支的提交历史。"></p>
<p>假设你希望将 <code>client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code> 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项， 选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重放：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase --onto master server client</span></span><br></pre></td></tr></table></figure>

<p>以上命令的意思是：“取出 <code>client</code> 分支，找出它从 <code>server</code> 分支分歧之后的补丁， 然后把这些补丁在 <code>master</code> 分支上重放一遍，让 <code>client</code> 看起来像直接基于 <code>master</code> 修改一样”。这理解起来有一点复杂，不过效果非常酷。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/interesting-rebase-2.png" alt="截取主题分支上的另一个主题分支，然后变基到其他分支。"></p>
<p>现在可以快进合并 <code>master</code> 分支了。（如图 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/bdiag_g">快进合并 <code>master</code> 分支，使之包含来自 <code>client</code> 分支的修改</a>）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge client</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/interesting-rebase-3.png" alt="快进合并 `master` 分支，使之包含来自 `client` 分支的修改。"></p>
<p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用 <code>git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code> 命令可以直接将主题分支 （即本例中的 <code>server</code>）变基到目标分支（即 <code>master</code>）上。 这样做能省去你先切换到 <code>server</code> 分支，再对其执行变基命令的多个步骤。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master server</span></span><br></pre></td></tr></table></figure>

<p>如图 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/bdiag_h">将 <code>server</code> 中的修改变基到 <code>master</code> 上</a> 所示，<code>server</code> 中的代码被“续”到了 <code>master</code> 后面。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/interesting-rebase-4.png" alt="将 `server` 中的修改变基到 `master` 上。"></p>
<p>然后就可以快进合并主分支 <code>master</code> 了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge server</span></span><br></pre></td></tr></table></figure>

<p>至此，<code>client</code> 和 <code>server</code> 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvYmRpYWdfaQ==">最终的提交历史<i class="fa fa-external-link-alt"></i></span> 中的样子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d client</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d server</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/interesting-rebase-5.png" alt="最终的提交历史。"></p>
<h3 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h3><p>它得遵守一条准则：</p>
<p><strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</strong></p>
<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>
<p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/perils-of-rebasing-1.png" alt="克隆一个仓库，然后在它的基础上进行了一些开发。"></p>
<p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/perils-of-rebasing-2.png" alt="抓取别人的提交，合并到自己的开发分支。"></p>
<p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/perils-of-rebasing-3.png" alt="有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。"></p>
<p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/perils-of-rebasing-4.png" alt="你将相同的内容又合并了一次，生成了一个新的提交。"></p>
<p>此时如果你执行 <code>git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 <code>C4</code> 和 <code>C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p>
<h3 id="用变基解决变基"><a href="#用变基解决变基" class="headerlink" title="用变基解决变基"></a>用变基解决变基</h3><p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p>
<p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。</p>
<p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p>
<p>举个例子，如果遇到前面提到的 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3ByZV9tZXJnZV9yZWJhc2Vfd29yaw==">有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交<i class="fa fa-external-link-alt"></i></span> 那种情境，如果我们不是执行合并，而是执行 <code>git rebase teamone/master</code>, Git 将会：</p>
<ul>
<li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li>
<li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li>
<li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</li>
<li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li>
</ul>
<p>从而我们将得到与 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX21lcmdlX3JlYmFzZV93b3Jr">你将相同的内容又合并了一次，生成了一个新的提交<i class="fa fa-external-link-alt"></i></span> 中不同的结果，如图 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3JlYmFzZV9yZWJhc2Vfd29yaw==">在一个被变基然后强制推送的分支上再次执行变基<i class="fa fa-external-link-alt"></i></span> 所示。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/perils-of-rebasing-5.png" alt="在一个被变基然后强制推送的分支上再次执行变基。"></p>
<p>要想上述方案有效，<strong>还需要对方在变基时确保 <code>C4&#39;</code> 和 <code>C4</code> 是几乎一样的。 否则变基操作将无法识别</strong>，并新建另一个类似 <code>C4</code> 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p>
<p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 <code>git pull</code>。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p>
<p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项 <code>--rebase</code>，你可以执行这条语句 <code>git config --global pull.rebase true</code> 来更改 <code>pull.rebase</code> 的默认配置。</p>
<p><strong>如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了</strong>，你的同事也会因此鄙视你。</p>
<p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code>git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p>
<h3 id="变基-vs-合并"><a href="#变基-vs-合并" class="headerlink" title="变基 vs. 合并"></a>变基 vs. 合并</h3><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 <em>谎言</em> 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p>
<p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 <code>rebase</code> 及 <code>filter-branch</code> 等工具来编写故事，怎么方便后来的读者就怎么写。</p>
<p> Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p>
<p>总的原则是，<strong>只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</strong></p>
<h1 id="服务器上的-Git"><a href="#服务器上的-Git" class="headerlink" title="服务器上的 Git"></a>服务器上的 Git</h1><p>为了使用 Git 协作功能，你还需要有远程的 Git 仓库。 尽管在技术上你可以从个人仓库进行推送（push）和拉取（pull）来修改内容，但不鼓励使用这种方法，因为一不留心就很容易弄混其他人的进度。 此外，你希望你的合作者们即使在你的电脑未联机时亦能存取仓库 — 拥有一个更可靠的公用仓库十分有用。 因此，与他人合作的最佳方法即是建立一个你与合作者们都有权利访问，且可从那里推送和拉取资料的共用仓库。</p>
<p>一个远程仓库通常只是一个裸仓库（bare repository）——即一个没有当前工作目录的仓库。 因为该仓库仅仅作为合作媒介，不需要从磁盘检查快照；存放的只有 Git 的资料。 简单的说，裸仓库就是你工程目录内的 <code>.git</code> 子目录内容，不包含其他资料。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>Git 可以使用四种不同的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。 在此，我们将会讨论那些协议及哪些情形应该使用（或避免使用）他们。</p>
<h3 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h3><p>最基本的就是 <em>本地协议（Local protocol）</em> ，其中的远程版本库就是同一主机上的另一个目录。 这常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。 后者并不理想，因为你的所有代码版本库如果长存于同一台电脑，更可能发生灾难性的损失。</p>
<p>如果你使用共享文件系统，就可以从本地版本库克隆（clone）、推送（push）以及拉取（pull）。 像这样去克隆一个版本库或者增加一个远程到现有的项目中，使用版本库路径作为 URL。 例如，克隆一个本地版本库，可以执行如下的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> /srv/git/project.git</span></span><br></pre></td></tr></table></figure>

<p>或你可以执行这个命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> file:///srv/git/project.git</span></span><br></pre></td></tr></table></figure>

<p>如果在 URL 开头明确的指定 <code>file://</code>，那么 Git 的行为会略有不同。 如果仅是指定路径，Git 会尝试使用硬链接（hard link）或直接复制所需要的文件。 如果指定 <code>file://</code>，Git 会触发平时用于网路传输资料的进程，那样传输效率会更低。 指定 <code>file://</code> 的主要目的是取得一个没有外部参考（extraneous references） 或对象（object）的干净版本库副本——通常是在从其他版本控制系统导入后或一些类似情况需要这么做 （关于维护任务可参见 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gxMC1naXQtaW50ZXJuYWxz">Git 内部原理<i class="fa fa-external-link-alt"></i></span> ）。 在此我们将使用普通路径，因为这样通常更快。</p>
<p>要增加一个本地版本库到现有的 Git 项目，可以执行如下的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add local_proj /srv/git/project.git</span></span><br></pre></td></tr></table></figure>

<p>然后，就可以通过新的远程仓库名 <code>local_proj</code> 像在网络上一样从远端版本库推送和拉取更新了。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>基于文件系统的版本库的优点是简单，并且直接使用了现有的文件权限和网络访问权限。 如果你的团队已经有共享文件系统，建立版本库会十分容易。 只需要像设置其他共享目录一样，把一个裸版本库的副本放到大家都可以访问的路径，并设置好读&#x2F;写的权限，就可以了， 我们会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2dldHRpbmdfZ2l0X29uX2Ffc2VydmVy">在服务器上搭建 Git<i class="fa fa-external-link-alt"></i></span> 讨论如何导出一个裸版本库。</p>
<p>这也是快速从别人的工作目录中拉取更新的方法。 如果你和别人一起合作一个项目，他想让你从版本库中拉取更新时，运行类似 <code>git pull /home/john/project</code> 的命令比推送到服务器再抓取回来简单多了。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>这种方法的缺点是，通常共享文件系统比较难配置，并且比起基本的网络连接访问，这不方便从多个位置访问。 如果你想从家里推送内容，必须先挂载一个远程磁盘，相比网络连接的访问方式，配置不方便，速度也慢。</p>
<p>值得一提的是，如果你使用的是类似于共享挂载的文件系统时，这个方法不一定是最快的。 访问本地版本库的速度与你访问数据的速度是一样的。 在同一个服务器上，如果允许 Git 访问本地硬盘，一般的通过 NFS 访问版本库要比通过 SSH 访问慢。</p>
<p>最终，这个协议并不保护仓库避免意外的损坏。 每一个用户都有“远程”目录的完整 shell 权限，没有方法可以阻止他们修改或删除 Git 内部文件和损坏仓库。</p>
<h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>Git 通过 HTTP 通信有两种模式。 在 Git 1.6.6 版本之前只有一个方式可用，十分简单并且通常是只读模式的。 Git 1.6.6 版本引入了一种新的、更智能的协议，让 Git 可以像通过 SSH 那样智能的协商和传输数据。 之后几年，这个新的 HTTP 协议因为其简单、智能变的十分流行。 新版本的 HTTP 协议一般被称为 <strong>智能</strong> HTTP 协议，旧版本的一般被称为 <strong>哑</strong> HTTP 协议。 我们先了解一下新的智能 HTTP 协议。</p>
<h4 id="智能-HTTP-协议"><a href="#智能-HTTP-协议" class="headerlink" title="智能 HTTP 协议"></a>智能 HTTP 协议</h4><p>智能 HTTP 的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP&#x2F;S 端口上并且可以使用各种 HTTP 验证机制， 这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名&#x2F;密码授权，免去设置 SSH 公钥。</p>
<p>智能 HTTP 协议或许已经是最流行的使用 Git 的方式了，它即支持像 <code>git://</code> 协议一样设置匿名服务， 也可以像 SSH 协议一样提供传输时的授权和加密。 而且只用一个 URL 就可以都做到，省去了为不同的需求设置不同的 URL。 如果你要推送到一个需要授权的服务器上（一般来讲都需要），服务器会提示你输入用户名和密码。 从服务器获取数据时也一样。</p>
<p>事实上，类似 GitHub 的服务，你在网页上看到的 URL（比如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NjaGFjb24vc2ltcGxlZ2l0JUVGJUJDJTg5JUVGJUJDJThD">https://github.com/schacon/simplegit），<i class="fa fa-external-link-alt"></i></span> 和你在克隆、推送（如果你有权限）时使用的是一样的。</p>
<h4 id="哑（Dumb）-HTTP-协议"><a href="#哑（Dumb）-HTTP-协议" class="headerlink" title="哑（Dumb） HTTP 协议"></a>哑（Dumb） HTTP 协议</h4><p>如果服务器没有提供智能 HTTP 协议的服务，Git 客户端会尝试使用更简单的“哑” HTTP 协议。 哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。 哑 HTTP 协议的优美之处在于设置起来简单。 基本上，只需要把一个裸版本库放在 HTTP 根目录，设置一个叫做 <code>post-update</code> 的挂钩就可以了 （见 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2dpdF9ob29rcw==">Git 钩子<i class="fa fa-external-link-alt"></i></span>）。 此时，只要能访问 web 服务器上你的版本库，就可以克隆你的版本库。 下面是设置从 HTTP 访问版本库的方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /var/www/htdocs/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> --bare /path/to/git_project gitproject.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> gitproject.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> hooks/post-update.sample hooks/post-update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> a+x hooks/post-update</span></span><br></pre></td></tr></table></figure>

<p>这样就可以了。 Git 自带的 <code>post-update</code> 挂钩会默认执行合适的命令（<code>git update-server-info</code>），来确保通过 HTTP 的获取和克隆操作正常工作。 这条命令会在你通过 SSH 向版本库推送之后被执行；然后别人就可以通过类似下面的命令来克隆：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://example.com/gitproject.git</span></span><br></pre></td></tr></table></figure>

<p>这里我们用了 Apache 里设置了常用的路径 <code>/var/www/htdocs</code>，不过你可以使用任何静态 Web 服务器 —— 只需要把裸版本库放到正确的目录下就可以。 Git 的数据是以基本的静态文件形式提供的（详情见 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gxMC1naXQtaW50ZXJuYWxz">Git 内部原理<i class="fa fa-external-link-alt"></i></span>）。</p>
<p>通常的，会在可以提供读／写的智能 HTTP 服务和简单的只读的哑 HTTP 服务之间选一个。 极少会将二者混合提供服务。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>我们将只关注智能 HTTP 协议的优点。</p>
<p>不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用 Git 变得非常简单。 相比 SSH 协议，可以使用用户名／密码授权是一个很大的优势，这样用户就不必须在使用 Git 之前先在本地生成 SSH 密钥对再把公钥上传到服务器。 对非资深的使用者，或者系统上缺少 SSH 相关程序的使用者，HTTP 协议的可用性是主要的优势。 与 SSH 协议类似，HTTP 协议也非常快和高效。</p>
<p>你也可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。</p>
<p>另一个好处是 HTTPS 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>在一些服务器上，架设 HTTPS 协议的服务端会比 SSH 协议的棘手一些。 除了这一点，用其他协议提供 Git 服务与智能 HTTP 协议相比就几乎没有优势了。</p>
<p>如果你在 HTTP 上使用需授权的推送，管理凭证会比使用 SSH 密钥认证麻烦一些。 然而，你可以选择使用凭证存储工具，比如 macOS 的 Keychain 或者 Windows 的凭证管理器。 参考 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2NyZWRlbnRpYWxfY2FjaGluZw==">凭证存储<i class="fa fa-external-link-alt"></i></span> 如何安全地保存 HTTP 密码。</p>
<h3 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h3><p>架设 Git 服务器时常用 SSH 协议作为传输协议。 因为大多数环境下服务器已经支持通过 SSH 访问 —— 即使没有也很容易架设。 SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。</p>
<p>通过 SSH 协议克隆版本库，你可以指定一个 <code>ssh://</code> 的 URL：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> ssh://[user@]server/project.git</span></span><br></pre></td></tr></table></figure>

<p>或者使用一个简短的 scp 式的写法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> [user@]server:project.git</span></span><br></pre></td></tr></table></figure>

<p>在上面两种情况中，如果你不指定可选的用户名，那么 Git 会使用当前登录的用的名字。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>用 SSH 协议的优势有很多。 首先，SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。 其次，通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。 最后，与 HTTPS 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</p>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>SSH 协议的缺点在于它不支持匿名访问 Git 仓库。 如果你使用 SSH，那么即便只是读取数据，使用者也 <strong>必须</strong> 通过 SSH 访问你的主机， 这使得 SSH 协议不利于开源的项目，毕竟人们可能只想把你的仓库克隆下来查看。 如果你只在公司网络使用，SSH 协议可能是你唯一要用到的协议。 如果你要同时提供匿名只读访问和 SSH 协议，那么你除了为自己推送架设 SSH 服务以外， 还得架设一个可以让其他人访问的服务。</p>
<h3 id="Git-协议"><a href="#Git-协议" class="headerlink" title="Git 协议"></a>Git 协议</h3><p>最后是 Git 协议。 这是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。 要让版本库支持 Git 协议，需要先创建一个 <code>git-daemon-export-ok</code> 文件 —— 它是 Git 协议守护进程为这个版本库提供服务的必要条件 —— 但是除此之外没有任何安全措施。 要么谁都可以克隆这个版本库，要么谁也不能。 这意味着，通常不能通过 Git 协议推送。 由于没有授权机制，一旦你开放推送操作，意味着网络上知道这个项目 URL 的人都可以向项目推送数据。 不用说，极少会有人这么做。</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>目前，Git 协议是 Git 使用的网络传输协议里最快的。 如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设 Git 守护进程来提供服务是不错的选择。 它使用与 SSH 相同的数据传输机制，但是省去了加密和授权的开销。</p>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>Git 协议缺点是缺乏授权机制。 把 Git 协议作为访问项目版本库的唯一手段是不可取的。 一般的做法里，会同时提供 SSH 或者 HTTPS 协议的访问服务，只让少数几个开发者有推送（写）权限，其他人通过 <code>git://</code> 访问只有读权限。 Git 协议也许也是最难架设的。 它要求有自己的守护进程，这就要配置 <code>xinetd</code>、<code>systemd</code> 或者其他的程序，这些工作并不简单。 它还要求防火墙开放 9418 端口，但是企业防火墙一般不会开放这个非标准端口。 而大型的企业防火墙通常会封锁这个端口。</p>
<h2 id="在服务器上搭建-Git"><a href="#在服务器上搭建-Git" class="headerlink" title="在服务器上搭建 Git"></a>在服务器上搭建 Git</h2><blockquote>
<p>这里我们将要演示在 Linux 服务器上进行一次基本且简化的安装所需的命令与步骤，当然在 macOS 或 Windows 服务器上同样可以运行这些服务。 事实上，在你的计算机基础架构中建立一个生产环境服务器，将不可避免的使用到不同的安全措施与操作系统工具。但是，希望你能从本节中获得一些必要的知识。</p>
</blockquote>
<p>在开始架设 Git 服务器前，需要把现有仓库导出为裸仓库——即一个不包含当前工作目录的仓库。 这通常是很简单的。 为了通过克隆你的仓库来创建一个新的裸仓库，你需要在克隆命令后加上 <code>--bare</code> 选项。 按照惯例，裸仓库的目录名以 .git 结尾，就像这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> --bare my_project my_project.git</span></span><br><span class="line">Cloning into bare repository &#x27;my_project.git&#x27;...</span><br><span class="line">done.</span><br></pre></td></tr></table></figure>

<p>现在，你的 <code>my_project.git</code> 目录中应该有 Git 目录的副本了。</p>
<p>整体上效果大致相当于</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -Rf my_project/.git my_project.git</span></span><br></pre></td></tr></table></figure>

<p>虽然在配置文件中有若干不同，但是对于你的目的来说，这两种方式都是一样的。 它只取出 Git 仓库自身，不要工作目录，然后特别为它单独创建一个目录。</p>
<h3 id="把裸仓库放到服务器上"><a href="#把裸仓库放到服务器上" class="headerlink" title="把裸仓库放到服务器上"></a>把裸仓库放到服务器上</h3><p>既然你有了裸仓库的副本，剩下要做的就是把裸仓库放到服务器上并设置你的协议。 假设一个域名为 <code>git.example.com</code> 的服务器已经架设好，并可以通过 SSH 连接， 你想把所有的 Git 仓库放在 <code>/srv/git</code> 目录下。 假设服务器上存在 <code>/srv/git/</code> 目录，你可以通过以下命令复制你的裸仓库来创建一个新仓库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">scp -r my_project.git user@git.example.com:/srv/git</span></span><br></pre></td></tr></table></figure>

<p>此时，其他可通过 SSH 读取此服务器上 <code>/srv/git</code> 目录的用户，可运行以下命令来克隆你的仓库。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> user@git.example.com:/srv/git/my_project.git</span></span><br></pre></td></tr></table></figure>

<p>如果一个用户，通过使用 SSH 连接到一个服务器，并且其对 <code>/srv/git/my_project.git</code> 目录拥有可写权限，那么他将自动拥有推送权限。</p>
<p>如果到该项目目录中运行 <code>git init</code> 命令，并加上 <code>--shared</code> 选项， 那么 Git 会自动修改该仓库目录的组权限为可写。 注意，运行此命令的工程中不会摧毁任何提交、引用等内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh user@git.example.com</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /srv/git/my_project.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init --bare --shared</span></span><br></pre></td></tr></table></figure>

<p>由此可见，根据现有的 Git 仓库创建一个裸仓库，然后把它放上你和协作者都有 SSH 访问权的服务器是多么容易。 现在你们已经准备好在同一项目上展开合作了。</p>
<p>值得注意的是，这的确是架设一个几个人拥有连接权的 Git 服务的全部—— 只要在服务器上加入可以用 SSH 登录的帐号，然后把裸仓库放在大家都有读写权限的地方。 你已经准备好了一切，无需更多。</p>
<p>下面的几节中，你会了解如何扩展到更复杂的设定。 这些内容包含如何避免为每一个用户建立一个账户，给仓库添加公共读取权限，架设网页界面等等。 然而，请记住这一点，如果只是和几个人在一个私有项目上合作的话，<em>仅仅</em> 是一个 SSH 服务器和裸仓库就足够了。</p>
<h3 id="小型安装"><a href="#小型安装" class="headerlink" title="小型安装"></a>小型安装</h3><p>如果设备较少或者你只想在小型开发团队里尝试 Git ，那么一切都很简单。 架设 Git 服务最复杂的地方在于用户管理。 如果需要仓库对特定的用户可读，而给另一部分用户读写权限，那么访问和许可安排就会比较困难。</p>
<h4 id="SSH-连接"><a href="#SSH-连接" class="headerlink" title="SSH 连接"></a>SSH 连接</h4><p>如果你有一台所有开发者都可以用 SSH 连接的服务器，架设你的第一个仓库就十分简单了， 因为你几乎什么都不用做（正如我们上一节所说的）。 如果你想在你的仓库上设置更复杂的访问控制权限，只要使用服务器操作系统的普通的文件系统权限就行了。</p>
<p>如果需要团队里的每个人都对仓库有写权限，又不能给每个人在服务器上建立账户，那么提供 SSH 连接就是唯一的选择了。 我们假设用来共享仓库的服务器已经安装了 SSH 服务，而且你通过它访问服务器。</p>
<p>有几个方法可以使你给团队每个成员提供访问权。 第一个就是给团队里的每个人创建账号，这种方法很直接但也很麻烦。 或许你不会想要为每个人运行一次 <code>adduser</code>（或者 <code>useradd</code>）并且设置临时密码。</p>
<p>第二个办法是在主机上建立一个 <em>git</em> 账户，让每个需要写权限的人发送一个 SSH 公钥， 然后将其加入 git 账户的 <code>~/.ssh/authorized_keys</code> 文件。 这样一来，所有人都将通过 <em>git</em> 账户访问主机。 这一点也不会影响提交的数据——访问主机用的身份不会影响提交对象的提交者信息。</p>
<p>另一个办法是让 SSH 服务器通过某个 LDAP 服务，或者其他已经设定好的集中授权机制，来进行授权。 只要每个用户可以获得主机的 shell 访问权限，任何 SSH 授权机制你都可视为是有效的。</p>
<h2 id="生成-SSH-公钥"><a href="#生成-SSH-公钥" class="headerlink" title="生成 SSH 公钥"></a>生成 SSH 公钥</h2><p>如前所述，许多 Git 服务器都使用 SSH 公钥进行认证。 为了向 Git 服务器提供 SSH 公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。 这个过程在所有操作系统上都是相似的。 首先，你需要确认自己是否已经拥有密钥。 默认情况下，用户的 SSH 密钥存储在其 <code>~/.ssh</code> 目录下。 进入该目录并列出其中内容，你便可以快速确认自己是否已拥有密钥：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/.ssh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">authorized_keys2  id_dsa       known_hosts</span><br><span class="line">config            id_dsa.pub</span><br></pre></td></tr></table></figure>

<p>我们需要寻找一对以 <code>id_dsa</code> 或 <code>id_rsa</code> 命名的文件，其中一个带有 <code>.pub</code> 扩展名。 <code>.pub</code> 文件是你的公钥，另一个则是与之对应的私钥。 如果找不到这样的文件（或者根本没有 <code>.ssh</code> 目录），你可以通过运行 <code>ssh-keygen</code> 程序来创建它们。 在 Linux&#x2F;macOS 系统中，<code>ssh-keygen</code> 随 SSH 软件包提供；在 Windows 上，该程序包含于 MSysGit 软件包中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -o</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/schacon/.ssh/id_rsa):</span><br><span class="line">Created directory &#x27;/home/schacon/.ssh&#x27;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /home/schacon/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/schacon/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local</span><br></pre></td></tr></table></figure>

<p>首先 <code>ssh-keygen</code> 会确认密钥的存储位置（默认是 <code>.ssh/id_rsa</code>），然后它会要求你输入两次密钥口令。 如果你不想在使用密钥时输入口令，将其留空即可。 然而，如果你使用了密码，那么请确保添加了 <code>-o</code> 选项，它会以比默认格式更能抗暴力破解的格式保存私钥。 你也可以用 <code>ssh-agent</code> 工具来避免每次都要输入密码。</p>
<p>现在，进行了上述操作的用户需要将各自的公钥发送给任意一个 Git 服务器管理员 （假设服务器正在使用基于公钥的 SSH 验证设置）。 他们所要做的就是复制各自的 <code>.pub</code> 文件内容，并将其通过邮件发送。 公钥看起来是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU</span><br><span class="line">GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3</span><br><span class="line">Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA</span><br><span class="line">t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En</span><br><span class="line">mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx</span><br><span class="line">NrRFi9wrf+M7Q== schacon@mylaptop.local</span><br></pre></td></tr></table></figure>

<p>关于在多种操作系统中生成 SSH 密钥的更深入教程，请参阅 GitHub 的 SSH 密钥指南 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vYXV0aGVudGljYXRpb24vY29ubmVjdGluZy10by1naXRodWItd2l0aC1zc2gvZ2VuZXJhdGluZy1hLW5ldy1zc2gta2V5LWFuZC1hZGRpbmctaXQtdG8tdGhlLXNzaC1hZ2VudCVFMyU4MCU4Mg==">https://docs.github.com/cn/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent。<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h2><p>将上面client的公钥加入系统用户 <code>git</code> 的 <code>.ssh</code> 目录下 <code>authorized_keys</code> 文件的末尾：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>

<p>现在我们来为开发者新建一个空仓库。可以借助带 <code>--bare</code> 选项的 <code>git init</code> 命令来做到这一点，该命令在初始化仓库时不会创建工作目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /srv/git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> project.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> project.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init --bare</span></span><br><span class="line">Initialized empty Git repository in /srv/git/project.git/</span><br></pre></td></tr></table></figure>

<p>接着，John、Josie 或者 Jessica 中的任意一人可以将他们项目的最初版本推送到这个仓库中， 他只需将此仓库设置为项目的远程仓库并向其推送分支。 请注意，每添加一个新项目，都需要有人登录服务器取得 shell，并创建一个裸仓库。 我们假定这个设置了 <code>git</code> 用户和 Git 仓库的服务器使用 <code>gitserver</code> 作为主机名。 同时，假设该服务器运行在内网，并且你已在 DNS 配置中将 <code>gitserver</code> 指向此服务器。 那么我们可以运行如下命令（假定 <code>myproject</code> 是已有项目且其中已包含文件）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">on John<span class="string">&#x27;s computer</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">cd myproject</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git init</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git add .</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git commit -m &#x27;</span>initial commit<span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git remote add origin git@gitserver:/srv/git/project.git</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git push origin master</span></span></span><br></pre></td></tr></table></figure>

<p>此时，其他开发者可以克隆此仓库，并推回各自的改动，步骤很简单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git@gitserver:/srv/git/project.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> project</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;fix for the README file&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br></pre></td></tr></table></figure>

<p>通过这种方法，你可以快速搭建一个具有读写权限、面向多个开发者的 Git 服务器。</p>
<p>需要注意的是，目前所有（获得授权的）开发者用户都能以系统用户 <code>git</code> 的身份登录服务器从而获得一个普通 shell。 如果你想对此加以限制，则需要修改 <code>/etc/passwd</code> 文件中（<code>git</code> 用户所对应）的 shell 值。</p>
<p>借助一个名为 <code>git-shell</code> 的受限 shell 工具，你可以方便地将用户 <code>git</code> 的活动限制在与 Git 相关的范围内。 该工具随 Git 软件包一同提供。如果将 <code>git-shell</code> 设置为用户 <code>git</code> 的登录 shell（login shell）， 那么该用户便不能获得此服务器的普通 shell 访问权限。 若要使用 <code>git-shell</code>，需要用它替换掉 bash 或 csh，使其成为该用户的登录 shell。 为进行上述操作，首先你必须确保 <code>git-shell</code> 的完整路径名已存在于 <code>/etc/shells</code> 文件中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/shells   <span class="comment"># see if git-shell is already in there. If not...</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> git-shell   <span class="comment"># make sure git-shell is installed on your system.</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo -e /etc/shells  <span class="comment"># and add the path to git-shell from last command</span></span></span><br></pre></td></tr></table></figure>

<p>现在你可以使用 <code>chsh &lt;username&gt; -s &lt;shell&gt;</code> 命令修改任一系统用户的 shell：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo chsh git -s $(<span class="built_in">which</span> git-shell)</span></span><br></pre></td></tr></table></figure>

<p>这样，用户 <code>git</code> 就只能利用 SSH 连接对 Git 仓库进行推送和拉取操作，而不能登录机器并取得普通 shell。 如果试图登录，你会发现尝试被拒绝，像这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh git@gitserver</span></span><br><span class="line">fatal: Interactive git shell is not enabled.</span><br><span class="line">hint: ~/git-shell-commands should exist and have read and execute access.</span><br><span class="line">Connection to gitserver closed.</span><br></pre></td></tr></table></figure>

<p>此时，用户仍可通过 SSH 端口转发来访问任何可达的 git 服务器。 如果你想要避免它，可编辑 <code>authorized_keys</code> 文件并在所有想要限制的公钥之前添加以下选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty</span><br></pre></td></tr></table></figure>

<p>其结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.ssh/authorized_keys</span></span><br><span class="line">no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa</span><br><span class="line">AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4LojG6rs6h</span><br><span class="line">PB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4kYjh6541N</span><br><span class="line">YsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9EzSdfd8AcC</span><br><span class="line">IicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myivO7TCUSBd</span><br><span class="line">LQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPqdAv8JggJ</span><br><span class="line">ICUvax2T9va5 gsg-keypair</span><br><span class="line"></span><br><span class="line">no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa</span><br><span class="line">AAAAB3NzaC1yc2EAAAADAQABAAABAQDEwENNMomTboYI+LJieaAY16qiXiH3wuvENhBG...</span><br></pre></td></tr></table></figure>

<p>现在，网络相关的 Git 命令依然能够正常工作，但是开发者用户已经无法得到一个普通 shell 了。 正如输出信息所提示的，你也可以在 <code>git</code> 用户的主目录下建立一个目录，来对 <code>git-shell</code> 命令进行一定程度的自定义。 比如，你可以限制掉某些本应被服务器接受的 Git 命令，或者对刚才的 SSH 拒绝登录信息进行自定义，这样，当有开发者用户以类似方式尝试登录时，便会看到你的信息。 要了解更多有关自定义 shell 的信息，请运行 <code>git help shell</code>。</p>
<h2 id="其他几种搭建方式"><a href="#其他几种搭建方式" class="headerlink" title="其他几种搭建方式"></a>其他几种搭建方式</h2><p>这种搭建方式现在基本上没人使用了，可以直接通过链接查阅：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyLyVFNiU5QyU4RCVFNSU4QSVBMSVFNSU5OSVBOCVFNCVCOCU4QSVFNyU5QSU4NC1HaXQtR2l0LSVFNSVBRSU4OCVFNiU4QSVBNCVFOCVCRiU5QiVFNyVBOCU4Qg==">Git 守护进程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyLyVFNiU5QyU4RCVFNSU4QSVBMSVFNSU5OSVBOCVFNCVCOCU4QSVFNyU5QSU4NC1HaXQtU21hcnQtSFRUUA==">Smart HTTP<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyLyVFNiU5QyU4RCVFNSU4QSVBMSVFNSU5OSVBOCVFNCVCOCU4QSVFNyU5QSU4NC1HaXQtR2l0V2Vi">GitWeb<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyLyVFNiU5QyU4RCVFNSU4QSVBMSVFNSU5OSVBOCVFNCVCOCU4QSVFNyU5QSU4NC1HaXQtR2l0TGFi">GitLab<i class="fa fa-external-link-alt"></i></span>（这种用的比较多）</li>
</ul>
<h1 id="分布式工作流程"><a href="#分布式工作流程" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h1><p>学习如何作为贡献者或整合者，在一个分布式协作的环境中使用 Git。 你会学习为一个项目成功地贡献代码，并接触一些最佳实践方式，让你和项目的维护者能轻松地完成这个过程。另外，你也会学到如何管理有很多开发者提交贡献的项目。</p>
<h2 id="分布式工作流程-1"><a href="#分布式工作流程-1" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h2><p>与传统的集中式版本控制系统（CVCS）相反，Git 的分布式特性使得开发者间的协作变得更加灵活多样。 在集中式系统中，每个开发者就像是连接在集线器上的节点，彼此的工作方式大体相像。 而在 Git 中，每个开发者同时扮演着节点和集线器的角色——也就是说， 每个开发者既可以将自己的代码贡献到其他的仓库中，同时也能维护自己的公开仓库， 让其他人可以在其基础上工作并贡献代码。 由此，Git 的分布式协作可以为你的项目和团队衍生出种种不同的工作流程， 接下来的章节会介绍几种利用了 Git 的这种灵活性的常见应用方式。 我们将讨论每种方式的优点以及可能的缺点；你可以选择使用其中的某一种，或者将它们的特性混合搭配使用。</p>
<h3 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h3><p>集中式系统中通常使用的是单点协作模型——集中式工作流。 一个中心集线器，或者说 <strong>仓库</strong>，可以接受代码，所有人将自己的工作与之同步。 若干个开发者则作为节点，即中心仓库的消费者与中心仓库同步。</p>
<p>​	<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/centralized_workflow.png" alt="集中式工作流。"></p>
<p>这意味着如果两个开发者从中心仓库克隆代码下来，同时作了一些修改，那么只有第一个开发者可以顺利地把数据推送回共享服务器。 第二个开发者在推送修改之前，必须先将第一个人的工作合并进来，这样才不会覆盖第一个人的修改。 这和 Subversion （或任何 CVCS）中的概念一样，而且这个模式也可以很好地运用到 Git 中。</p>
<p>如果在公司或者团队中，你已经习惯了使用这种集中式工作流程，完全可以继续采用这种简单的模式。 只需要搭建好一个中心仓库，并给开发团队中的每个人推送数据的权限，就可以开展工作了。Git 不会让用户覆盖彼此的修改。</p>
<p>例如 John 和 Jessica 同时开始工作。 John 完成了他的修改并推送到服务器。 接着 Jessica 尝试提交她自己的修改，却遭到服务器拒绝。 她被告知她的修改正通过非快进式（non-fast-forward）的方式推送，只有将数据抓取下来并且合并后方能推送。 这种模式的工作流程的使用非常广泛，因为大多数人对其很熟悉也很习惯。</p>
<p>当然这并不局限于小团队。 利用 Git 的分支模型，通过同时在多个分支上工作的方式，即使是上百人的开发团队也可以很好地在单个项目上协作。</p>
<h3 id="集成管理者工作流"><a href="#集成管理者工作流" class="headerlink" title="集成管理者工作流"></a>集成管理者工作流</h3><p>Git 允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。 这种情形下通常会有个代表“官方”项目的权威的仓库。 要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。 接着你可以请求官方仓库的维护者拉取更新合并到主项目。 维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。 这一流程的工作方式如下所示（见 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvd2ZkaWFnX2I=">集成管理者工作流。<i class="fa fa-external-link-alt"></i></span>）：</p>
<ol>
<li>项目维护者推送到主仓库。</li>
<li>贡献者克隆此仓库，做出修改。</li>
<li>贡献者将数据推送到自己的公开仓库。</li>
<li>贡献者给维护者发送邮件，请求拉取自己的更新。</li>
<li>维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。</li>
<li>维护者将合并后的修改推送到主仓库。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/02/integration-manager.png" alt="集成管理者工作流。"></p>
<p>这是 GitHub 和 GitLab 等集线器式（hub-based）工具最常用的工作流程。人们可以容易地将某个项目派生成为自己的公开仓库，向这个仓库推送自己的修改，并为每个人所见。 这么做最主要的优点之一是你可以持续地工作，而主仓库的维护者可以随时拉取你的修改。 贡献者不必等待维护者处理完提交的更新——每一方都可以按照自己的节奏工作。</p>
<h3 id="主管与副主管工作流"><a href="#主管与副主管工作流" class="headerlink" title="主管与副主管工作流"></a>主管与副主管工作流</h3><p>这其实是多仓库工作流程的变种。 一般拥有数百位协作开发者的超大型项目才会用到这样的工作方式，例如著名的 Linux 内核项目。 被称为 <strong>副主管（lieutenant）</strong> 的各个集成管理者分别负责集成项目中的特定部分。 所有这些副主管头上还有一位称为 <strong>主管（dictator）</strong> 的总集成管理者负责统筹。 主管维护的仓库作为参考仓库，为所有协作者提供他们需要拉取的项目代码。 整个流程看起来是这样的（见 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvd2ZkaWFnX2M=">主管与副主管工作流。<i class="fa fa-external-link-alt"></i></span> ）：</p>
<ol>
<li>普通开发者在自己的主题分支上工作，并根据 <code>master</code> 分支进行变基。 这里是主管推送的参考仓库的 <code>master</code> 分支。</li>
<li>副主管将普通开发者的主题分支合并到自己的 <code>master</code> 分支中。</li>
<li>主管将所有副主管的 <code>master</code> 分支并入自己的 <code>master</code> 分支中。</li>
<li>最后，主管将集成后的 <code>master</code> 分支推送到参考仓库中，以便所有其他开发者以此为基础进行变基。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/03/benevolent-dictator.png" alt="主管与副主管工作流。"></p>
<p>这种工作流程并不常用，只有当项目极为庞杂，或者需要多级别管理时，才会体现出优势。 利用这种方式，项目总负责人（即主管）可以把大量分散的集成工作委托给不同的小组负责人分别处理，然后在不同时刻将大块的代码子集统筹起来，用于之后的整合。</p>
<h2 id="向一个项目贡献"><a href="#向一个项目贡献" class="headerlink" title="向一个项目贡献"></a>向一个项目贡献</h2><p>为 Git 非常灵活，人们可以通过不同的方式来一起工作，所以描述应该如何贡献并不是非常准确——每一个项目都有一点儿不同。 影响因素包括活跃贡献者的数量、选择的工作流程、提交权限与可能包含的外部贡献方法。</p>
<h3 id="提交准则"><a href="#提交准则" class="headerlink" title="提交准则"></a>提交准则</h3><p>在我们开始查看特定的用例前，这里有一个关于提交信息的快速说明。 有一个好的创建提交的准则并且坚持使用会让与 Git 工作和与其他人协作更容易。 Git 项目提供了一个文档，其中列举了关于创建提交到提交补丁的若干好的提示——可以在 Git 源代码中的 <code>Documentation/SubmittingPatches</code> 文件中阅读它。</p>
<p>首先，你的提交不应该包含任何空白错误。 Git 提供了一个简单的方式来检查这点——在提交前，运行 <code>git diff --check</code>，它将会找到可能的空白错误并将它们为你列出来。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/git-diff-check.png" alt="`git diff --check` 的输出。"></p>
<p>如果在提交前运行那个命令，可以知道提交中是否包含可能会使其他开发者恼怒的空白问题。</p>
<p>接下来，尝试让每一个提交成为一个逻辑上的独立变更集。 如果可以，尝试让改动可以理解——不要在整个周末编码解决五个问题，然后在周一时将它们提交为一个巨大的提交。 即使在周末期间你无法提交，在周一时使用暂存区域将你的工作最少拆分为每个问题一个提交，并且为每一个提交附带一个有用的信息。 如果其中一些改动修改了同一个文件，尝试使用 <code>git add --patch</code> 来部分暂存文件（在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2ludGVyYWN0aXZlX3N0YWdpbmc=">交互式暂存<i class="fa fa-external-link-alt"></i></span> 中有详细介绍）。 不管你做一个或五个提交，只要所有的改动都曾添加过，项目分支末端的快照就是一样的，所以尽量让你的开发者同事们在审查你的改动的时候更容易些吧。</p>
<p>当你之后需要时这个方法也会使拉出或还原一个变更集更容易些。 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3Jld3JpdGluZ19oaXN0b3J5">重写历史<i class="fa fa-external-link-alt"></i></span> 描述了重写历史与交互式暂存文件的若干有用的 Git 技巧——在将工作发送给其他人前使用这些工具来帮助生成一个干净又易懂的历史。</p>
<p>最后一件要牢记的事是提交信息。 有一个创建优质提交信息的习惯会使 Git 的使用与协作容易的多。 一般情况下，信息应当以少于 50 个字符（25个汉字）的单行开始且简要地描述变更，接着是一个空白行，再接着是一个更详细的解释。 Git 项目要求一个更详细的解释，包括做改动的动机和它的实现与之前行为的对比——这是一个值得遵循的好规则。 使用指令式的语气来编写提交信息，比如使用“Fix bug”而非“Fixed bug”或“Fixes bug”。 这里是一份 <span class="exturl" data-url="aHR0cHM6Ly90YmFnZ2VyeS5jb20vMjAwOC8wNC8xOS9hLW5vdGUtYWJvdXQtZ2l0LWNvbW1pdC1tZXNzYWdlcy5odG1s">最初由 Tim Pope 写的模板<i class="fa fa-external-link-alt"></i></span>：</p>
<blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">首字母大写的摘要（不多于 50 个字符）</span><br><span class="line"></span><br><span class="line">如果必要的话，加入更详细的解释文字。在大概 72 个字符的时候换行。</span><br><span class="line">在某些情形下，第一行被当作一封电子邮件的标题，剩下的文本作为正文。</span><br><span class="line">分隔摘要与正文的空行是必须的（除非你完全省略正文），</span><br><span class="line">如果你将两者混在一起，那么类似变基等工具无法正常工作。</span><br><span class="line"></span><br><span class="line">使用指令式的语气来编写提交信息：使用“Fix bug”而非“Fixed bug”或“Fixes bug”。</span><br><span class="line">此约定与 git merge 和 git revert 命令生成提交说明相同。</span><br><span class="line"></span><br><span class="line">空行接着更进一步的段落。</span><br><span class="line"></span><br><span class="line">- 标号也是可以的。</span><br><span class="line"></span><br><span class="line">- 项目符号可以使用典型的连字符或星号，后跟一个空格，行之间用空行隔开，</span><br><span class="line">  但是可以依据不同的惯例有所不同。</span><br><span class="line"></span><br><span class="line">- 使用悬挂式缩进</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果你所有的提交信息都遵循此模版，那么对你和与你协作的其他开发者来说事情会变得非常容易。 Git 项目有一个良好格式化的提交信息——尝试在那儿运行 <code>git log --no-merges</code> 来看看漂亮的格式化的项目提交历史像什么样。</p>
<blockquote>
<p>按我们说的去做，不要照着我们做的去做。</p>
<p>为简单起见，本书中很多例子的提交说明并没有遵循这样良好的格式， 我们只是对 <code>git commit</code> 使用了 <code>-m</code> 选项。</p>
<p>简而言之，按我们说的去做，不要照着我们做的去做。</p>
</blockquote>
<h3 id="私有小型团队"><a href="#私有小型团队" class="headerlink" title="私有小型团队"></a>私有小型团队</h3><p>你可能会遇到的最简单的配置是有一两个其他开发者的私有项目。 “私有” 在这个上下文中，意味着闭源——不可以从外面的世界中访问到。 你和其他的开发者都有仓库的推送权限。</p>
<p>在这个环境下，可以采用一个类似使用 Subversion 或其他集中式的系统时会使用的工作流程。 依然可以得到像离线提交、非常容易地新建分支与合并分支等高级功能，但是工作流程可以是很简单的；主要的区别是合并发生在客户端这边而不是在提交时发生在服务器那边。 让我们看看当两个开发者在一个共享仓库中一起工作时会是什么样子。 第一个开发者，John，克隆了仓库，做了改动，然后本地提交。 （为了缩短这些例子长度，协议信息已被替换为 <code>…</code>。）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">John<span class="string">&#x27;s Machine</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git clone john@githost:simplegit.git</span></span></span><br><span class="line">Cloning into &#x27;simplegit&#x27;...</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">cd simplegit/</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">vim lib/simplegit.rb</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git commit -am &#x27;</span>remove invalid default value<span class="string">&#x27;</span></span></span><br><span class="line">[master 738ee87] remove invalid default value</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure>

<p>第二个开发者，Jessica，做了同样的事情——克隆仓库并提交了一个改动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Jessica<span class="string">&#x27;s Machine</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git clone jessica@githost:simplegit.git</span></span></span><br><span class="line">Cloning into &#x27;simplegit&#x27;...</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">cd simplegit/</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">vim TODO</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git commit -am &#x27;</span>add reset task<span class="string">&#x27;</span></span></span><br><span class="line">[master fbff5bc] add reset task</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>

<p>现在，Jessica 把她的工作推送到服务器上，一切正常：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Jessica<span class="string">&#x27;s Machine</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git push origin master</span></span></span><br><span class="line">...</span><br><span class="line">To jessica@githost:simplegit.git</span><br><span class="line">   1edee6b..fbff5bc  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>上方输出信息中最后一行显示的是推送操作执行完毕后返回的一条很有用的消息。 消息的基本格式是 <code>&lt;oldref&gt;..&lt;newref&gt; fromref → toref</code> ， <code>oldref</code> 的含义是推送前所指向的引用， <code>newref</code> 的含义是推送后所指向的引用， <code>fromref</code> 是将要被推送的本地引用的名字， <code>toref</code> 是将要被更新的远程引用的名字。 在后面的讨论中你还会看到类似的输出消息，所以对这条消息的含义有一些基础的了解将会帮助你理解仓库的诸多状态。 想要了解更多细节请访问文档 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1wdXNo">git-push<i class="fa fa-external-link-alt"></i></span> 。</p>
<p>John 稍候也做了些改动，将它们提交到了本地仓库中，然后试着将它们推送到同一个服务器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">John<span class="string">&#x27;s Machine</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git push origin master</span></span></span><br><span class="line">To john@githost:simplegit.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast forward)</span><br><span class="line">error: failed to push some refs to &#x27;john@githost:simplegit.git&#x27;</span><br></pre></td></tr></table></figure>

<p>这时 John 会推送失败，因为之前 Jessica 已经推送了她的更改。 如果之前习惯于用 Subversion 那么理解这点特别重要，因为你会注意到两个开发者并没有编辑同一个文件。 尽管 Subversion 会对编辑的不同文件在服务器上自动进行一次合并，但 Git 要求你先在本地合并提交。 换言之，John 必须先抓取 Jessica 的上游改动并将它们合并到自己的本地仓库中，才能被允许推送。</p>
<p>第一步，John 抓取 Jessica 的工作（这只会 <strong>抓取</strong> Jessica 的上游工作，并不会将它合并到 John 的工作中）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch origin</span></span><br><span class="line">...</span><br><span class="line">From john@githost:simplegit</span><br><span class="line"> + 049d078...fbff5bc master     -&gt; origin/master</span><br></pre></td></tr></table></figure>

<p>在这个时候，John 的本地仓库看起来像这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-1.png" alt="John 的分叉历史。"></p>
<p>现在 John 可以将抓取下来的 Jessica 的工作合并到他自己的本地工作中了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge origin/master</span></span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> TODO |    1 +</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>

<p>合并进行得很顺利——John 更新后的历史现在看起来像这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-2.png" alt="合并了 `origin/master` 之后 John 的仓库。"></p>
<p>此时，John 可能想要测试新的代码，以确保 Jessica 的工作没有影响他自己的工作， 当一切正常后，他就能将新合并的工作推送到服务器了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br><span class="line">...</span><br><span class="line">To john@githost:simplegit.git</span><br><span class="line">   fbff5bc..72bbc59  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>最终，John 的提交历史看起来像这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-3.png" alt="推送到 `origin` 服务器后 John 的历史。"></p>
<p>在此期间，Jessica 新建了一个名为 <code>issue54</code> 的主题分支，然后在该分支上提交了三次。 她还没有抓取 John 的改动，所以她的提交历史看起来像这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-4.png" alt="Jessica 的主题分支。"></p>
<p>忽然，Jessica 发现 John 向服务器推送了一些新的工作，她想要看一下， 于是就抓取了所有服务器上的新内容：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Jessica<span class="string">&#x27;s Machine</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git fetch origin</span></span></span><br><span class="line">...</span><br><span class="line">From jessica@githost:simplegit</span><br><span class="line">   fbff5bc..72bbc59  master     -&gt; origin/master</span><br></pre></td></tr></table></figure>

<p>那会同时拉取 John 推送的工作。 Jessica 的历史现在看起来像这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-5.png" alt="抓取 John 的改动后 Jessica 的历史。"></p>
<p>Jessica 认为她的主题分支已经准备好了，但她想知道需要将 John 工作的哪些合并到自己的工作中才能推送。 她运行 <code>git log</code> 找了出来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --no-merges issue54..origin/master</span></span><br><span class="line">commit 738ee872852dfaa9d6634e0dea7a324040193016</span><br><span class="line">Author: John Smith &lt;jsmith@example.com&gt;</span><br><span class="line">Date:   Fri May 29 16:01:27 2009 -0700</span><br><span class="line"></span><br><span class="line">   remove invalid default value</span><br></pre></td></tr></table></figure>

<p><code>issue54..origin/master</code> 语法是一个日志过滤器，要求 Git 只显示所有在后面分支 （在本例中是 <code>origin/master</code>）但不在前面分支（在本例中是 <code>issue54</code>）的提交的列表。 我们将会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2NvbW1pdF9yYW5nZXM=">提交区间<i class="fa fa-external-link-alt"></i></span> 中详细介绍这个语法。</p>
<p>目前，我们可以从输出中看到有一个 John 生成的但是 Jessica 还没有合并的提交。 如果她合并 <code>origin/master</code>，那个未合并的提交将会修改她的本地工作。</p>
<p>现在，Jessica 可以合并她的特性工作到她的 master 分支， 合并 John 的工作（<code>origin/master</code>）进入她的 <code>master</code> 分支，然后再次推送回服务器。</p>
<p>首先（在已经提交了所有 <code>issue54</code> 主题分支上的工作后），为了整合所有这些工作， 她切换回她的 master 分支。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is behind &#x27;origin/master&#x27; by 2 commits, and can be fast-forwarded.</span><br></pre></td></tr></table></figure>

<p>Jessica 既可以先合并 <code>origin/master</code> 也可以先合并 <code>issue54</code> ——它们都是上游，所以顺序并没有关系。 不论她选择的顺序是什么最终的结果快照是完全一样的；只是历史会稍微有些不同。 她选择先合并 <code>issue54</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge issue54</span></span><br><span class="line">Updating fbff5bc..4af4298</span><br><span class="line">Fast forward</span><br><span class="line"> README           |    1 +</span><br><span class="line"> lib/simplegit.rb |    6 +++++-</span><br><span class="line"> 2 files changed, 6 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure>

<p>没有发生问题，如你所见它是一次简单的快进合并。 现在 Jessica 在本地合并了之前抓取的 <code>origin/master</code> 分支上 John 的工作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge origin/master</span></span><br><span class="line">Auto-merging lib/simplegit.rb</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> lib/simplegit.rb |    2 +-</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure>

<p>每一个文件都干净地合并了，Jessica 的历史现在看起来像这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-6.png" alt="合并了 John 的改动后 Jessica 的历史。"></p>
<p>现在 <code>origin/master</code> 是可以从 Jessica 的 <code>master</code> 分支到达的， 所以她应该可以成功地推送（假设同一时间 John 并没有更多推送）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br><span class="line">...</span><br><span class="line">To jessica@githost:simplegit.git</span><br><span class="line">   72bbc59..8059c15  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>每一个开发者都提交了几次并成功地合并了其他人的工作。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-7.png" alt="推送所有的改动回服务器后 Jessica 的历史。"></p>
<p>这是一个最简单的工作流程。 你通常会在一个主题分支上工作一会儿，当它准备好整合时就合并到你的 <code>master</code> 分支。 当想要共享工作时，如果有改动的话就抓取它然后合并到你自己的 <code>master</code> 分支， 之后推送到服务器上的 <code>master</code> 分支。通常顺序像这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/small-team-flow.png" alt="一个简单的多人 Git 工作流程的通常事件顺序。"></p>
<h3 id="私有管理团队"><a href="#私有管理团队" class="headerlink" title="私有管理团队"></a>私有管理团队</h3><p>在接下来的场景中，你会看到大型私有团队中贡献者的角色。 你将学到如何在这种工作环境中工作，其中小组基于特性进行协作，而这些团队的贡献将会由其他人整合。</p>
<p>让我们假设 John 与 Jessica 在一个特性（<code>featureA</code>）上工作， 同时 Jessica 与第三个开发者 Josie 在第二个特性（<code>featureB</code>）上工作。 在本例中，公司使用了一种整合-管理者工作流程，独立小组的工作只能被特定的工程师整合， 主仓库的 <code>master</code> 分支只能被那些工程师更新。 在这种情况下，所有的工作都是在基于团队的分支上完成的并且稍后会被整合者拉到一起。</p>
<p>因为 Jessica 在两个特性上工作，并且平行地与两个不同的开发者协作，让我们跟随她的工作流程。 假设她已经克隆了仓库，首先决定在 <code>featureA</code> 上工作。 她为那个特性创建了一个新分支然后在那做了一些工作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Jessica<span class="string">&#x27;s Machine</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git checkout -b featureA</span></span></span><br><span class="line">Switched to a new branch &#x27;featureA&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">vim lib/simplegit.rb</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git commit -am &#x27;</span>add <span class="built_in">limit</span> to <span class="built_in">log</span> <span class="keyword">function</span><span class="string">&#x27;</span></span></span><br><span class="line">[featureA 3300904] add limit to log function</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure>

<p>在这个时候，她需要将工作共享给 John，所以她推送了 <code>featureA</code> 分支的提交到服务器上。 Jessica 没有 <code>master</code> 分支的推送权限——只有整合者有——所以为了与 John 协作必须推送另一个分支。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push -u origin featureA</span></span><br><span class="line">...</span><br><span class="line">To jessica@githost:simplegit.git</span><br><span class="line"> * [new branch]      featureA -&gt; featureA</span><br></pre></td></tr></table></figure>

<p>Jessica 向 John 发邮件告诉他已经推送了一些工作到 <code>featureA</code> 分支现在可以看一看。 当她等待 John 的反馈时，Jessica 决定与 Josie 开始在 <code>featureB</code> 上工作。 为了开始工作，她基于服务器的 <code>master</code> 分支开始了一个新分支。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Jessica<span class="string">&#x27;s Machine</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git fetch origin</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git checkout -b featureB origin/master</span></span></span><br><span class="line">Switched to a new branch &#x27;featureB&#x27;</span><br></pre></td></tr></table></figure>

<p>现在，Jessica 在 <code>featureB</code> 分支上创建了几次提交：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim lib/simplegit.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;made the ls-tree function recursive&#x27;</span></span></span><br><span class="line">[featureB e5b0fdc] made the ls-tree function recursive</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim lib/simplegit.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;add ls-files&#x27;</span></span></span><br><span class="line">[featureB 8512791] add ls-files</span><br><span class="line"> 1 files changed, 5 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>

<p>现在 Jessica 的仓库看起来像这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/managed-team-1.png" alt="Jessica 的初始提交历史。"></p>
<p>她准备好推送工作了，但是一封来自 Josie 的邮件告知一些初始的“featureB” 工作已经被推送到服务器的 <code>featureBee</code> 上了。 Jessica 在能够将她的工作推送到服务器前，需要将那些改动与她自己的合并。 她首先通过 <code>git fetch</code> 抓取了 Josie 的改动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch origin</span></span><br><span class="line">...</span><br><span class="line">From jessica@githost:simplegit</span><br><span class="line"> * [new branch]      featureBee -&gt; origin/featureBee</span><br></pre></td></tr></table></figure>

<p>假设 Jessica 还在她检出的 <code>featureB</code> 分支上，现在可以通过 <code>git merge</code> 将其合并到她做的工作中了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge origin/featureBee</span></span><br><span class="line">Auto-merging lib/simplegit.rb</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> lib/simplegit.rb |    4 ++++</span><br><span class="line"> 1 files changed, 4 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>

<p>此时，Jessica 想要将所有合并后的“featureB”推送回服务器，，但她并不想直接推送她自己的 <code>featureB</code> 分支。 由于 Josie 已经开启了一个上游的 <code>featureBee</code> 分支，因此 Jessica 想要推送到 <strong>这个</strong> 分支上，于是她这样做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push -u origin featureB:featureBee</span></span><br><span class="line">...</span><br><span class="line">To jessica@githost:simplegit.git</span><br><span class="line">   fba9af8..cd685d1  featureB -&gt; featureBee</span><br></pre></td></tr></table></figure>

<p>这称作一个 <em>引用规范</em>。 查看 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3JlZnNwZWM=">引用规范<i class="fa fa-external-link-alt"></i></span> 了解关于 Git 引用规范与通过它们可以做的不同的事情的详细讨论。 也要注意 <code>-u</code> 标记；这是 <code>--set-upstream</code> 的简写，该标记会为之后轻松地推送与拉取配置分支。</p>
<p>紧接着，John 发邮件给 Jessica 说他已经推送了一些改动到 <code>featureA</code> 分支并要求她去验证它们。 她运行一个 <code>git fetch</code> 来拉取下那些改动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch origin</span></span><br><span class="line">...</span><br><span class="line">From jessica@githost:simplegit</span><br><span class="line">   3300904..aad881d  featureA   -&gt; origin/featureA</span><br></pre></td></tr></table></figure>

<p>Jessica 通过比较新抓取的 <code>featureA</code> 分支和她同一分支的本地副本，看到了 John 的新工作日志。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> featureA..origin/featureA</span></span><br><span class="line">commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6</span><br><span class="line">Author: John Smith &lt;jsmith@example.com&gt;</span><br><span class="line">Date:   Fri May 29 19:57:33 2009 -0700</span><br><span class="line"></span><br><span class="line">    changed log output to 30 from 25</span><br></pre></td></tr></table></figure>

<p>如果 Jessica 觉得可以，她就能将 John 的新工作合并到她本地的 <code>featureA</code> 分支上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout featureA</span></span><br><span class="line">Switched to branch &#x27;featureA&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge origin/featureA</span></span><br><span class="line">Updating 3300904..aad881d</span><br><span class="line">Fast forward</span><br><span class="line"> lib/simplegit.rb |   10 +++++++++-</span><br><span class="line">1 files changed, 9 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure>

<p>最后，Jessica 可能想要对整个合并后的内容做一些小修改， 于是她将这些修改提交到了本地的 <code>featureA</code> 分支，接着将最终的结果推送回了服务器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;small tweak&#x27;</span></span></span><br><span class="line">[featureA 774b3ed] small tweak</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push</span></span><br><span class="line">...</span><br><span class="line">To jessica@githost:simplegit.git</span><br><span class="line">   3300904..774b3ed  featureA -&gt; featureA</span><br></pre></td></tr></table></figure>

<p>Jessica 的提交历史现在看起来像这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/managed-team-2-20230403173417621.png" alt="在一个主题分支提交后 Jessica 的历史。"></p>
<p>这时，Jessica、Josie 与 John 通知整合者服务器上的 <code>featureA</code> 与 <code>featureBee</code> 分支准备好整合到主线中了。 在整合者将这些分支合并到主线后，就能一次将这个新的合并提交抓取下来，历史看起来就会像这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/managed-team-3.png" alt="合并了 Jessica 的两个主题分支后她的历史。"></p>
<p>许多团队切换到 Git 就是看中了这种能让多个团队并行工作、并在之后合并不同工作的能力。 团队中更小一些的子小组可以通过远程分支协作而不必影响或妨碍整个团队的能力是 Git 的一个巨大优势。 在这儿看到的工作流程顺序类似这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/managed-team-flow.png" alt="这种管理团队工作流程的基本顺序。"></p>
<h3 id="派生的公开项目"><a href="#派生的公开项目" class="headerlink" title="派生的公开项目"></a>派生的公开项目</h3><p>向公开项目做贡献有一点儿不同。 因为没有权限直接更新项目的分支，你必须用其他办法将工作给维护者。 第一个例子描述在支持简单派生的 Git 托管上使用派生来做贡献。 许多托管站点支持这个功能（包括 GitHub、BitBucket、repo.or.cz 等等），许多项目维护者期望这种风格的贡献。 下一节会讨论偏好通过邮件接受贡献补丁的项目。</p>
<p>首先，你可能想要克隆主仓库，为计划贡献的补丁或补丁序列创建一个主题分支，然后在那儿做工作。 顺序看起来基本像这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> &lt;url&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> project</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b featureA</span></span><br><span class="line">  ... work ...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br><span class="line">  ... work ...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>你可以用 <code>rebase -i</code> 将工作压缩成一个单独的提交，或者重排提交中的工作使补丁更容易被维护者审核—— 查看 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3Jld3JpdGluZ19oaXN0b3J5">重写历史<i class="fa fa-external-link-alt"></i></span> 了解关于交互式变基的更多信息。</p>
</blockquote>
<p>当你的分支工作完成后准备将其贡献回维护者，去原始项目中然后点击“Fork”按钮，创建一份自己的可写的项目派生仓库。 然后需要在本地仓库中将该仓库添加为一个新的远程仓库，在本例中称作 <code>myfork</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add myfork &lt;url&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后需要推送工作到上面。 相对于合并到主分支再推送上去，推送你正在工作的主题分支到仓库上更简单。 原因是工作如果不被接受或者是被拣选的，就不必回退你的 master 分支 （拣选操作 <code>cherry-pick</code> 详见 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3JlYmFzZV9jaGVycnlfcGljaw==">变基与拣选工作流<i class="fa fa-external-link-alt"></i></span>）。 如果维护者合并、变基或拣选你的工作，不管怎样你最终会通过拉取他们的仓库找回来你的工作。</p>
<p>在任何情况下，你都可以使用下面的命令推送你的工作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push -u myfork featureA</span></span><br></pre></td></tr></table></figure>

<p>当工作已经被推送到你的派生仓库后，你需要通知原项目的维护者你有想要他们合并的工作。 这通常被称作一个 <strong>拉取请求（Pull Request）</strong>，你通常可以通过网站生成它—— GitHub 有它自己的 Pull Request 机制，我们将会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gwNi1naXRodWI=">GitHub<i class="fa fa-external-link-alt"></i></span> 介绍——也可以运行 <code>git request-pull</code> 命令然后将随后的输出通过电子邮件手动发送给项目维护者。</p>
<p><code>git request-pull</code> 命令接受一个要拉取主题分支的基础分支，以及它们要拉取的 Git 仓库的 URL， 产生一个请求拉取的所有修改的摘要。 例如，Jessica 想要发送给 John 一个拉取请求，她已经在刚刚推送的分支上做了两次提交。她可以运行这个：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git request-pull origin/master myfork</span></span><br><span class="line">The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:</span><br><span class="line">Jessica Smith (1):</span><br><span class="line">        added a new function</span><br><span class="line"></span><br><span class="line">are available in the git repository at:</span><br><span class="line"></span><br><span class="line">  git://githost/simplegit.git featureA</span><br><span class="line"></span><br><span class="line">Jessica Smith (2):</span><br><span class="line">      add limit to log function</span><br><span class="line">      change log output to 30 from 25</span><br><span class="line"></span><br><span class="line"> lib/simplegit.rb |   10 +++++++++-</span><br><span class="line"> 1 files changed, 9 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure>

<p>此输出可被发送给维护者——它告诉他们工作是从哪个分支开始的、提交的摘要、以及从哪里拉取这些工作。</p>
<p>在一个你不是维护者的项目上，通常有一个总是跟踪 <code>origin/master</code> 的 <code>master</code> 分支会很方便，在主题分支上做工作是因为如果它们被拒绝时你可以轻松地丢弃。 如果同一时间主仓库移动了然后你的提交不再能干净地应用，那么使工作主题独立于主题分支也会使你变基（rebase）工作时更容易。 例如，你想要提供第二个特性工作到项目，不要继续在刚刚推送的主题分支上工作——从主仓库的 <code>master</code> 分支重新开始：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b featureB origin/master</span></span><br><span class="line">  ... work ...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push myfork featureB</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git request-pull origin/master myfork</span></span><br><span class="line">  ... email generated request pull to maintainer ...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch origin</span></span><br></pre></td></tr></table></figure>

<p>现在，每一个特性都保存在一个贮藏库中——类似于补丁队列——可以重写、变基与修改而不会让特性互相干涉或互相依赖，像这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/public-small-1.png" alt="`featureB` 的初始提交历史。"></p>
<p>假设项目维护者已经拉取了一串其他补丁，然后尝试拉取你的第一个分支，但是没有干净地合并。 在这种情况下，可以尝试变基那个分支到 <code>origin/master</code> 的顶部，为维护者解决冲突，然后重新提交你的改动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout featureA</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase origin/master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push -f myfork featureA</span></span><br></pre></td></tr></table></figure>

<p>这样会重写你的历史，现在看起来像是 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/psp_b"><code>featureA</code> 工作之后的提交历史</a></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/public-small-2.png" alt="`featureA` 工作之后的提交历史。"></p>
<p>因为你将分支变基了，所以必须为推送命令指定 <code>-f</code> 选项，这样才能将服务器上有一个不是它的后代的提交的 <code>featureA</code> 分支替换掉。 一个替代的选项是推送这个新工作到服务器上的一个不同分支（可能称作 <code>featureAv2</code>）。</p>
<p>让我们看一个更有可能的情况：维护者看到了你的第二个分支上的工作并且很喜欢其中的概念，但是想要你修改一下实现的细节。 你也可以利用这次机会将工作基于项目现在的 <code>master</code> 分支。 你从现在的 <code>origin/master</code> 分支开始一个新分支，在那儿压缩 <code>featureB</code> 的改动，解决任何冲突，改变实现，然后推送它为一个新分支。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b featureBv2 origin/master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --squash featureB</span></span><br><span class="line">  ... change implementation ...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push myfork featureBv2</span></span><br></pre></td></tr></table></figure>

<p><code>--squash</code> 选项接受被合并的分支上的所有工作，并将其压缩至一个变更集， 使仓库变成一个真正的合并发生的状态，而不会真的生成一个合并提交。 这意味着你的未来的提交将会只有一个父提交，并允许你引入另一个分支的所有改动， 然后在记录一个新提交前做更多的改动。同样 <code>--no-commit</code> 选项在默认合并过程中可以用来延迟生成合并提交。</p>
<p>现在你可以给维护者发送一条消息，表示你已经做了要求的修改然后他们可以在你的 <code>featureBv2</code> 分支上找到那些改动。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/public-small-3.png" alt="`featureBv2` 工作之后的提交历史。"></p>
<h3 id="通过邮件的公开项目"><a href="#通过邮件的公开项目" class="headerlink" title="通过邮件的公开项目"></a>通过邮件的公开项目</h3><p>许多项目建立了接受补丁的流程——需要检查每一个项目的特定规则，因为它们之间有区别。 因为有几个历史悠久的、大型的项目会通过一个开发者的邮件列表接受补丁，现在我们将会通过一个例子来演示。</p>
<p>工作流程与之前的用例是类似的——你为工作的每一个补丁序列创建主题分支。 区别是如何提交它们到项目中。 生成每一个提交序列的电子邮件版本然后邮寄它们到开发者邮件列表，而不是派生项目然后推送到你自己的可写版本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b topicA</span></span><br><span class="line">  ... work ...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br><span class="line">  ... work ...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br></pre></td></tr></table></figure>

<p>现在有两个提交要发送到邮件列表。 使用 <code>git format-patch</code> 来生成可以邮寄到列表的 mbox 格式的文件——它将每一个提交转换为一封电子邮件，提交信息的第一行作为主题，剩余信息与提交引入的补丁作为正文。 它有一个好处是使用 <code>format-patch</code> 生成的一封电子邮件应用的提交正确地保留了所有的提交信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git format-patch -M origin/master</span></span><br><span class="line">0001-add-limit-to-log-function.patch</span><br><span class="line">0002-changed-log-output-to-30-from-25.patch</span><br></pre></td></tr></table></figure>

<p><code>format-patch</code> 命令打印出它创建的补丁文件名字。 <code>-M</code> 开关告诉 Git 查找重命名。 文件最后看起来像这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> 0001-add-limit-to-log-function.patch</span></span><br><span class="line">From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: Jessica Smith &lt;jessica@example.com&gt;</span><br><span class="line">Date: Sun, 6 Apr 2008 10:17:23 -0700</span><br><span class="line">Subject: [PATCH 1/2] add limit to log function</span><br><span class="line"></span><br><span class="line">Limit log functionality to the first 20</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"> lib/simplegit.rb |    2 +-</span><br><span class="line"> 1 files changed, 1 insertions(+), 1 deletions(-)</span><br><span class="line"></span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index 76f47bc..f9815f1 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -14,7 +14,7 @@ class SimpleGit</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   def log(treeish = &#x27;master&#x27;)</span><br><span class="line">-    command(&quot;git log #&#123;treeish&#125;&quot;)</span><br><span class="line">+    command(&quot;git log -n 20 #&#123;treeish&#125;&quot;)</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   def ls_tree(treeish = &#x27;master&#x27;)</span><br><span class="line">--</span><br><span class="line">2.1.0</span><br></pre></td></tr></table></figure>

<p>也可以编辑这些补丁文件为邮件列表添加更多不想要在提交信息中显示出来的信息。 如果在 <code>---</code> 行与补丁开头（<code>diff --git</code> 行）之间添加文本，那么开发者就可以阅读它，但是应用补丁时会忽略它。</p>
<p>为了将其邮寄到邮件列表，你既可以将文件粘贴进电子邮件客户端，也可以通过命令行程序发送它。 粘贴文本经常会发生格式化问题，特别是那些不会合适地保留换行符与其他空白的 “更聪明的” 客户端。 幸运的是，Git 提供了一个工具帮助你通过 IMAP 发送正确格式化的补丁，这可能对你更容易些。 我们将会演示如何通过 Gmail 发送一个补丁，它正好是我们所知最好的邮件代理；可以在之前提到的 Git 源代码中的 <code>Documentation/SubmittingPatches</code> 文件的最下面了解一系列邮件程序的详细指令。</p>
<p>首先，需要在 <code>~/.gitconfig</code> 文件中设置 imap 区块。 可以通过一系列的 <code>git config</code> 命令来分别设置每一个值，或者手动添加它们，不管怎样最后配置文件应该看起来像这样：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[imap]</span></span><br><span class="line">  <span class="attr">folder</span> = <span class="string">&quot;[Gmail]/Drafts&quot;</span></span><br><span class="line">  <span class="attr">host</span> = imaps://imap.gmail.com</span><br><span class="line">  <span class="attr">user</span> = user@gmail.com</span><br><span class="line">  <span class="attr">pass</span> = YX]<span class="number">8</span>g76G_2^sFbd</span><br><span class="line">  <span class="attr">port</span> = <span class="number">993</span></span><br><span class="line">  <span class="attr">sslverify</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>如果 IMAP 服务器不使用 SSL，最后两行可能没有必要，host 的值会是 <code>imap://</code> 而不是 <code>imaps://</code>。 当那些设置完成后，可以使用 <code>git imap-send</code> 将补丁序列放在特定 IMAP 服务器的 Drafts 文件夹中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> *.patch |git imap-send</span></span><br><span class="line">Resolving imap.gmail.com... ok</span><br><span class="line">Connecting to [74.125.142.109]:993... ok</span><br><span class="line">Logging in...</span><br><span class="line">sending 2 messages</span><br><span class="line"><span class="meta prompt_">100% </span><span class="language-bash">(2/2) <span class="keyword">done</span></span></span><br></pre></td></tr></table></figure>

<p>此时，你可以到 Drafts 文件夹中，修改收件人字段为想要发送补丁的邮件列表， 可能需要抄送给维护者或负责那个部分的人，然后发送。</p>
<p>你也可以通过一个 SMTP 服务器发送补丁。 同之前一样，你可以通过一系列的 <code>git config</code> 命令来分别设置选项， 或者你可以手动地将它们添加到你的 <code>~/.gitconfig</code> 文件的 sendmail 区块：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[sendemail]</span></span><br><span class="line">  <span class="attr">smtpencryption</span> = tls</span><br><span class="line">  <span class="attr">smtpserver</span> = smtp.gmail.com</span><br><span class="line">  <span class="attr">smtpuser</span> = user@gmail.com</span><br><span class="line">  <span class="attr">smtpserverport</span> = <span class="number">587</span></span><br></pre></td></tr></table></figure>

<p>当这完成后，你可以使用 <code>git send-email</code> 发送你的补丁：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git send-email *.patch</span></span><br><span class="line">0001-added-limit-to-log-function.patch</span><br><span class="line">0002-changed-log-output-to-30-from-25.patch</span><br><span class="line">Who should the emails appear to be from? [Jessica Smith &lt;jessica@example.com&gt;]</span><br><span class="line">Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;</span><br><span class="line">Who should the emails be sent to? jessica@example.com</span><br><span class="line">Message-ID to be used as In-Reply-To for the first email? y</span><br></pre></td></tr></table></figure>

<p>然后，对于正在发送的每一个补丁，Git 会吐出这样的一串日志信息：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from</span><br><span class="line">  \line &#x27;From: Jessica Smith &lt;jessica@example.com&gt;&#x27;</span><br><span class="line">OK. Log says:</span><br><span class="line">Sendmail: /usr/sbin/sendmail -i jessica@example.com</span><br><span class="line">From: Jessica Smith &lt;jessica@example.com&gt;</span><br><span class="line">To: jessica@example.com</span><br><span class="line">Subject: [PATCH 1/2] added limit to log function</span><br><span class="line">Date: Sat, 30 May 2009 13:29:15 -0700</span><br><span class="line">Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;</span><br><span class="line">X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty</span><br><span class="line">In-Reply-To: &lt;y&gt;</span><br><span class="line">References: &lt;y&gt;</span><br><span class="line"></span><br><span class="line">Result: OK</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个部分介绍了处理可能会遇到的几个迥然不同类型的 Git 项目的一些常见的工作流程， 介绍了帮助管理这个过程的一些新工具。 接下来，你会了解到如何在贡献的另一面工作：维护一个 Git 项目。 你将会学习如何成为一个仁慈的独裁者或整合管理者。</p>
<h2 id="维护项目"><a href="#维护项目" class="headerlink" title="维护项目"></a>维护项目</h2><p>除了如何有效地参与一个项目的贡献之外，你可能也需要了解如何维护项目。 这包含接受并应用别人使用 <code>format-patch</code> 生成并通过电子邮件发送过来的补丁， 或对项目添加的远程版本库分支中的更改进行整合。 但无论是管理版本库，还是帮忙验证、审核收到的补丁，都需要同其他贡献者约定某种长期可持续的工作方式。</p>
<h3 id="在主题分支中工作"><a href="#在主题分支中工作" class="headerlink" title="在主题分支中工作"></a>在主题分支中工作</h3><p>如果你想向项目中整合一些新东西，最好将这些尝试局限在 <strong>主题分支</strong>——一种通常用来尝试新东西的临时分支中。 这样便于单独调整补丁，如果遇到无法正常工作的情况，可以先不用管，等到有时间的时候再来处理。 如果你基于你所尝试进行工作的特性为分支创建一个简单的名字，比如 <code>ruby_client</code> 或者具有类似描述性的其他名字，这样即使你必须暂时抛弃它，以后回来时也不会忘记。 项目的维护者一般还会为这些分支附带命名空间，比如 <code>sc/ruby_client</code>（其中 <code>sc</code> 是贡献该项工作的人名称的简写）。 你应该记得，可以使用如下方式基于 <code>master</code> 分支建立主题分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch sc/ruby_client master</span></span><br></pre></td></tr></table></figure>

<p>或者如果你同时想立刻切换到新分支上的话，可以使用 <code>checkout -b</code> 选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b sc/ruby_client master</span></span><br></pre></td></tr></table></figure>

<p>现在你已经准备好将你收到的贡献加入到这个主题分支，并考虑是否将其合并到长期分支中去了。</p>
<h3 id="应用来自邮件的补丁"><a href="#应用来自邮件的补丁" class="headerlink" title="应用来自邮件的补丁"></a>应用来自邮件的补丁</h3><p>如果你通过电子邮件收到了一个需要整合进入项目的补丁，你需要将其应用到主题分支中进行评估。 有两种应用该种补丁的方法：使用 <code>git apply</code>，或者使用 <code>git am</code>。</p>
<h4 id="使用-apply-命令应用补丁"><a href="#使用-apply-命令应用补丁" class="headerlink" title="使用 apply 命令应用补丁"></a>使用 <code>apply</code> 命令应用补丁</h4><p>如果你收到了一个使用 <code>git diff</code> 或 Unix <code>diff</code> 命令的变体（不推荐使用这种方式，具体见下一节） 创建的补丁，可以使用 <code>git apply</code> 命令来应用。 假设你将补丁保存在了 <code>/tmp/patch-ruby-client.patch</code> 中，可以这样应用补丁：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git apply /tmp/patch-ruby-client.patch</span></span><br></pre></td></tr></table></figure>

<p>这会修改工作目录中的文件。 它与运行 <code>patch -p1</code> 命令来应用补丁几乎是等效的，但是这种方式更加严格，相对于 patch 来说，它能够接受的模糊匹配更少。 它也能够处理 <code>git diff</code> 格式文件所描述的文件添加、删除和重命名操作，而 <code>patch</code> 则不会。 最后，<code>git apply</code> 命令采用了一种“全部应用，否则就全部撤销（apply all or abort all）”的模型， 即补丁只有全部内容都被应用和完全不被应用两个状态，而 <code>patch</code> 可能会导致补丁文件被部分应用， 最后使你的工作目录保持在一个比较奇怪的状态。 总体来看，<code>git apply</code> 命令要比 <code>patch</code> 谨慎得多。 并且，它不会为你创建提交——在运行之后，你需要手动暂存并提交补丁所引入的更改。</p>
<p>在实际应用补丁前，你还可以使用 git apply 来检查补丁是否可以顺利应用——即对补丁运行 <code>git apply --check</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git apply --check 0001-seeing-if-this-helps-the-gem.patch</span></span><br><span class="line">error: patch failed: ticgit.gemspec:1</span><br><span class="line">error: ticgit.gemspec: patch does not apply</span><br></pre></td></tr></table></figure>

<p>如果没有产生输出，则该补丁可以顺利应用。 如果检查失败了，该命令还会以一个非零的状态退出，所以需要时你也可以在脚本中使用它。</p>
<h4 id="使用-am-命令应用补丁"><a href="#使用-am-命令应用补丁" class="headerlink" title="使用 am 命令应用补丁"></a>使用 <code>am</code> 命令应用补丁</h4><p>如果补丁的贡献者也是一个 Git 用户，并且其能熟练使用 <code>format-patch</code> 命令来生成补丁，这样的话你的工作会变得更加轻松，因为这种补丁中包含了作者信息和提交信息供你参考。 如果可能的话，请鼓励贡献者使用 <code>format-patch</code> 而不是 <code>diff</code> 来为你生成补丁。 而只有对老式的补丁，你才必须使用 <code>git apply</code> 命令。</p>
<p>要应用一个由 <code>format-patch</code> 命令生成的补丁，你应该使用 <code>git am</code> 命令 （该命令的名字 <code>am</code> 表示它“应用（Apply）一系列来自邮箱（Mailbox）的补丁”）。 从技术的角度看，<code>git am</code> 是为了读取 mbox 文件而构建的， mbox 是一种用来在单个文本文件中存储一个或多个电子邮件消息的简单纯文本格式。 其大致格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: Jessica Smith &lt;jessica@example.com&gt;</span><br><span class="line">Date: Sun, 6 Apr 2008 10:17:23 -0700</span><br><span class="line">Subject: [PATCH 1/2] add limit to log function</span><br><span class="line"></span><br><span class="line">Limit log functionality to the first 20</span><br></pre></td></tr></table></figure>

<p>这其实就是你前面看到的 <code>git format-patch</code> 命令输出的开始几行， 而同时它也是有效的 mbox 电子邮件格式。 如果有人使用 <code>git send-email</code> 命令将补丁以电子邮件的形式发送给你， 你便可以将它下载为 mbox 格式的文件，之后将 git am 命令指向该文件，它会应用其中包含的所有补丁。 如果你所使用的邮件客户端能够同时将多封邮件保存为 mbox 格式的文件， 你甚至能够将一系列补丁打包为单个 mbox 文件，并利用 <code>git am</code> 命令将它们一次性全部应用。</p>
<p>然而，如果贡献者将 <code>git format-patch</code> 生成的补丁文件上传到工单系统或类似的任务处理系统， 你可以先将其保存到本地，之后通过 <code>git am</code> 来应用补丁：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git am 0001-limit-log-function.patch</span></span><br><span class="line">Applying: add limit to log function</span><br></pre></td></tr></table></figure>

<p>你会看到补丁被顺利地应用，并且为你自动创建了一个新的提交。 其中的作者信息来自于电子邮件头部的 <code>From</code> 和 <code>Date</code> 字段，提交消息则取自 <code>Subject</code> 和邮件正文中补丁之前的内容。 比如，应用上面那个 mbox 示例后生成的提交是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=fuller -1</span></span><br><span class="line">commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0</span><br><span class="line">Author:     Jessica Smith &lt;jessica@example.com&gt;</span><br><span class="line">AuthorDate: Sun Apr 6 10:17:23 2008 -0700</span><br><span class="line">Commit:     Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">CommitDate: Thu Apr 9 09:19:06 2009 -0700</span><br><span class="line"></span><br><span class="line">   add limit to log function</span><br><span class="line"></span><br><span class="line">   Limit log functionality to the first 20</span><br></pre></td></tr></table></figure>

<p>其中 <code>Commit</code> 信息表示的是应用补丁的人和应用补丁的时间。 <code>Author</code> 信息则表示补丁的原作者和原本的创建时间。</p>
<p>但是，有时候无法顺利地应用补丁。 这也许是因为你的主分支和创建补丁的分支相差较多，也有可能是因为这个补丁依赖于其他你尚未应用的补丁。 这种情况下，<code>git am</code> 进程将会报错并且询问你要做什么：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git am 0001-seeing-if-this-helps-the-gem.patch</span></span><br><span class="line">Applying: seeing if this helps the gem</span><br><span class="line">error: patch failed: ticgit.gemspec:1</span><br><span class="line">error: ticgit.gemspec: patch does not apply</span><br><span class="line">Patch failed at 0001.</span><br><span class="line">When you have resolved this problem run &quot;git am --resolved&quot;.</span><br><span class="line">If you would prefer to skip this patch, instead run &quot;git am --skip&quot;.</span><br><span class="line">To restore the original branch and stop patching run &quot;git am --abort&quot;.</span><br></pre></td></tr></table></figure>

<p>该命令将会在所有出现问题的文件内加入冲突标记，就和发生冲突的合并或变基操作一样。 而你解决问题的手段很大程度上也是一样的——即手动编辑那些文件来解决冲突，暂存新的文件， 之后运行 <code>git am --resolved</code> 继续应用下一个补丁：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(fix the file)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add ticgit.gemspec</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git am --resolved</span></span><br><span class="line">Applying: seeing if this helps the gem</span><br></pre></td></tr></table></figure>

<p>如果你希望 Git 能够尝试以更加智能的方式解决冲突，你可以对其传递 <code>-3</code> 选项来使 Git 尝试进行三方合并。 该选项默认并没有打开，因为如果用于创建补丁的提交并不在你的版本库内的话，这样做是没有用处的。 而如果你确实有那个提交的话——比如补丁是基于某个公共提交的——那么通常 <code>-3</code> 选项对于应用有冲突的补丁是更加明智的选择。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git am -3 0001-seeing-if-this-helps-the-gem.patch</span></span><br><span class="line">Applying: seeing if this helps the gem</span><br><span class="line">error: patch failed: ticgit.gemspec:1</span><br><span class="line">error: ticgit.gemspec: patch does not apply</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">No changes -- Patch already applied.</span><br></pre></td></tr></table></figure>

<p>比如上面这种情况，如果没有 <code>-3</code> 选项的话，这看起来就像是存在一个冲突。 由于使用了 <code>-3</code> 选项，该补丁就被干净地应用了</p>
<p>如果你正在利用一个 mbox 文件应用多个补丁，也可以在交互模式下运行 <code>am</code> 命令， 这样在每个补丁之前，它会停住询问你是否要应用该补丁：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git am -3 -i mbox</span></span><br><span class="line">Commit Body is:</span><br><span class="line">--------------------------</span><br><span class="line">seeing if this helps the gem</span><br><span class="line">--------------------------</span><br><span class="line">Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all</span><br></pre></td></tr></table></figure>

<p>这在你保存的补丁较多时很好用，因为你可以在应用之前查看忘掉内容的补丁，并且跳过已经应用过的补丁。</p>
<p>当与你的特性相关的所有补丁都被应用并提交到分支中之后，你就可以选择是否以及如何将其整合到更长期的分支中去了。</p>
<h3 id="检出远程分支"><a href="#检出远程分支" class="headerlink" title="检出远程分支"></a>检出远程分支</h3><p>如果你的贡献者建立了自己的版本库，并且向其中推送了若干修改， 之后将版本库的 URL 和包含更改的远程分支发送给你，那么你可以将其添加为一个远程分支，并且在本地进行合并。</p>
<p>比如 Jessica 向你发送了一封电子邮件，内容是在她的版本库中的 <code>ruby-client</code> 分支中有一个很不错的新功能， 为了测试该功能，你可以将其添加为一个远程分支，并在本地检出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add jessica git://github.com/jessica/myproject.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch jessica</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b rubyclient jessica/ruby-client</span></span><br></pre></td></tr></table></figure>

<p>如果她再次发邮件说另一个分支中包含另一个优秀功能，因为之前已经设置好远程分支了， 你就可以直接进行 <code>fetch</code> 和 <code>checkout</code> 操作。</p>
<p>这对于与他人长期合作工作来说很有用。 而对于提交补丁频率较小的贡献者，相对于每个人维护自己的服务器，不断增删远程分支的做法，使用电子邮件来接收可能会比较省时。 况且你也不会想要加入数百个只提供一两个补丁的远程分支。 然而，脚本和托管服务在一定程度上可以简化这些工作——这很大程度上依赖于你和你的贡献者开发的方式。</p>
<p>这种方式的另一种优点是你可以同时得到提交历史。 虽然代码合并中可能会出现问题，但是你能获知他人的工作是基于你的历史中的具体哪一个位置；所以 Git 会默认进行三方合并，不需要提供 <code>-3</code> 选项，你也不需要担心补丁是基于某个你无法访问的提交生成的。</p>
<p>对于非持续性的合作，如果你依然想要以这种方式拉取数据的话，你可以对远程版本库的 URL 调用 <code>git pull</code> 命令。 这会执行一个一次性的抓取，而不会将该 URL 存为远程引用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull https://github.com/onetimeguy/project</span></span><br><span class="line">From https://github.com/onetimeguy/project</span><br><span class="line"> * branch            HEAD       -&gt; FETCH_HEAD</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br></pre></td></tr></table></figure>

<h3 id="确定引入了哪些东西"><a href="#确定引入了哪些东西" class="headerlink" title="确定引入了哪些东西"></a>确定引入了哪些东西</h3><p>你已经有了一个包含其他人贡献的主题分支。 现在你可以决定如何处理它们了。 本节回顾了若干命令，以便于你检查若将其合并入主分支所引入的更改。</p>
<p>一般来说，你应该对该分支中所有 <code>master</code> 分支尚未包含的提交进行检查。 通过在分支名称前加入 <code>--not</code> 选项，你可以排除 <code>master</code> 分支中的提交。 这和我们之前使用的 <code>master..contrib</code> 格式是一样的。 假设贡献者向你发送了两个补丁，为此你创建了一个名叫 <code>contrib</code> 的分支并在其上应用补丁，你可以运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> contrib --not master</span></span><br><span class="line">commit 5b6235bd297351589efc4d73316f0a68d484f118</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri Oct 24 09:53:59 2008 -0700</span><br><span class="line"></span><br><span class="line">    seeing if this helps the gem</span><br><span class="line"></span><br><span class="line">commit 7482e0d16d04bea79d0dba8988cc78df655f16a0</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Oct 22 19:38:36 2008 -0700</span><br><span class="line"></span><br><span class="line">    updated the gemspec to hopefully work better</span><br></pre></td></tr></table></figure>

<p>如果要查看每次提交所引入的具体修改，你应该记得可以给 <code>git log</code> 命令传递 <code>-p</code> 选项，这样它会在每次提交后面附加对应的差异（diff）。</p>
<p>而要查看将该主题分支与另一个分支合并的完整 diff，你可能需要使用一个有些奇怪的技巧来得到正确的结果。 你可能会想到这种方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff master</span></span><br></pre></td></tr></table></figure>

<p>这个命令会输出一个 diff，但它可能并不是我们想要的。 如果在你创建主题分支之后，<code>master</code> 分支向前移动了，你获得的结果就会显得有些不对。 这是因为 Git 会直接将该主题分支与 <code>master</code> 分支的最新提交快照进行比较。 比如说你在 <code>master</code> 分支中向某个文件添加了一行内容，那么直接比对最新快照的结果看上去就像是你在主题分支中将这一行删除了。</p>
<p>如果 <code>master</code> 分支是你的主题分支的直接祖先，其实是没有任何问题的； 但是一旦两个分支的历史产生了分叉，上述比对产生的 diff 看上去就像是将主题分支中所有的新东西加入， 并且将 <code>master</code> 分支所独有的东西删除。</p>
<p>而你真正想要检查的东西，实际上仅仅是主题分支所添加的更改——也就是该分支与 <code>master</code> 分支合并所要引入的工作。 要达到此目的，你需要让 Git 对主题分支上最新的提交与该分支与 <code>master</code> 分支的首个公共祖先进行比较。</p>
<p>从技术的角度讲，你可以以手工的方式找出公共祖先，并对其显式运行 diff 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge-base contrib master</span></span><br><span class="line">36c7dba2c95e6bbb78dfa822519ecfec6e1ca649</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff 36c7db</span></span><br></pre></td></tr></table></figure>

<p>或者，更简洁的形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff $(git merge-base contrib master)</span></span><br></pre></td></tr></table></figure>

<p>然而，这种做法比较麻烦，所以 Git 提供了一种比较便捷的方式：三点语法。 对于 <code>git diff</code> 命令来说，你可以通过把 <code>…</code> 置于另一个分支名后来对该分支的最新提交与两个分支的共同祖先进行比较：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff master...contrib</span></span><br></pre></td></tr></table></figure>

<p>该命令仅会显示自当前主题分支与 <code>master</code> 分支的共同祖先起，该分支中的工作。 这个语法很有用，应该牢记。</p>
<h3 id="将贡献的工作整合进来"><a href="#将贡献的工作整合进来" class="headerlink" title="将贡献的工作整合进来"></a>将贡献的工作整合进来</h3><p>当主题分支中所有的工作都已经准备好整合进入更靠近主线的分支时，接下来的问题就是如何进行整合了。 此外，还有一个问题是，你想使用怎样的总体工作流来维护你的项目？ 你的选择有很多，我们会介绍其中的一部分。</p>
<h4 id="合并工作流"><a href="#合并工作流" class="headerlink" title="合并工作流"></a>合并工作流</h4><p>一种基本的工作流就是将所有的工作直接合并到 <code>master</code> 分支。 在这种情况下，<code>master</code> 分支包含的代码是基本稳定的。 当你完成某个主题分支的工作，或审核通过了其他人所贡献的工作时，你会将其合并进入 <code>master</code> 分支，之后将主题分支删除，如此反复。</p>
<p>举例来说，如果我们的版本库包含类似 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvbWVyd2ZfYQ==">包含若干主题分支的提交历史。<i class="fa fa-external-link-alt"></i></span> 的两个名称分别为 <code>ruby_client</code> 和 <code>php_client</code> 的分支， 并且我们合并完 <code>ruby_client</code> 分支后，再合并 <code>php_client</code> 分支，那么提交历史最后会变成 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvbWVyd2ZfYg==">合并主题分支之后。<i class="fa fa-external-link-alt"></i></span> 的样子。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/merging-workflows-1.png" alt="包含若干主题分支的提交历史。"></p>
<p>Figure 73. 包含若干主题分支的提交历史。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/merging-workflows-2.png" alt="合并主题分支之后。"></p>
<p>这也许是最简单的工作流了，但是当项目更大，或更稳定，你对自己所引入的工作更加在意时，它可能会带来问题。</p>
<p>如果你的项目非常重要，你可能会使用两阶段合并循环。 在这种情况下，你会维护两个长期分支，分别是 <code>master</code> 和 <code>develop</code>，<code>master</code> 分支只会在一个非常稳定的版本发布时才会更新，而所有的新代码会首先整合进入 <code>develop</code> 分支。 你定期将这两个分支推送到公共版本库中。 每次需要合并新的主题分支时（<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvbWVyd2ZfYw==">合并主题分支前。<i class="fa fa-external-link-alt"></i></span>），你都应该合并进入 <code>develop</code> 分支（<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvbWVyd2ZfZA==">合并主题分支后。<i class="fa fa-external-link-alt"></i></span>）；当打标签发布的时候，你会将 <code>master</code> 分支快进到已经稳定的 <code>develop</code> 分支（<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvbWVyd2ZfZQ==">一次发布之后。<i class="fa fa-external-link-alt"></i></span>）。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/merging-workflows-3.png" alt="合并主题分支前。"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/merging-workflows-4.png" alt="合并主题分支后。"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/merging-workflows-5.png" alt="一次发布之后。"></p>
<p>这样当人们克隆你项目的版本库后，既可以检出 <code>master</code> 分支以构建最新的稳定版本并保持更新， 也可以检出包含更多前沿内容 <code>develop</code> 分支。 你也可以扩展这个概念，维护一个将所有工作合并到一起的整合分支。 当该分支的代码稳定并通过测试之后，将其合并进入 <code>develop</code> 分支； 经过一段时间，确认其稳定之后，将其以快进的形式并入 <code>master</code> 分支。</p>
<h4 id="大项目合并工作流"><a href="#大项目合并工作流" class="headerlink" title="大项目合并工作流"></a>大项目合并工作流</h4><p>Git 项目包含四个长期分支：<code>master</code>、<code>next</code>，用于新工作的 <code>pu</code>（proposed updates）和用于维护性向后移植工作（maintenance backports）的 <code>maint</code> 分支。 贡献者的新工作会以类似之前所介绍的方式收入主题分支中（见 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvbWVyd2ZfZg==">管理复杂的一系列接收贡献的平行主题分支。<i class="fa fa-external-link-alt"></i></span>）。 之后对主题分支进行测试评估，检查其是否已经能够合并，或者仍需要更多工作。 安全的主题分支会被合并入 <code>next</code> 分支，之后该分支会被推送使得所有人都可以尝试整合到一起的特性。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/large-merges-1.png" alt="管理复杂的一系列接收贡献的平行主题分支。"></p>
<p>如果主题分支需要更多工作，它则会被并入 <code>pu</code> 分支。 当它们完全稳定之后，会被再次并入 <code>master</code> 分支。 这意味着 <code>master</code> 分支始终在进行快进，<code>next</code> 分支偶尔会被变基，而 <code>pu</code> 分支的变基比较频繁：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/large-merges-2.png" alt="将贡献的主题分支并入长期整合分支。"></p>
<p>当主题分支最终被并入 <code>master</code> 分支后，便会被从版本库中删除掉。 Git 项目还有一个从上一次发布中派生出来的 <code>maint</code> 分支来提供向后移植过来的补丁以供发布维护更新。 因此，当你克隆 Git 的版本库之后，就会有四个可分别评估该项目开发的不同阶段的可检出的分支， 检出哪个分支，取决于你需要多新的版本，或者你想要如何进行贡献； 对于维护者来说，这套结构化的工作流能帮助它们审查新的贡献。 Git 项目的工作流是特别的。要清晰地理解它，请阅读 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdC9naXQvYmxvYi9tYXN0ZXIvRG9jdW1lbnRhdGlvbi9ob3d0by9tYWludGFpbi1naXQudHh0">Git 维护者手册<i class="fa fa-external-link-alt"></i></span>。</p>
<h4 id="变基与拣选工作流"><a href="#变基与拣选工作流" class="headerlink" title="变基与拣选工作流"></a>变基与拣选工作流</h4><p>为了保持线性的提交历史，有些维护者更喜欢在 <code>master</code> 分支上对贡献过来的工作进行变基和拣选，而不是直接将其合并。 当你完成了某个主题分支中的工作，并且决定要将其整合的时候，你可以在该分支中运行变基命令， 在当前 <code>master</code> 分支（或者是 <code>develop</code> 等分支）的基础上重新构造修改。 如果结果理想的话，你可以快进 <code>master</code> 分支，最后得到一个线性的项目提交历史。</p>
<p>另一种将引入的工作转移到其他分支的方法是拣选。 Git 中的拣选类似于对特定的某次提交的变基。 它会提取该提交的补丁，之后尝试将其重新应用到当前分支上。 这种方式在你只想引入主题分支中的某个提交，或者主题分支中只有一个提交，而你不想运行变基时很有用。 举个例子，假设你的项目提交历史类似：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/rebasing-1.png" alt="拣选之前的示例历史。"></p>
<p>如果你希望将提交 <code>e43a6</code> 拉取到 <code>master</code> 分支，你可以运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cherry-pick e43a6</span></span><br><span class="line">Finished one cherry-pick.</span><br><span class="line">[master]: created a0a41a9: &quot;More friendly message when locking the index fails.&quot;</span><br><span class="line"> 3 files changed, 17 insertions(+), 3 deletions(-)</span><br></pre></td></tr></table></figure>

<p>这样会拉取和 <code>e43a6</code> 相同的更改，但是因为应用的日期不同，你会得到一个新的提交 SHA-1 值。 现在你的历史会变成这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/rebasing-2.png" alt="拣选主题分支中的一个提交后的历史。"></p>
<p>现在你可以删除这个主题分支，并丢弃不想拉入的提交。</p>
<h4 id="Rerere"><a href="#Rerere" class="headerlink" title="Rerere"></a>Rerere</h4><p>如果你在进行大量的合并或变基，或维护一个长期的主题分支，Git 提供的一个叫做“rerere”的功能会有一些帮助。</p>
<p>Rerere 是“重用已记录的冲突解决方案（reuse recorded resolution）”的意思——它是一种简化冲突解决的方法。 当启用 rerere 时，Git 将会维护一些成功合并之前和之后的镜像，当 Git 发现之前已经修复过类似的冲突时， 便会使用之前的修复方案，而不需要你的干预。</p>
<p>这个功能包含两个部分：一个配置选项和一个命令。 其中的配置选项是 <code>rerere.enabled</code>，把它放在全局配置中就可以了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global rerere.enabled <span class="literal">true</span></span></span><br></pre></td></tr></table></figure>

<p>现在每当你进行一次需要解决冲突的合并时，解决方案都会被记录在缓存中，以备之后使用。</p>
<p>如果你需要和 rerere 的缓存交互，你可以使用 <code>git rerere</code> 命令。 当单独调用它时，Git 会检查解决方案数据库，尝试寻找一个和当前任一冲突相关的匹配项并解决冲突 （尽管当 <code>rerere.enabled</code> 被设置为 <code>true</code> 时会自动进行）。 它也有若干子命令，可用来查看记录项，删除特定解决方案和清除缓存全部内容等。 我们将在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvZWZfcmVyZXJl">Rerere<i class="fa fa-external-link-alt"></i></span> 中详细探讨。</p>
<h3 id="为发布打标签"><a href="#为发布打标签" class="headerlink" title="为发布打标签"></a>为发布打标签</h3><p>当你决定进行一次发布时，你可能想要打一个标签，这样在之后的任何一个提交点都可以重新创建该发布。 你在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gwMi1naXQtYmFzaWNzLWNoYXB0ZXI=">Git 基础<i class="fa fa-external-link-alt"></i></span> 中已经了解了创建新标签的过程。 作为一个维护者，如果你决定要为标签签名的话，打标签的过程应该是这样子的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -s v1.5 -m <span class="string">&#x27;my signed 1.5 tag&#x27;</span></span></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Scott Chacon &lt;schacon@gmail.com&gt;&quot;</span><br><span class="line">1024-bit DSA key, ID F721C45A, created 2009-02-09</span><br></pre></td></tr></table></figure>

<p>如果你为标签签名了，你可能会遇到分发用来签名的 PGP 公钥的问题。 Git 项目的维护者已经解决了这一问题，其方法是在版本库中以 blob 对象的形式包含他们的公钥，并添加一个直接指向该内容的标签。 要完成这一任务，首先你可以通过运行 <code>gpg --list-keys</code> 找出你所想要的 key：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --list-keys</span></span><br><span class="line">/Users/schacon/.gnupg/pubring.gpg</span><br><span class="line">---------------------------------</span><br><span class="line">pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]</span><br><span class="line">uid                  Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</span><br></pre></td></tr></table></figure>

<p>之后你可以通过导出 key 并通过管道传递给 <code>git hash-object</code> 来直接将 key 导入到 Git 的数据库中，<code>git hash-object</code> 命令会向 Git 中写入一个包含其内容的新 blob 对象，并向你返回该 blob 对象的 SHA-1 值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg -a --<span class="built_in">export</span> F721C45A | git hash-object -w --stdin</span></span><br><span class="line">659ef797d181633c87ec71ac3f9ba29fe5775b92</span><br></pre></td></tr></table></figure>

<p>既然 Git 中已经包含你的 key 的内容了，你就可以通过指定由 <code>hash-object</code> 命令给出的新 SHA-1 值来创建一个直接指向它的标签：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</span></span><br></pre></td></tr></table></figure>

<p>如果你运行 <code>git push --tags</code> 命令，那么 <code>maintainer-pgp-pub</code> 标签将会被共享给所有人。 需要校验标签的人可以通过从数据库中直接拉取 blob 对象并导入到 GPG 中来导入 PGP key：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show maintainer-pgp-pub | gpg --import</span></span><br></pre></td></tr></table></figure>

<p>人们可以使用这个 key 来校验所有由你签名的标签。 另外，如果你在标签信息中包含了一些操作说明，用户可以通过运行 <code>git show &lt;tag&gt;</code> 来获取更多关于标签校验的说明。</p>
<h3 id="生成一个构建号"><a href="#生成一个构建号" class="headerlink" title="生成一个构建号"></a>生成一个构建号</h3><p>Git 中不存在随每次提交递增的“v123”之类的数字序列，如果你想要为提交附上一个可读的名称， 可以对其运行 <code>git describe</code> 命令。作为回应，Git 将会生成一个字符串， 它由最近的标签名、自该标签之后的提交数目和你所描述的提交的部分 SHA-1 值（前缀的 <code>g</code> 表示 Git）构成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git describe master</span></span><br><span class="line">v1.6.2-rc1-20-g8c5b85c</span><br></pre></td></tr></table></figure>

<p>这样你在导出一个快照或构建时，可以给出一个便于人们理解的命名。 实际上，如果你的 Git 是从 Git 自己的版本库克隆下来并构建的，那么 <code>git --version</code> 命令给出的结果是与此类似的。 如果你所描述的提交自身就有一个标签，那么它将只会输出标签名，没有后面两项信息。</p>
<p>默认情况下， <code>git describe</code> 命令需要有注解的标签（即使用 <code>-a</code> 或 <code>-s</code> 选项创建的标签）； 如果你想使用轻量标签（无注解的标签），请在命令后添加 <code>--tags</code> 选项。 你也可以使用这个字符串来调用 <code>git checkout</code> 或 <code>git show</code> 命令， 但是这依赖于其末尾的简短 SHA-1 值，因此不一定一直有效。 比如，最近 Linux 内核为了保证 SHA-1 值对象的唯一性，将其位数由 8 位扩展到了 10 位， 导致以前的 <code>git describe</code> 输出全部失效。</p>
<h3 id="准备一次发布"><a href="#准备一次发布" class="headerlink" title="准备一次发布"></a>准备一次发布</h3><p>现在你可以发布一个构建了。 其中一件事情就是为那些不使用 Git 的可怜包们创建一个最新的快照归档。 使用 <code>git archive</code> 命令完成此工作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git archive master --prefix=<span class="string">&#x27;project/&#x27;</span> | gzip &gt; `git describe master`.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> *.tar.gz</span></span><br><span class="line">v1.6.2-rc1-20-g8c5b85c.tar.gz</span><br></pre></td></tr></table></figure>

<p>如果有人将这个压缩包解压，他就可以在一个 <code>project</code> 目录中得到你项目的最新快照。 你也可以以类似的方式创建一个 zip 压缩包，但此时你应该向 <code>git archive</code> 命令传递 <code>--format=zip</code> 选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git archive master --prefix=<span class="string">&#x27;project/&#x27;</span> --format=zip &gt; `git describe master`.zip</span></span><br></pre></td></tr></table></figure>

<p>现在你有了本次发布的一个 tar 包和一个 zip 包，可以将其上传到网站或以电子邮件的形式发送给人们。</p>
<h3 id="制作提交简报"><a href="#制作提交简报" class="headerlink" title="制作提交简报"></a>制作提交简报</h3><p>现在是时候通知邮件列表里那些好奇你的项目发生了什么的人了。 使用 <code>git shortlog</code> 命令可以快速生成一份包含从上次发布之后项目新增内容的修改日志（changelog）类文档。 它会对你给定范围内的所有提交进行总结；比如，你的上一次发布名称是 v1.0.1，那么下面的命令可以给出上次发布以来所有提交的总结：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git shortlog --no-merges master --not v1.0.1</span></span><br><span class="line">Chris Wanstrath (6):</span><br><span class="line">      Add support for annotated tags to Grit::Tag</span><br><span class="line">      Add packed-refs annotated tag support.</span><br><span class="line">      Add Grit::Commit#to_patch</span><br><span class="line">      Update version and History.txt</span><br><span class="line">      Remove stray `puts`</span><br><span class="line">      Make ls_tree ignore nils</span><br><span class="line"></span><br><span class="line">Tom Preston-Werner (4):</span><br><span class="line">      fix dates in history</span><br><span class="line">      dynamic version method</span><br><span class="line">      Version bump to 1.0.2</span><br><span class="line">      Regenerated gemspec for version 1.0.2</span><br></pre></td></tr></table></figure>

<p>这份整洁的总结包括了自 v1.0.1 以来的所有提交，并且已经按照作者分好组，你可以通过电子邮件将其直接发送到列表中。</p>
<h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><p>GitHub 是最大的 Git 版本库托管商，是成千上万的开发者和项目能够合作进行的中心。 大部分 Git 版本库都托管在 GitHub，很多开源项目使用 GitHub 实现 Git 托管、问题追踪、代码审查以及其它事情。 所以，尽管这不是 Git 开源项目的直接部分，但如果想要专业地使用 Git，你将不可避免地与 GitHub 打交道，所以这依然是一个绝好的学习机会。</p>
<h2 id="账户的创建和配置"><a href="#账户的创建和配置" class="headerlink" title="账户的创建和配置"></a>账户的创建和配置</h2><p>你所需要做的第一件事是创建一个免费账户。 直接访问 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==">https://github.com<i class="fa fa-external-link-alt"></i></span>，选择一个未被占用的用户名，提供一个电子邮件地址和密码，点击写着“Sign up for GitHub”的绿色大按钮即可。</p>
<p>你将看到的下一个页面是升级计划的价格页面，目前我们可以直接忽略这个页面。 GitHub 会给你提供的邮件地址发送一封验证邮件。 尽快到你的邮箱进行验证，这是非常重要的（我们会在后面了解到这点）。</p>
<blockquote>
<p>GitHub 为免费账户提供了几乎所有的功能，除了一些高级的特性。GitHub 的付费计划包含一些高级工具和功能，不过本书将不涉及这部分内容。 关于可选方案及其对比的更多信息见 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ByaWNpbmclRTMlODAlODI=">https://github.com/pricing。<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>点击屏幕左上角的章鱼猫（Octocat）图标，你将来到控制面板页面。 现在，你已经做好了使用 GitHub 的准备工作。</p>
<h3 id="SSH-访问"><a href="#SSH-访问" class="headerlink" title="SSH 访问"></a>SSH 访问</h3><p>现在，你完全可以使用 <code>https://</code> 协议，通过你刚刚创建的用户名和密码访问 Git 版本库。 但是，如果仅仅克隆公有项目，你甚至不需要注册——刚刚我们创建的账户是为了以后 fork 其它项目，以及推送我们自己的修改。</p>
<p>如果你习惯使用 SSH 远程，你需要配置一个公钥。 （如果你没有公钥，参考 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2dlbmVyYXRlX3NzaF9rZXk=">生成 SSH 公钥<i class="fa fa-external-link-alt"></i></span>。） 使用窗口右上角的链接打开你的账户设置：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/account-settings.png" alt="“Account settings”链接。"></p>
<p>然后在左侧选择“SSH keys”部分。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/ssh-keys.png" alt="“SSH keys”链接。"></p>
<p>在这个页面点击“<code>Add an SSH key</code>”按钮，给你的公钥起一个名字，将你的 <code>~/.ssh/id_rsa.pub</code> （或者自定义的其它名字）公钥文件的内容粘贴到文本区，然后点击“Add key”。</p>
<blockquote>
<p>确保给你的 SSH 密钥起一个能够记得住的名字。 你可以为每一个密钥起名字（例如，“我的笔记本电脑”或者“工作账户”等），以便以后需要吊销密钥时能够方便地区分。</p>
</blockquote>
<h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><p>下一步，如果愿意的话，你可以将生成的头像换成你喜欢的图片。 首先，来到“Profile”标签页（在“SSH Keys”标签页上方），点击“Upload new picture”。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/your-profile.png" alt="“Profile”链接。"></p>
<p>我们选择了本地磁盘上的一个 Git 图标，上传之后还可以对其进行裁剪。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/avatar-crop.png" alt="裁剪已上传的头像。"></p>
<p>现在，在网站任意有你参与的位置，人们都可以在你的用户名旁边看到你的头像。</p>
<p>如果你已经把头像上传到了流行的 Gravatar 托管服务（Wordpress 账户经常使用），默认就会使用这个头像，因此，你就不需要进行这一步骤了。</p>
<h3 id="邮件地址"><a href="#邮件地址" class="headerlink" title="邮件地址"></a>邮件地址</h3><p>GitHub 使用用户邮件地址区分 Git 提交。 如果你在自己的提交中使用了多个邮件地址，希望 GitHub 可以正确地将它们连接起来， 你需要在管理页面的 Emails 部分添加你拥有的所有邮箱地址。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/email-settings.png" alt="添加所有邮件地址。"></p>
<p>在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2FkZF9lbWFpbF9hZGRyZXNzZXM=">添加邮件地址<i class="fa fa-external-link-alt"></i></span> 中我们可以看到一些不同的状态。 顶部的地址是通过验证的，并且被设置为主要地址，这意味着该地址会接收到所有的通知和回复。 第二个地址是通过验证的，如果愿意的话，可以将其设置为主要地址。 最后一个地址是未通过验证的，这意味着你不能将其设置为主要地址。 当 GitHub 发现任意版本库中的任意提交信息包含了这些地址，它就会将其链接到你的账户。</p>
<h3 id="两步验证"><a href="#两步验证" class="headerlink" title="两步验证"></a>两步验证</h3><p>最后，为了额外的安全性，你绝对应当设置两步验证，简写为 “2FA”。 两步验证是一种用于降低因你的密码被盗而带来的账户风险的验证机制，现在已经变得越来越流行。 开启两步验证，GitHub 会要求你用两种不同的验证方法，这样，即使其中一个被攻破，攻击者也不能访问你的账户。</p>
<p>你可以在 Account settings 页面的 Security 标签页中找到 Two-factor Authentication 设置。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/2fa-1.png" alt="Security 标签页中的 2FA"></p>
<p>点击“Set up two-factor authentication”按钮，会跳转到设置页面。该页面允许你选择是要在登录时使用手机 app 生成辅助码（一种“基于时间的一次性密码”），还是要 GitHub 通过 SMS 发送辅助码。</p>
<p>选择合适的方法后，按照提示步骤设置 2FA，你的账户会变得更安全，每次登录 GitHub 时都需要提供除密码以外的辅助码。</p>
<h2 id="对项目做出贡献"><a href="#对项目做出贡献" class="headerlink" title="对项目做出贡献"></a>对项目做出贡献</h2><p>账户已经建立好了，现在我们来了解一些能帮助你对现有的项目做出贡献的知识。</p>
<h3 id="派生项目"><a href="#派生项目" class="headerlink" title="派生项目"></a>派生项目</h3><p>如果你想要参与某个项目，但是并没有推送权限，这时可以对这个项目进行“派生（Fork）”。 当你“派生”一个项目时，GitHub 会在你的空间中创建一个完全属于你的项目副本，且你对其具有推送权限。</p>
<blockquote>
<p>在以前，“fork”是一个贬义词，指的是某个人使开源项目向不同的方向发展，或者创建一个竞争项目，使得原项目的贡献者分裂。 在 GitHub，“fork”指的是你自己的空间中创建的项目副本，这个副本允许你以一种更开放的方式对其进行修改。</p>
</blockquote>
<p>通过这种方式，项目的管理者不再需要忙着把用户添加到贡献者列表并给予他们推送权限。 人们可以派生这个项目，将修改推送到派生出的项目副本中，并通过创建拉取请求（Pull Request，简称 PR）来让他们的改动进入源版本库，下文我们会详细说明。 创建了拉取请求后，就会开启一个可供审查代码的板块，项目的拥有者和贡献者可以在此讨论相关修改，直到项目拥有者对其感到满意，并且认为这些修改可以被合并到版本库。</p>
<p>你可以通过点击项目页面右上角的“Fork”按钮，来派生这个项目。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/forkbutton.png" alt="“Fork”按钮."></p>
<p>稍等片刻，你将被转到新项目页面，该项目包含可写的代码副本。</p>
<h3 id="GitHub-流程"><a href="#GitHub-流程" class="headerlink" title="GitHub 流程"></a>GitHub 流程</h3><p>GitHub 设计了一个以拉取请求为中心的特殊合作流程。 它基于我们在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3RvcGljX2JyYW5jaA==">主题分支<i class="fa fa-external-link-alt"></i></span> 的 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gwMy1naXQtYnJhbmNoaW5n">Git 分支<i class="fa fa-external-link-alt"></i></span> 中提到的工作流程。 不管你是在一个紧密的团队中使用单独的版本库，或者使用许多的“Fork”来为一个由陌生人组成的国际企业或网络做出贡献，这种合作流程都能应付。</p>
<p>流程通常如下：</p>
<ol>
<li>派生一个项目</li>
<li>从 <code>master</code> 分支创建一个新分支</li>
<li>提交一些修改来改进项目</li>
<li>将这个分支推送到 GitHub 上</li>
<li>创建一个拉取请求</li>
<li>讨论，根据实际情况继续修改</li>
<li>项目的拥有者合并或关闭你的拉取请求</li>
<li>将更新后的 <code>master</code> 分支同步到你的派生中</li>
</ol>
<p>这基本和 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2ludGVncmF0aW9uX21hbmFnZXI=">集成管理者工作流<i class="fa fa-external-link-alt"></i></span> 中的一体化管理流程差不多，但是团队可以使用 GitHub 提供的网页工具替代电子邮件来交流和审查修改。</p>
<p>现在我们来看一个使用这个流程的例子。</p>
<h4 id="创建拉取请求"><a href="#创建拉取请求" class="headerlink" title="创建拉取请求"></a>创建拉取请求</h4><p>Tony 在找一些能在他的 Arduino 微控制器上运行的代码，他觉得 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NjaGFjb24vYmxpbms=">https://github.com/schacon/blink<i class="fa fa-external-link-alt"></i></span> 中的代码不错。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-01-start.png" alt="他想要做出贡献的项目"></p>
<p>但是有个问题，这个代码中的的闪烁频率太高，我们觉得 3 秒一次比 1 秒一次更好一些。 所以让我们来改进这个程序，并将修改后的代码提交给这个项目。</p>
<p>首先，单击“Fork”按钮来获得这个项目的副本。 我们使用的用户名是“tonychacon”，所以这个项目副本的访问地址是： <code>https://github.com/tonychacon/blink</code> 。 我们将它克隆到本地，创建一个分支，修改代码，最后再将改动推送到 GitHub。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/tonychacon/blink (1)</span></span><br><span class="line">Cloning into &#x27;blink&#x27;...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> blink</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b slow-blink (2)</span></span><br><span class="line">Switched to a new branch &#x27;slow-blink&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -i <span class="string">&#x27;&#x27;</span> <span class="string">&#x27;s/1000/3000/&#x27;</span> blink.ino (macOS) (3)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If you<span class="string">&#x27;re on a Linux system, do this instead:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">$ sed -i &#x27;</span>s/1000/3000/<span class="string">&#x27; blink.ino (3)</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git diff --word-diff (4)</span></span></span><br><span class="line">diff --git a/blink.ino b/blink.ino</span><br><span class="line">index 15b9911..a6cc5a5 100644</span><br><span class="line">--- a/blink.ino</span><br><span class="line">+++ b/blink.ino</span><br><span class="line">@@ -18,7 +18,7 @@ void setup() &#123;</span><br><span class="line">// the loop routine runs over and over again forever:</span><br><span class="line">void loop() &#123;</span><br><span class="line">  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)</span><br><span class="line">  [-delay(1000);-]&#123;+delay(3000);+&#125;               // wait for a second</span><br><span class="line">  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW</span><br><span class="line">  [-delay(1000);-]&#123;+delay(3000);+&#125;               // wait for a second</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git commit -a -m &#x27;</span>three seconds is better<span class="string">&#x27; (5)</span></span></span><br><span class="line">[slow-blink 5ca509d] three seconds is better</span><br><span class="line"> 1 file changed, 2 insertions(+), 2 deletions(-)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">git push origin slow-blink (6)</span></span></span><br><span class="line">Username for &#x27;https://github.com&#x27;: tonychacon</span><br><span class="line">Password for &#x27;https://tonychacon@github.com&#x27;:</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">To https://github.com/tonychacon/blink</span><br><span class="line"> * [new branch]      slow-blink -&gt; slow-blink</span><br></pre></td></tr></table></figure>

<ol>
<li>将派生出的副本克隆到本地</li>
<li>创建出名称有意义的分支</li>
<li>修改代码</li>
<li>检查改动</li>
<li>将改动提交到分支中</li>
<li>将新分支推送到 GitHub 的副本中</li>
</ol>
<p>现在到 GitHub 上查看之前的项目副本，可以看到 GitHub 提示我们有新的分支， 并且显示了一个大大的绿色按钮让我们可以检查我们的改动，并给源项目创建拉取请求。</p>
<p>你也可以到“Branches”（分支）页面查看分支并创建拉取请求： <code>https://github.com/&lt;用户名&gt;/&lt;项目名&gt;/branches</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-02-pr.png" alt="拉取请求按钮"></p>
<p>如果我们点击那个绿色按钮，就会跳到一个新页面，在这里我们可以为拉取请求填写标题和描述。 花点时间编写一个清晰有用的描述是非常值得的，这能让原项目拥有者明白你做了什么， 为什么这个改动是正确的，以及接受此更改是否能够改进他的项目。</p>
<p>同时我们也能看到比主分支中所“领先”（ahead）的提交（在这个例子中只有一个）以及所有将会被合并的改动与之前代码的对比。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-03-pull-request-open.png" alt="拉取请求创建页面"></p>
<p>当你单击了“Create pull request”（创建拉取请求）的按钮后，这个项目的拥有者将会收到一条包含关改动和拉取请求页面的链接的提醒。</p>
<blockquote>
<p>虽然拉取请求通常是在贡献者准备好在公开项目中提交改动的时候提交，但是也常被用在仍处于开发阶段的内部项目中。 因为拉取请求在提交后 <strong>依然可以加入新的改动</strong> ，它也经常被用来建立团队合作的环境，而不只是在最终阶段使用。</p>
</blockquote>
<h4 id="利用拉取请求"><a href="#利用拉取请求" class="headerlink" title="利用拉取请求"></a>利用拉取请求</h4><p>现在，项目的拥有者可以看到你的改动并合并它，拒绝它或是发表评论。 在这里我们就当作他喜欢这个点子，但是他想要让灯熄灭的时间比点亮的时间稍长一些。</p>
<p>接下来可能会通过电子邮件进行互动，就像我们在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gwNS1kaXN0cmlidXRlZC1naXQ=">分布式 Git<i class="fa fa-external-link-alt"></i></span> 中提到的工作流程那样，但是在 GitHub，这些都在线上完成。 项目的拥有者可以审查修改，只需要单击某一行，就可以对其发表评论。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-04-pr-comment.png" alt="拉取请求中对某一行的评论"></p>
<p>当维护者发表评论后，提交拉取请求的人，以及所有正在关注（Watching）这个版本库的用户都会收到通知。 我们待会儿将会告诉你如何修改这项设置。现在，如果 Tony 有开启电子邮件提醒，他将会收到这样的一封邮件：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-04-email.png" alt="电子邮件提醒"></p>
<p>每个人都能在拉取请求中发表评论。在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3ByX2Rpc2N1c3Npb24=">拉取请求讨论页面<i class="fa fa-external-link-alt"></i></span> 里我们可以看到项目拥有者对某行代码发表评论， 并在讨论区留下了一个普通评论。你可以看到被评论的代码也会在互动中显示出来。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-05-general-comment.png" alt="拉取请求讨论页面"></p>
<p>现在贡献者可以看到如何做才能让他们的改动被接受。幸运的是，这也是一件轻松的事情。 如果你使用的是电子邮件进行交流，你需要再次对代码进行修改并重新提交至邮件列表， 这些修改会自动更新到拉取请求上。在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3ByX2ZpbmFs">最终的拉取请求<i class="fa fa-external-link-alt"></i></span> 中，你也可以在更新后的拉取请求中看到已折叠的旧代码评论， 因为它是在修改后的行上添加的评论。</p>
<p>对现有的拉取请求添加提交并不会触发提醒，因此 Tony 在推送了他的修正后， 还需要通过评论告知项目拥有者他完成了修改请求。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/blink-06-final.png" alt="最终的拉取请求"></p>
<p>如果你点开拉取请求的“Files Changed”（更改的文件）选项卡，你将会看到“整理过的”差异表 —— 也就是这个分支被合并到主分支之后将会产生的所有改动， 其实就是 <code>git diff master…&lt;分支名&gt;</code> 命令的执行结果。 你可以浏览 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3doYXRfaXNfaW50cm9kdWNlZA==">确定引入了哪些东西<i class="fa fa-external-link-alt"></i></span> 来了解更多关于差异表的知识。</p>
<p>你还会注意到，GitHub 会检查你的拉取请求是否能直接合并，如果可以，将会提供一个按钮来进行合并操作。 这个按钮只在你对版本库有写入权限并且可以进行简洁合并时才会显示。 你点击后 GitHub 将做出一个“非快进式”（non-fast-forward）合并， 即使这个合并 <strong>能够</strong> 快进式（fast-forward）合并，GitHub 依然会创建一个合并提交。</p>
<p>如果你需要，你还可以将分支拉取并在本地合并。 如果你将这个分支合并到 <code>master</code> 分支中并推送到 GitHub，这个拉取请求会被自动关闭。</p>
<p>这就是大部分 GitHub 项目使用的工作流程。创建分支，基于分支创建拉取请求，进行讨论， 根据需要继续在分支上进行修改，最终关闭或合并拉取请求。</p>
<blockquote>
<p>不必总是 Fork</p>
<p>有件很重要的事情：你可以在同一个版本库中不同的分支提交拉取请求。 如果你正在和某人实现某个功能，而且你对项目有写权限，你可以推送分支到版本库， 并在 <code>master</code> 分支提交一个拉取请求并在此进行代码审查和讨论的操作。不需要进行“Fork”。</p>
</blockquote>
<h3 id="拉取请求的进阶用法"><a href="#拉取请求的进阶用法" class="headerlink" title="拉取请求的进阶用法"></a>拉取请求的进阶用法</h3><p>目前，我们学到了如何在 GitHub 平台对一个项目进行最基础的贡献。现在我们会教给你一些小技巧，让你可以更加有效率地使用拉取请求。</p>
<h4 id="将拉取请求制作成补丁"><a href="#将拉取请求制作成补丁" class="headerlink" title="将拉取请求制作成补丁"></a>将拉取请求制作成补丁</h4><p>有一件重要的事情：许多项目并不认为拉取请求可以作为补丁， 就和通过邮件列表工作的的项目对补丁贡献的看法一样。 大多数的 GitHub 项目将拉取请求的分支当作对改动的交流方式，并将变更集合起来统一进行合并。</p>
<p>这是个重要的差异，因为一般来说改动会在代码完成前提出，这和基于邮件列表的补丁贡献有着天差地别。 这使得维护者们可以更早的沟通，由社区中的力量能提出更好的方案。 当有人从拉取请求提交了一些代码，并且维护者和社区提出了一些意见，这个补丁系列并不需要从头来过， 只需要将改动重新提交并推送到分支中，这使得讨论的背景和过程可以齐头并进。</p>
<p>举个例子，你可以回去看看 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3ByX2ZpbmFs">最终的拉取请求<i class="fa fa-external-link-alt"></i></span>，你会注意到贡献者没有变基他的提交再提交一个新的拉取请求， 而是直接增加了新的提交并推送到已有的分支中。 如果你之后再回去查看这个拉取请求，你可以轻松地找到这个修改的原因。 点击网页上的“Merge”（合并）按钮后，会建立一个合并提交并指向这个拉取请求，你就可以很轻松的研究原来的讨论内容。</p>
<h4 id="与上游保持同步"><a href="#与上游保持同步" class="headerlink" title="与上游保持同步"></a>与上游保持同步</h4><p>如果你的拉取请求由于过时或其他原因不能干净地合并，你需要进行修复才能让维护者对其进行合并。 GitHub 会对每个提交进行测试，让你知道你的拉取请求能否简洁的合并。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/pr-01-fail.png" alt="拉取请求合并失败"></p>
<p>如果你看到了像 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3ByX2ZhaWw=">不能进行干净合并<i class="fa fa-external-link-alt"></i></span> 中的画面，你就需要修复你的分支让这个提示变成绿色，这样维护者就不需要再做额外的工作。</p>
<p>你有两种方法来解决这个问题。你可以把你的分支变基到目标分支中去 （通常是你派生出的版本库中的 <code>master</code> 分支），或者你可以合并目标分支到你的分支中去。</p>
<p>GitHub 上的大多数的开发者会使用后一种方法，基于我们在上一节提到的理由： 我们最看重的是历史记录和最后的合并，变基除了给你带来看上去简洁的历史记录， 只会让你的工作变得更加困难且更容易犯错。</p>
<p>如果你想要合并目标分支来让你的拉取请求变得可合并，你需要将源版本库添加为一个新的远端，并从远端抓取内容，合并主分支的内容到你的分支中去，修复所有的问题并最终重新推送回你提交拉取请求使用的分支。</p>
<p>在这个例子中，我们再次使用之前的“tonychacon”用户来进行示范，源作者提交了一个改动， 使得拉取请求和它产生了冲突。现在来看我们解决这个问题的步骤。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add upstream https://github.com/schacon/blink (1)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch upstream (2)</span></span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (3/3), done.</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">From https://github.com/schacon/blink</span><br><span class="line"> * [new branch]      master     -&gt; upstream/master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge upstream/master (3)</span></span><br><span class="line">Auto-merging blink.ino</span><br><span class="line">CONFLICT (content): Merge conflict in blink.ino</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim blink.ino (4)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add blink.ino</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br><span class="line">[slow-blink 3c8d735] Merge remote-tracking branch &#x27;upstream/master&#x27; \</span><br><span class="line">    into slower-blink</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin slow-blink (5)</span></span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (6/6), done.</span><br><span class="line">Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https://github.com/tonychacon/blink</span><br><span class="line">   ef4725c..3c8d735  slower-blink -&gt; slow-blink</span><br></pre></td></tr></table></figure>

<ol>
<li>将源版本库添加为一个远端，并命名为“upstream”（上游）</li>
<li>从远端抓取最新的内容</li>
<li>将该仓库的主分支的内容合并到你的分支中</li>
<li>修复产生的冲突</li>
<li>再推送回同一个分支</li>
</ol>
<p>你完成了上面的步骤后，拉取请求将会自动更新并重新检查是否能干净的合并。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/pr-02-merge-fix.png" alt="修复了的拉取请求"></p>
<p>Git 的伟大之处就是你可以一直重复以上操作。如果你有一个运行了十分久的项目， 你可以轻松地合并目标分支且只需要处理最近的一次冲突，这使得管理流程更加容易。</p>
<p>如果你一定想对分支做变基并进行清理，你可以这么做，但是强烈建议你不要强行地提交到已经提交了拉取请求的分支。 如果其他人拉取了这个分支并进行一些修改，你将会遇到 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3JlYmFzZV9wZXJpbA==">变基的风险<i class="fa fa-external-link-alt"></i></span> 中提到的问题。 相对的，将变基后的分支推送到 GitHub 上的一个新分支中，并且创建一个全新的拉取请求引用旧的拉取请求，然后关闭旧的拉取请求。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>你的下个问题可能是“我该如何引用旧的拉取请求？”。 有许多方法可以让你在 GitHub 上的几乎任何地方引用其他东西。</p>
<p>先从如何对拉取请求或议题（Issue）进行相互引用开始。所有的拉取请求和议题在项目中都会有一个独一无二的编号。 举个例子，你无法同时拥有 3 号拉取请求和 3 号议题。如果你想要引用任何一个拉取请求或议题， 你只需要在提交或描述中输入 <code>&lt;编号&gt;</code> 即可。 你也可以指定引用其他版本库的议题或拉取请求，如果你想要引用其他人对该版本库的“Fork”中的议题或拉取请求， 输入 <code>用户名&lt;编号&gt;</code> ，如果在不同的版本库中，输入 <code>用户名/版本库名#&lt;编号&gt;</code> 。</p>
<p>我们来看一个例子。假设我们对上个例子中的分支进行了变基，并为此创建一个新的拉取请求， 现在我们希望能在新的拉取请求中引用旧的拉取请求。 我们同时希望引用一个派生出的项目中的议题和一个完全不同的项目中的议题， 就可以像 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3ByX3JlZmVyZW5jZXM=">在拉取请求中的交叉引用<i class="fa fa-external-link-alt"></i></span> 这样填写描述。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/mentions-01-syntax.png" alt="拉取请求中的引用"></p>
<p>当我们提交了这个拉取请求，我们将会看到以上内容被渲染成这样：<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3ByX3JlZmVyZW5jZXNfcmVuZGVy">在拉取请求中渲染后的交叉引用<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/mentions-02-render.png" alt="渲染后的拉取请求中的引用"></p>
<p>你会注意到完整的 GitHub 地址被简化了，只留下了必要的信息。</p>
<p>如果 Tony 回去关闭了源拉取请求，我们可以看到一个被引用的提示， GitHub 会自动的反向追踪事件并显示在拉取请求的时间轴上。 这意味着任何查看这个拉取请求的人可以轻松地访问新的拉取请求。 这个链接就像 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3ByX2Nsb3NlZA==">在拉取请求中渲染后的交叉引用<i class="fa fa-external-link-alt"></i></span> 中展示的那样。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/mentions-03-closed.png" alt="拉取请求关闭"></p>
<p>除了议题编号外，你还可以通过使用提交的 SHA-1 来引用提交。 你必须完整的写出 40 位长的 SHA-1，GitHub 会在评论中自动地产生指向这个提交的链接。 同样的，你可以像引用议题一样对派生的项目中的提交或者其他项目中的提交进行引用。</p>
<h3 id="GitHub-风格的-Markdown"><a href="#GitHub-风格的-Markdown" class="headerlink" title="GitHub 风格的 Markdown"></a>GitHub 风格的 Markdown</h3><p>对于在 GitHub 中绝大多数文本框中能够做到的事，引用其他议题只是个开始。 在议题和拉取请求的描述，评论和代码评论还有其他地方，都可以使用“GitHub 风格的 Markdown”。 Markdown 可以让你输入纯文本，但是渲染出丰富的内容。</p>
<p>查看 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2V4YW1wbGVfbWFya2Rvd24=">一个 Markdown 的示例和渲染效果<i class="fa fa-external-link-alt"></i></span> 里的示例来了解如何书写评论或文本，并通过 Markdown 进行渲染。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-01-example.png" alt="Markdown 示例"></p>
<h4 id="GitHub-风格的-Markdown-1"><a href="#GitHub-风格的-Markdown-1" class="headerlink" title="GitHub 风格的 Markdown"></a>GitHub 风格的 Markdown</h4><p>GitHub 风格的 Markdown 增加了一些基础的 Markdown 中做不到的东西。 它在创建拉取请求和议题中的评论和描述时十分有用。</p>
<h6 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h6><p>第一个 GitHub 专属的 Markdown 功能，特别是用在拉取请求中，就是任务列表。 一个任务列表可以展示出一系列你想要完成的事情，并带有复选框。 把它们放在议题或拉取请求中时，通常可以展示你想要完成的事情。</p>
<p>你可以这样创建一个任务列表：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [X] 编写代码</span><br><span class="line">- [ ] 编写所有测试程序</span><br><span class="line">- [ ] 为代码编写文档</span><br></pre></td></tr></table></figure>

<p>如果我们将这个列表加入拉取请求或议题的描述中，它将会被渲染 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2VnX3Rhc2tfbGlzdHM=">Markdown 评论中渲染后的任务列表<i class="fa fa-external-link-alt"></i></span> 这样。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-02-tasks.png" alt="任务列表示例"></p>
<p>在拉取请求中，任务列表经常被用来在合并之前展示这个分支将要完成的事情。 最酷的地方就是，你只需要点击复选框，就能更新评论 —— 你不需要直接修改 Markdown。</p>
<p>不仅如此，GitHub 还会将你在议题和拉取请求中的任务列表整理起来集中展示。 举个例子，如果你在一个拉取请求中有任务清单，你将会在所有拉取请求的总览页面上看到它的进度。 这使得人们可以把一个拉取请求分解成不同的小任务，同时便于其他人了解分支的进度。 你可以在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3Rhc2tfbGlzdF9wcm9ncmVzcw==">在拉取请求列表中的任务列表总结<i class="fa fa-external-link-alt"></i></span> 看到一个例子。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-03-task-summary.png" alt="任务列表示例"></p>
<p> 当你在实现一个任务的早期就提交拉取请求，并使用任务清单追踪你的进度，这个功能会十分的有用。</p>
<h4 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h4><p>你也可以在评论中添加代码片段。这在你想要展示尚未提交到分支中的代码时会十分有用。 它也经常被用在展示无法正常工作的代码或这个拉取请求需要的代码。</p>
<p>你需要用“反引号”将需要添加的代码片段包起来。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line">for(int i=0 ; i &lt; 5 ; i++)</span><br><span class="line">&#123;</span><br><span class="line">   System.out.println(&quot;i is : &quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>如果加入语言的名称，就像我们这里加入的“java”一样，GitHub 会自动尝试对摘录的片段进行语法高亮。 在下面的例子中，它最终会渲染成这个样子： <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX21kX2NvZGU=">渲染后的代码片段示例<i class="fa fa-external-link-alt"></i></span> 。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-04-fenced-code.png" alt="渲染后的代码片段"></p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>如果你在回复一个很长的评论之中的一小段，你只需要复制你需要的片段，并在每行前添加 <code>&gt;</code> 符号即可。 事实上，因为这个功能会被经常用到，它也有一个快捷键。 只要你把你要回应的文字选中，并按下 <code>r</code> 键，选中的问题会自动引用并填入评论框。</p>
<p>引用的部分就像这样:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Whether &#x27;tis Nobler in the mind to suffer</span><br><span class="line">&gt; The Slings and Arrows of outrageous Fortune,</span><br><span class="line"></span><br><span class="line">How big are these slings and in particular, these arrows?</span><br></pre></td></tr></table></figure>

<p>经过渲染后，就会变成这样： <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX21kX3F1b3Rl">渲染后的引用示例<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-05-quote.png" alt="渲染后的引用"></p>
<h4 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h4><p>最后，我们可以在评论中使用表情符号。这经常出现在 GitHub 的议题和拉取请求的评论中。 GitHub 上甚至有表情助手。如果你在输入评论时以 <code>:</code> 开头，自动完成器会帮助你找到你需要的表情。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-06-emoji-complete.png" alt="表情符号自动完成器"></p>
<p>你也可以在评论的任何地方使用 <code>:&lt;表情名称&gt;:</code> 来添加表情符号。 举个例子，你可以输入以下文字：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I :eyes: that :bug: and I :cold<span class="emphasis">_sweat:.</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">:trophy: for :microscope: it.</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">:+1: and :sparkles: on this :ship:, it&#x27;s :fire::poop:!</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">:clap::tada::panda_</span>face:</span><br></pre></td></tr></table></figure>

<p>渲染之后，就会变成这样： <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX21kX2Vtb2pp">使用了大量表情符号的评论<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-07-emoji.png" alt="Emoji"></p>
<p>虽然这个功能并不是非常实用，但是它在这种不方便表达感情的媒体里，加入了趣味的元素。</p>
<blockquote>
<p>事实上现在已经有大量的在线服务可以使用表情符号，这里有个列表可以让你快速的找到能表达你的情绪的表情符号：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cud2ViZnguY29tL3Rvb2xzL2Vtb2ppLWNoZWF0LXNoZWV0Lw==">https://www.webfx.com/tools/emoji-cheat-sheet/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>从技术层面来说，这并不是 GitHub 风格 Markdown 的功能，但是也很有用。 如果不想使用 Markdown 语法来插入图片，GitHub 允许你通过拖拽图片到文本区来插入图片。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/markdown-08-drag-drop.png" alt="拖拽插入图片"></p>
<p>如果你回去查看 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX21kX2RyYWc=">通过拖拽的方式自动插入图片<i class="fa fa-external-link-alt"></i></span> ，你会发现文本区上有个“Parsed as Markdown”的提示。 点击它你可以了解所有能在 GitHub 上使用的 Markdown 功能。</p>
<h3 id="让你的-GitHub-公共仓库保持更新"><a href="#让你的-GitHub-公共仓库保持更新" class="headerlink" title="让你的 GitHub 公共仓库保持更新"></a>让你的 GitHub 公共仓库保持更新</h3><p>当你派生了一个 GitHub 仓库之后，你的仓库（即你的“派生”）会独立于原仓库而独立。 特别地，当原仓库有新的提交时，GitHub 会通知你：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This branch is 5 commits behind progit:master.</span><br><span class="line">（本分支落后 progit:master 5 个提交。）</span><br></pre></td></tr></table></figure>

<p>但你的 GitHub 仓库不会被 GitHub 自动更新，这件事必须由你自己来做。还好，这事儿很简单。</p>
<p>第一种方法无需配置。例如，若你从 <code>https://github.com/progit/progit2.git</code> 派生了项目， 你可以像这样更新你的 <code>master</code> 分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master (1)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull https://github.com/progit/progit2.git (2)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master (3)</span></span><br></pre></td></tr></table></figure>

<ol>
<li>如果在另一个分支上，就切换到 <code>master</code></li>
<li>从 <code>https://github.com/progit/progit2.git</code> 抓取更改后合并到 <code>master</code></li>
<li>将 <code>master</code> 分支推送到 <code>origin</code></li>
</ol>
<p>这虽然可行，但每次都要输入从哪个 URL 抓取有点麻烦。你可以稍微设置一下来自动完成它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add progit https://github.com/progit/progit2.git (1)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --set-upstream-to=progit/master master (2)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --<span class="built_in">local</span> remote.pushDefault origin (3)</span></span><br></pre></td></tr></table></figure>

<ol>
<li>添加源仓库并取一个名字，这里叫它 <code>progit</code></li>
<li>将 <code>master</code> 分支设置为从 <code>progit</code> 远端抓取</li>
<li>将默认推送仓库设置为 <code>origin</code></li>
</ol>
<p>搞定之后，工作流程为更加简单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master (1)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull (2)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push (3)</span></span><br></pre></td></tr></table></figure>

<ol>
<li>如果在另一个分支上，就切换到 <code>master</code></li>
<li>从 <code>progit</code> 抓取更改后合并到 <code>master</code></li>
<li>将 <code>master</code> 分支推送到 <code>origin</code></li>
</ol>
<p>这种方法可能很有用，但也不是没有缺点。如果你向 <code>master</code> 提交，再从 <code>progit</code> 中拉取，然后推送到 <code>origin</code>，Git 会很乐意安静地为您完成这项工作，但不会警告你——所有这些操作在以上设置下都是有效的。 所以你必须注意永远不要直接提交到 <code>master</code>，因为该分支实际上属于上游仓库。</p>
<h2 id="维护项目-1"><a href="#维护项目-1" class="headerlink" title="维护项目"></a>维护项目</h2><p>现在我们可以很方便地向一个项目贡献内容，来看一下另一个方面的内容：创建、维护和管理你自己的项目。</p>
<h3 id="创建新的版本库"><a href="#创建新的版本库" class="headerlink" title="创建新的版本库"></a>创建新的版本库</h3><p>让我们创建一个版本库来分享我们的项目。 通过点击面板右侧的“New repository”按钮，或者顶部工具条你用户名旁边的 <code>+</code> 按钮来开始我们的旅程。 参见 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX25ld19yZXBvX2Ryb3Bkb3du">这是 “New repository” 下拉列表.<i class="fa fa-external-link-alt"></i></span>。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/newrepo.png" alt="“Your repositories” 区域."></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/new-repo.png" alt="“new repository” 下拉列表."></p>
<p>这会带你到 “new repository” 表单:</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/newrepoform.png" alt="“new repository” 表单。"></p>
<p>这里除了一个你必须要填的项目名，其他字段都是可选的。 现在只需要点击 “Create Repository” 按钮，Duang!!! – 你就在 GitHub 上拥有了一个以 <code>&lt;user&gt;/&lt;project_name&gt;</code> 命名的新仓库了。</p>
<p>因为目前暂无代码，GitHub 会显示有关创建新版本库或者关联到一个已有的 Git 版本库的一些说明。 我们不会在这里详细说明此项，如果你需要复习，去看 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gwMi1naXQtYmFzaWNzLWNoYXB0ZXI=">Git 基础<i class="fa fa-external-link-alt"></i></span>。</p>
<p>现在你的项目就托管在 GitHub 上了，你可以把 URL 给任何你想分享的人。 GitHub 上的项目可通过 HTTP 或 SSH 访问，HTTPS 为 <code>https://github.com/&lt;user&gt;/&lt;project_name&gt;</code> ， SSH 为 <code>git@github.com:&lt;user&gt;/&lt;project_name&gt;</code> 。 Git 可以通过以上两种 URL 进行抓取和推送，但是用户的访问权限又因连接时使用的证书不同而异。</p>
<blockquote>
<p>通常对于公开项目可以优先分享基于 HTTPS 的 URL，因为用户克隆项目不需要有一个 GitHub 帐号。 如果你分享 SSH URL，用户必须有一个帐号并且上传 SSH 密钥才能访问你的项目。 HTTPS URL 与你贴到浏览器里查看项目用的地址是一样的。</p>
</blockquote>
<h3 id="添加合作者"><a href="#添加合作者" class="headerlink" title="添加合作者"></a>添加合作者</h3><p>如果你想与他人合作，并想给他们提交的权限，你需要把他们添加为 “Collaborators”。 如果 Ben，Jeff，Louise 都在 GitHub 上注册了，你想给他们推送的权限，你可以将他们添加到你的项目。 这样做会给他们 “推送” 权限，就是说他们对项目和 Git 版本库都有读写的权限。</p>
<p>点击边栏底部的 “Settings” 链接。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/reposettingslink.png" alt="版本库设置链接."></p>
<p>然后从左侧菜单中选择 “Collaborators” 。 然后，在输入框中填写用户名，点击 “Add collaborator.” 如果你想授权给多个人，你可以多次重复这个步骤。 如果你想收回权限，点击他们同一行右侧的 “X”</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/collaborators.png" alt="版本库合作者."></p>
<h3 id="管理合并请求"><a href="#管理合并请求" class="headerlink" title="管理合并请求"></a>管理合并请求</h3><p>现在你有一个包含一些代码的项目，可能还有几个有推送权限的合作者，下面来看当你收到合并请求时该做什么。</p>
<p>合并请求可以来自仓库副本的一个分支，或者同一仓库的另一个分支。 唯一的区别是 fork 过来的通常是和你不能互相推送的人，而内部的推送通常都可以互相访问。</p>
<p>作为例子，假设你是 “tonychacon” ，你创建了一个名为 “fade” 的 Arduino 项目.</p>
<h4 id="邮件通知"><a href="#邮件通知" class="headerlink" title="邮件通知"></a>邮件通知</h4><p>有人来修改了你的代码，给你发了一个合并请求。 你会收一封关于合并请求的提醒邮件，它看起来像 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2VtYWlsX3By">新的合并请求的邮件通知.<i class="fa fa-external-link-alt"></i></span>。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-01-email.png" alt="合并请求的邮件通知"></p>
<p>关于这个邮件有几个要注意的地方。 它会给你一个小的变动统计结果 — 一个包含合并请求中改变的文件和改变了多少的列表。 它还给你一个 GitHub 上进行合并请求操作的链接。 还有几个可以在命令行使用的 URL。</p>
<p>如果你注意到 <code>git pull &lt;url&gt; patch-1</code> 这一行，这是一种合并远程分支的简单方式，无需必须添加一个远程分支。 我们很快会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2NoZWNraW5nX291dF9yZW1vdGVz">检出远程分支<i class="fa fa-external-link-alt"></i></span> 讲到它。 如果你愿意，你可以创建并切换到一个主题分支，然后运行这个命令把合并请求合并进来。</p>
<p>还有一些有趣的 URL，像 <code>.diff</code> 和 <code>.patch</code> ，就像你猜的那样，它们提供 diff 和 patch 的标准版本。 你可以技术性地用下面的方法合并“合并请求”：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl https://github.com/tonychacon/fade/pull/1.patch | git am</span></span><br></pre></td></tr></table></figure>

<h4 id="在合并请求上进行合作"><a href="#在合并请求上进行合作" class="headerlink" title="在合并请求上进行合作"></a>在合并请求上进行合作</h4><p>就像我们在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2dpdGh1Yl9mbG93">GitHub 流程<i class="fa fa-external-link-alt"></i></span> 中说过的，现在你可以跟开启合并请求的人进行会话。 你既可以对某些代码发表评论，也可以对整个提交或整个合并请求发表评论， 在任何地方都可以用 GitHub 风格的 Markdown。</p>
<p>每次有人在合并请求上发表了评论，你都会收到邮件，通知你哪里发生了改变。邮件里面包含一个链接，指向改变的位置，你可以直接在邮件中回复，相当于在合并请求上发表评论。</p>
<p><img src="https://git-scm.com/book/en/v2/images/maint-03-email-resp.png" alt="邮件回复">s</p>
<p>一旦代码符合了你的要求，你想把它合并进来，你可以把代码拉取下来在本地进行合并，也可以用我们之前提到过的 <code>git pull &lt;url&gt; &lt;branch&gt;</code> 语法，或者把 fork 添加为一个 remote，然后进行抓取和合并。</p>
<p>对于很琐碎的合并，你也可以用 GitHub 网站上的 “Merge” 按钮。 它会做一个 “non-fast-forward” 合并，即使可以快进（fast-forward）合并也会产生一个合并提交记录。 就是说无论如何，只要你点击 merge 按钮，就会产生一个合并提交记录。 你可以在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX21lcmdlX2J1dHRvbg==">合并按钮和手工合并一个合并请求的指令.<i class="fa fa-external-link-alt"></i></span> 看到，如果你点击提示链接，GitHub 会给你所有的这些信息。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-02-merge.png" alt="合并按钮"></p>
<p>如果你决定不合并它，你可以把合并请求关掉，开启合并请求的人会收到通知。</p>
<h4 id="合并请求引用"><a href="#合并请求引用" class="headerlink" title="合并请求引用"></a>合并请求引用</h4><p>如果你正在处理 <strong>许多</strong> 合并请求，不想添加一堆 remote 或者每次都要做一次拉取，这里有一个可以在 GitHub 上用的小技巧。 这是有点高级的技巧，但它相当有用，我们会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3JlZnNwZWM=">引用规范<i class="fa fa-external-link-alt"></i></span> 有更多的细节说明。</p>
<p>实际上 GitHub 在服务器上把合并请求分支视为一种 “假分支”。 默认情况下你克隆时不会得到它们，但它们还是隐式地存在，你可以很容易地访问到它们。</p>
<p>为了展示这个，我们要用到一个叫做 <code>ls-remote</code> 的低级命令（通常被叫做“plumbing”， 我们会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3BsdW1iaW5nX3BvcmNlbGFpbg==">底层命令与上层命令<i class="fa fa-external-link-alt"></i></span> 读到更多相关内容）。 这个命令在日常 Git 操作中基本不会用到，但在显示服务器上有哪些引用（reference）时很管用。</p>
<p>如果在我们之前用过的 “blink” 版本库上使用这个命令，我们会得到一个版本库里所有的分支，标签和其它引用（reference）的列表。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git ls-remote https://github.com/schacon/blink</span></span><br><span class="line">10d539600d86723087810ec636870a504f4fee4d	HEAD</span><br><span class="line">10d539600d86723087810ec636870a504f4fee4d	refs/heads/master</span><br><span class="line">6a83107c62950be9453aac297bb0193fd743cd6e	refs/pull/1/head</span><br><span class="line">afe83c2d1a70674c9505cc1d8b7d380d5e076ed3	refs/pull/1/merge</span><br><span class="line">3c8d735ee16296c242be7a9742ebfbc2665adec1	refs/pull/2/head</span><br><span class="line">15c9f4f80973a2758462ab2066b6ad9fe8dcf03d	refs/pull/2/merge</span><br><span class="line">a5a7751a33b7e86c5e9bb07b26001bb17d775d1a	refs/pull/4/head</span><br><span class="line">31a45fc257e8433c8d8804e3e848cf61c9d3166c	refs/pull/4/merge</span><br></pre></td></tr></table></figure>

<p>当然，如果你在你自己的版本库或其它你想检查的远程版本库中使用 <code>git ls-remote origin</code> ，它会显示相似的内容。</p>
<p>如果版本库在 GitHub 上并且有打开的合并请求，你会得到一些以 <code>refs/pull/</code> 开头的引用。 它们实际上是分支，但因为它们不在 <code>refs/heads/</code> 中，所以正常情况下你克隆时不会从服务器上得到它们 ——抓取过程正常情况下会忽略它们。</p>
<p>每个合并请求有两个引用——其中以 <code>/head</code> 结尾的引用指向的提交记录与合并请求分支中的最后一个提交记录是同一个。 所以如果有人在我们的版本库中开启了一个合并请求，他们的分支叫做 <code>bug-fix</code>， 指向 <code>a5a775</code> 这个提交记录，那么在 <strong>我们的</strong> 版本库中我们没有 <code>bug-fix</code> 分支（因为那是在他们的 fork 中）， 但我们 <strong>可以</strong> 有一个 <code>pull/&lt;pr#&gt;/head</code> 指向 <code>a5a775</code>。 这意味着我们可以很容易地拉取每一个合并请求分支而不用添加一堆远程仓库。</p>
<p>现在，你可以像直接抓取引用一样抓取那些分支或提交。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch origin refs/pull/958/head</span></span><br><span class="line">From https://github.com/libgit2/libgit2</span><br><span class="line"> * branch            refs/pull/958/head -&gt; FETCH_HEAD</span><br></pre></td></tr></table></figure>

<p>告诉 Git： “连接到 <code>origin</code> 这个 remote，下载名字为 <code>refs/pull/958/head</code> 的引用。” Git 高高兴兴去执行，下载构建那个引用需要的所有内容，然后把指针指向 <code>.git/FETCH_HEAD</code> 下面你想要的提交记录。 然后你可以用 <code>git merge FETCH_HEAD</code> 把它合并到你想进行测试的分支，但那个合并的提交信息看起来有点怪。 然而，如果你需要审查 <strong>一大批</strong> 合并请求，这样操作会很麻烦。</p>
<p>还有一种方法可以抓取 <em>所有的</em> 合并请求，并且在你连接到远程仓库的时候保持更新。 用你最喜欢的编辑器打开 <code>.git/config</code> ，查找 <code>origin</code> 远程仓库。 看起来差不多像下面这样：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[remote &quot;origin&quot;]</span></span><br><span class="line">    <span class="attr">url</span> = https://github.com/libgit2/libgit2</span><br><span class="line">    <span class="attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure>

<p>以 <code>fetch =</code> 开头的行是一个 “refspec.” 它是一种把 remote 的名称映射到你本地 <code>.git</code> 目录的方法。 这一条（就是上面的这一条）告诉 Git，“remote 上 <code>refs/heads</code> 下面的内容在我本地版本库中都放在 <code>refs/remotes/origin</code> 。” 你可以把这一段修改一下，添加另一个 refspec：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[remote &quot;origin&quot;]</span></span><br><span class="line">    <span class="attr">url</span> = https://github.com/libgit2/libgit2.git</span><br><span class="line">    <span class="attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">    <span class="attr">fetch</span> = +refs/pull/*/head:refs/remotes/origin/pr/*</span><br></pre></td></tr></table></figure>

<p>最后一行告诉 Git： “所有看起来像 <code>refs/pull/123/head</code> 的引用应该在本地版本库像 <code>refs/remotes/origin/pr/123</code> 一样存储” 现在，如果你保存那个文件，执行 <code>git fetch</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">…</span></span><br><span class="line"> * [new ref]         refs/pull/1/head -&gt; origin/pr/1</span><br><span class="line"> * [new ref]         refs/pull/2/head -&gt; origin/pr/2</span><br><span class="line"> * [new ref]         refs/pull/4/head -&gt; origin/pr/4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">…</span></span><br></pre></td></tr></table></figure>

<p>现在所有的合并请求在本地像分支一样展现，它们是只读的，当你执行抓取时它们也会更新。 这让在本地测试合并请求中的代码变得超级简单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout <span class="built_in">pr</span>/2</span></span><br><span class="line">Checking out files: 100% (3769/3769)， done.</span><br><span class="line">Branch pr/2 set up to track remote branch pr/2 from origin.</span><br><span class="line">Switched to a new branch &#x27;pr/2&#x27;</span><br></pre></td></tr></table></figure>

<p>你的鹰眼系统会发现在 refspec 的 remote 部分的结尾有个 <code>head</code> 。 在 GitHub 那边也有一个 <code>refs/pull/#/merge</code> 引用，它代表的是如果你在网站上按了 “merge” 按钮对应的提交记录。 这甚至让你可以在按按钮之前就测试这个合并。</p>
<h4 id="合并请求之上的合并请求"><a href="#合并请求之上的合并请求" class="headerlink" title="合并请求之上的合并请求"></a>合并请求之上的合并请求</h4><p>你不仅可以在主分支或者说 <code>master</code> 分支上开启合并请求，实际上你可以在网络上的任何一个分支上开启合并请求。 其实，你甚至可以在另一个合并请求上开启一个合并请求。</p>
<p>如果你看到一个合并请求在向正确的方向发展，然后你想在这个合并请求上做一些修改或者你不太确定这是个好主意，或者你没有目标分支的推送权限，你可以直接在合并请求上开启一个合并请求。</p>
<p>当你开启一个合并请求时，在页面的顶端有一个框框显示你要合并到哪个分支和你从哪个分支合并过来的。 如果你点击那个框框右边的 “Edit” 按钮，你不仅可以改变分支，还可以选择哪个 fork。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-04-target.png" alt="合并目标"></p>
<p>这里你可以很简单地指明合并你的分支到哪一个合并请求或 fork。</p>
<h3 id="提醒和通知"><a href="#提醒和通知" class="headerlink" title="提醒和通知"></a>提醒和通知</h3><p>GitHub 内置了一个很好的通知系统，当你需要与别人或别的团队交流时用起来很方便。</p>
<p>在任何评论中你可以先输入一个 <code>@</code> ，系统会自动补全项目中合作者或贡献者的名字和用户名。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-05-mentions.png" alt="提醒"></p>
<p>你也可以提醒不在列表中的用户，但是通常自动补全用起更快。</p>
<p>当你发布了一个带用户提醒的评论，那个用户会收到通知。 这意味着把人们拉进会话中要比让他们投票有效率得多。 对于 GitHub 上的合并请求，人们经常把他们团队或公司中的其它人拉来审查问题或合并请求。</p>
<p>如果有人收到了合并请求或问题的提醒，他们会“订阅”它，后面有新的活动发生他们都会持续收到提醒。 如果你是合并请求或者问题的发起方你也会被订阅上，比如你在关注一个版本库或者你评论了什么东西。 如果你不想再收到提醒，在页面上有个 “Unsubscribe” 按钮，点一下就不会再收到更新了。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-06-unsubscribe.png" alt="取消订阅"></p>
<h3 id="通知页面"><a href="#通知页面" class="headerlink" title="通知页面"></a>通知页面</h3><p>当我们在这提到特指 GitHub 的 “notifications” ，指的是当 GitHub 上有事件发生时，它通知你的方式，这里有几种不同的方式来配置它们。 如果你打开配置页面的 “Notification center” 标签，你可以看到一些选项。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-07-notifications.png" alt="通知中心"></p>
<p>有两个选项，通过“邮件（Email）”和通过“网页（Web）”，你可以选用一个或者都不选或者都选。</p>
<h3 id="网页通知"><a href="#网页通知" class="headerlink" title="网页通知"></a>网页通知</h3><p>网页通知只在 GitHub 上存在，你也只能在 GitHub 上查看。 如果你打开了这个选项并且有一个你的通知，你会在你屏幕上方的通知图标上看到一个小蓝点。参见 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX25vdF9jZW50ZXI=">通知中心.<i class="fa fa-external-link-alt"></i></span>。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-08-notifications-page.png" alt="通知中心"></p>
<p>如果你点击那个玩意儿，你会看到你被通知到的所有条目，按照项目分好了组。 你可以点击左边栏的项目名字来过滤项目相关的通知。 你可以点击通知旁边的对号图标把通知标为已读，或者点击组上面的图标把项目中 <strong>所有的</strong> 通知标为已读。 在每个对号图标旁边都有一个静音按钮，你可以点一下，以后就不会收到它相关的通知。</p>
<p>所有这些工具对于处理大量通知非常有用。 很多 GitHub 资深用户都关闭邮件通知，在这个页面上处理他们所有的通知。</p>
<h3 id="邮件通知-1"><a href="#邮件通知-1" class="headerlink" title="邮件通知"></a>邮件通知</h3><p>邮件通知是你处理 GitHub 通知的另一种方式。 如果你打开这个选项，每当有通知时，你会收到一封邮件。 我们在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2VtYWlsX25vdGlmaWNhdGlvbg==">通过电子邮件发送的评论提醒<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2VtYWlsX3By">新的合并请求的邮件通知.<i class="fa fa-external-link-alt"></i></span> 看到了一些例子。 邮件也会被合适地按话题组织在一起，如果你使用一个具有会话功能的邮件客户端那会很方便。</p>
<p>GitHub 在发送给你的邮件头中附带了很多元数据，这对于设置过滤器和邮件规则非常有帮助。</p>
<p>举个例子，我们来看一看在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2VtYWlsX3By">新的合并请求的邮件通知.<i class="fa fa-external-link-alt"></i></span> 中发给 Tony 的一封真实邮件的头部，我们会看到下面这些：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">To: tonychacon/fade &lt;fade@noreply.github.com&gt;</span><br><span class="line">Message-ID: &lt;tonychacon/fade/pull/1@github.com&gt;</span><br><span class="line">Subject: [fade] Wait longer to see the dimming effect better (#1)</span><br><span class="line">X-GitHub-Recipient: tonychacon</span><br><span class="line">List-ID: tonychacon/fade &lt;fade.tonychacon.github.com&gt;</span><br><span class="line">List-Archive: https://github.com/tonychacon/fade</span><br><span class="line">List-Post: &lt;mailto:reply+i-4XXX@reply.github.com&gt;</span><br><span class="line">List-Unsubscribe: &lt;mailto:unsub+i-XXX@reply.github.com&gt;，...</span><br><span class="line">X-GitHub-Recipient-Address: tchacon@example.com</span><br></pre></td></tr></table></figure>

<p>这里有一些有趣的东西。如果你想高亮或者转发这个项目甚至这个合并请求相关的邮件， <code>Message-ID</code> 中的信息会以<code>&lt;user&gt;/&lt;project&gt;/&lt;type&gt;/&lt;id&gt;</code> 的格式展现所有的数据。 例如，如果这是一个问题（issue），那么 <code>&lt;type&gt;</code> 字段就会是 “issues” 而不是 “pull” 。</p>
<p><code>List-Post</code> 和 <code>List-Unsubscribe</code> 字段表示如果你的邮件客户端能够处理这些，那么你可以很容易地在列表中发贴或取消对这个相关帖子的订阅。 那会很有效率，就像在页面中点击静音按钮或在问题&#x2F;合并请求页面点击 “Unsubscribe” 一样。</p>
<p>值得注意的是，如果你同时打开了邮件和网页通知，那么当你在邮件客户端允许加载图片的情况下阅读邮件通知时，对应的网页通知也将会同时被标记为已读。</p>
<h3 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h3><p>如果你的版本库中有一些特殊文件，GitHub 会提醒你。</p>
<h3 id="README"><a href="#README" class="headerlink" title="README"></a>README</h3><p>第一个就是 <code>README</code> 文件，可以是几乎任何 GitHub 可以识别的格式。 例如，它可以是 <code>README</code> ，<code>README.md</code> ， <code>README.asciidoc</code> 。 如果 GitHub 在你的版本库中找到 README 文件，会把它在项目的首页渲染出来。</p>
<p>很多团队在这个文件里放版本库或项目新人需要了解的所有相关的信息。 它一般包含这些内容：</p>
<ul>
<li>该项目的作用</li>
<li>如何配置与安装</li>
<li>有关如何使用和运行的例子</li>
<li>项目的许可证</li>
<li>如何向项目贡献力量</li>
</ul>
<p>因为 GitHub 会渲染这个文件，你可以在文件里植入图片或链接让它更容易理解。</p>
<h3 id="贡献-CONTRIBUTING"><a href="#贡献-CONTRIBUTING" class="headerlink" title="贡献 CONTRIBUTING"></a>贡献 CONTRIBUTING</h3><p>另一个 GitHub 可以识别的特殊文件是 <code>CONTRIBUTING</code> 。 如果你有一个任意扩展名的 <code>CONTRIBUTING</code> 文件，当有人开启一个合并请求时 GitHub 会显示 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2NvbnRyaWJfZmlsZQ==">开启合并请求时有 CONTRIBUTING 文件存在.<i class="fa fa-external-link-alt"></i></span>。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-09-contrib.png" alt="贡献注意事项"></p>
<p>这个的作用就是你可以在这里指出对于你的项目开启的合并请求你想要的／不想要的各种事情。 这样别人在开启合并请求之前可以读到这些指导方针。</p>
<h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p>对于一个单个项目其实没有很多管理事务要做，但也有几点有趣的。</p>
<h4 id="改变默认分支"><a href="#改变默认分支" class="headerlink" title="改变默认分支"></a>改变默认分支</h4><p>如果你想用 “master” 之外的分支作为你的默认分支，其他人将默认会在这个分支上开启合并请求或进行浏览，你可以在你版本库的设置页面的 “options” 标签下修改。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-10-default-branch.png" alt="默认分支"></p>
<p>简单地改变默认分支下拉列表中的选项，它就会作为所有主要操作的默认分支，他人进行克隆时该分支也将被默认检出。</p>
<h4 id="移交项目"><a href="#移交项目" class="headerlink" title="移交项目"></a>移交项目</h4><p>如果你想把一个项目移交给 GitHub 中的另一个人或另一个组织，还是设置页面的这个 “options” 标签下有一个 “Transfer ownership” 选项可以用来干这个。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/maint-11-transfer.png" alt="移交"></p>
<p>当你正准备放弃一个项目且正好有别人想要接手时，或者你的项目壮大了想把它移到一个组织里时，这就管用了。</p>
<p>这么做不仅会把版本库连带它所有的关注者和星标数都移到另一个地方，它还会将你的 URL 重定向到新的位置。 它也重定向了来自 Git 的克隆和抓取，而不仅仅是网页端请求。</p>
<h2 id="管理组织"><a href="#管理组织" class="headerlink" title="管理组织"></a>管理组织</h2><p>除了个人帐户之外，GitHub 还提供被称为组织（Organizations）的帐户。 组织账户和个人账户一样都有一个用于存放所拥有项目的命名空间，但是许多其他的东西都是不同的。 组织帐户代表了一组共同拥有多个项目的人，同时也提供一些工具用于对成员进行分组管理。 通常，这种账户被用于开源群组（例如：“perl”或者“rails”），或者公司（例如：“google”或者“twitter”）。</p>
<h3 id="组织的基本知识"><a href="#组织的基本知识" class="headerlink" title="组织的基本知识"></a>组织的基本知识</h3><p>我们可以很简单地创建一个组织，只需要点击任意 GitHub 页面右上角的“+”图标，在菜单中选择“New organization”即可。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/neworg.png" alt="“New organization”菜单项"></p>
<p>首先你必须提供组织的名称和组织的主要联系邮箱。 然后，如果你希望的话，也可以邀请其他用户作为共同拥有人。</p>
<p>完成以上步骤后，你就会拥有一个全新的组织。 类似于个人帐户，如果组织的所有内容都是开源的，那么你就可以免费使用这个组织。</p>
<p>作为一个组织的拥有者，当你在派生一个版本库的时候，你可以选择把它派生到你的组织的命名空间内。 当你新建版本库时，你可以把它存放到你的个人帐户或你拥有的组织内。 同时，你也会自动地“关注”所有这些组织内的新版本库。</p>
<p>就像<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3BlcnNvbmFsX2F2YXRhcg==">头像<i class="fa fa-external-link-alt"></i></span>，你可以为你的组织上传头像，使它更个性化。 同时，也和个人帐户类似，组织会有一个着陆页（landing page），用于列出该组织所有的版本库，并且该页面可供所有人浏览。</p>
<p>下面我们来说一些组织和个人帐户不同的地方。</p>
<h3 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h3><p>组织使用团队（Teams）来管理成员，团队就是组织中的一组个人账户和版本库，以及团队成员对这些版本库的访问权限。</p>
<p>例如，假设你的公司有三个版本库：<code>frontend</code>、<code>backend</code> 和 <code>deployscripts</code>。 你会希望你的 HTML&#x2F;CSS&#x2F;Javascript 开发者有 <code>frontend</code> 或者 <code>backend</code> 的访问权限，操作人员有 <code>backend</code> 和 <code>deployscripts</code> 的访问权限。 团队让这个任务变得更简单，而不用为每个版本库管理它的协作者。</p>
<p>组织页面主要由一个面板（dashboard）构成，这个仪表盘包含了这个组织内的所有版本库，用户和团队。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/orgs-01-page.png" alt="组织页面"></p>
<p>你可以点击 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX29yZ19wYWdl">组织页面<i class="fa fa-external-link-alt"></i></span> 右边的团队侧边栏（Teams）来管理你的团队。 点击之后，你会进入一个新页面，在这里你可以添加新成员和版本库到团队中，或者管理团队的访问权限和其它设置。 每个团队对于版本库可以有只读、读写和管理三种权限。 你可以通过点击在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3RlYW1fcGFnZQ==">团队页面<i class="fa fa-external-link-alt"></i></span> 内的 “Settings” 按钮更改相应权限等级。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/orgs-02-teams.png" alt="团队页面"></p>
<p>当你邀请一个用户加入团队，该用户会收到一封通知他被邀请的邮件。</p>
<p>除此之外，团队也类似于个人帐户，有 <code>@mentions</code>（例如：<code>@acmecorp/frontend</code>）的功能，不同之处就在于被提及的团队内 <strong>所有</strong> 成员都会成为这个话题的订阅者。 当你希望得到团队中某个人的关注，又不知道具体应该问谁的时候，这个功能就显得很有帮助。</p>
<p>一个用户可以加入任意数量的团队，所以别把自己局限于拥有访问控制的团队。 对于某一类课题，像 <code>ux</code>, <code>css</code> 或者 <code>refactoring</code> 这样有着特殊关注点的团队就显得很有帮助，而像 <code>legal</code> 和 <code>colorblind</code> 这样的就完全是针对它们各自领域的。</p>
<h3 id="审计日志"><a href="#审计日志" class="headerlink" title="审计日志"></a>审计日志</h3><p>组织的拥有者还可以访问组织中发生的事情的所有信息。 在 ‘Audit Log’ 标签页有整个组织的日志，你可以看到谁在世界上哪个地方做了什么事。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/orgs-03-audit.png" alt="orgs 03 audit"></p>
<p>你也可以通过选定某一类型的事件、某个地方、某个人对日志进行过滤。</p>
<h2 id="脚本-GitHub"><a href="#脚本-GitHub" class="headerlink" title="脚本 GitHub"></a>脚本 GitHub</h2><p>所以现在我们已经介绍了 GitHub 的大部分功能与工作流程，但是任意一个小组或项目都会去自定义，因为他们想要创造或扩展想要整合的服务。</p>
<p>对我们来说很幸运的是，GitHub 在许多方面都真的很方便 Hack。 在本节中我们将会介绍如何使用 GitHub 钩子系统与 API 接口，使 GitHub 按照我们的设想来工作。</p>
<h3 id="服务与钩子"><a href="#服务与钩子" class="headerlink" title="服务与钩子"></a>服务与钩子</h3><p>GitHub 仓库管理中的钩子与服务区块是 GitHub 与外部系统交互最简单的方式。</p>
<h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>首先我们来看一下服务。 钩子与服务整合都可以在仓库的设置区块中找到，就在我们之前添加协作者与改变项目的默认分支的地方。 在 “Webhooks and Services” 标签下你会看到与 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3NlcnZpY2VzX2hvb2tz">服务与钩子配置区域<i class="fa fa-external-link-alt"></i></span> 类似的内容。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-01-services.png" alt="服务与钩子"></p>
<p>有许多可以选择的服务，大多数是整合到其他的商业与开源系统中。 它们中的大多数是为了整合持续集成服务、BUG 与问题追踪系统、聊天室系统与文档系统。 我们将会通过设置一个非常简单的例子来介绍。 如果从 “Add Service” 选择 “email”，会得到一个类似 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3NlcnZpY2VfY29uZmln">电子邮件服务配置<i class="fa fa-external-link-alt"></i></span> 的配置屏幕。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-02-email-service.png" alt="电子邮件服务"></p>
<p>在本例中，如果我们点击 “Add service” 按钮，每次有人推送内容到仓库时，指定的电子邮件地址都会收到一封邮件。 服务可以监听许多不同类型的事件，但是大多数只监听推送事件然后使用那些数据做一些事情。</p>
<p>如果有一个正在使用的系统想要整合到 GitHub，应当先检查这里看有没有已有的可用的服务整合。 例如，如果正使用 Jenkins 来测试你的代码库，当每次有人推送到你的仓库时你可以启用 Jenkins 内置的整合启动测试运行。</p>
<h4 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h4><p>如果需要做一些更具体的事，或者想要整合一个不在这个列表中的服务或站点，可以转而使用更通用的钩子系统。 GitHub 仓库钩子是非常简单的。 指定一个 URL 然后 GitHub 在任一期望的事件发生时就会发送一个 HTTP 请求到那个 URL 。</p>
<p>通常做这件事的方式是可以设置一个小的 web 服务来监听 GitHub 钩子请求然后使用收到的数据做一些事情。</p>
<p>为了启用一个钩子，点击 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3NlcnZpY2VzX2hvb2tz">服务与钩子配置区域<i class="fa fa-external-link-alt"></i></span> 中的 “Add webhook” 按钮。 这会将你引导至一个类似 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3dlYl9ob29r">Web 钩子配置<i class="fa fa-external-link-alt"></i></span> 的页面。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-03-webhook.png" alt="Web 钩子配置"></p>
<p>Web 钩子的设置非常简单。 大多数情况下只需要输入一个 URL 与一个密钥然后点击 “Add webhook”。 有几个选项可以指定在哪个事件时想要 GitHub 发送请求—— 默认的行为是只有当某人推送新代码到仓库的任一分支时的 <code>push</code> 事件获得一个请求。</p>
<p>让我们看一个设置处理 web 钩子的 web 服务的小例子。 我们将会使用 Ruby web 框架 Sinatra，因为它相当简洁，应该能够轻松地看到我们正在做什么。</p>
<p>假设我们想要在某个特定的人推送到我们的项目的特定分支并修改一个特定文件时得到一封邮件。 我们可以相当容易地使用类似下面的代码做到：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;sinatra&#x27;</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;json&#x27;</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;mail&#x27;</span></span><br><span class="line"></span><br><span class="line">post <span class="string">&#x27;/payload&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  push = <span class="variable constant_">JSON</span>.parse(request.body.read) <span class="comment"># parse the JSON</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># gather the data we&#x27;re looking for</span></span><br><span class="line">  pusher = push[<span class="string">&quot;pusher&quot;</span>][<span class="string">&quot;name&quot;</span>]</span><br><span class="line">  branch = push[<span class="string">&quot;ref&quot;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># get a list of all the files touched</span></span><br><span class="line">  files = push[<span class="string">&quot;commits&quot;</span>].map <span class="keyword">do</span> |<span class="params">commit</span>|</span><br><span class="line">    commit[<span class="string">&#x27;added&#x27;</span>] + commit[<span class="string">&#x27;modified&#x27;</span>] + commit[<span class="string">&#x27;removed&#x27;</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  files = files.flatten.uniq</span><br><span class="line"></span><br><span class="line">  <span class="comment"># check for our criteria</span></span><br><span class="line">  <span class="keyword">if</span> pusher == <span class="string">&#x27;schacon&#x27;</span> &amp;&amp;</span><br><span class="line">     branch == <span class="string">&#x27;ref/heads/special-branch&#x27;</span> &amp;&amp;</span><br><span class="line">     files.<span class="keyword">include</span>?(<span class="string">&#x27;special-file.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Mail</span>.deliver <span class="keyword">do</span></span><br><span class="line">      from     <span class="string">&#x27;tchacon@example.com&#x27;</span></span><br><span class="line">      to       <span class="string">&#x27;tchacon@example.com&#x27;</span></span><br><span class="line">      subject  <span class="string">&#x27;Scott Changed the File&#x27;</span></span><br><span class="line">      body     <span class="string">&quot;ALARM&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这里我们拿到一个 GitHub 传送给我们的 JSON 请求然后查找推送者，他们推送到了什么分支以及推送的所有提交都改动了哪些文件。 然后我们检查它是否与我们的条件区配，如果匹配则发送一封邮件。</p>
<p>为了开发与测试类似这样的东西，在设置钩子的地方有一个漂亮的开发者控制台。 可以看到 GitHub 为那个 webhook 的最后几次请求。 对每一个钩子，当它发送后都可以深入挖掘，检测它是否是成功的与请求及回应的消息头与消息体。 这使得测试与调试钩子非常容易。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-04-webhook-debug.png" alt="Web 钩子调试信息"></p>
<p>开发者控制台的另一个很棒的功能是可以轻松地重新发送任何请求来测试你的服务。</p>
<p>关于如何编写 web 钩子与所有可监听的不同事件类型的更多信息，请访问在 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vZGV2ZWxvcGVycy93ZWJob29rcy1hbmQtZXZlbnRzL3dlYmhvb2tzL2Fib3V0LXdlYmhvb2tz">https://docs.github.com/cn/developers/webhooks-and-events/webhooks/about-webhooks<i class="fa fa-external-link-alt"></i></span> 的 GitHub 开发者文档。</p>
<h3 id="GitHub-API"><a href="#GitHub-API" class="headerlink" title="GitHub API"></a>GitHub API</h3><p>服务与钩子给你提供了一种方式来接收关于在仓库中发生的事件的推送通知，但是如何获取相关事件的详情呢？ 如何自动化一些诸如添加协作者或给问题加标签的事情呢？</p>
<p>这是 GitHub API 派上用场的地方。 在自动化流行的趋势下，GitHub 提供了大量的 API 接口，可以进行几乎任何能在网站上进行的操作。 在本节中我们将会学习如何授权与连接到 API，如何通过 API 在一个问题上评论与如何修改一个 Pull Request 的状态。</p>
<h3 id="基本用途"><a href="#基本用途" class="headerlink" title="基本用途"></a>基本用途</h3><p>可以做的最基本的事情是向一个不需要授权的接口上发送一个简单的 GET 请求。 该接口可能是一个用户或开源项目的只读信息。 例如，如果我们想要知道更多关于名为 “schacon” 的用户信息，我们可以运行类似下面的东西：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="attr">https</span>:<span class="comment">//api.github.com/users/schacon</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;login&quot;</span>: <span class="string">&quot;schacon&quot;</span>,</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: <span class="number">70</span>,</span><br><span class="line">  <span class="string">&quot;avatar_url&quot;</span>: <span class="string">&quot;https://avatars.githubusercontent.com/u/70&quot;</span>,</span><br><span class="line"># …</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Scott Chacon&quot;</span>,</span><br><span class="line">  <span class="string">&quot;company&quot;</span>: <span class="string">&quot;GitHub&quot;</span>,</span><br><span class="line">  <span class="string">&quot;following&quot;</span>: <span class="number">19</span>,</span><br><span class="line">  <span class="string">&quot;created_at&quot;</span>: <span class="string">&quot;2008-01-27T17:19:28Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;updated_at&quot;</span>: <span class="string">&quot;2014-06-10T02:37:23Z&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有大量类似这样的接口来获得关于组织、项目、问题、提交的信息 — 差不多就是你能在 GitHub 上看到的所有东西。 甚至可以使用 API 来渲染任意 Markdown 或寻找一个 <code>.gitignore</code> 模板。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="attr">https</span>:<span class="comment">//api.github.com/gitignore/templates/Java</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Java&quot;</span>,</span><br><span class="line">  <span class="string">&quot;source&quot;</span>: <span class="string">&quot;*.class</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Mobile Tools for Java (J2ME)</span></span><br><span class="line"><span class="string">.mtj.tmp/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Package Files #</span></span><br><span class="line"><span class="string">*.jar</span></span><br><span class="line"><span class="string">*.war</span></span><br><span class="line"><span class="string">*.ear</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># virtual machine crash logs, see https://www.java.com/en/download/help/error_hotspot.xml</span></span><br><span class="line"><span class="string">hs_err_pid*</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在一个问题上评论"><a href="#在一个问题上评论" class="headerlink" title="在一个问题上评论"></a>在一个问题上评论</h3><p>然而，如果想要在网站上进行一个操作，如在 Issue 或 Pull Request 上评论，或者想要查看私有内容或与其交互，你需要授权。</p>
<p>这里提供了几种授权方式。 你可以使用仅需用户名与密码的基本授权，但是通常更好的主意是使用一个个人访问令牌。 可以从设置页的 “Applications” 标签生成访问令牌。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-05-access-token.png" alt="访问令牌"></p>
<p>它会询问这个令牌的作用域与一个描述。 确保使用一个好的描述信息，这样当脚本或应用不再使用时你会很放心地移除。</p>
<p>GitHub 只会显示令牌一次，所以记得一定要拷贝它。 现在可以在脚本中使用它代替使用用户名写密码来授权。 这很漂亮，因为可以限制想要做的范围并且令牌是可废除的。</p>
<p>这也会有一个提高频率上限的附加优点。 如果没有授权的话，你会被限制在一小时最多发起 60 次请求。 如果授权则可以一小时最多发起 5000 次请求。</p>
<p>所以让我们利用它来对我们的其中一个问题进行评论。 想要对一个特定问题 Issue #6 留下一条评论。 必须使用刚刚生成的令牌作为 Authorization 头信息，发送一个到 <code>repos/&lt;user&gt;/&lt;repo&gt;/issues/&lt;num&gt;/comments</code> 的 HTTP POST 请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">       -H <span class="string">&quot;Authorization: token TOKEN&quot;</span> \</span><br><span class="line">       --data <span class="string">&#x27;&#123;&quot;body&quot;:&quot;A new comment, :+1:&quot;&#125;&#x27;</span> \</span><br><span class="line">       <span class="attr">https</span>:<span class="comment">//api.github.com/repos/schacon/blink/issues/6/comments</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: <span class="number">58322100</span>,</span><br><span class="line">  <span class="string">&quot;html_url&quot;</span>: <span class="string">&quot;https://github.com/schacon/blink/issues/6#issuecomment-58322100&quot;</span>,</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;login&quot;</span>: <span class="string">&quot;tonychacon&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">7874698</span>,</span><br><span class="line">    <span class="string">&quot;avatar_url&quot;</span>: <span class="string">&quot;https://avatars.githubusercontent.com/u/7874698?v=2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;User&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;created_at&quot;</span>: <span class="string">&quot;2014-10-08T07:48:19Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;updated_at&quot;</span>: <span class="string">&quot;2014-10-08T07:48:19Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;A new comment, :+1:&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在如果进入到那个问题，可以看到我们刚刚发布的评论，像 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2FwaV9jb21tZW50">从 GitHub API 发布的一条评论<i class="fa fa-external-link-alt"></i></span> 一样。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-06-comment.png" alt="API 评论"></p>
<p>可以使用 API 去做任何可以在网站上做的事情 — 创建与设置里程碑、指派人员到 Issues 与 Pull Requests，创建与修改标签、访问提交数据、创建新的提交与分支、打开关闭或合并 Pull Requests、创建与编辑团队、在 Pull Request 中评论某行代码、搜索网站等等。</p>
<h3 id="修改-Pull-Request-的状态"><a href="#修改-Pull-Request-的状态" class="headerlink" title="修改 Pull Request 的状态"></a>修改 Pull Request 的状态</h3><p>我们要看最后一个例子在使用拉取请求时非常有用。 每一个提交可以有一个或多个与它关联的状态，有 API 来添加与查询状态。</p>
<p>大多数持续集成与测试服务通过测试推送的代码后使用这个 API 来回应，然后报告提交是否通过了全部测试。 你也可以使用该接口来检查提交信息是否经过合适的格式化、提交者是否遵循了所有你的贡献准则、提交是否经过有效的签名 — 种种这类事情。</p>
<p>假设在仓库中设置了一个 web 钩子访问一个用来检查提交信息中的 <code>Signed-off-by</code> 字符串的小的 web 服务。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;httparty&#x27;</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;sinatra&#x27;</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;json&#x27;</span></span><br><span class="line"></span><br><span class="line">post <span class="string">&#x27;/payload&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  push = <span class="variable constant_">JSON</span>.parse(request.body.read) <span class="comment"># parse the JSON</span></span><br><span class="line">  repo_name = push[<span class="string">&#x27;repository&#x27;</span>][<span class="string">&#x27;full_name&#x27;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># look through each commit message</span></span><br><span class="line">  push[<span class="string">&quot;commits&quot;</span>].each <span class="keyword">do</span> |<span class="params">commit</span>|</span><br><span class="line"></span><br><span class="line">    <span class="comment"># look for a Signed-off-by string</span></span><br><span class="line">    <span class="keyword">if</span> /<span class="title class_">Signed</span>-off-by/.match commit[<span class="string">&#x27;message&#x27;</span>]</span><br><span class="line">      state = <span class="string">&#x27;success&#x27;</span></span><br><span class="line">      description = <span class="string">&#x27;Successfully signed off!&#x27;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      state = <span class="string">&#x27;failure&#x27;</span></span><br><span class="line">      description = <span class="string">&#x27;No signoff found.&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># post status to GitHub</span></span><br><span class="line">    sha = commit[<span class="string">&quot;id&quot;</span>]</span><br><span class="line">    status_url = <span class="string">&quot;https://api.github.com/repos/<span class="subst">#&#123;repo_name&#125;</span>/statuses/<span class="subst">#&#123;sha&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    status = &#123;</span><br><span class="line">      <span class="string">&quot;state&quot;</span>       =&gt; state,</span><br><span class="line">      <span class="string">&quot;description&quot;</span> =&gt; description,</span><br><span class="line">      <span class="string">&quot;target_url&quot;</span>  =&gt; <span class="string">&quot;http://example.com/how-to-signoff&quot;</span>,</span><br><span class="line">      <span class="string">&quot;context&quot;</span>     =&gt; <span class="string">&quot;validate/signoff&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">HTTParty</span>.post(status_url,</span><br><span class="line">      <span class="symbol">:body</span> =&gt; status.to_json,</span><br><span class="line">      <span class="symbol">:headers</span> =&gt; &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>  =&gt; <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>    =&gt; <span class="string">&#x27;tonychacon/signoff&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Authorization&#x27;</span> =&gt; <span class="string">&quot;token <span class="subst">#&#123;<span class="variable constant_">ENV</span>[<span class="string">&#x27;TOKEN&#x27;</span>]&#125;</span>&quot;</span> &#125;</span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>希望这相当容易做。 在这个 web 钩子处理器中我们浏览刚刚推送上来的每一个提交，在提交信息中查找字符串 ‘Signed-off-by’ 并且最终使用 HTTP 向 <code>/repos/&lt;user&gt;/&lt;repo&gt;/statuses/&lt;commit_sha&gt;</code> API 接口发送一个带有状态的 POST 请求。</p>
<p>在本例中可以发送一个状态（’success’, ‘failure’, ‘error’）、一个发生了什么的描述信息、 一个用户可以了解更多信息的目标 URL 与一个 “context” 以防一个单独的提交有多个状态。 例如，一个测试服务可以提供一个状态与一个类似这样的验证服务也可能提供一个状态 — “context” 字段是用来区别它们的。</p>
<p>如果某人在 GitHub 中打开了一个新的拉取请求并且这个钩子已经设置，会看到类似 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2NvbW1pdF9zdGF0dXM=">通过 API 的提交状态<i class="fa fa-external-link-alt"></i></span> 的信息。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/scripting-07-status.png" alt="提交状态"></p>
<p>现在可以看到一个小的绿色对勾标记在提交信息中有 “Signed-off-by” 的提交旁边，红色的对勾标记在作者忘记签名的提交旁边。 也可以看到 Pull Request 显示在那个分支上的最后提交的状态，如果失败的话会警告你。 如果对测试结果使用这个 API 那么就不会不小心合并某些未通过测试的最新提交。</p>
<h3 id="Octokit"><a href="#Octokit" class="headerlink" title="Octokit"></a>Octokit</h3><p>尽管我们在这些例子中都是通过 <code>curl</code> 与基本的 HTTP 请求来做几乎所有的事情，还有一些以更自然的方式利用 API 的开源库存在着。 在写这篇文章的时候，被支持的语言包括 Go、Objective-C、Ruby 与 .NET。 访问 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29jdG9raXQ=">https://github.com/octokit<i class="fa fa-external-link-alt"></i></span> 了解更多相关信息，它们帮你处理了更多 HTTP 相关的内容。</p>
<p>希望这些工具能帮助你自定义与修改 GitHub 来更好地为特定的工作流程工作。 关于全部 API 的完整文档与常见任务的指南，请查阅 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24lRTMlODAlODI=">https://docs.github.com/cn。<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="Git-工具"><a href="#Git-工具" class="headerlink" title="Git 工具"></a>Git 工具</h1><p>这些功能你可能并不会在日常操作中使用，但在某些时候你可能会需要。</p>
<h2 id="选择修订版本"><a href="#选择修订版本" class="headerlink" title="选择修订版本"></a>选择修订版本</h2><p>Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。</p>
<h3 id="单个修订版本"><a href="#单个修订版本" class="headerlink" title="单个修订版本"></a>单个修订版本</h3><p>你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。</p>
<h3 id="简短的-SHA-1"><a href="#简短的-SHA-1" class="headerlink" title="简短的 SHA-1"></a>简短的 SHA-1</h3><p>Git 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。</p>
<p>例如，要查看你知道其中添加了某个功能的提交，首先运行 <code>git log</code> 命令来定位该提交：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit 734713bc047d87bf7eac9674765ae793478c50d3</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri Jan 2 18:32:33 2009 -0800</span><br><span class="line"></span><br><span class="line">    fixed refs handling, added gc auto, updated tests</span><br><span class="line"></span><br><span class="line">commit d921970aadf03b3cf0e71becdaab3147ba71cdef</span><br><span class="line">Merge: 1c002dd... 35cfb2b...</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 15:08:43 2008 -0800</span><br><span class="line"></span><br><span class="line">    Merge commit &#x27;phedders/rdocs&#x27;</span><br><span class="line"></span><br><span class="line">commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 14:58:32 2008 -0800</span><br><span class="line"></span><br><span class="line">    added some blame and merge stuff</span><br></pre></td></tr></table></figure>

<p>在本例中，假设你想要的提交其 SHA-1 以 <code>1c002dd….</code> 开头， 那么你可以用如下几种 <code>git show</code> 的变体来检视该提交（假设简短的版本没有歧义）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show 1c002dd4b536e7479f</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show 1c002d</span></span><br></pre></td></tr></table></figure>

<p>Git 可以为 SHA-1 值生成出简短且唯一的缩写。 如果你在 <code>git log</code> 后加上 <code>--abbrev-commit</code> 参数，输出结果里就会显示简短且唯一的值； 默认使用七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --abbrev-commit --pretty=oneline</span></span><br><span class="line">ca82a6d changed the version number</span><br><span class="line">085bb3b removed unnecessary test code</span><br><span class="line">a11bef0 first commit</span><br></pre></td></tr></table></figure>

<p>通常 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的歧义。 例如，到 2019 年 2 月为止，Linux 内核这个相当大的 Git 项目， 其对象数据库中有超过 875,000 个提交，包含七百万个对象，也只需要前 12 个字符就能保证唯一性。</p>
<blockquote>
<p>关于 SHA-1 的简短说明</p>
<p>许多人觉得他们的仓库里有可能出现两个不同的对象其 SHA-1 值相同。 然后呢？</p>
<p>如果你真的向仓库里提交了一个对象，它跟之前的某个 <strong>不同</strong> 对象的 SHA-1 值相同， Git 会发现该对象的散列值已经存在于仓库里了，于是就会认为该对象被写入，然后直接使用它。 如果之后你想检出那个对象时，你将得到先前那个对象的数据。</p>
<p>但是这种情况发生的概率十分渺小。 SHA-1 摘要长度是 20 字节，也就是 160 位。 2^80 个随机哈希对象才有 50% 的概率出现一次冲突 （计算冲突机率的公式是 <code>p = (n(n-1)/2) * (1/2^160))</code> ）。 2^80 是 1.2 x 10^24，也就是一亿亿亿，这是地球上沙粒总数的 1200 倍。</p>
<p>举例说一下怎样才能产生一次 SHA-1 冲突。 如果地球上 65 亿个人类都在编程，每人每秒都在产生等价于整个 Linux 内核历史（650 万个 Git 对象）的代码， 并将之提交到一个巨大的 Git 仓库里面，这样持续两年的时间才会产生足够的对象， 使其拥有 50% 的概率产生一次 SHA-1 对象冲突， 这比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。</p>
</blockquote>
<h3 id="分支引用"><a href="#分支引用" class="headerlink" title="分支引用"></a>分支引用</h3><p>引用特定提交的一种直接方法是，若它是一个分支的顶端的提交， 那么可以在任何需要引用该提交的 Git 命令中直接使用该分支的名称。 例如，你想要查看一个分支的最后一次提交的对象，假设 <code>topic1</code> 分支指向提交 <code>ca82a6d…</code> ， 那么以下的命令是等价的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show ca82a6dff817ec66f44342007202690a93763949</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show topic1</span></span><br></pre></td></tr></table></figure>

<p>如果你想知道某个分支指向哪个特定的 SHA-1，或者想看任何一个例子中被简写的 SHA-1， 你可以使用一个叫做 <code>rev-parse</code> 的 Git 探测工具。 你可以在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gxMC1naXQtaW50ZXJuYWxz">Git 内部原理<i class="fa fa-external-link-alt"></i></span> 中查看更多关于探测工具的信息。 简单来说，<code>rev-parse</code> 是为了底层操作而不是日常操作设计的。 不过，有时你想看 Git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 <code>rev-parse</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rev-parse topic1</span></span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949</span><br></pre></td></tr></table></figure>

<h3 id="引用日志"><a href="#引用日志" class="headerlink" title="引用日志"></a>引用日志</h3><p>当你在工作时， Git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。</p>
<p>你可以使用 <code>git reflog</code> 来查看引用日志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reflog</span></span><br><span class="line">734713b HEAD@&#123;0&#125;: commit: fixed refs handling, added gc auto, updated</span><br><span class="line">d921970 HEAD@&#123;1&#125;: merge phedders/rdocs: Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line">1c002dd HEAD@&#123;2&#125;: commit: added some blame and merge stuff</span><br><span class="line">1c36188 HEAD@&#123;3&#125;: rebase -i (squash): updating HEAD</span><br><span class="line">95df984 HEAD@&#123;4&#125;: commit: # This is a combination of two commits.</span><br><span class="line">1c36188 HEAD@&#123;5&#125;: rebase -i (squash): updating HEAD</span><br><span class="line">7e05da5 HEAD@&#123;6&#125;: rebase -i (pick): updating HEAD</span><br></pre></td></tr></table></figure>

<p>每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 你也可以通过 reflog 数据来获取之前的提交历史。 如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 <code>@&#123;n&#125;</code> 来引用 reflog 中输出的提交记录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show HEAD@&#123;5&#125;</span></span><br></pre></td></tr></table></figure>

<p>你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 <code>master</code> 分支在昨天的时候指向了哪个提交，你可以输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show master@&#123;yesterday&#125;</span></span><br></pre></td></tr></table></figure>

<p>就会显示昨天 <code>master</code> 分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。</p>
<p>可以运行 <code>git log -g</code> 来查看类似于 <code>git log</code> 输出格式的引用日志信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -g master</span></span><br><span class="line">commit 734713bc047d87bf7eac9674765ae793478c50d3</span><br><span class="line">Reflog: master@&#123;0&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)</span><br><span class="line">Reflog message: commit: fixed refs handling, added gc auto, updated</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri Jan 2 18:32:33 2009 -0800</span><br><span class="line"></span><br><span class="line">    fixed refs handling, added gc auto, updated tests</span><br><span class="line"></span><br><span class="line">commit d921970aadf03b3cf0e71becdaab3147ba71cdef</span><br><span class="line">Reflog: master@&#123;1&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)</span><br><span class="line">Reflog message: merge phedders/rdocs: Merge made by recursive.</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 15:08:43 2008 -0800</span><br><span class="line"></span><br><span class="line">    Merge commit &#x27;phedders/rdocs&#x27;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，引用日志只存在于本地仓库，它只是一个记录你在 <strong>自己</strong> 的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同，而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 <code>git show HEAD@&#123;2.months.ago&#125;</code> 这条命令只有在你克隆了一个项目至少两个月时才会显示匹配的提交—— 如果你刚刚克隆了仓库，那么它将不会有任何结果返回。</p>
<blockquote>
<p>将引用日志想作 Git 版的 shell 历史记录</p>
<p>如果你有 UNIX 或者 Linux 的背景，不妨将引用日志想作 Git 版的 shell 历史记录， 重点在于仅与你和你的会话相关，而与他人无关。</p>
</blockquote>
<h3 id="祖先引用"><a href="#祖先引用" class="headerlink" title="祖先引用"></a>祖先引用</h3><p>祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 <code>^</code>（脱字符）， Git 会将其解析为该引用的上一个提交。 假设你的提交历史是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=format:<span class="string">&#x27;%h %s&#x27;</span> --graph</span></span><br><span class="line">* 734713b fixed refs handling, added gc auto, updated tests</span><br><span class="line">*   d921970 Merge commit &#x27;phedders/rdocs&#x27;</span><br><span class="line">|\</span><br><span class="line">| * 35cfb2b Some rdoc changes</span><br><span class="line">* | 1c002dd added some blame and merge stuff</span><br><span class="line">|/</span><br><span class="line">* 1c36188 ignore *.gem</span><br><span class="line">* 9b29157 add open3_detach to gemspec file list</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>HEAD^</code> 来查看上一个提交，也就是 “HEAD 的父提交”：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show HEAD^</span></span><br><span class="line">commit d921970aadf03b3cf0e71becdaab3147ba71cdef</span><br><span class="line">Merge: 1c002dd... 35cfb2b...</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 15:08:43 2008 -0800</span><br><span class="line"></span><br><span class="line">    Merge commit &#x27;phedders/rdocs&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Windows 上转义脱字符</p>
<p>在 Windows 的 <code>cmd.exe</code> 中，<code>^</code> 是一个特殊字符，因此需要区别对待。 你可以双写它或者将提交引用放在引号中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show HEAD^     <span class="comment"># 在 Windows 上无法工作</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show HEAD^^    <span class="comment"># 可以</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show <span class="string">&quot;HEAD^&quot;</span>   <span class="comment"># 可以</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>你也可以在 <code>^</code> 后面添加一个数字来指明想要 <strong>哪一个</strong> 父提交——例如 <code>d921970^2</code> 代表 “d921970 的第二父提交” 这个语法只适用于合并的提交，因为合并提交会有多个父提交。 合并提交的第一父提交是你合并时所在分支（通常为 <code>master</code>），而第二父提交是你所合并的分支（例如 <code>topic</code>）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show d921970^</span></span><br><span class="line">commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Thu Dec 11 14:58:32 2008 -0800</span><br><span class="line"></span><br><span class="line">    added some blame and merge stuff</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show d921970^2</span></span><br><span class="line">commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548</span><br><span class="line">Author: Paul Hedderly &lt;paul+git@mjr.org&gt;</span><br><span class="line">Date:   Wed Dec 10 22:22:03 2008 +0000</span><br><span class="line"></span><br><span class="line">    Some rdoc changes</span><br></pre></td></tr></table></figure>

<p>另一种指明祖先提交的方法是 <code>~</code>（波浪号）。 同样是指向第一父提交，因此 <code>HEAD~</code> 和 <code>HEAD^</code> 是等价的。 而区别在于你在后面加数字的时候。 <code>HEAD~2</code> 代表“第一父提交的第一父提交”，也就是“祖父提交”——Git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，<code>HEAD~3</code> 就是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show HEAD~3</span></span><br><span class="line">commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d</span><br><span class="line">Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;</span><br><span class="line">Date:   Fri Nov 7 13:47:59 2008 -0500</span><br><span class="line"></span><br><span class="line">    ignore *.gem</span><br></pre></td></tr></table></figure>

<p>也可以写成 <code>HEAD~</code>，也是第一父提交的第一父提交的第一父提交：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show HEAD~~~</span></span><br><span class="line">commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d</span><br><span class="line">Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;</span><br><span class="line">Date:   Fri Nov 7 13:47:59 2008 -0500</span><br><span class="line"></span><br><span class="line">    ignore *.gem</span><br></pre></td></tr></table></figure>

<p>你也可以组合使用这两个语法——你可以通过 <code>HEAD~3^2</code> 来取得之前引用的第二父提交（假设它是一个合并提交）。</p>
<h3 id="提交区间"><a href="#提交区间" class="headerlink" title="提交区间"></a>提交区间</h3><p>你已经学会如何指定单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支十分有用， 你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题</p>
<h4 id="双点"><a href="#双点" class="headerlink" title="双点"></a>双点</h4><p>最常用的指明提交区间语法是双点。 这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvZG91YmxlX2RvdA==">Example history for range selection.<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/04/double-dot.png" alt="区间选择的提交历史示例"></p>
<p>你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 <code>master..experiment</code> 来让 Git 显示这些提交。也就是“在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> master..experiment</span></span><br><span class="line">D</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<p>反过来，如果你想查看在 <code>master</code> 分支中而不在 <code>experiment</code> 分支中的提交，你只要交换分支名即可。 <code>experiment..master</code> 会显示在 <code>master</code> 分支中而不在 <code>experiment</code> 分支中的提交：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> experiment..master</span></span><br><span class="line">F</span><br><span class="line">E</span><br></pre></td></tr></table></figure>

<p>这可以让你保持 <code>experiment</code> 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> origin/master..HEAD</span></span><br></pre></td></tr></table></figure>

<p>这个命令会输出在你当前分支中而不在远程 <code>origin</code> 中的提交。 如果你执行 <code>git push</code> 并且你的当前分支正在跟踪 <code>origin/master</code>，由 <code>git log origin/master..HEAD</code> 所输出的提交就是会被传输到远端服务器的提交。如果你留空了其中的一边， Git 会默认为 <code>HEAD</code>。 例如， <code>git log origin/master..</code> 将会输出与之前例子相同的结果 —— Git 使用 HEAD 来代替留空的一边。</p>
<h4 id="多点"><a href="#多点" class="headerlink" title="多点"></a>多点</h4><p>双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订， 比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 Git 允许你在任意引用前加上 <code>^</code> 字符或者 <code>--not</code> 来指明你不希望提交被包含其中的分支。 因此下列三个命令是等价的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> refA..refB</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> ^refA refB</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> refB --not refA</span></span><br></pre></td></tr></table></figure>

<p>这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 <code>refA</code> 或 <code>refB</code> 包含的但是不被 <code>refC</code> 包含的提交，你可以使用以下任意一个命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> refA refB ^refC</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> refA refB --not refC</span></span><br></pre></td></tr></table></figure>

<p>这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。</p>
<h4 id="三点"><a href="#三点" class="headerlink" title="三点"></a>三点</h4><p>最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用 <strong>之一</strong> 包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 <code>master</code> 或者 <code>experiment</code> 中包含的但不是两者共有的提交，你可以执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> master...experiment</span></span><br><span class="line">F</span><br><span class="line">E</span><br><span class="line">D</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<p>这和通常 <code>log</code> 按日期排序的输出一样，仅仅给出了4个提交的信息。</p>
<p>这种情形下，<code>log</code> 命令的一个常用参数是 <code>--left-right</code>，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --left-right master...experiment</span></span><br><span class="line">&lt; F</span><br><span class="line">&lt; E</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">D</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">C</span></span><br></pre></td></tr></table></figure>

<p>有了这些工具，你就可以十分方便地查看你 Git 仓库中的提交。</p>
<h2 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h2><p>本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 <code>git add</code> 时使用 <code>-i</code> 或者 <code>--interactive</code> 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add -i</span></span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:    unchanged        +1/-1 index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line"></span><br><span class="line">*** Commands ***</span><br><span class="line">  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked</span><br><span class="line">  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp</span><br><span class="line">What now&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到这个命令以和平时非常不同的视图显示了暂存区——基本上与 <code>git status</code> 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。</p>
<p>在这块区域后是“Commands”命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。</p>
<h3 id="暂存与取消暂存文件"><a href="#暂存与取消暂存文件" class="headerlink" title="暂存与取消暂存文件"></a>暂存与取消暂存文件</h3><p>如果在 <code>What now&gt;</code> 提示符后键入 <code>u</code> 或 <code>2</code>（更新），它会问你想要暂存哪个文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">What now&gt; u</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:    unchanged        +1/-1 index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line"><span class="meta prompt_">Update&gt;</span><span class="language-bash">&gt;</span></span><br></pre></td></tr></table></figure>

<p>要暂存 <code>TODO</code> 和 <code>index.html</code> 文件，可以输入数字：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">Update&gt;</span><span class="language-bash">&gt; 1,2</span></span><br><span class="line">           staged     unstaged path</span><br><span class="line">* 1:    unchanged        +0/-1 TODO</span><br><span class="line">* 2:    unchanged        +1/-1 index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line"><span class="meta prompt_">Update&gt;</span><span class="language-bash">&gt;</span></span><br></pre></td></tr></table></figure>

<p>每个文件前面的 <code>*</code> 意味着选中的文件将会被暂存。 如果在 <code>Update&gt;&gt;</code> 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">Update&gt;</span><span class="language-bash">&gt;</span></span><br><span class="line">updated 2 paths</span><br><span class="line"></span><br><span class="line">*** Commands ***</span><br><span class="line">  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked</span><br><span class="line">  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp</span><br><span class="line">What now&gt; s</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:        +0/-1      nothing TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p>现在可以看到 <code>TODO</code> 与 <code>index.html</code> 文件已经被暂存而 <code>simplegit.rb</code> 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 <code>r</code> 或 <code>3</code>（撤消）选项：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked</span><br><span class="line">  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp</span><br><span class="line">What now&gt; r</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:        +0/-1      nothing TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line"><span class="meta prompt_">Revert&gt;</span><span class="language-bash">&gt; 1</span></span><br><span class="line">           staged     unstaged path</span><br><span class="line">* 1:        +0/-1      nothing TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br><span class="line"><span class="meta prompt_">Revert&gt;</span><span class="language-bash">&gt; [enter]</span></span><br><span class="line">reverted one path</span><br></pre></td></tr></table></figure>

<p>再次查看 Git 状态，可以看到已经取消暂存 <code>TODO</code> 文件：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked</span><br><span class="line">  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp</span><br><span class="line">What now&gt; s</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:    unchanged        +5/-1 lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p>如果想要查看已暂存内容的区别，可以使用 <code>d</code> 或 <code>6</code>（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 <code>git diff --cached</code> 非常相似：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*** Commands ***</span><br><span class="line">  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked</span><br><span class="line">  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp</span><br><span class="line">What now&gt; d</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:        +1/-1      nothing index.html</span><br><span class="line">Review diff&gt;&gt; 1</span><br><span class="line">diff --git a/index.html b/index.html</span><br><span class="line">index 4d07108..4335f49 100644</span><br><span class="line">--- a/index.html</span><br><span class="line">+++ b/index.html</span><br><span class="line">@@ -16,7 +16,7 @@ Date Finder</span><br><span class="line"></span><br><span class="line"> &lt;p id=&quot;out&quot;&gt;...&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">-&lt;div id=&quot;footer&quot;&gt;contact : support@github.com&lt;/div&gt;</span><br><span class="line">+&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script type=&quot;text/javascript&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。</p>
<h3 id="暂存补丁"><a href="#暂存补丁" class="headerlink" title="暂存补丁"></a>暂存补丁</h3><p>Git 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 在和上一节一样的交互式提示符中，输入 <code>p</code> 或 <code>5</code>（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index dd5ecc4..57399e0 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -22,7 +22,7 @@ class SimpleGit</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   def log(treeish = &#x27;master&#x27;)</span><br><span class="line">-    command(&quot;git log -n 25 #&#123;treeish&#125;&quot;)</span><br><span class="line">+    command(&quot;git log -n 30 #&#123;treeish&#125;&quot;)</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   def blame(path)</span><br><span class="line">Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</span><br></pre></td></tr></table></figure>

<p>这时有很多选项。 输入 <code>?</code> 显示所有可以使用的命令列表：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?</span><br><span class="line">y - stage this hunk</span><br><span class="line">n - do not stage this hunk</span><br><span class="line">a - stage this and all the remaining hunks in the file</span><br><span class="line">d - do not stage this hunk nor any of the remaining hunks in the file</span><br><span class="line">g - select a hunk to go to</span><br><span class="line">/ - search for a hunk matching the given regex</span><br><span class="line">j - leave this hunk undecided, see next undecided hunk</span><br><span class="line">J - leave this hunk undecided, see next hunk</span><br><span class="line">k - leave this hunk undecided, see previous undecided hunk</span><br><span class="line">K - leave this hunk undecided, see previous hunk</span><br><span class="line">s - split the current hunk into smaller hunks</span><br><span class="line">e - manually edit the current hunk</span><br><span class="line">? - print help</span><br></pre></td></tr></table></figure>

<p>通常情况下可以输入 <code>y</code> 或 <code>n</code> 来选择是否要暂存每一个区块， 当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">What now&gt; 1</span><br><span class="line">           staged     unstaged path</span><br><span class="line">  1:    unchanged        +0/-1 TODO</span><br><span class="line">  2:        +1/-1      nothing index.html</span><br><span class="line">  3:        +1/-1        +4/-0 lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p><code>simplegit.rb</code> 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 <code>git commit</code> 来提交部分暂存的文件。</p>
<p>也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 <code>git add -p</code> 或 <code>git add --patch</code> 来启动同样的脚本。</p>
<p>更进一步地，可以使用 <code>git reset --patch</code> 命令的补丁模式来部分重置文件， 通过 <code>git checkout --patch</code> 命令来部分检出文件与 <code>git stash save --patch</code> 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。</p>
<h2 id="贮藏与清理"><a href="#贮藏与清理" class="headerlink" title="贮藏与清理"></a>贮藏与清理</h2><p>有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支做一点别的事情。 问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。 针对这个问题的答案是 <code>git stash</code> 命令。</p>
<p>贮藏（stash）会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上， 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。</p>
<blockquote>
<p>迁移到 <code>git stash push</code></p>
<p>截至 2017 年 10 月下旬，Git 邮件列表上进行了广泛讨论，该讨论中弃用了 <code>git stash save</code> 命令， 代之以现有 <code>git stash push</code> 命令。主因是 <code>git stash push</code> 引入了贮藏选定的 <strong>路径规范</strong> 的选项， 而有些东西 <code>git stash save</code> 不支持。</p>
<p><code>git stash save</code> 不会很快就消失，所以不用担心它突然不见。 不过你可能想要迁移到 <code>push</code> 来获取新功能。</p>
</blockquote>
<h3 id="贮藏工作"><a href="#贮藏工作" class="headerlink" title="贮藏工作"></a>贮藏工作</h3><p>为了演示贮藏，你需要进入项目并改动几个文件，然后可以暂存其中的一个改动。 如果运行 <code>git status</code>，可以看到有改动的状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   index.html</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p>现在想要切换分支，但是还不想要提交之前的工作；所以贮藏修改。 将新的贮藏推送到栈上，运行 <code>git stash</code> 或 <code>git stash push</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash</span></span><br><span class="line">Saved working directory and index state \</span><br><span class="line">  &quot;WIP on master: 049d078 added the index file&quot;</span><br><span class="line">HEAD is now at 049d078 added the index file</span><br><span class="line">(To restore them type &quot;git stash apply&quot;)</span><br></pre></td></tr></table></figure>

<p>可以看到工作目录是干净的了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<p>此时，你可以切换分支并在其他地方工作；你的修改被存储在栈上。 要查看贮藏的东西，可以使用 <code>git stash list</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash list</span></span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;</span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log</span><br></pre></td></tr></table></figure>

<p>在本例中，有两个之前的贮藏，所以你接触到了三个不同的贮藏工作。 可以通过原来 stash 命令的帮助提示中的命令将你刚刚贮藏的工作重新应用：<code>git stash apply</code>。 如果想要应用其中一个更旧的贮藏，可以通过名字指定它，像这样：<code>git stash apply stash@&#123;2&#125;</code>。 如果不指定一个贮藏，Git 认为指定的是最近的贮藏：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash apply</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   index.html</span><br><span class="line">	modified:   lib/simplegit.rb</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>可以看到 Git 重新修改了当你保存贮藏时撤消的文件。 在本例中，当尝试应用贮藏时有一个干净的工作目录，并且尝试将它应用在保存它时所在的分支。 并不是必须要有一个干净的工作目录，或者要应用到同一分支才能成功应用贮藏。 可以在一个分支上保存一个贮藏，切换到另一个分支，然后尝试重新应用这些修改。 当应用贮藏时工作目录中也可以有修改与未提交的文件——如果有任何东西不能干净地应用，Git 会产生合并冲突。</p>
<p>文件的改动被重新应用了，但是之前暂存的文件却没有重新暂存。 想要那样的话，必须使用 <code>--index</code> 选项来运行 <code>git stash apply</code> 命令，来尝试重新应用暂存的修改。 如果已经那样做了，那么你将回到原来的位置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash apply --index</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   index.html</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p>应用选项只会尝试应用贮藏的工作——在堆栈上还有它。 可以运行 <code>git stash drop</code> 加上将要移除的贮藏的名字来移除它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash list</span></span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;</span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash drop stash@&#123;0&#125;</span></span><br><span class="line">Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43)</span><br></pre></td></tr></table></figure>

<p>也可以运行 <code>git stash pop</code> 来应用贮藏然后立即从栈上扔掉它。</p>
<h3 id="贮藏的创意性使用"><a href="#贮藏的创意性使用" class="headerlink" title="贮藏的创意性使用"></a>贮藏的创意性使用</h3><p>有几个贮藏的变种可能也很有用。 第一个非常流行的选项是 <code>git stash</code> 命令的 <code>--keep-index</code> 选项。 它告诉 Git 不仅要贮藏所有已暂存的内容，同时还要将它们保留在索引中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line">M  index.html</span><br><span class="line"> M lib/simplegit.rb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash --keep-index</span></span><br><span class="line">Saved working directory and index state WIP on master: 1b65b17 added the index file</span><br><span class="line">HEAD is now at 1b65b17 added the index file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line">M  index.html</span><br></pre></td></tr></table></figure>

<p>另一个经常使用贮藏来做的事情是像贮藏跟踪文件一样贮藏未跟踪文件。 默认情况下，<code>git stash</code> 只会贮藏已修改和暂存的 <strong>已跟踪</strong> 文件。 如果指定 <code>--include-untracked</code> 或 <code>-u</code> 选项，Git 也会贮藏任何未跟踪文件。 然而，在贮藏中包含未跟踪的文件仍然不会包含明确 <strong>忽略</strong> 的文件。 要额外包含忽略的文件，请使用 <code>--all</code> 或 <code>-a</code> 选项。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line">M  index.html</span><br><span class="line"> M lib/simplegit.rb</span><br><span class="line">?? new-file.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash -u</span></span><br><span class="line">Saved working directory and index state WIP on master: 1b65b17 added the index file</span><br><span class="line">HEAD is now at 1b65b17 added the index file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>最终，如果指定了 <code>--patch</code> 标记，Git 不会贮藏所有修改过的任何东西， 但是会交互式地提示哪些改动想要贮藏、哪些改动需要保存在工作目录中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash --patch</span></span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index 66d332e..8bb5674 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -16,6 +16,10 @@ class SimpleGit</span><br><span class="line">         return `#&#123;git_cmd&#125; 2&gt;&amp;1`.chomp</span><br><span class="line">       end</span><br><span class="line">     end</span><br><span class="line">+</span><br><span class="line">+    def show(treeish = &#x27;master&#x27;)</span><br><span class="line">+      command(&quot;git show #&#123;treeish&#125;&quot;)</span><br><span class="line">+    end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line"> test</span><br><span class="line">Stash this hunk [y,n,q,a,d,/,e,?]? y</span><br><span class="line"></span><br><span class="line">Saved working directory and index state WIP on master: 1b65b17 added the index file</span><br></pre></td></tr></table></figure>

<h3 id="从贮藏创建一个分支"><a href="#从贮藏创建一个分支" class="headerlink" title="从贮藏创建一个分支"></a>从贮藏创建一个分支</h3><p>如果贮藏了一些工作，将它留在那儿了一会儿，然后继续在贮藏的分支上工作，在重新应用工作时可能会有问题。 如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。 如果想要一个轻松的方式来再次测试贮藏的改动，可以运行 <code>git stash branch &lt;new branchname&gt;</code> 以你指定的分支名创建一个新分支，检出贮藏工作时所在的提交，重新在那应用工作，然后在应用成功后丢弃贮藏：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash branch testchanges</span></span><br><span class="line">M	index.html</span><br><span class="line">M	lib/simplegit.rb</span><br><span class="line">Switched to a new branch &#x27;testchanges&#x27;</span><br><span class="line">On branch testchanges</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   index.html</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   lib/simplegit.rb</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (29d385a81d163dfd45a452a2ce816487a6b8b014)</span><br></pre></td></tr></table></figure>

<p>这是在新分支轻松恢复贮藏工作并继续工作的一个很不错的途径。</p>
<h3 id="清理工作目录"><a href="#清理工作目录" class="headerlink" title="清理工作目录"></a>清理工作目录</h3><p>对于工作目录中一些工作或文件，你想做的也许不是贮藏而是移除。 <code>git clean</code> 命令就是用来干这个的。</p>
<p>清理工作目录有一些常见的原因，比如说为了移除由合并或外部工具生成的东西， 或是为了运行一个干净的构建而移除之前构建的残留。</p>
<p>你需要谨慎地使用这个命令，因为它被设计为从工作目录中移除未被追踪的文件。 如果你改变主意了，你也不一定能找回来那些文件的内容。 一个更安全的选项是运行 <code>git stash --all</code> 来移除每一样东西并存放在栈中。</p>
<p>你可以使用 <code>git clean</code> 命令去除冗余文件或者清理工作目录。 使用 <code>git clean -f -d</code> 命令来移除工作目录中所有未追踪的文件以及空的子目录。 <code>-f</code> 意味着“强制（force）”或“确定要移除”，使用它需要 Git 配置变量 <code>clean.requireForce</code> 没有显式设置为 <code>false</code>。</p>
<p>如果只是想要看看它会做什么，可以使用 <code>--dry-run</code> 或 <code>-n</code> 选项来运行命令， 这意味着“做一次演习然后告诉你 <strong>将要</strong> 移除什么”。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git clean -d -n</span></span><br><span class="line">Would remove test.o</span><br><span class="line">Would remove tmp/</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>git clean</code> 命令只会移除没有忽略的未跟踪文件。 任何与 <code>.gitignore</code> 或其他忽略文件中的模式匹配的文件都不会被移除。 如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的 <code>.o</code> 文件， 可以给 clean 命令增加一个 <code>-x</code> 选项。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -s</span></span><br><span class="line"> M lib/simplegit.rb</span><br><span class="line">?? build.TMP</span><br><span class="line">?? tmp/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git clean -n -d</span></span><br><span class="line">Would remove build.TMP</span><br><span class="line">Would remove tmp/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git clean -n -d -x</span></span><br><span class="line">Would remove build.TMP</span><br><span class="line">Would remove test.o</span><br><span class="line">Would remove tmp/</span><br></pre></td></tr></table></figure>

<p>如果不知道 <code>git clean</code> 命令将会做什么，在将 <code>-n</code> 改为 <code>-f</code> 来真正做之前总是先用 <code>-n</code> 来运行它做双重检查。 另一个小心处理过程的方式是使用 <code>-i</code> 或 “interactive” 标记来运行它。</p>
<p>这将会以交互模式运行 clean 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git clean -x -i</span></span><br><span class="line">Would remove the following items:</span><br><span class="line">  build.TMP  test.o</span><br><span class="line">*** Commands ***</span><br><span class="line">    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit</span><br><span class="line">    6: help</span><br><span class="line">What now&gt;</span><br></pre></td></tr></table></figure>

<p>这种方式下可以分别地检查每一个文件或者交互地指定删除的模式。</p>
<blockquote>
<p>在一种奇怪的情况下，可能需要格外用力才能让 Git 清理你的工作目录。 如果你恰好在工作目录中复制或克隆了其他 Git 仓库（可能是子模块），那么即便是 <code>git clean -fd</code> 都会拒绝删除这些目录。这种情况下，你需要加上第二个 <code>-f</code> 选项来强调。</p>
</blockquote>
<h2 id="签署工作"><a href="#签署工作" class="headerlink" title="签署工作"></a>签署工作</h2><p>Git 虽然是密码级安全的，但它不是万无一失的。 如果你从因特网上的其他人那里拿取工作，并且想要验证提交是不是真正地来自于可信来源， Git 提供了几种通过 GPG 来签署和验证工作的方式。</p>
<h3 id="GPG-介绍"><a href="#GPG-介绍" class="headerlink" title="GPG 介绍"></a>GPG 介绍</h3><p>首先，在开始签名之前你需要先配置 GPG 并安装个人密钥。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --list-keys</span></span><br><span class="line">/Users/schacon/.gnupg/pubring.gpg</span><br><span class="line">---------------------------------</span><br><span class="line">pub   2048R/0A46826A 2014-06-04</span><br><span class="line">uid                  Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;</span><br><span class="line">sub   2048R/874529A9 2014-06-04</span><br></pre></td></tr></table></figure>

<p>如果你还没有安装一个密钥，可以使用 <code>gpg --gen-key</code> 生成一个。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gpg --gen-key</span></span><br></pre></td></tr></table></figure>

<p>一旦你有一个可以签署的私钥，可以通过设置 Git 的 <code>user.signingkey</code> 选项来签署。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.signingkey 0A46826A</span></span><br></pre></td></tr></table></figure>

<p>现在 Git 默认使用你的密钥来签署标签与提交。</p>
<h3 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h3><p>如果已经设置好一个 GPG 私钥，可以使用它来签署新的标签。 所有需要做的只是使用 <code>-s</code> 代替 <code>-a</code> 即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -s v1.5 -m <span class="string">&#x27;my signed 1.5 tag&#x27;</span></span></span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Ben Straub &lt;ben@straub.cc&gt;&quot;</span><br><span class="line">2048-bit RSA key, ID 800430EB, created 2014-05-04</span><br></pre></td></tr></table></figure>

<p>如果在那个标签上运行 <code>git show</code>，会看到你的 GPG 签名附属在后面：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v1.5</span></span><br><span class="line">tag v1.5</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:29:41 2014 -0700</span><br><span class="line"></span><br><span class="line">my signed 1.5 tag</span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v1</span><br><span class="line"></span><br><span class="line">iQEcBAABAgAGBQJTZbQlAAoJEF0+sviABDDrZbQH/09PfE51KPVPlanr6q1v4/Ut</span><br><span class="line">LQxfojUWiLQdg2ESJItkcuweYg+kc3HCyFejeDIBw9dpXt00rY26p05qrpnG+85b</span><br><span class="line">hM1/PswpPLuBSr+oCIDj5GMC2r2iEKsfv2fJbNW8iWAXVLoWZRF8B0MfqX/YTMbm</span><br><span class="line">ecorc4iXzQu7tupRihslbNkfvfciMnSDeSvzCpWAHl7h8Wj6hhqePmLm9lAYqnKp</span><br><span class="line">8S5B/1SSQuEAjRZgI4IexpZoeKGVDptPHxLLS38fozsyi0QyDyzEgJxcJQVMXxVi</span><br><span class="line">RUysgqjcpT8+iQM1PblGfHR4XAhuOqN5Fx06PSaFZhqvWFezJ28/CLyX5q+oIVk=</span><br><span class="line">=EFTF</span><br><span class="line">-----END PGP SIGNATURE-----</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure>

<h3 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h3><p>要验证一个签署的标签，可以运行 <code>git tag -v &lt;tag-name&gt;</code>。 这个命令使用 GPG 来验证签名。 为了验证能正常工作，签署者的公钥需要在你的钥匙链中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -v v1.4.2.1</span></span><br><span class="line">object 883653babd8ee7ea23e6a5c392bb739348b1eb61</span><br><span class="line">type commit</span><br><span class="line">tag v1.4.2.1</span><br><span class="line">tagger Junio C Hamano &lt;junkio@cox.net&gt; 1158138501 -0700</span><br><span class="line"></span><br><span class="line">GIT 1.4.2.1</span><br><span class="line"></span><br><span class="line">Minor fixes since 1.4.2, including git-mv and git-http with alternates.</span><br><span class="line">gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A</span><br><span class="line">gpg: Good signature from &quot;Junio C Hamano &lt;junkio@cox.net&gt;&quot;</span><br><span class="line">gpg:                 aka &quot;[jpeg image of size 1513]&quot;</span><br><span class="line">Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A</span><br></pre></td></tr></table></figure>

<p>如果没有签署者的公钥，那么你将会得到类似下面的东西：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A</span><br><span class="line">gpg: Can&#x27;t check signature: public key not found</span><br><span class="line">error: could not verify the tag &#x27;v1.4.2.1&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="签署提交"><a href="#签署提交" class="headerlink" title="签署提交"></a>签署提交</h3><p>在最新版本的 Git 中（v1.7.9 及以上），也可以签署个人提交。 如果相对于标签而言你对直接签署到提交更感兴趣的话，所有要做的只是增加一个 <code>-S</code> 到 <code>git commit</code> 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -S -m <span class="string">&#x27;signed commit&#x27;</span></span></span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;</span><br><span class="line">2048-bit RSA key, ID 0A46826A, created 2014-06-04</span><br><span class="line"></span><br><span class="line">[master 5c3386c] signed commit</span><br><span class="line"> 4 files changed, 4 insertions(+), 24 deletions(-)</span><br><span class="line"> rewrite Rakefile (100%)</span><br><span class="line"> create mode 100644 lib/git.rb</span><br></pre></td></tr></table></figure>

<p><code>git log</code> 也有一个 <code>--show-signature</code> 选项来查看及验证这些签名。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --show-signature -1</span></span><br><span class="line">commit 5c3386cf54bba0a33a32da706aa52bc0155503c2</span><br><span class="line">gpg: Signature made Wed Jun  4 19:49:17 2014 PDT using RSA key ID 0A46826A</span><br><span class="line">gpg: Good signature from &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Wed Jun 4 19:49:17 2014 -0700</span><br><span class="line"></span><br><span class="line">    signed commit</span><br></pre></td></tr></table></figure>

<p>另外，也可以配置 <code>git log</code> 来验证任何找到的签名并将它们以 <code>%G?</code> 格式列在输出中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=<span class="string">&quot;format:%h %G? %aN  %s&quot;</span></span></span><br><span class="line"></span><br><span class="line">5c3386c G Scott Chacon  signed commit</span><br><span class="line">ca82a6d N Scott Chacon  changed the version number</span><br><span class="line">085bb3b N Scott Chacon  removed unnecessary test code</span><br><span class="line">a11bef0 N Scott Chacon  first commit</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到只有最后一次提交是签署并有效的，而之前的提交都不是。</p>
<p>在 Git 1.8.3 及以后的版本中，<code>git merge</code> 与 <code>git pull</code> 可以使用 <code>--verify-signatures</code> 选项来检查并拒绝没有携带可信 GPG 签名的提交。</p>
<p>如果使用这个选项来合并一个包含未签名或有效的提交的分支时，合并不会生效。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --verify-signatures non-verify</span></span><br><span class="line">fatal: Commit ab06180 does not have a GPG signature.</span><br></pre></td></tr></table></figure>

<p>如果合并包含的只有有效的签名的提交，合并命令会提示所有的签名它已经检查过了然后会继续向前。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --verify-signatures signed-branch</span></span><br><span class="line">Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;</span><br><span class="line">Updating 5c3386c..13ad65e</span><br><span class="line">Fast-forward</span><br><span class="line"> README | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>

<p>也可以给 <code>git merge</code> 命令附加 <code>-S</code> 选项来签署自己生成的合并提交。 下面的例子演示了验证将要合并的分支的每一个提交都是签名的并且签署最后生成的合并提交。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --verify-signatures -S  signed-branch</span></span><br><span class="line">Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key for</span><br><span class="line">user: &quot;Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;&quot;</span><br><span class="line">2048-bit RSA key, ID 0A46826A, created 2014-06-04</span><br><span class="line"></span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> README | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure>

<h3 id="每个人必须签署"><a href="#每个人必须签署" class="headerlink" title="每个人必须签署"></a>每个人必须签署</h3><p>签署标签与提交很棒，但是如果决定在正常的工作流程中使用它，你必须确保团队中的每一个人都理解如何这样做。 如果没有，你将会花费大量时间帮助其他人找出并用签名的版本重写提交。 在采用签署成为标准工作流程的一部分前，确保你完全理解 GPG 及签署带来的好处。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>无论仓库里的代码量有多少，你经常需要查找一个函数是在哪里调用或者定义的，或者显示一个方法的变更历史。 Git 提供了两个有用的工具来快速地从它的数据库中浏览代码和提交。 我们来简单的看一下。</p>
<h3 id="Git-Grep"><a href="#Git-Grep" class="headerlink" title="Git Grep"></a>Git Grep</h3><p>Git 提供了一个 <code>grep</code> 命令，你可以很方便地从提交历史、工作目录、甚至索引中查找一个字符串或者正则表达式。 我们用 Git 本身源代码的查找作为例子。</p>
<p>默认情况下 <code>git grep</code> 会查找你工作目录的文件。 第一种变体是，你可以传递 <code>-n</code> 或 <code>--line-number</code> 选项数来输出 Git 找到的匹配行的行号。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git grep -n gmtime_r</span></span><br><span class="line">compat/gmtime.c:3:#undef gmtime_r</span><br><span class="line">compat/gmtime.c:8:      return git_gmtime_r(timep, &amp;result);</span><br><span class="line">compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm *result)</span><br><span class="line">compat/gmtime.c:16:     ret = gmtime_r(timep, result);</span><br><span class="line">compat/mingw.c:826:struct tm *gmtime_r(const time_t *timep, struct tm *result)</span><br><span class="line">compat/mingw.h:206:struct tm *gmtime_r(const time_t *timep, struct tm *result);</span><br><span class="line">date.c:482:             if (gmtime_r(&amp;now, &amp;now_tm))</span><br><span class="line">date.c:545:             if (gmtime_r(&amp;time, tm)) &#123;</span><br><span class="line">date.c:758:             /* gmtime_r() in match_digit() may have clobbered it */</span><br><span class="line">git-compat-util.h:1138:struct tm *git_gmtime_r(const time_t *, struct tm *);</span><br><span class="line">git-compat-util.h:1140:#define gmtime_r git_gmtime_r</span><br></pre></td></tr></table></figure>

<p>除了上面的基本搜索命令外，<code>git grep</code> 还支持大量其它有趣的选项。</p>
<p>例如，若不想打印所有匹配的项，你可以使用 <code>-c</code> 或 <code>--count</code> 选项来让 <code>git grep</code> 输出概述的信息， 其中仅包括那些包含匹配字符串的文件，以及每个文件中包含了多少个匹配。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git grep --count gmtime_r</span></span><br><span class="line">compat/gmtime.c:4</span><br><span class="line">compat/mingw.c:1</span><br><span class="line">compat/mingw.h:1</span><br><span class="line">date.c:3</span><br><span class="line">git-compat-util.h:2</span><br></pre></td></tr></table></figure>

<p>如果你还关心搜索字符串的 <strong>上下文</strong>，那么可以传入 <code>-p</code> 或 <code>--show-function</code> 选项来显示每一个匹配的字符串所在的方法或函数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git grep -p gmtime_r *.c</span></span><br><span class="line">date.c=static int match_multi_number(timestamp_t num, char c, const char *date,</span><br><span class="line">date.c:         if (gmtime_r(&amp;now, &amp;now_tm))</span><br><span class="line">date.c=static int match_digit(const char *date, struct tm *tm, int *offset, int *tm_gmt)</span><br><span class="line">date.c:         if (gmtime_r(&amp;time, tm)) &#123;</span><br><span class="line">date.c=int parse_date_basic(const char *date, timestamp_t *timestamp, int *offset)</span><br><span class="line">date.c:         /* gmtime_r() in match_digit() may have clobbered it */</span><br></pre></td></tr></table></figure>

<p>如你所见，date.c 文件中的 <code>match_multi_number</code> 和 <code>match_digit</code> 两个函数都调用了 <code>gmtime_r</code> 例程 （第三个显示的匹配只是注释中的字符串）。</p>
<p>你还可以使用 <code>--and</code> 标志来查看复杂的字符串组合，它确保了多个匹配出现在同一文本行中。 比如，我们要查看在旧版本 1.8.0 的 Git 代码库中定义了常量名包含 “LINK” 或者 “BUF_MAX” 这两个字符串的行 （这里也用到了 <code>--break</code> 和 <code>--heading</code> 选项来使输出更加容易阅读）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git grep --<span class="built_in">break</span> --heading \</span></span><br><span class="line"><span class="language-bash">    -n -e <span class="string">&#x27;#define&#x27;</span> --and \( -e LINK -e BUF_MAX \) v1.8.0</span></span><br><span class="line">v1.8.0:builtin/index-pack.c</span><br><span class="line">62:#define FLAG_LINK (1u&lt;&lt;20)</span><br><span class="line"></span><br><span class="line">v1.8.0:cache.h</span><br><span class="line">73:#define S_IFGITLINK  0160000</span><br><span class="line">74:#define S_ISGITLINK(m)       (((m) &amp; S_IFMT) == S_IFGITLINK)</span><br><span class="line"></span><br><span class="line">v1.8.0:environment.c</span><br><span class="line">54:#define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKS</span><br><span class="line"></span><br><span class="line">v1.8.0:strbuf.c</span><br><span class="line">326:#define STRBUF_MAXLINK (2*PATH_MAX)</span><br><span class="line"></span><br><span class="line">v1.8.0:symlinks.c</span><br><span class="line">53:#define FL_SYMLINK  (1 &lt;&lt; 2)</span><br><span class="line"></span><br><span class="line">v1.8.0:zlib.c</span><br><span class="line">30:/* #define ZLIB_BUF_MAX ((uInt)-1) */</span><br><span class="line">31:#define ZLIB_BUF_MAX ((uInt) 1024 * 1024 * 1024) /* 1GB */</span><br></pre></td></tr></table></figure>

<p>相比于一些常用的搜索命令比如 <code>grep</code> 和 <code>ack</code>，<code>git grep</code> 命令有一些的优点。 第一就是速度非常快，第二是你不仅仅可以可以搜索工作目录，还可以搜索任意的 Git 树。 在上一个例子中，我们在一个旧版本的 Git 源代码中查找，而不是当前检出的版本。</p>
<h3 id="Git-日志搜索"><a href="#Git-日志搜索" class="headerlink" title="Git 日志搜索"></a>Git 日志搜索</h3><p>或许你不想知道某一项在 <strong>哪里</strong> ，而是想知道是什么 <strong>时候</strong> 存在或者引入的。 <code>git log</code> 命令有许多强大的工具可以通过提交信息甚至是 diff 的内容来找到某个特定的提交。</p>
<p>例如，如果我们想找到 <code>ZLIB_BUF_MAX</code> 常量是什么时候引入的，我们可以使用 <code>-S</code> 选项 （在 Git 中俗称“鹤嘴锄（pickaxe）”选项）来显示新增和删除该字符串的提交。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -S ZLIB_BUF_MAX --oneline</span></span><br><span class="line">e01503b zlib: allow feeding more than 4GB in one go</span><br><span class="line">ef49a7a zlib: zlib can only process 4GB at a time</span><br></pre></td></tr></table></figure>

<p>如果我们查看这些提交的 diff，我们可以看到在 <code>ef49a7a</code> 这个提交引入了常量，并且在 <code>e01503b</code> 这个提交中被修改了。</p>
<p>如果你希望得到更精确的结果，你可以使用 <code>-G</code> 选项来使用正则表达式搜索。</p>
<h4 id="行日志搜索"><a href="#行日志搜索" class="headerlink" title="行日志搜索"></a>行日志搜索</h4><p>行日志搜索是另一个相当高级并且有用的日志搜索功能。 在 <code>git log</code> 后加上 <code>-L</code> 选项即可调用，它可以展示代码中一行或者一个函数的历史。</p>
<p>例如，假设我们想查看 <code>zlib.c</code> 文件中 <code>git_deflate_bound</code> 函数的每一次变更， 我们可以执行 <code>git log -L :git_deflate_bound:zlib.c</code>。 Git 会尝试找出这个函数的范围，然后查找历史记录，并且显示从函数创建之后一系列变更对应的补丁。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -L :git_deflate_bound:zlib.c</span></span><br><span class="line">commit ef49a7a0126d64359c974b4b3b71d7ad42ee3bca</span><br><span class="line">Author: Junio C Hamano &lt;gitster@pobox.com&gt;</span><br><span class="line">Date:   Fri Jun 10 11:52:15 2011 -0700</span><br><span class="line"></span><br><span class="line">    zlib: zlib can only process 4GB at a time</span><br><span class="line"></span><br><span class="line">diff --git a/zlib.c b/zlib.c</span><br><span class="line">--- a/zlib.c</span><br><span class="line">+++ b/zlib.c</span><br><span class="line">@@ -85,5 +130,5 @@</span><br><span class="line">-unsigned long git_deflate_bound(z_streamp strm, unsigned long size)</span><br><span class="line">+unsigned long git_deflate_bound(git_zstream *strm, unsigned long size)</span><br><span class="line"> &#123;</span><br><span class="line">-       return deflateBound(strm, size);</span><br><span class="line">+       return deflateBound(&amp;strm-&gt;z, size);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">commit 225a6f1068f71723a910e8565db4e252b3ca21fa</span><br><span class="line">Author: Junio C Hamano &lt;gitster@pobox.com&gt;</span><br><span class="line">Date:   Fri Jun 10 11:18:17 2011 -0700</span><br><span class="line"></span><br><span class="line">    zlib: wrap deflateBound() too</span><br><span class="line"></span><br><span class="line">diff --git a/zlib.c b/zlib.c</span><br><span class="line">--- a/zlib.c</span><br><span class="line">+++ b/zlib.c</span><br><span class="line">@@ -81,0 +85,5 @@</span><br><span class="line">+unsigned long git_deflate_bound(z_streamp strm, unsigned long size)</span><br><span class="line">+&#123;</span><br><span class="line">+       return deflateBound(strm, size);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>

<p>如果 Git 无法计算出如何匹配你代码中的函数或者方法，你可以提供一个正则表达式。 例如，这个命令和上面的是等同的：<code>git log -L &#39;/unsigned long git_deflate_bound/&#39;,/^&#125;/:zlib.c</code>。 你也可以提供单行或者一个范围的行号来获得相同的输出。</p>
<h2 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h2><p>许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 <code>git stash</code> 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。</p>
<blockquote>
<p>在满意之前不要推送你的工作</p>
<p>Git 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 <strong>在本地</strong> 随便重写历史记录。 然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。 简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。</p>
</blockquote>
<h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><p>修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：简单地修改提交信息， 或者通过添加、移除或修改文件来更改提交实际的内容。</p>
<p>如果，你只是想修改最近一次提交的提交信息，那么很简单：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure>

<p>上面这条命令会将最后一次的提交信息载入到编辑器中供你修改。 当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中，它会成为新的最后一次提交。</p>
<p>另一方面，如果你想要修改最后一次提交的实际内容，那么流程很相似：首先作出你想要补上的修改， 暂存它们，然后用 <code>git commit --amend</code> 以新的改进后的提交来 <strong>替换</strong> 掉旧有的最后一次提交，</p>
<p>使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。</p>
<blockquote>
<p>修补后的提交可能需要修补提交信息</p>
<p>当你在修补一次提交时，可以同时修改提交信息和提交内容。 如果你修补了提交的内容，那么几乎肯定要更新提交消息以反映修改后的内容。</p>
<p>另一方面，如果你的修补是琐碎的（如修改了一个笔误或添加了一个忘记暂存的文件）， 那么之前的提交信息不必修改，你只需作出更改，暂存它们，然后通过以下命令避免不必要的编辑器环节即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend --no-edit</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="修改多个提交信息"><a href="#修改多个提交信息" class="headerlink" title="修改多个提交信息"></a>修改多个提交信息</h3><p>为了修改在提交历史中较远的提交，必须使用更复杂的工具。 Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 <code>git rebase</code> 增加 <code>-i</code> 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。</p>
<p>例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息， 将想要修改的最近一次提交的父提交作为参数传递给 <code>git rebase -i</code> 命令，即 <code>HEAD~2^</code> 或 <code>HEAD~3</code>。 记住 <code>~3</code> 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase -i HEAD~3</span></span><br></pre></td></tr></table></figure>

<p>再次记住这是一个变基命令——在 <code>HEAD~3..HEAD</code> 范围内的每一个修改了提交信息的提交及其 <strong>所有后裔</strong> 都会被重写。 不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。</p>
<p>运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Rebase 710f0f8..a5f4a0d onto 710f0f8</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Commands:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">e, edit &lt;commit&gt; = use commit, but stop <span class="keyword">for</span> amending</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">f, fixup &lt;commit&gt; = like <span class="string">&quot;squash&quot;</span>, but discard this commit<span class="string">&#x27;s log message</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">b, break = stop here (continue rebase later with &#x27;</span>git rebase --<span class="built_in">continue</span><span class="string">&#x27;)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">d, drop &lt;commit&gt; = remove commit</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">l, label &lt;label&gt; = label current HEAD with a name</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">t, reset &lt;label&gt; = reset HEAD to a label</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">.       create a merge commit using the original merge commit&#x27;</span>s</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.       message (or the oneline, <span class="keyword">if</span> no original merge commit was</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.       specified). Use -c &lt;commit&gt; to reword the commit message.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Note that empty commits are commented out</span></span></span><br></pre></td></tr></table></figure>

<p>需要重点注意的是相对于正常使用的 <code>log</code> 命令，这些提交显示的顺序是相反的。 运行一次 ‘log’ 命令，会看到类似这样的东西：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> HEAD~3..HEAD</span></span><br><span class="line">a5f4a0d added cat-file</span><br><span class="line">310154e updated README formatting and added blame</span><br><span class="line">f7f3f6d changed my name a bit</span><br></pre></td></tr></table></figure>

<p>注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（<code>HEAD~3</code>）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。</p>
<p>你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 <code>pick&#39; 改为 </code>edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edit f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br></pre></td></tr></table></figure>

<p>当保存并退出编辑器时，Git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase -i HEAD~3</span></span><br><span class="line">Stopped at f7f3f6d... changed my name a bit</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">       git commit --amend</span><br><span class="line"></span><br><span class="line">Once you&#x27;re satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">       git rebase --continue</span><br></pre></td></tr></table></figure>

<p>这些指令准确地告诉你该做什么。 输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure>

<p>修改提交信息，然后退出编辑器。 然后，运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase --<span class="built_in">continue</span></span></span><br></pre></td></tr></table></figure>

<p>这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，Git 将会停止，让你修正提交，然后继续直到完成。</p>
<h3 id="重新排序提交"><a href="#重新排序提交" class="headerlink" title="重新排序提交"></a>重新排序提交</h3><p>也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br></pre></td></tr></table></figure>

<p>改为这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick f7f3f6d changed my name a bit</span><br></pre></td></tr></table></figure>

<p>当保存并退出编辑器时，Git 将你的分支带回这些提交的父提交，应用 <code>310154e</code> 然后应用 <code>f7f3f6d</code>，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。</p>
<h3 id="压缩提交"><a href="#压缩提交" class="headerlink" title="压缩提交"></a>压缩提交</h3><p>通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Commands:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">e, edit &lt;commit&gt; = use commit, but stop <span class="keyword">for</span> amending</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">f, fixup &lt;commit&gt; = like <span class="string">&quot;squash&quot;</span>, but discard this commit<span class="string">&#x27;s log message</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">b, break = stop here (continue rebase later with &#x27;</span>git rebase --<span class="built_in">continue</span><span class="string">&#x27;)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">d, drop &lt;commit&gt; = remove commit</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">l, label &lt;label&gt; = label current HEAD with a name</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">t, reset &lt;label&gt; = reset HEAD to a label</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">.       create a merge commit using the original merge commit&#x27;</span>s</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.       message (or the oneline, <span class="keyword">if</span> no original merge commit was</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.       specified). Use -c &lt;commit&gt; to reword the commit message.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Note that empty commits are commented out</span></span></span><br></pre></td></tr></table></figure>

<p>如果，指定 “squash” 而不是 “pick” 或 “edit”，Git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">squash 310154e updated README formatting and added blame</span><br><span class="line">squash a5f4a0d added cat-file</span><br></pre></td></tr></table></figure>

<p>当保存并退出编辑器时，Git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is a combination of 3 commits.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The first commit<span class="string">&#x27;s message is:</span></span></span><br><span class="line">changed my name a bit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">This is the 2nd commit message:</span></span></span><br><span class="line"></span><br><span class="line">updated README formatting and added blame</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">This is the 3rd commit message:</span></span></span><br><span class="line"></span><br><span class="line">added cat-file</span><br></pre></td></tr></table></figure>

<p>当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。</p>
<h3 id="拆分提交"><a href="#拆分提交" class="headerlink" title="拆分提交"></a>拆分提交</h3><p>拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated README formatting”，第二个 “added blame” 来代替原来的 “updated README formatting and added blame”。 可以通过修改 <code>rebase -i</code> 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">edit 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br></pre></td></tr></table></figure>

<p>然后，当脚本带你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（<code>f7f3f6d</code>）， 应用第二个提交（<code>310154e</code>），然后让你进入命令行。 那里，可以通过 <code>git reset HEAD^</code> 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件取消暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 <code>git rebase --continue</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD^</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;updated README formatting&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add lib/simplegit.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;added blame&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase --<span class="built_in">continue</span></span></span><br></pre></td></tr></table></figure>

<p>Git 在脚本中应用最后一次提交（<code>a5f4a0d</code>），历史记录看起来像这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> -4 --pretty=format:<span class="string">&quot;%h %s&quot;</span></span></span><br><span class="line">1c002dd added cat-file</span><br><span class="line">9b29157 added blame</span><br><span class="line">35cfb2b updated README formatting</span><br><span class="line">f3cc40e changed my name a bit</span><br></pre></td></tr></table></figure>

<p>再次强调，这些改动了所有在列表中的提交的 SHA-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。</p>
<h3 id="核武器级选项：filter-branch"><a href="#核武器级选项：filter-branch" class="headerlink" title="核武器级选项：filter-branch"></a>核武器级选项：filter-branch</h3><p>有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 <code>filter-branch</code>，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。</p>
<blockquote>
<p><code>git filter-branch</code> 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用 <code>git-filter-repo</code>，它是一个 Python 脚本，相比大多数使用 <code>filter-branch</code> 的应用来说，它做得要更好。它的文档和源码可访问 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25ld3Jlbi9naXQtZmlsdGVyLXJlcG8=">https://github.com/newren/git-filter-repo<i class="fa fa-external-link-alt"></i></span> 获取。</p>
</blockquote>
<h4 id="从每一个提交中移除一个文件"><a href="#从每一个提交中移除一个文件" class="headerlink" title="从每一个提交中移除一个文件"></a>从每一个提交中移除一个文件</h4><p>这经常发生。 有人粗心地通过 <code>git add .</code> 提交了一个巨大的二进制文件，你想要从所有地方删除。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 <code>filter-branch</code> 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 <code>passwords.txt</code> 的文件，可以使用 <code>--tree-filter</code> 选项给 <code>filter-branch</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git filter-branch --tree-filter <span class="string">&#x27;rm -f passwords.txt&#x27;</span> HEAD</span></span><br><span class="line">Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)</span><br><span class="line">Ref &#x27;refs/heads/master&#x27; was rewritten</span><br></pre></td></tr></table></figure>

<p><code>--tree-filter</code> 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 <code>passwords.txt</code> 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 <code>git filter-branch --tree-filter &#39;rm -f *~&#39; HEAD</code> 的命令。</p>
<p>最后将可以看到 Git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 <code>master</code> 分支。 为了让 <code>filter-branch</code> 在所有分支上运行，可以给命令传递 <code>--all</code> 选项。</p>
<h4 id="使一个子目录做为新的根目录"><a href="#使一个子目录做为新的根目录" class="headerlink" title="使一个子目录做为新的根目录"></a>使一个子目录做为新的根目录</h4><p>假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（<code>trunk</code>、<code>tags</code> 等等）。 如果想要让 <code>trunk</code> 子目录作为每一个提交的新的项目根目录，<code>filter-branch</code> 也可以帮助你那么做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git filter-branch --subdirectory-filter trunk HEAD</span></span><br><span class="line">Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)</span><br><span class="line">Ref &#x27;refs/heads/master&#x27; was rewritten</span><br></pre></td></tr></table></figure>

<p>现在新项目根目录是 <code>trunk</code> 子目录了。 Git 会自动移除所有不影响子目录的提交。</p>
<h4 id="全局修改邮箱地址"><a href="#全局修改邮箱地址" class="headerlink" title="全局修改邮箱地址"></a>全局修改邮箱地址</h4><p>另一个常见的情形是在你开始工作时忘记运行 <code>git config</code> 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 <code>filter-branch</code> 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 <code>--commit-filter</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git filter-branch --commit-filter <span class="string">&#x27;</span></span></span><br><span class="line">        if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ];</span><br><span class="line">        then</span><br><span class="line">                GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;</span><br><span class="line">                GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        else</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        fi&#x27; HEAD</span><br></pre></td></tr></table></figure>

<p>这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。</p>
<h2 id="重置揭密"><a href="#重置揭密" class="headerlink" title="重置揭密"></a>重置揭密</h2><p>Git 的 <code>reset</code> 和 <code>checkout</code> 命令。</p>
<h3 id="三棵树"><a href="#三棵树" class="headerlink" title="三棵树"></a>三棵树</h3><p>理解 <code>reset</code> 和 <code>checkout</code> 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）</p>
<p>Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：</p>
<table>
<thead>
<tr>
<th align="left">树</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HEAD</td>
<td align="left">上一次提交的快照，下一次提交的父结点</td>
</tr>
<tr>
<td align="left">Index</td>
<td align="left">预期的下一次提交的快照</td>
</tr>
<tr>
<td align="left">Working Directory</td>
<td align="left">沙盒</td>
</tr>
</tbody></table>
<h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 <strong>该分支上的最后一次提交</strong> 的快照。</p>
<p>其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p HEAD</span></span><br><span class="line">tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf</span><br><span class="line">author Scott Chacon  1301511835 -0700</span><br><span class="line">committer Scott Chacon  1301511835 -0700</span><br><span class="line"></span><br><span class="line">initial commit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git ls-tree -r HEAD</span></span><br><span class="line">100644 blob a906cb2a4a904a152...   README</span><br><span class="line">100644 blob 8f94139338f9404f2...   Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19...   lib</span><br></pre></td></tr></table></figure>

<p>Git 的 <code>cat-file</code> 和 <code>ls-tree</code> 是底层命令，它们一般用于底层工作，在日常工作中并不使用。 不过它们能帮助我们了解到底发生了什么。</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引是你的 <strong>预期的下一次提交</strong>。 我们也会将这个概念引用为 Git 的“暂存区”，这就是当你运行 <code>git commit</code> 时 Git 看起来的样子。</p>
<p>Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 <code>git commit</code> 将它们转换为树来用作新的提交。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git ls-files -s</span></span><br><span class="line">100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README</span><br><span class="line">100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile</span><br><span class="line">100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb</span><br></pre></td></tr></table></figure>

<p>再说一次，我们在这里又用到了 <code>git ls-files</code> 这个幕后的命令，它会显示出索引当前的样子。</p>
<p>确切来说，索引在技术上并非树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。</p>
<h4 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h4><p>最后，你就有了自己的 <strong>工作目录</strong>（通常也叫 <strong>工作区</strong>）。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 <code>.git</code> 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 <strong>沙盒</strong>。在你将修改提交到暂存区并记录到历史之前，可以随意更改。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── README</span><br><span class="line">├── Rakefile</span><br><span class="line">└── lib</span><br><span class="line">    └── simplegit.rb</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure>

<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>经典的 Git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-workflow.png" alt="reset workflow"></p>
<p>让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 <strong>v1</strong> 版本，将它标记为蓝色。 现在运行 <code>git init</code>，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的 <code>master</code> 分支。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-ex1.png" alt="reset ex1"></p>
<p>此时，只有工作目录有内容。</p>
<p>现在我们想要提交这个文件，所以用 <code>git add</code> 来获取工作目录中的内容，并将其复制到索引中。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-ex2.png" alt="reset ex2"></p>
<p>接着运行 <code>git commit</code>，它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 <code>master</code> 来指向本次提交。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-ex3.png" alt="reset ex3"></p>
<p>此时如果我们运行 <code>git status</code>，会发现没有任何改动，因为现在三棵树完全相同。</p>
<p>现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 <strong>v2</strong> 版本，并将它标记为红色。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-ex4.png" alt="reset ex4"></p>
<p>如果现在运行 <code>git status</code>，我们会看到文件显示在 “Changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 <code>git add</code> 来将它暂存到索引中。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-ex5.png" alt="reset ex5"></p>
<p>此时，由于索引和 HEAD 不同，若运行 <code>git status</code> 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 <code>git commit</code> 来完成提交。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-ex6.png" alt="reset ex6"></p>
<p>现在运行 <code>git status</code> 会没有输出，因为三棵树又变得相同了。</p>
<p>切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 <strong>HEAD</strong> 指向新的分支引用，将 <strong>索引</strong> 填充为该次提交的快照， 然后将 <strong>索引</strong> 的内容复制到 <strong>工作目录</strong> 中。</p>
<h3 id="重置的作用"><a href="#重置的作用" class="headerlink" title="重置的作用"></a>重置的作用</h3><p>在以下情景中观察 <code>reset</code> 命令会更有意义。</p>
<p>为了演示这些例子，假设我们再次修改了 <code>file.txt</code> 文件并第三次提交它。 现在的历史看起来是这样的：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-start.png" alt="reset start"></p>
<p>让我们跟着 <code>reset</code> 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。</p>
<h4 id="第-1-步：移动-HEAD"><a href="#第-1-步：移动-HEAD" class="headerlink" title="第 1 步：移动 HEAD"></a>第 1 步：移动 HEAD</h4><p><code>reset</code> 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（<code>checkout</code> 所做的）；<code>reset</code> 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 <code>master</code> 分支（例如，你正在 <code>master</code> 分支上）， 运行 <code>git reset 9e5e6a4</code> 将会使 <code>master</code> 指向 <code>9e5e6a4</code>。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-soft.png" alt="reset soft"></p>
<p>无论你调用了何种形式的带有一个提交的 <code>reset</code>，它首先都会尝试这样做。 使用 <code>reset --soft</code>，它将仅仅停在那儿。</p>
<p>现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 <code>git commit</code> 命令。 当你在运行 <code>git commit</code> 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 <code>reset</code> 回 <code>HEAD~</code>（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 <code>git commit</code> 来完成 <code>git commit --amend</code> 所要做的事情了（见 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2dpdF9hbWVuZA==">修改最后一次提交<i class="fa fa-external-link-alt"></i></span>）。</p>
<h4 id="第-2-步：更新索引（–mixed）"><a href="#第-2-步：更新索引（–mixed）" class="headerlink" title="第 2 步：更新索引（–mixed）"></a>第 2 步：更新索引（–mixed）</h4><p>注意，如果你现在运行 <code>git status</code> 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。</p>
<p>接下来，<code>reset</code> 会用 HEAD 指向的当前快照的内容来更新索引。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-mixed.png" alt="reset mixed"></p>
<p>如果指定 <code>--mixed</code> 选项，<code>reset</code> 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 <code>git reset HEAD~</code>），这就是命令将会停止的地方。</p>
<p>现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 <code>提交</code>，但还会 <em>取消暂存</em> 所有的东西。 于是，我们回滚到了所有 <code>git add</code> 和 <code>git commit</code> 的命令执行之前。</p>
<h4 id="第-3-步：更新工作目录（–hard）"><a href="#第-3-步：更新工作目录（–hard）" class="headerlink" title="第 3 步：更新工作目录（–hard）"></a>第 3 步：更新工作目录（–hard）</h4><p><code>reset</code> 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 <code>--hard</code> 选项，它将会继续这一步。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-hard.png" alt="reset hard"></p>
<p>现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、<code>git add</code> 和 <code>git commit</code> 命令 <strong>以及</strong> 工作目录中的所有工作。</p>
<p>必须注意，<code>--hard</code> 标记是 <code>reset</code> 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 <code>reset</code> 调用都可以轻松撤消，但是 <code>--hard</code> 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 <strong>v3</strong> 版本， 我们可以通过 <code>reflog</code> 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。</p>
<h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p><code>reset</code> 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：</p>
<ol>
<li>移动 HEAD 分支的指向 <em>（若指定了 <code>--soft</code>，则到此停止）</em></li>
<li>使索引看起来像 HEAD <em>（若未指定 <code>--hard</code>，则到此停止）</em></li>
<li>使工作目录看起来像索引</li>
</ol>
<h3 id="通过路径来重置"><a href="#通过路径来重置" class="headerlink" title="通过路径来重置"></a>通过路径来重置</h3><p>前面讲述了 <code>reset</code> 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，<code>reset</code> 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 <em>可以部分更新</em>，所以重置会继续进行第 2、3 步。</p>
<p>现在，假如我们运行 <code>git reset file.txt</code> （这其实是 <code>git reset --mixed HEAD file.txt</code> 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 <code>--soft</code> 或 <code>--hard</code>），它会：</p>
<ol>
<li>移动 HEAD 分支的指向 <em>（已跳过）</em></li>
<li>让索引看起来像 HEAD <em>（到此处停止）</em></li>
</ol>
<p>所以它本质上只是将 <code>file.txt</code> 从 HEAD 复制到索引中。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-path1.png" alt="reset path1"></p>
<p>它还有 <em>取消暂存文件</em> 的实际效果。 如果我们查看该命令的示意图，然后再想想 <code>git add</code> 所做的事，就会发现它们正好相反。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-path2.png" alt="reset path2"></p>
<p>这就是为什么 <code>git status</code> 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3Vuc3RhZ2luZw==">取消暂存的文件<i class="fa fa-external-link-alt"></i></span> 来了解更多。）</p>
<p>我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 <code>git reset eb43bf file.txt</code> 的命令即可。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-path3.png" alt="reset path3"></p>
<p>它其实做了同样的事情，也就是把工作目录中的文件恢复到 <strong>v1</strong> 版本，运行 <code>git add</code> 添加它， 然后再将它恢复到 <strong>v3</strong> 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 <code>git commit</code>，它就会记录一条“将该文件恢复到 <strong>v1</strong> 版本”的更改， 尽管我们并未在工作目录中真正地再次拥有它。</p>
<p>还有一点同 <code>git add</code> 一样，就是 <code>reset</code> 命令也可以接受一个 <code>--patch</code> 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。</p>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。</p>
<p>假设你的一系列提交信息中有 “oops.”“WIP” 和 “forgot this file”， 聪明的你就能使用 <code>reset</code> 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3NxdWFzaGluZw==">压缩提交<i class="fa fa-external-link-alt"></i></span> 展示了另一种方式，不过在本例中用 <code>reset</code> 更简单。）</p>
<p>假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-squash-r1.png" alt="reset squash r1"></p>
<p>那么可以运行 <code>git reset --soft HEAD~2</code> 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-squash-r2.png" alt="reset squash r2"></p>
<p>然后只需再次运行 <code>git commit</code>：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-squash-r3.png" alt="reset squash r3"></p>
<p>在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 <code>file-a.txt</code> 的提交， 接着第二个提交将 <code>file-a.txt</code> 修改成了 v3 版并增加了 <code>file-b.txt</code>。 包含 v2 版本的文件已经不在历史中了。</p>
<h3 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h3><p>最后，你大概还想知道 <code>checkout</code> 和 <code>reset</code> 之间的区别。 和 <code>reset</code> 一样，<code>checkout</code> 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。</p>
<h4 id="不带路径"><a href="#不带路径" class="headerlink" title="不带路径"></a>不带路径</h4><p>运行 <code>git checkout [branch]</code> 与运行 <code>git reset --hard [branch]</code> 非常相似，它会更新所有三棵树使其看起来像 <code>[branch]</code>，不过有两点重要的区别。</p>
<p>首先不同于 <code>reset --hard</code>，<code>checkout</code> 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有 <em>还未修改过的</em> 文件都会被更新。 而 <code>reset --hard</code> 则会不做检查就全面地替换所有东西。</p>
<p>第二个重要的区别是 <code>checkout</code> 如何更新 HEAD。 <code>reset</code> 会移动 HEAD 分支的指向，而 <code>checkout</code> 只会移动 HEAD 自身来指向另一个分支。</p>
<p>例如，假设我们有 <code>master</code> 和 <code>develop</code> 分支，它们分别指向不同的提交；我们现在在 <code>develop</code> 上（所以 HEAD 指向它）。 如果我们运行 <code>git reset master</code>，那么 <code>develop</code> 自身现在会和 <code>master</code> 指向同一个提交。 而如果我们运行 <code>git checkout master</code> 的话，<code>develop</code> 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 <code>master</code>。</p>
<p>所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但 <em>做法</em> 是非常不同的。 <code>reset</code> 会移动 HEAD 分支的指向，而 <code>checkout</code> 则移动 HEAD 自身。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/05/reset-checkout.png" alt="reset checkout"></p>
<h4 id="带路径"><a href="#带路径" class="headerlink" title="带路径"></a>带路径</h4><p>运行 <code>checkout</code> 的另一种方式就是指定一个文件路径，这会像 <code>reset</code> 一样不会移动 HEAD。 它就像 <code>git reset [branch] file</code> 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 <code>git reset --hard [branch] file</code>（如果 <code>reset</code> 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 HEAD。</p>
<p>此外，同 <code>git reset</code> 和 <code>git add</code> 一样，<code>checkout</code> 也接受一个 <code>--patch</code> 选项，允许你根据选择一块一块地恢复文件内容。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>希望你现在熟悉并理解了 <code>reset</code> 命令，不过关于它和 <code>checkout</code> 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。</p>
<p>下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而 “HEAD” 则表示只移动了 HEAD 自身。 特别注意 ‘WD Safe?’ 一列——如果它标记为 <strong>NO</strong>，那么运行该命令之前请考虑一下。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">HEAD</th>
<th align="left">Index</th>
<th align="left">Workdir</th>
<th align="left">WD Safe?</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Commit Level</strong></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>reset --soft [commit]</code></td>
<td align="left">REF</td>
<td align="left">NO</td>
<td align="left">NO</td>
<td align="left">YES</td>
</tr>
<tr>
<td align="left"><code>reset [commit]</code></td>
<td align="left">REF</td>
<td align="left">YES</td>
<td align="left">NO</td>
<td align="left">YES</td>
</tr>
<tr>
<td align="left"><code>reset --hard [commit]</code></td>
<td align="left">REF</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left"><strong>NO</strong></td>
</tr>
<tr>
<td align="left"><code>checkout &lt;commit&gt;</code></td>
<td align="left">HEAD</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">YES</td>
</tr>
<tr>
<td align="left"><strong>File Level</strong></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>reset [commit] &lt;paths&gt;</code></td>
<td align="left">NO</td>
<td align="left">YES</td>
<td align="left">NO</td>
<td align="left">YES</td>
</tr>
<tr>
<td align="left"><code>checkout [commit] &lt;paths&gt;</code></td>
<td align="left">NO</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left"><strong>NO</strong></td>
</tr>
</tbody></table>
<h2 id="高级合并"><a href="#高级合并" class="headerlink" title="高级合并"></a>高级合并</h2><p>在 Git 中合并是相当容易的。 因为 Git 使多次合并另一个分支变得很容易，这意味着你可以有一个始终保持最新的长期分支， 经常解决小的冲突，比在一系列提交后解决一个巨大的冲突要好。</p>
<p>然而，有时也会有棘手的冲突。 不像其他的版本控制系统，Git 并不会尝试过于聪明的合并冲突解决方案。 Git 的哲学是聪明地决定无歧义的合并方案，但是如果有冲突，它不会尝试智能地自动解决它。 因此，如果很久之后才合并两个分叉的分支，你可能会撞上一些问题。</p>
<h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>我们在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2Jhc2ljX21lcmdlX2NvbmZsaWN0cw==">遇到冲突时的分支合并<i class="fa fa-external-link-alt"></i></span> 介绍了解决合并冲突的一些基础知识， 对于更复杂的冲突，Git 提供了几个工具来帮助你指出将会发生什么以及如何更好地处理冲突。</p>
<p>首先，在做一次可能有冲突的合并前尽可能保证工作目录是干净的。 如果你有正在做的工作，要么提交到一个临时分支要么储藏它。 这使你可以撤消在这里尝试做的 <strong>任何事情</strong> 。 如果在你尝试一次合并时工作目录中有未保存的改动，下面的这些技巧可能会使你丢失那些工作。</p>
<p>让我们通过一个非常简单的例子来了解一下。 我们有一个超级简单的打印 ‘hello world’ 的 Ruby 文件。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span></span><br><span class="line">  puts <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<p>在我们的仓库中，创建一个名为 <code>whitespace</code> 的新分支并将所有 Unix 换行符修改为 DOS 换行符， 实质上虽然改变了文件的每一行，但改变的都只是空白字符。 然后我们修改行 “hello world” 为 “hello mundo”。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b whitespace</span></span><br><span class="line">Switched to a new branch &#x27;whitespace&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unix2dos hello.rb</span></span><br><span class="line">unix2dos: converting file hello.rb to DOS format ...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;converted hello.rb to DOS&#x27;</span></span></span><br><span class="line">[whitespace 3270f76] converted hello.rb to DOS</span><br><span class="line"> 1 file changed, 7 insertions(+), 7 deletions(-)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim hello.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff -b</span></span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index ac51efd..e85207e 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,7 +1,7 @@</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line"> def hello</span><br><span class="line">-  puts &#x27;hello world&#x27;</span><br><span class="line">+  puts &#x27;hello mundo&#x27;^M</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line"> hello()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;hello mundo change&#x27;</span></span></span><br><span class="line">[whitespace 6d338d2] hello mundo change</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>现在我们切换回我们的 <code>master</code> 分支并为函数增加一些注释。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim hello.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index ac51efd..36c06c8 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,5 +1,6 @@</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line">+# prints out a greeting</span><br><span class="line"> def hello</span><br><span class="line">   puts &#x27;hello world&#x27;</span><br><span class="line"> end</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;document the function&#x27;</span></span></span><br><span class="line">[master bec6336] document the function</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>现在我们尝试合并入我们的 <code>whitespace</code> 分支，因为修改了空白字符，所以合并会出现冲突。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge whitespace</span></span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">CONFLICT (content): Merge conflict in hello.rb</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<h4 id="中断一次合并"><a href="#中断一次合并" class="headerlink" title="中断一次合并"></a>中断一次合并</h4><p>我们现在有几个选项。 首先，让我们介绍如何摆脱这个情况。 你可能不想处理冲突这种情况，完全可以通过 <code>git merge --abort</code> 来简单地退出合并。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -sb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># master</span></span></span><br><span class="line">UU hello.rb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --abort</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status -sb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># master</span></span></span><br></pre></td></tr></table></figure>

<p><code>git merge --abort</code> 选项会尝试恢复到你运行合并前的状态。 但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好。</p>
<p>如果出于某些原因你想要重来一次，也可以运行 <code>git reset --hard HEAD</code> 回到上一次提交的状态。 请牢记此时任何未提交的工作都会丢失，所以请确认你不需要保留任何改动。</p>
<h4 id="忽略空白"><a href="#忽略空白" class="headerlink" title="忽略空白"></a>忽略空白</h4><p>在这个特定的例子中，冲突与空白有关。 我们知道这点是因为这个例子很简单，但是在实际的例子中发现这样的冲突也很容易， 因为每一行都被移除而在另一边每一行又被加回来了。 默认情况下，Git 认为所有这些行都改动了，所以它不会合并文件。</p>
<p>默认合并策略可以带有参数，其中的几个正好是关于忽略空白改动的。 如果你看到在一次合并中有大量关于空白的问题，你可以直接中止它并重做一次， 这次使用 <code>-Xignore-all-space</code> 或 <code>-Xignore-space-change</code> 选项。 第一个选项在比较行时 <strong>完全忽略</strong> 空白修改，第二个选项将一个空白符与多个连续的空白字符视作等价的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge -Xignore-space-change whitespace</span></span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> hello.rb | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>因为在本例中，实际上文件修改并没有冲突，一旦我们忽略空白修改，每一行都能被很好地合并。</p>
<p>如果你的团队中的某个人可能不小心重新格式化空格为制表符或者相反的操作，这会是一个救命稻草。</p>
<h4 id="手动文件再合并"><a href="#手动文件再合并" class="headerlink" title="手动文件再合并"></a>手动文件再合并</h4><p>虽然 Git 对空白的预处理做得很好，还有很多其他类型的修改，Git 也许无法自动处理，但是脚本可以处理它们。 例如，假设 Git 无法处理空白修改因此我们需要手动处理。</p>
<p>我们真正想要做的是对将要合并入的文件在真正合并前运行 <code>dos2unix</code> 程序。 所以如果那样的话，我们该如何做？</p>
<p>首先，我们进入到了合并冲突状态。 然后我们想要我的版本的文件，他们的版本的文件（从我们将要合并入的分支）和共同的版本的文件（从分支叉开时的位置）的拷贝。 然后我们想要修复任何一边的文件，并且为这个单独的文件重试一次合并。</p>
<p>获得这三个文件版本实际上相当容易。 Git 在索引中存储了所有这些版本，在 “stages” 下每一个都有一个数字与它们关联。 Stage 1 是它们共同的祖先版本，stage 2 是你的版本，stage 3 来自于 <code>MERGE_HEAD</code>，即你将要合并入的版本（“theirs”）。</p>
<p>通过 <code>git show</code> 命令与一个特别的语法，你可以将冲突文件的这些版本释放出一份拷贝。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show :1:hello.rb &gt; hello.common.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show :2:hello.rb &gt; hello.ours.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show :3:hello.rb &gt; hello.theirs.rb</span></span><br></pre></td></tr></table></figure>

<p>如果你想要更专业一点，也可以使用 <code>ls-files -u</code> 底层命令来得到这些文件的 Git blob 对象的实际 SHA-1 值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git ls-files -u</span></span><br><span class="line">100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb</span><br><span class="line">100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb</span><br><span class="line">100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</span><br></pre></td></tr></table></figure>

<p><code>:1:hello.rb</code> 只是查找那个 blob 对象 SHA-1 值的简写。</p>
<p>既然在我们的工作目录中已经有这所有三个阶段的内容，我们可以手工修复它们来修复空白问题，然后使用鲜为人知的 <code>git merge-file</code> 命令来重新合并那个文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dos2unix hello.theirs.rb</span></span><br><span class="line">dos2unix: converting file hello.theirs.rb to Unix format ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge-file -p \</span></span><br><span class="line"><span class="language-bash">    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff -b</span></span><br><span class="line">diff --cc hello.rb</span><br><span class="line">index 36c06c8,e85207e..0000000</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@@ -1,8 -1,7 +1,8 @@@</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line"> +# prints out a greeting</span><br><span class="line">  def hello</span><br><span class="line">-   puts &#x27;hello world&#x27;</span><br><span class="line">+   puts &#x27;hello mundo&#x27;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  hello()</span><br></pre></td></tr></table></figure>

<p>在这时我们已经漂亮地合并了那个文件。 实际上，这比使用 <code>ignore-space-change</code> 选项要更好，因为在合并前真正地修复了空白修改而不是简单地忽略它们。 在使用 <code>ignore-space-change</code> 进行合并操作后，我们最终得到了有几行是 DOS 行尾的文件，从而使提交内容混乱了。</p>
<p>如果你想要在最终提交前看一下我们这边与另一边之间实际的修改， 你可以使用 <code>git diff</code> 来比较将要提交作为合并结果的工作目录与其中任意一个阶段的文件差异。 让我们看看它们。</p>
<p>要在合并前比较结果与在你的分支上的内容，换一句话说，看看合并引入了什么，可以运行 <code>git diff --ours</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --ours</span></span><br><span class="line">* Unmerged path hello.rb</span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index 36c06c8..44d0a25 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -2,7 +2,7 @@</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">prints out a greeting</span></span><br><span class="line"> def hello</span><br><span class="line">-  puts &#x27;hello world&#x27;</span><br><span class="line">+  puts &#x27;hello mundo&#x27;</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line"> hello()</span><br></pre></td></tr></table></figure>

<p>这里我们可以很容易地看到在我们的分支上发生了什么，在这次合并中我们实际引入到这个文件的改动，是修改了其中一行。</p>
<p>如果我们想要查看合并的结果与他们那边有什么不同，可以运行 <code>git diff --theirs</code>。 在本例及后续的例子中，我们会使用 <code>-b</code> 来去除空白，因为我们将它与 Git 中的， 而不是我们清理过的 <code>hello.theirs.rb</code> 文件比较。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --theirs -b</span></span><br><span class="line">* Unmerged path hello.rb</span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index e85207e..44d0a25 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,5 +1,6 @@</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line">+# prints out a greeting</span><br><span class="line"> def hello</span><br><span class="line">   puts &#x27;hello mundo&#x27;</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>

<p>最终，你可以通过 <code>git diff --base</code> 来查看文件在两边是如何改动的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --base -b</span></span><br><span class="line">* Unmerged path hello.rb</span><br><span class="line">diff --git a/hello.rb b/hello.rb</span><br><span class="line">index ac51efd..44d0a25 100755</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,7 +1,8 @@</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line">+# prints out a greeting</span><br><span class="line"> def hello</span><br><span class="line">-  puts &#x27;hello world&#x27;</span><br><span class="line">+  puts &#x27;hello mundo&#x27;</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line"> hello()</span><br></pre></td></tr></table></figure>

<p>在这时我们可以使用 <code>git clean</code> 命令来清理我们为手动合并而创建但不再有用的额外文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git clean -f</span></span><br><span class="line">Removing hello.common.rb</span><br><span class="line">Removing hello.ours.rb</span><br><span class="line">Removing hello.theirs.rb</span><br></pre></td></tr></table></figure>

<h4 id="检出冲突"><a href="#检出冲突" class="headerlink" title="检出冲突"></a>检出冲突</h4><p>也许有时我们并不满意这样的解决方案，或许有时还要手动编辑一边或者两边的冲突，但还是依旧无法正常工作，这时我们需要更多的上下文关联来解决这些冲突。</p>
<p>让我们来稍微改动下例子。 对于本例，我们有两个长期分支，每一个分支都有几个提交，但是在合并时却创建了一个合理的冲突。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --graph --oneline --decorate --all</span></span><br><span class="line">* f1270f7 (HEAD, master) update README</span><br><span class="line">* 9af9d3b add a README</span><br><span class="line">* 694971d update phrase to hola world</span><br><span class="line">| * e3eb223 (mundo) add more tests</span><br><span class="line">| * 7cff591 add testing script</span><br><span class="line">| * c3ffff1 changed text to hello mundo</span><br><span class="line">|/</span><br><span class="line">* b7dcc89 initial hello world code</span><br></pre></td></tr></table></figure>

<p>现在有只在 <code>master</code> 分支上的三次单独提交，还有其他三次提交在 <code>mundo</code> 分支上。 如果我们尝试将 <code>mundo</code> 分支合并入 <code>master</code> 分支，我们得到一个冲突。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge mundo</span></span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">CONFLICT (content): Merge conflict in hello.rb</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>我们想要看一下合并冲突是什么。 如果我们打开这个文件，我们将会看到类似下面的内容：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="variable constant_">HEAD</span></span><br><span class="line">  puts <span class="string">&#x27;hola world&#x27;</span></span><br><span class="line">=======</span><br><span class="line">  puts <span class="string">&#x27;hello mundo&#x27;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<p>合并的两边都向这个文件增加了内容，但是导致冲突的原因是其中一些提交修改了文件的同一个地方。</p>
<p>让我们探索一下现在你手边可用来查明这个冲突是如何产生的工具。 应该如何修复这个冲突看起来或许并不明显。 这时你需要更多上下文。</p>
<p>一个很有用的工具是带 <code>--conflict</code> 选项的 <code>git checkout</code>。 这会重新检出文件并替换合并冲突标记。 如果想要重置标记并尝试再次解决它们的话这会很有用。</p>
<p>可以传递给 <code>--conflict</code> 参数 <code>diff3</code> 或 <code>merge</code>（默认选项）。 如果传给它 <code>diff3</code>，Git 会使用一个略微不同版本的冲突标记： 不仅仅只给你 “ours” 和 “theirs” 版本，同时也会有 “base” 版本在中间来给你更多的上下文。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout --conflict=diff3 hello.rb</span></span><br></pre></td></tr></table></figure>

<p>一旦我们运行它，文件看起来会像下面这样：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours</span><br><span class="line">  puts <span class="string">&#x27;hola world&#x27;</span></span><br><span class="line">|<span class="params"></span>||<span class="params"></span>||<span class="params"></span>||<span class="params"> base</span></span><br><span class="line"><span class="params">  puts &#x27;hello world&#x27;</span></span><br><span class="line"><span class="params">=======</span></span><br><span class="line"><span class="params">  puts &#x27;hello mundo&#x27;</span></span><br><span class="line"><span class="params">&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">hello()</span></span><br></pre></td></tr></table></figure>

<p>如果你喜欢这种格式，可以通过设置 <code>merge.conflictstyle</code> 选项为 <code>diff3</code> 来做为以后合并冲突的默认选项。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global merge.conflictstyle diff3</span></span><br></pre></td></tr></table></figure>

<p><code>git checkout</code> 命令也可以使用 <code>--ours</code> 和 <code>--theirs</code> 选项，这是一种无需合并的快速方式，你可以选择留下一边的修改而丢弃掉另一边修改。</p>
<p>当有二进制文件冲突时这可能会特别有用，因为可以简单地选择一边，或者可以只合并另一个分支的特定文件——可以做一次合并然后在提交前检出一边或另一边的特定文件。</p>
<h4 id="合并日志"><a href="#合并日志" class="headerlink" title="合并日志"></a>合并日志</h4><p>另一个解决合并冲突有用的工具是 <code>git log</code>。 这可以帮助你得到那些对冲突有影响的上下文。 回顾一点历史来记起为什么两条线上的开发会触碰同一片代码有时会很有用。</p>
<p>为了得到此次合并中包含的每一个分支的所有独立提交的列表， 我们可以使用之前在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3RyaXBsZV9kb3Q=">三点<i class="fa fa-external-link-alt"></i></span> 学习的“三点”语法。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --left-right HEAD...MERGE_HEAD</span></span><br><span class="line">&lt; f1270f7 update README</span><br><span class="line">&lt; 9af9d3b add a README</span><br><span class="line">&lt; 694971d update phrase to hola world</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">e3eb223 add more tests</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">7cff591 add testing script</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">c3ffff1 changed text to hello mundo</span></span><br></pre></td></tr></table></figure>

<p>这个漂亮的列表包含 6 个提交和每一个提交所在的不同开发路径。</p>
<p>我们可以通过更加特定的上下文来进一步简化这个列表。 如果我们添加 <code>--merge</code> 选项到 <code>git log</code> 中，它会只显示任何一边接触了合并冲突文件的提交。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --oneline --left-right --merge</span></span><br><span class="line">&lt; 694971d update phrase to hola world</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">c3ffff1 changed text to hello mundo</span></span><br></pre></td></tr></table></figure>

<p>如果你运行命令时用 <code>-p</code> 选项代替，你会得到所有冲突文件的区别。 快速获得你需要帮助理解为什么发生冲突的上下文，以及如何聪明地解决它，这会 <strong>非常</strong> 有用。</p>
<h4 id="组合式差异格式"><a href="#组合式差异格式" class="headerlink" title="组合式差异格式"></a>组合式差异格式</h4><p>因为 Git 暂存合并成功的结果，当你在合并冲突状态下运行 <code>git diff</code> 时，只会得到现在还在冲突状态的区别。 当需要查看你还需要解决哪些冲突时这很有用。</p>
<p>在合并冲突后直接运行的 <code>git diff</code> 会给你一个相当独特的输出格式。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --cc hello.rb</span><br><span class="line">index 0399cd5,59727f0..0000000</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@@ -1,7 -1,7 +1,11 @@@</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line">  def hello</span><br><span class="line">++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line"> +  puts &#x27;hola world&#x27;</span><br><span class="line">++=======</span><br><span class="line">+   puts &#x27;hello mundo&#x27;</span><br><span class="line">++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  hello()</span><br></pre></td></tr></table></figure>

<p>这种叫作“组合式差异”的格式会在每一行给你两列数据。 第一列为你显示 “ours” 分支与工作目录的文件区别（添加或删除）， 第二列显示 “theirs” 分支与工作目录的拷贝区别。</p>
<p>所以在上面的例子中可以看到 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> 与 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 行在工作拷贝中但是并不在合并的任意一边中。 这很有意义，合并工具因为我们的上下文被困住了，它期望我们去移除它们。</p>
<p>如果我们解决冲突再次运行 <code>git diff</code>，我们将会看到同样的事情，但是它有一点帮助。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim hello.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --cc hello.rb</span><br><span class="line">index 0399cd5,59727f0..0000000</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@@ -1,7 -1,7 +1,7 @@@</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line">  def hello</span><br><span class="line">-   puts &#x27;hola world&#x27;</span><br><span class="line"> -  puts &#x27;hello mundo&#x27;</span><br><span class="line">++  puts &#x27;hola mundo&#x27;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  hello()</span><br></pre></td></tr></table></figure>

<p>这里显示出 “hola world” 在我们这边但不在工作拷贝中，那个 “hello mundo” 在他们那边但不在工作拷贝中， 最终 “hola mundo” 不在任何一边但是现在在工作拷贝中。在提交解决方案前这对审核很有用。</p>
<p>也可以在合并后通过 <code>git log</code> 来获取相同信息，查看冲突是如何解决的。 如果你对一个合并提交运行 <code>git show</code> 命令 Git 将会输出这种格式， 或者你也可以在 <code>git log -p</code>（默认情况下该命令只会展示还没有合并的补丁）命令之后加上 <code>--cc</code> 选项。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --cc -p -1</span></span><br><span class="line">commit 14f41939956d80b9e17bb8721354c33f8d5b5a79</span><br><span class="line">Merge: f1270f7 e3eb223</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Fri Sep 19 18:14:49 2014 +0200</span><br><span class="line"></span><br><span class="line">    Merge branch &#x27;mundo&#x27;</span><br><span class="line"></span><br><span class="line">    Conflicts:</span><br><span class="line">        hello.rb</span><br><span class="line"></span><br><span class="line">diff --cc hello.rb</span><br><span class="line">index 0399cd5,59727f0..e1d0799</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@@ -1,7 -1,7 +1,7 @@@</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line">  def hello</span><br><span class="line">-   puts &#x27;hola world&#x27;</span><br><span class="line"> -  puts &#x27;hello mundo&#x27;</span><br><span class="line">++  puts &#x27;hola mundo&#x27;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  hello()</span><br></pre></td></tr></table></figure>

<h3 id="撤消合并"><a href="#撤消合并" class="headerlink" title="撤消合并"></a>撤消合并</h3><p>虽然你已经知道如何创建一个合并提交，但有时出错是在所难免的。 使用 Git 最棒的一件事情是犯错是可以的，因为有可能（大多数情况下都很容易）修复它们。</p>
<p>合并提交并无不同。 假设现在在一个主题分支上工作，不小心将其合并到 <code>master</code> 中，现在提交历史看起来是这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/06/undomerge-start-20230620161946970.png" alt="意外的合并提交"></p>
<p>Figure 138. 意外的合并提交</p>
<p>有两种方法来解决这个问题，这取决于你想要的结果是什么。</p>
<h4 id="修复引用"><a href="#修复引用" class="headerlink" title="修复引用"></a>修复引用</h4><p>如果这个不想要的合并提交只存在于你的本地仓库中，最简单且最好的解决方案是移动分支到你想要它指向的地方。 大多数情况下，如果你在错误的 <code>git merge</code> 后运行 <code>git reset --hard HEAD~</code>，这会重置分支指向所以它们看起来像这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/06/undomerge-reset.png" alt="在 `git reset --hard HEAD~` 之后的历史"></p>
<p>Figure 139. 在 <code>git reset --hard HEAD~</code> 之后的历史</p>
<p>我们之前在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2dpdF9yZXNldA==">重置揭密<i class="fa fa-external-link-alt"></i></span> 已经介绍了 <code>reset</code>，所以现在指出这里发生了什么并不是很困难。 让我们快速复习下：<code>reset --hard</code> 通常会经历三步：</p>
<ol>
<li>移动 HEAD 指向的分支。 在本例中，我们想要移动 <code>master</code> 到合并提交（<code>C6</code>）之前所在的位置。</li>
<li>使索引看起来像 HEAD。</li>
<li>使工作目录看起来像索引。</li>
</ol>
<p>这个方法的缺点是它会重写历史，在一个共享的仓库中这会造成问题的。 查阅 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX3JlYmFzZV9wZXJpbA==">变基的风险<i class="fa fa-external-link-alt"></i></span> 来了解更多可能发生的事情； 用简单的话说就是如果其他人已经有你将要重写的提交，你应当避免使用 <code>reset</code>。 如果有任何其他提交在合并之后创建了，那么这个方法也会无效；移动引用实际上会丢失那些改动。</p>
<h4 id="还原提交"><a href="#还原提交" class="headerlink" title="还原提交"></a>还原提交</h4><p>如果移动分支指针并不适合你，Git 给你一个生成一个新提交的选项，提交将会撤消一个已存在提交的所有修改。 Git 称这个操作为“还原”，在这个特定的场景下，你可以像这样调用它：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git revert -m 1 HEAD</span></span><br><span class="line">[master b1d8379] Revert &quot;Merge branch &#x27;topic&#x27;&quot;</span><br></pre></td></tr></table></figure>

<p><code>-m 1</code> 标记指出 “mainline” 需要被保留下来的父结点。 当你引入一个合并到 <code>HEAD</code>（<code>git merge topic</code>），新提交有两个父结点：第一个是 <code>HEAD</code>（<code>C6</code>），第二个是将要合并入分支的最新提交（<code>C4</code>）。 在本例中，我们想要撤消所有由父结点 #2（<code>C4</code>）合并引入的修改，同时保留从父结点 #1（<code>C6</code>）开始的所有内容。</p>
<p>有还原提交的历史看起来像这样：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/06/undomerge-revert-20230620162105260.png" alt="在 `git revert -m 1` 后的历史"></p>
<p>Figure 140. 在 <code>git revert -m 1</code> 后的历史</p>
<p>新的提交 <code>^M</code> 与 <code>C6</code> 有完全一样的内容，所以从这儿开始就像合并从未发生过，除了“现在还没合并”的提交依然在 <code>HEAD</code> 的历史中。 如果你尝试再次合并 <code>topic</code> 到 <code>master</code> Git 会感到困惑：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge topic</span></span><br><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure>

<p><code>topic</code> 中并没有东西不能从 <code>master</code> 中追踪到达。 更糟的是，如果你在 <code>topic</code> 中增加工作然后再次合并，Git 只会引入被还原的合并 <em>之后</em> 的修改。</p>
<p><img src="https://git-scm.com/book/en/v2/images/undomerge-revert2.png" alt="含有坏掉合并的历史"></p>
<p>Figure 141. 含有坏掉合并的历史</p>
<p>解决这个最好的方式是撤消还原原始的合并，因为现在你想要引入被还原出去的修改，<strong>然后</strong> 创建一个新的合并提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git revert ^M</span></span><br><span class="line">[master 09f0126] Revert &quot;Revert &quot;Merge branch &#x27;topic&#x27;&quot;&quot;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge topic</span></span><br></pre></td></tr></table></figure>

<p><img src="https://git-scm.com/book/en/v2/images/undomerge-revert3.png" alt="在重新合并一个还原合并后的历史"></p>
<p>Figure 142. 在重新合并一个还原合并后的历史</p>
<p>在本例中，<code>M</code> 与 <code>^M</code> 抵消了。 <code>^^M</code> 事实上合并入了 <code>C3</code> 与 <code>C4</code> 的修改，<code>C8</code> 合并了 <code>C7</code> 的修改，所以现在 <code>topic</code> 已经完全被合并了。</p>
<h3 id="其他类型的合并"><a href="#其他类型的合并" class="headerlink" title="其他类型的合并"></a>其他类型的合并</h3><p>到目前为止我们介绍的都是通过一个叫作 “recursive” 的合并策略来正常处理的两个分支的正常合并。 然而还有其他方式来合并两个分支到一起。 让我们来快速介绍其中的几个。</p>
<h4 id="我们的或他们的偏好"><a href="#我们的或他们的偏好" class="headerlink" title="我们的或他们的偏好"></a>我们的或他们的偏好</h4><p>首先，有另一种我们可以通过 “recursive” 合并模式做的有用工作。 我们之前已经看到传递给 <code>-X</code> 的 <code>ignore-all-space</code> 与 <code>ignore-space-change</code> 选项， 但是我们也可以告诉 Git 当它看见一个冲突时直接选择一边。</p>
<p>默认情况下，当 Git 看到两个分支合并中的冲突时，它会将合并冲突标记添加到你的代码中并标记文件为冲突状态来让你解决。 如果你希望 Git 简单地选择特定的一边并忽略另外一边而不是让你手动解决冲突，你可以传递给 <code>merge</code> 命令一个 <code>-Xours</code> 或 <code>-Xtheirs</code> 参数。</p>
<p>如果 Git 看到这个，它并不会增加冲突标记。 任何可以合并的区别，它会直接合并。 任何有冲突的区别，它会简单地选择你全局指定的一边，包括二进制文件。</p>
<p>如果我们回到之前我们使用的 “hello world” 例子中，我们可以看到合并入我们的分支时引发了冲突。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge mundo</span></span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">CONFLICT (content): Merge conflict in hello.rb</span><br><span class="line">Resolved &#x27;hello.rb&#x27; using previous resolution.</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>然而如果我们运行时增加 <code>-Xours</code> 或 <code>-Xtheirs</code> 参数就不会有冲突。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge -Xours mundo</span></span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> hello.rb | 2 +-</span><br><span class="line"> test.sh  | 2 ++</span><br><span class="line"> 2 files changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 test.sh</span><br></pre></td></tr></table></figure>

<p>在上例中，它并不会为 “hello mundo” 与 “hola world” 标记合并冲突，它只会简单地选取 “hola world”。 然而，在那个分支上所有其他非冲突的改动都可以被成功地合并入。</p>
<p>这个选项也可以传递给我们之前看到的 <code>git merge-file</code> 命令， 通过运行类似 <code>git merge-file --ours</code> 的命令来合并单个文件。</p>
<p>如果想要做类似的事情但是甚至并不想让 Git 尝试合并另外一边的修改， 有一个更严格的选项，它是 “ours” 合并 <em>策略</em>。 这与 “ours” recursive 合并 <em>选项</em> 不同。</p>
<p>这本质上会做一次假的合并。 它会记录一个以两边分支作为父结点的新合并提交，但是它甚至根本不关注你正合并入的分支。 它只会简单地把当前分支的代码当作合并结果记录下来。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge -s ours mundo</span></span><br><span class="line">Merge made by the &#x27;ours&#x27; strategy.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff HEAD HEAD~</span></span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>你可以看到合并后与合并前我们的分支并没有任何区别。</p>
<p>当再次合并时从本质上欺骗 Git 认为那个分支已经合并过经常是很有用的。 例如，假设你有一个分叉的 <code>release</code> 分支并且在上面做了一些你想要在未来某个时候合并回 <code>master</code> 的工作。 与此同时 <code>master</code> 分支上的某些 bugfix 需要向后移植回 <code>release</code> 分支。 你可以合并 bugfix 分支进入 <code>release</code> 分支同时也 <code>merge -s ours</code> 合并进入你的 <code>master</code> 分支 （即使那个修复已经在那儿了）这样当你之后再次合并 <code>release</code> 分支时，就不会有来自 bugfix 的冲突。</p>
<h4 id="子树合并"><a href="#子树合并" class="headerlink" title="子树合并"></a>子树合并</h4><p>子树合并的思想是你有两个项目，并且其中一个映射到另一个项目的一个子目录，或者反过来也行。 当你执行一个子树合并时，Git 通常可以自动计算出其中一个是另外一个的子树从而实现正确的合并。</p>
<p>我们来看一个例子如何将一个项目加入到一个已存在的项目中，然后将第二个项目的代码合并到第一个项目的子目录中。</p>
<p>首先，我们将 Rack 应用添加到你的项目里。 我们把 Rack 项目作为一个远程的引用添加到我们的项目里，然后检出到它自己的分支。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add rack_remote https://github.com/rack/rack</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch rack_remote --no-tags</span></span><br><span class="line">warning: no common commits</span><br><span class="line">remote: Counting objects: 3184, done.</span><br><span class="line">remote: Compressing objects: 100% (1465/1465), done.</span><br><span class="line">remote: Total 3184 (delta 1952), reused 2770 (delta 1675)</span><br><span class="line">Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (1952/1952), done.</span><br><span class="line">From https://github.com/rack/rack</span><br><span class="line"> * [new branch]      build      -&gt; rack_remote/build</span><br><span class="line"> * [new branch]      master     -&gt; rack_remote/master</span><br><span class="line"> * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4</span><br><span class="line"> * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b rack_branch rack_remote/master</span></span><br><span class="line">Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.</span><br><span class="line">Switched to a new branch &quot;rack_branch&quot;</span><br></pre></td></tr></table></figure>

<p>现在在我们的 <code>rack_branch</code> 分支里就有 Rack 项目的根目录，而我们的项目则在 <code>master</code> 分支里。 如果你从一个分支切换到另一个分支，你可以看到它们的项目根目录是不同的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib</span><br><span class="line">COPYING         README         bin           example         test</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &quot;master&quot;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README</span><br></pre></td></tr></table></figure>

<p>这个是一个比较奇怪的概念。 并不是仓库中的所有分支都是必须属于同一个项目的分支. 这并不常见，因为没啥用，但是却是在不同分支里包含两条完全不同提交历史的最简单的方法。</p>
<p>在这个例子中，我们希望将 Rack 项目拉到 <code>master</code> 项目中作为一个子目录。 我们可以在 Git 中执行 <code>git read-tree</code> 来实现。 你可以在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvY2gxMC1naXQtaW50ZXJuYWxz">Git 内部原理<i class="fa fa-external-link-alt"></i></span> 中查看更多 <code>read-tree</code> 的相关信息，现在你只需要知道它会读取一个分支的根目录树到当前的暂存区和工作目录里。 先切回你的 <code>master</code> 分支，将 <code>rack_back</code> 分支拉取到我们项目的 <code>master</code> 分支中的 <code>rack</code> 子目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git read-tree --prefix=rack/ -u rack_branch</span></span><br></pre></td></tr></table></figure>

<p>当我们提交时，那个子目录中拥有所有 Rack 项目的文件 —— 就像我们直接从压缩包里复制出来的一样。 有趣的是你可以很容易地将一个分支的变更合并到另一个分支里。 所以，当 Rack 项目有更新时，我们可以切换到那个分支来拉取上游的变更。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout rack_branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull</span></span><br></pre></td></tr></table></figure>

<p>接着，我们可以将这些变更合并回我们的 <code>master</code> 分支。 使用 <code>--squash</code> 选项和使用 <code>-Xsubtree</code> 选项（它采用递归合并策略）， 都可以用来可以拉取变更并且预填充提交信息。 （递归策略在这里是默认的，提到它是为了让读者有个清晰的概念。）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --squash -s recursive -Xsubtree=rack rack_branch</span></span><br><span class="line">Squash commit -- not updating HEAD</span><br><span class="line">Automatic merge went well; stopped before committing as requested</span><br></pre></td></tr></table></figure>

<p>Rack 项目中所有的改动都被合并了，等待被提交到本地。 你也可以用相反的方法——在 <code>master</code> 分支上的 <code>rack</code> 子目录中做改动然后将它们合并入你的 <code>rack_branch</code> 分支中，之后你可能将其提交给项目维护着或者将它们推送到上游。</p>
<p>这给我们提供了一种类似子模块工作流的工作方式，但是它并不需要用到子模块 （有关子模块的内容我们会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2dpdF9zdWJtb2R1bGVz">子模块<i class="fa fa-external-link-alt"></i></span> 中介绍）。 我们可以在自己的仓库中保持一些和其他项目相关的分支，偶尔使用子树合并将它们合并到我们的项目中。 某些时候这种方式很有用，例如当所有的代码都提交到一个地方的时候。 然而，它同时也有缺点，它更加复杂且更容易让人犯错，例如重复合并改动或者不小心将分支提交到一个无关的仓库上去。</p>
<p>另外一个有点奇怪的地方是，当你想查看 <code>rack</code> 子目录和 <code>rack_branch</code> 分支的差异—— 来确定你是否需要合并它们——你不能使用普通的 <code>diff</code> 命令。 取而代之的是，你必须使用 <code>git diff-tree</code> 来和你的目标分支做比较：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff-tree -p rack_branch</span></span><br></pre></td></tr></table></figure>

<p>或者，将你的 <code>rack</code> 子目录和最近一次从服务器上抓取的 <code>master</code> 分支进行比较，你可以运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff-tree -p rack_remote/master</span></span><br></pre></td></tr></table></figure>

<h2 id="Rerere-1"><a href="#Rerere-1" class="headerlink" title="Rerere"></a>Rerere</h2><p><code>git rerere</code> 功能是一个隐藏的功能。 正如它的名字“重用记录的解决方案（reuse recorded resolution）”所示，它允许你让 Git 记住解决一个块冲突的方法， 这样在下一次看到相同冲突时，Git 可以为你自动地解决它。</p>
<p>有几种情形下这个功能会非常有用。 在文档中提到的一个例子是想要保证一个长期分支会干净地合并，但是又不想要一串中间的合并提交弄乱你的提交历史。 将 <code>rerere</code> 功能开启后，你可以试着偶尔合并，解决冲突，然后退出合并。 如果你持续这样做，那么最终的合并会很容易，因为 <code>rerere</code> 可以为你自动做所有的事情。</p>
<p>可以将同样的策略用在维持一个变基的分支时，这样就不用每次解决同样的变基冲突了。 或者你将一个分支合并并修复了一堆冲突后想要用变基来替代合并——你可能并不想要再次解决相同的冲突。</p>
<p>另一个 <code>rerere</code> 的应用场景是当你偶尔将一堆正在改进的主题分支合并到一个可测试的头时，就像 Git 项目自身经常做的。 如果测试失败，你可以倒回合并之前然后在去除导致测试失败的那个主题分支后重做合并，而不用再次重新解决所有的冲突。</p>
<p>要启用 <code>rerere</code> 功能，只需运行以下配置选项即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global rerere.enabled <span class="literal">true</span></span></span><br></pre></td></tr></table></figure>

<p>你也可以通过在特定的仓库中创建 <code>.git/rr-cache</code> 目录来开启它，但是设置选项更干净并且可以应用到全局。</p>
<p>现在我们看一个简单的例子，类似之前的那个。 假设有一个名为 <code>hello.rb</code> 的文件如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span></span><br><span class="line">  puts <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在一个分支中修改单词 “hello” 为 “hola”，然后在另一个分支中修改 “world” 为 “mundo”，就像之前一样。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/06/rerere1.png" alt="rerere1"></p>
<p>当合并两个分支到一起时，我们将会得到一个合并冲突：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge i18n-world</span></span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">CONFLICT (content): Merge conflict in hello.rb</span><br><span class="line">Recorded preimage for &#x27;hello.rb&#x27;</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>你会注意到那个新行 <code>Recorded preimage for FILE</code>。 除此之外它应该看起来就像一个普通的合并冲突。 在这个时候，<code>rerere</code> 可以告诉我们几件事。 和往常一样，在这个时候你可以运行 <code>git status</code> 来查看所有冲突的内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unmerged paths:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#	both modified:      hello.rb</span></span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure>

<p>然而，<code>git rerere</code> 也会通过 <code>git rerere status</code> 告诉你它记录的合并前状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rerere status</span></span><br><span class="line">hello.rb</span><br></pre></td></tr></table></figure>

<p>并且 <code>git rerere diff</code> 将会显示解决方案的当前状态——开始解决前与解决后的样子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rerere diff</span></span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,11 +1,11 @@</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line"> def hello</span><br><span class="line">-&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">-  puts &#x27;hello mundo&#x27;</span><br><span class="line">-=======</span><br><span class="line">+&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">   puts &#x27;hola world&#x27;</span><br><span class="line"><span class="meta prompt_">-&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line">+=======</span><br><span class="line">+  puts &#x27;hello mundo&#x27;</span><br><span class="line">+&gt;&gt;&gt;&gt;&gt;&gt;&gt; i18n-world</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>

<p>同样（这并不是真的与 <code>rerere</code> 有关系），可以使用 <code>git ls-files -u</code> 来查看冲突文件的之前、左边与右边版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git ls-files -u</span></span><br><span class="line">100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1	hello.rb</span><br><span class="line">100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2	hello.rb</span><br><span class="line">100644 54336ba847c3758ab604876419607e9443848474 3	hello.rb</span><br></pre></td></tr></table></figure>

<p>现在可以通过改为 <code>puts &#39;hola mundo&#39;</code> 来解决它，可以再次运行 <code>git rerere diff</code> 命令来查看 rerere 将会记住的内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rerere diff</span></span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@ -1,11 +1,7 @@</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line"> def hello</span><br><span class="line">-&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">-  puts &#x27;hello mundo&#x27;</span><br><span class="line">-=======</span><br><span class="line">-  puts &#x27;hola world&#x27;</span><br><span class="line"><span class="meta prompt_">-&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line">+  puts &#x27;hola mundo&#x27;</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>

<p>所以从本质上说，当 Git 看到一个 <code>hello.rb</code> 文件的一个块冲突中有 “hello mundo” 在一边与 “hola world” 在另一边，它会将其解决为 “hola mundo”。</p>
<p>现在我们可以将它标记为已解决并提交它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add hello.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br><span class="line">Recorded resolution for &#x27;hello.rb&#x27;.</span><br><span class="line">[master 68e16e5] Merge branch &#x27;i18n&#x27;</span><br></pre></td></tr></table></figure>

<p>可以看到它 “Recorded resolution for FILE”。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/06/rerere2.png" alt="rerere2"></p>
<p>现在，让我们撤消那个合并然后将它变基到 <code>master</code> 分支顶部来替代它。 可以通过使用之前在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2dpdF9yZXNldA==">重置揭密<i class="fa fa-external-link-alt"></i></span> 看到的 <code>git reset</code> 来回滚分支。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard HEAD^</span></span><br><span class="line">HEAD is now at ad63f15 i18n the hello</span><br></pre></td></tr></table></figure>

<p>我们的合并被撤消了。 现在让我们变基主题分支。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout i18n-world</span></span><br><span class="line">Switched to branch &#x27;i18n-world&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase master</span></span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: i18n one word</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.rb</span><br><span class="line">CONFLICT (content): Merge conflict in hello.rb</span><br><span class="line">Resolved &#x27;hello.rb&#x27; using previous resolution.</span><br><span class="line">Failed to merge in the changes.</span><br><span class="line">Patch failed at 0001 i18n one word</span><br></pre></td></tr></table></figure>

<p>现在，正像我们期望的一样，得到了相同的合并冲突，但是看一下 <code>Resolved FILE using previous resolution</code> 这行。 如果我们看这个文件，会发现它已经被解决了，而且在它里面没有合并冲突标记。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span></span><br><span class="line">  puts <span class="string">&#x27;hola mundo&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>同样，<code>git diff</code> 将会显示出它是如何自动地重新解决的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff</span></span><br><span class="line">diff --cc hello.rb</span><br><span class="line">index a440db6,54336ba..0000000</span><br><span class="line">--- a/hello.rb</span><br><span class="line">+++ b/hello.rb</span><br><span class="line">@@@ -1,7 -1,7 +1,7 @@@</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line">  def hello</span><br><span class="line">-   puts &#x27;hola world&#x27;</span><br><span class="line"> -  puts &#x27;hello mundo&#x27;</span><br><span class="line">++  puts &#x27;hola mundo&#x27;</span><br><span class="line">  end</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/06/rerere3.png" alt="rerere3"></p>
<p>也可以通过 <code>git checkout</code> 命令重新恢复到冲突时候的文件状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout --conflict=merge hello.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> hello.rb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line">def hello</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours</span><br><span class="line">  puts &#x27;hola world&#x27;</span><br><span class="line">=======</span><br><span class="line">  puts &#x27;hello mundo&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt; theirs</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>我们将会在 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL2NoMDAvX2FkdmFuY2VkX21lcmdpbmc=">高级合并<i class="fa fa-external-link-alt"></i></span> 中看到这个的一个例子。 然而现在，让我们通过运行 <code>git rerere</code> 来重新解决它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rerere</span></span><br><span class="line">Resolved &#x27;hello.rb&#x27; using previous resolution.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> hello.rb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line">def hello</span><br><span class="line">  puts &#x27;hola mundo&#x27;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>我们通过 <code>rerere</code> 缓存的解决方案来自动重新解决了文件冲突。 现在可以添加并继续变基来完成它。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add hello.rb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase --<span class="built_in">continue</span></span></span><br><span class="line">Applying: i18n one word</span><br></pre></td></tr></table></figure>

<p>所以，如果做了很多次重新合并，或者想要一个主题分支始终与你的 <code>master</code> 分支保持最新但却不想要一大堆合并， 或者经常变基，打开 <code>rerere</code> 功能可以帮助你的生活变得更美好。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/48a2.html" rel="prev" title="Golang代码质量持续检测">
                  <i class="fa fa-chevron-left"></i> Golang代码质量持续检测
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/fe74.html" rel="next" title="LeetCode每日一题">
                  LeetCode每日一题 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mitaka xu</span>
</div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"TVx6Wkfs8VJGOwYPurtjWY2e-9Nh9j0Va","app_key":"c7VvaRnyF8r3DUIPq1x2KJ7Q","server_url":"https://tvx6wkfs.lc-cn-e1-shared.com","security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"xiaoyeshiyu","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
