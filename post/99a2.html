<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="S_5aoPFd3QQihrUOLiKdVR0Mj4fj6n6qJojwyjj9cAY">
  <meta name="msvalidate.01" content="9032A67FCF787F07CB04374E59E518A9">
  <meta name="baidu-site-verification" content="code-Onlniop0d6">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.xiaoyeshiyu.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="消息队列之RabbitMQ。RabbitMQ是最为常用的开源消息中间件，支持队列、工作分配、发布订阅、路由、主题、RPC的模式，插件丰富，自带管理页面，是后端程序员必须掌握的后端技术栈。">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ学习笔记">
<meta property="og:url" content="https://www.xiaoyeshiyu.com/post/99a2.html">
<meta property="og:site_name" content="小夜时雨">
<meta property="og:description" content="消息队列之RabbitMQ。RabbitMQ是最为常用的开源消息中间件，支持队列、工作分配、发布订阅、路由、主题、RPC的模式，插件丰富，自带管理页面，是后端程序员必须掌握的后端技术栈。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/hello-world-example-routing.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221024105047528.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20220712000102279.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20220712000153120.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20220712000349394.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20220712000945238.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20220712001451062.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/1620.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/1620-20221024102352276.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/10/2226025-20210527172158028-453119641.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/1460000038432420-20221101173426296.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/rabbitmq-quorum-queues-raft-consensus-illustration.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101165313406.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101174856959.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101180228811.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101175016438.png">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221101175138523.png">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221101175203161.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101175236843.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101175508511.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101175559718.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101175624932.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101180601759.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101180629694.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101180945564.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181444396.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181123405.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181229790.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181425946.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181531898.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181610421.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181630242.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181640713.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181915439.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181936703.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101182146762.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101182301229.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101182331051.png">
<meta property="article:published_time" content="2022-07-11T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-08T01:41:30.594Z">
<meta property="article:author" content="Mitaka xu">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/hello-world-example-routing.png">


<link rel="canonical" href="https://www.xiaoyeshiyu.com/post/99a2.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.xiaoyeshiyu.com/post/99a2.html","path":"post/99a2.html","title":"RabbitMQ学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>RabbitMQ学习笔记 | 小夜时雨</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MBVJ11TVHH"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBVJ11TVHH","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?573725610fbc6ff9b42032bd13615370"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="小夜时雨" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小夜时雨</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">君子敬其在己者，而不慕其在天者，是以日进也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AMQP"><span class="nav-number">2.</span> <span class="nav-text">AMQP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">消息队列的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">5.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87golang%E6%93%8D%E4%BD%9Crabbitmq"><span class="nav-number">6.</span> <span class="nav-text">通过golang操作rabbitmq</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">6.1.</span> <span class="nav-text">获取客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F%E3%80%81%E5%B7%A5%E4%BD%9C%E5%88%86%E9%85%8D%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">队列模式、工作分配模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.3.</span> <span class="nav-text">发布、订阅模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.4.</span> <span class="nav-text">路由模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.5.</span> <span class="nav-text">主题模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="nav-number">6.6.</span> <span class="nav-text">方法说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Return%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6"><span class="nav-number">6.7.</span> <span class="nav-text">Return消息机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#qos%E9%99%90%E6%B5%81"><span class="nav-number">6.8.</span> <span class="nav-text">qos限流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ack%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="nav-number">6.9.</span> <span class="nav-text">ack消息确认机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TTL%E9%98%9F%E5%88%97%E3%80%81%E6%B6%88%E6%81%AF"><span class="nav-number">6.10.</span> <span class="nav-text">TTL队列、消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97-DLX-Dead-letter-Exchange"><span class="nav-number">6.11.</span> <span class="nav-text">死信队列 DLX Dead-letter-Exchange</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">高可用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.1.</span> <span class="nav-text">普通集群模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.2.</span> <span class="nav-text">镜像队列模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E9%99%B7"><span class="nav-number">7.2.1.</span> <span class="nav-text">缺陷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97"><span class="nav-number">7.3.</span> <span class="nav-text">仲裁队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF"><span class="nav-number">7.3.1.</span> <span class="nav-text">优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A3%E5%8A%BF"><span class="nav-number">7.3.2.</span> <span class="nav-text">劣势</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E6%80%A7%E6%9B%B4%E5%B0%91"><span class="nav-number">7.3.2.1.</span> <span class="nav-text">特性更少</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E5%86%99%E5%85%A5%E6%94%BE%E5%A4%A7"><span class="nav-number">7.3.2.2.</span> <span class="nav-text">磁盘使用——写入放大</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94%E6%89%80%E6%9C%89%E6%B6%88%E6%81%AF%E4%B8%80%E7%9B%B4%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD"><span class="nav-number">7.3.2.3.</span> <span class="nav-text">内存使用——所有消息一直保存在内存中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%B1%E5%8E%BB%E5%A4%9A%E6%95%B0%E8%8A%82%E7%82%B9%E6%97%B6%E6%84%8F%E5%91%B3%E7%9D%80%E9%98%9F%E5%88%97%E4%B8%8D%E5%8F%AF%E7%94%A8"><span class="nav-number">7.3.2.4.</span> <span class="nav-text">失去多数节点时意味着队列不可用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F"><span class="nav-number">7.3.2.5.</span> <span class="nav-text">延迟</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87kubernetes%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8RabbitMQ%E9%9B%86%E7%BE%A4"><span class="nav-number">8.</span> <span class="nav-text">通过kubernetes搭建高可用RabbitMQ集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F-1"><span class="nav-number">8.1.</span> <span class="nav-text">普通集群模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E9%98%9F%E9%87%8C%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.2.</span> <span class="nav-text">镜像队里模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97-1"><span class="nav-number">8.3.</span> <span class="nav-text">仲裁队列</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mitaka xu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mitaka xu</p>
  <div class="site-description" itemprop="description">Golang开发博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaoyeshiyu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/99a2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="RabbitMQ学习笔记 | 小夜时雨">
      <meta itemprop="description" content="消息队列之RabbitMQ。RabbitMQ是最为常用的开源消息中间件，支持队列、工作分配、发布订阅、路由、主题、RPC的模式，插件丰富，自带管理页面，是后端程序员必须掌握的后端技术栈。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RabbitMQ学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-07-12 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-12T00:00:00+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-08 09:41:30" itemprop="dateModified" datetime="2023-09-08T09:41:30+08:00">2023-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/midware/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
    </span>

  
    <span id="/post/99a2.html" class="post-meta-item leancloud_visitors" data-flag-title="RabbitMQ学习笔记" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

            <div class="post-description">消息队列之RabbitMQ。RabbitMQ是最为常用的开源消息中间件，支持队列、工作分配、发布订阅、路由、主题、RPC的模式，插件丰富，自带管理页面，是后端程序员必须掌握的后端技术栈。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>消息系统允许软件、应用相互连接和扩展．这些应用可以相互链接起来组成一个更大的应用，或者将用户设备和数据进行连接．消息系统通过将消息的发送和接收分离来实现应用程序的异步和解偶．</strong></p>
<p>或许你正在考虑进行数据投递，非阻塞操作或推送通知。或许你想要实现发布／订阅，异步处理，或者工作队列。所有这些都可以通过消息系统实现。</p>
<p>RabbitMQ是一个消息代理 - 一个消息系统的媒介。它可以为你的应用提供一个通用的消息发送和接收平台，并且保证消息在传输过程中的安全。</p>
<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP（高级消息队列协议）是一个网络协议。它支持符合要求的客户端应用（application）和消息中间件代理（messaging middleware broker）之间进行通信。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/hello-world-example-routing.png" alt="enter image description here"></p>
<p>消息（message）被发布者（publisher）发送给交换机（exchange），交换机常常被比喻成邮局或者邮箱。然后交换机将收到的消息根据路由规则分发给绑定的队列（queue）。最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221024105047528.png" alt="image-20221024105047528"></p>
<p><strong>Connection</strong>：AMQP是一个长连接协议。Connection被设计为长期使用的，可以携带多个Channel。</p>
<p><strong>Channel</strong>：AMQP是一个多通道协议。Channel提供了一种方式，在比较重的TCP&#x2F;IP连接上建立多个轻量级的连接。这会让协议对防火墙更加友好，因为端口使用是可预知的。它也意味着很容易支持流量调整和其他QoS特性。</p>
<p><strong>Exchange</strong>：Exchange类能够让应用操作服务端的交换器。这个类能够让程序自己设置路由，而不是通过某些配置。不过大部分程序并不需要这个级别的复杂度，过去的中间件也不只支持这个语义。</p>
<p><strong>Queue</strong>：该类用于让程序管理服务端上的消息队列。几乎所有的消费者应用都是基本步骤，至少要验证使用的消息队列是否存在。</p>
<p><strong>VHost</strong>：虚拟主机是服务端的一个数据分区。在多租户使用是，可以方便进行管理。虚拟主机有自己的命名空间、交换器、消息队列等等。<strong>所有连接，只可能和一个虚拟主机建立。</strong></p>
<p><strong>Exchange</strong>：交换器是一个虚拟主机内的消息路由Agent。用于处理消息的路由信息（一般是Routing-Key），然后将其发送到消息队列或者内部服务中。交换器可能是持久化的、临时的、自动删除的。交换器把消息路由到消息队列时可以是并行的。这会创建一个消息的多个实例。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>队列模式：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20220712000102279.png" alt="image-20220712000102279"></p>
<ul>
<li>一个生产者，一个队列，一个消费者</li>
<li>生产者将消息发送到一个指定队列，消费者监听队列消费</li>
</ul>
<p>工作分配模式：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20220712000153120.png" alt="image-20220712000153120"></p>
<ul>
<li>一个生产者，一个队列，多个消费者</li>
<li>生产者将消息发送到一个指定队列</li>
<li>多个消费者同时监听一个队列，从队列中抢消息</li>
</ul>
<p>发布、订阅模式</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20220712000349394.png" alt="image-20220712000349394"></p>
<ul>
<li>一个生产者，一个<code>exchange</code>，多个队列</li>
<li>生产者将消息发送到<code>exchange</code>，由<code>exchange</code>发送给每一个队列，每个队列的消息是一样的</li>
<li><code>exchange</code>不负责存储，如果没有绑定队列，则会将消息丢弃</li>
<li><code>exchange</code>类型是<code>fanout</code>，发送到所有绑定到exchange的队列</li>
</ul>
<p>路由模式</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20220712000945238.png" alt="image-20220712000945238"></p>
<ul>
<li>一个生产者，一个<code>exchange</code>，多个队列，多个消费者</li>
<li><code>exchange</code>类型是<code>direct</code>，通过消息的<code>routing-key</code>将消息发送到不同的队列</li>
<li>生产者将消息发送到<code>exchange</code>时需要指定<code>routing-key</code>，如果没有被<code>exchange</code>匹配上，则消息会被丢弃</li>
<li>队列定义时，需要通过<code>routing-key</code>与<code>exchange</code>绑定，通过<code>routing-key</code>获取不同的消息</li>
</ul>
<p>主题模式</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20220712001451062.png" alt="image-20220712001451062"></p>
<ul>
<li>一个生产者，一个<code>exchange</code>，多个队列，多个消费者</li>
<li><code>exchange</code>类型是<code>topic</code>，通过消息的<code>routing-key</code>将消息发送到不同的队列</li>
<li>不同的<code>routing-key</code>通过字符串匹配，发往不同的队列，其中<code>*</code>匹配一个单词，<code>#</code>匹配0个或更多的单词</li>
</ul>
<h2 id="消息队列的问题"><a href="#消息队列的问题" class="headerlink" title="消息队列的问题"></a>消息队列的问题</h2><ol>
<li><p>为什么会造成重复消息</p>
<p>由于网络传输等问题，在消息提交时没有收到ack，导致消息重复提交；或者在消费消息时，消费者ack时队列没有收到，这个消息被发送给多个消费者</p>
</li>
<li><p>如何解决重复消息</p>
<p>不同的消息队列有不同的解决方案。</p>
<p>rabbitmq中，rabbitmq不保证消息不重复，则需要业务端去重。</p>
<ul>
<li>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现</li>
<li>拿到这个消息做数据库的insert操作，给这个消息做一个唯一主键</li>
</ul>
</li>
<li><p>如何保证消息的可靠性传输</p>
<p>每个MQ都要从三个角度来分析：生产者丢弃消息、消息队列丢失消息、消费者丢失消息，以rabbitmq为例</p>
<ul>
<li><p>生产者丢失消息</p>
<p>rabbitmq提供<code>transaction</code>和<code>confirm</code>模式来确保生产者不丢消息。</p>
<p><code>transaction</code>机制，发送消息前，开启事务(<code>channel.txSelect()</code>)，然后发送消息，如果发送过程中出现异常，事务就会回滚(<code>channel.txRollback()</code>)，如果发送成功，则提交事务(<code>channel.txCommit()</code>)。缺点是吞吐下降。</p>
<p><code>confirm</code>机制，所有在该信道上面发布的消息都会被指派到一个唯一的ID，一旦消息被投递到所有匹配的队列之后，<code>rabbitmq</code>就会发送一个<code>ack</code>给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列。如果<code>rabbitmq</code>没能处理消息，则会发送一个<code>Nack</code>消息，生产者可以重试操作。</p>
</li>
<li><p>消息队列丢失数据</p>
<p>一般是开启磁盘持久化的配置。这个持久化配置可以和<code>confirm</code>机制配合使用，在持久化磁盘之后，再给生产者发送一个<code>ack</code>。</p>
<p>持久化的步骤：</p>
<ol>
<li>将<code>queue</code>的持久化标识<code>durable</code>设置为<code>true</code>，则代表一个持久化队列</li>
<li>发送消息时，将<code>deliveryMode=2</code>，<code>rabbitmq</code>挂了之后，重启后也能恢复数据</li>
</ol>
</li>
<li><p>消费者丢失数据</p>
<p>这种情况一般是采用了自动确认模式，这种模式下，消费者会自动确认收到的消息。这时<code>rabbitmq</code>会立即将消息删除，这种情况下如果消费者出现异常没能处理消息，就会丢弃该消息。解决方案是采用手动确认消息。</p>
</li>
</ul>
</li>
<li><p>如何确保消息的有序性</p>
<p>一般通过某个算法，将需要保持先后顺序的消息放到同一个消息队列中（<code>kafka</code>就是<code>Partition</code>，<code>rabbitmq</code>就是<code>queue</code>），然后只用一个消费者去消费该队列。</p>
<p>如果是消费消息有序，则需要确保消费者只有一个，或者消费过程有序，例如先消费一个消息，ack之后，再消费下一个。</p>
<p>核心点是入队有序。</p>
</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>练习使用，通过<code>helm</code>在<code>k8s</code>上安装集群。前提准备<code>sc</code>，添加<code>bitnami</code>的<code>repo</code>库，使用<code>bitnami</code>中的<code>rabbitmq</code>包。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// pull下来，手动修改，并且做好备份</span><br><span class="line">helm pull bitnami/rabbitmq </span><br><span class="line">tar zxvf rabbitmq-10.1.13.tgz</span><br><span class="line">cd rabbitmq/</span><br></pre></td></tr></table></figure>

<p>更改配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim values.yaml</span><br><span class="line"></span><br><span class="line">global:</span><br><span class="line">  storageClass: &quot;nfs-client&quot;</span><br><span class="line">// 副本数设置为3</span><br><span class="line">replicaCount: 3	</span><br><span class="line">service:</span><br><span class="line">  type: NodePort</span><br></pre></td></tr></table></figure>

<p>部署</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create ns rabbitmq</span><br><span class="line">helm install rabbitmq -f values.yaml ./ -n rabbitmq</span><br></pre></td></tr></table></figure>

<p>账号密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Username      : user&quot;</span><br><span class="line">echo &quot;Password      : $(kubectl get secret --namespace rabbitmq rabbitmq -o jsonpath=&quot;&#123;.data.rabbitmq-password&#125;&quot; | base64 -d)&quot;</span><br></pre></td></tr></table></figure>

<p>通过<code>svc</code>映射的<code>15672</code>端口打开管理页面</p>
<h2 id="通过golang操作rabbitmq"><a href="#通过golang操作rabbitmq" class="headerlink" title="通过golang操作rabbitmq"></a>通过golang操作rabbitmq</h2><p>官方文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cucmFiYml0bXEuY29tL2dldHN0YXJ0ZWQuaHRtbA==">rabbitmq操作指南<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="获取客户端"><a href="#获取客户端" class="headerlink" title="获取客户端"></a>获取客户端</h3><p>安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/rabbitmq/amqp091-go</span><br></pre></td></tr></table></figure>

<p>初始化连接</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RabbitMQClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	Conn       *amqp.Connection</span><br><span class="line">	Channel    *amqp.Channel</span><br><span class="line">	Queue      amqp.Queue</span><br><span class="line">	RoutingKey <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitClient</span><span class="params">()</span></span> (client RabbitMQClient, err <span class="type">error</span>) &#123;</span><br><span class="line">	client.Conn, err = amqp.Dial(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	client.Channel, err = client.Conn.Channel()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> client, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failOnError</span><span class="params">(err <span class="type">error</span>, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Panicf(<span class="string">&quot;%s: %s&quot;</span>, msg, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列模式、工作分配模式"><a href="#队列模式、工作分配模式" class="headerlink" title="队列模式、工作分配模式"></a>队列模式、工作分配模式</h3><p>生产者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">conn, err := amqp.Dial(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	failOnError(err, <span class="string">&quot;Failed to init a connection&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者协程消费</span></span><br><span class="line"><span class="comment">//	go consumer(conn, &quot;consumer1&quot;)</span></span><br><span class="line"><span class="comment">//	go consumer(conn, &quot;consumer2&quot;)</span></span><br><span class="line"></span><br><span class="line">	pChan, err := conn.Channel()</span><br><span class="line">	failOnError(err, <span class="string">&quot;Failed to init a publish channel&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> pChan.Close()</span><br><span class="line"></span><br><span class="line">	queue, err := pChan.QueueDeclare(</span><br><span class="line">		name,  <span class="comment">// 队列名称，如果是空的，则会自动生成</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// 是否持久化，false代表不持久化，当服务器重启，队列数据消失</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// 是否自动删除，为 true 则设置队列为自动删除。自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除这个队列。</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// 排他，当设置为true时，其他的connection声明、绑定、使用、清除或删除同名队列时将收到错误，当连接关闭时，队列会被自动删除。（同一个connection可以起多个channel声明队列）</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// 与queue交互是否等待回应，一般为false</span></span><br><span class="line">		<span class="literal">nil</span>,   <span class="comment">// 其他参数</span></span><br><span class="line">	)</span><br><span class="line">	failOnError(err, <span class="string">&quot;Failed to declare a queue&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">		body := fmt.Sprintf(<span class="string">&quot;Hello World: %d&quot;</span>, i)</span><br><span class="line">		err = pChan.Publish(</span><br><span class="line">			<span class="string">&quot;&quot;</span>,         <span class="comment">// 不指定交换机</span></span><br><span class="line">			queue.Name, <span class="comment">// 队列名称</span></span><br><span class="line">			<span class="literal">false</span>,      <span class="comment">// 强制，指定交换机时有用，如果设置为true，当没有绑定与routing key匹配的队列，则消息无法发送出去</span></span><br><span class="line">			<span class="literal">false</span>,      <span class="comment">// 立即接受，设置为true时，如果队列对端没有消费者，则消费不会发送过去</span></span><br><span class="line">			amqp.Publishing&#123;</span><br><span class="line">				ContentType: <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">				Body:        []<span class="type">byte</span>(body),</span><br><span class="line">			&#125;)</span><br><span class="line">		failOnError(err, <span class="string">&quot;Failed to publish a message&quot;</span>)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(conn *amqp.Connection, cname <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	cChan, err := conn.Channel()</span><br><span class="line">	failOnError(err, <span class="string">&quot;Failed to init a consumer channel&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> cChan.Close()</span><br><span class="line"></span><br><span class="line">	queue, err := cChan.QueueDeclare(</span><br><span class="line">		name,  <span class="comment">// 队列名称，如果是空的，则会自动生成</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// 是否持久化，false代表不持久化，当服务器重启，队列数据消失</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// 是否自动删除，为 true 则设置队列为自动删除。自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// 排他，当设置为true时，其他的connection声明、绑定、使用、清除或删除同名队列时将收到错误，当连接关闭时，队列会被自动删除</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// 与queue交互是否等待回应，一般为false</span></span><br><span class="line">		<span class="literal">nil</span>,   <span class="comment">// 其他参数</span></span><br><span class="line">	)</span><br><span class="line">	failOnError(err, <span class="string">&quot;Failed to declare a queue&quot;</span>)</span><br><span class="line"></span><br><span class="line">	msgs, err := cChan.Consume(</span><br><span class="line">		queue.Name, <span class="comment">// queue</span></span><br><span class="line">		cname,      <span class="comment">// 消费者名称</span></span><br><span class="line">		<span class="literal">true</span>,       <span class="comment">// 是否自动ack，true代表获取消息之后就ack掉</span></span><br><span class="line">		<span class="literal">false</span>,      <span class="comment">// 排他，true代表队列消费者只能有一个，即使是同一个connection也只能有一个消费者</span></span><br><span class="line">		<span class="literal">false</span>,      <span class="comment">// 参数不支持</span></span><br><span class="line">		<span class="literal">false</span>,      <span class="comment">// 与queue交互是否等待回应，一般为false</span></span><br><span class="line">		<span class="literal">nil</span>,        <span class="comment">// args</span></span><br><span class="line">	)</span><br><span class="line">	failOnError(err, <span class="string">&quot;Failed to register a consumer&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;%s Received a message: %s&quot;</span>, d.ConsumerTag, d.Body)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发布、订阅模式"><a href="#发布、订阅模式" class="headerlink" title="发布、订阅模式"></a>发布、订阅模式</h3><p>生产者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">conn, err := amqp.Dial(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to init a connection&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> consumerPub(conn, <span class="string">&quot;consumer1&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> consumerPub(conn, <span class="string">&quot;consumer2&quot;</span>)</span><br><span class="line"></span><br><span class="line">pChan, err := conn.Channel()</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to init a publish channel&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> pChan.Close()</span><br><span class="line"></span><br><span class="line">err = pChan.ExchangeDeclare(</span><br><span class="line">	exchange, <span class="comment">// 交换机名称</span></span><br><span class="line">	<span class="string">&quot;fanout&quot;</span>, <span class="comment">// 交换机类型</span></span><br><span class="line">	<span class="literal">true</span>,     <span class="comment">// 是否持久化</span></span><br><span class="line">	<span class="literal">false</span>,    <span class="comment">// 是否自动删除</span></span><br><span class="line">	<span class="literal">false</span>,    <span class="comment">// 是否是内部交换机，内部交换机外部无法发送，只有内部交换机之间能够发送消息</span></span><br><span class="line">	<span class="literal">false</span>,    <span class="comment">// 与交换机交互，是否要等待响应</span></span><br><span class="line">	<span class="literal">nil</span>,      <span class="comment">// 其他参数</span></span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to declare a exchange&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">	body := fmt.Sprintf(<span class="string">&quot;Hello World: %d&quot;</span>, i)</span><br><span class="line">	err = pChan.Publish(</span><br><span class="line">		exchange, <span class="comment">// 指定交换机 // 发送到交换机</span></span><br><span class="line">		<span class="string">&quot;&quot;</span>,       <span class="comment">// 不指定队列名称，fanout下发送到所有队列</span></span><br><span class="line">		<span class="literal">false</span>,    <span class="comment">// 强制，指定交换机时有用，如果设置为true，当没有绑定与routing key匹配的队列，则消息无法发送出去</span></span><br><span class="line">		<span class="literal">false</span>,    <span class="comment">// 立即接受，设置为true时，如果队列对端没有消费者，则消费不会发送过去</span></span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			ContentType: <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">			Body:        []<span class="type">byte</span>(body),</span><br><span class="line">		&#125;)</span><br><span class="line">	failOnError(err, <span class="string">&quot;Failed to publish a message&quot;</span>)</span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">channel, err := conn.Channel()</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to init a consumer channel&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> channel.Close()</span><br><span class="line"></span><br><span class="line">q, err := channel.QueueDeclare(</span><br><span class="line">	name,  <span class="comment">// 队列名称，如果是空的，则会自动生成</span></span><br><span class="line">	<span class="literal">false</span>, <span class="comment">// 是否持久化，false代表不持久化，当服务器重启，队列数据消失</span></span><br><span class="line">	<span class="literal">false</span>, <span class="comment">// 是否自动删除，为 true 则设置队列为自动删除。自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。</span></span><br><span class="line">	<span class="literal">false</span>, <span class="comment">// 排他，当设置为true时，其他的connection声明、绑定、使用、清除或删除同名队列时将收到错误，当连接关闭时，队列会被自动删除</span></span><br><span class="line">	<span class="literal">false</span>, <span class="comment">// 与queue交互是否等待回应，一般为false</span></span><br><span class="line">	<span class="literal">nil</span>,   <span class="comment">// 其他参数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定队列</span></span><br><span class="line">err = channel.QueueBind(</span><br><span class="line">	q.Name,   <span class="comment">// 队列名称</span></span><br><span class="line">	<span class="string">&quot;&quot;</span>,       <span class="comment">// 不指定routing key</span></span><br><span class="line">	exchange, <span class="comment">// 交换机名称</span></span><br><span class="line">	<span class="literal">false</span>,    <span class="comment">// 绑定是否等待回应</span></span><br><span class="line">	<span class="literal">nil</span>,      <span class="comment">// 其他参数</span></span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to bind a queue with exchange&quot;</span>)</span><br><span class="line"></span><br><span class="line">msgs, err := channel.Consume(</span><br><span class="line">	q.Name, <span class="comment">// queue</span></span><br><span class="line">	name,   <span class="comment">// 消费者名称</span></span><br><span class="line">	<span class="literal">true</span>,   <span class="comment">// 是否自动ack，true代表获取消息之后就ack掉</span></span><br><span class="line">	<span class="literal">false</span>,  <span class="comment">// 排他，true代表队列消费者只能有一个，即使是同一个connection也只能有一个消费者</span></span><br><span class="line">	<span class="literal">false</span>,  <span class="comment">// 参数不支持</span></span><br><span class="line">	<span class="literal">false</span>,  <span class="comment">// 与queue交互是否等待回应，一般为false</span></span><br><span class="line">	<span class="literal">nil</span>,    <span class="comment">// args</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to register a consumer&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;%s Received a message: %s&quot;</span>, d.ConsumerTag, d.Body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>生产者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">conn, err := amqp.Dial(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to init a connection&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> consumerRouting(conn, <span class="string">&quot;rabbit&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> consumerRouting(conn, <span class="string">&quot;dog&quot;</span>)</span><br><span class="line"></span><br><span class="line">pChan, err := conn.Channel()</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to init a publish channel&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> pChan.Close()</span><br><span class="line"></span><br><span class="line">err = pChan.ExchangeDeclare(</span><br><span class="line">	exchange, <span class="comment">// 交换机名称</span></span><br><span class="line">	<span class="string">&quot;direct&quot;</span>,  <span class="comment">// 交换机类型，direct路由模式</span></span><br><span class="line">	<span class="literal">true</span>,     <span class="comment">// 是否持久化</span></span><br><span class="line">	<span class="literal">false</span>,    <span class="comment">// 是否自动删除</span></span><br><span class="line">	<span class="literal">false</span>,    <span class="comment">// 是否是内部交换机，内部交换机外部无法发送，只有内部交换机之间能够发送消息</span></span><br><span class="line">	<span class="literal">false</span>,    <span class="comment">// 与交换机交互，是否要等待响应</span></span><br><span class="line">	<span class="literal">nil</span>,      <span class="comment">// 其他参数</span></span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to declare a exchange&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> message &#123;</span><br><span class="line">		body := fmt.Sprintf(<span class="string">&quot;%s: %d&quot;</span>, v, i)</span><br><span class="line"></span><br><span class="line">		err = pChan.Publish(</span><br><span class="line">			exchange, <span class="comment">// 指定交换机 // 发送到交换机</span></span><br><span class="line">			k,        <span class="comment">// 不同的routing key，发送到不同的队列</span></span><br><span class="line">			<span class="literal">false</span>,    <span class="comment">// 强制，指定交换机时有用，如果设置为true，当没有绑定与routing key匹配的队列，则消息无法发送出去</span></span><br><span class="line">			<span class="literal">false</span>,    <span class="comment">// 立即接受，设置为true时，如果队列对端没有消费者，则消费不会发送过去</span></span><br><span class="line">			amqp.Publishing&#123;</span><br><span class="line">				ContentType: <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">				Body:        []<span class="type">byte</span>(body),</span><br><span class="line">			&#125;)</span><br><span class="line">		failOnError(err, <span class="string">&quot;Failed to publish a message&quot;</span>)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">channel, err := conn.Channel()</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to init a consumer channel&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> channel.Close()</span><br><span class="line"></span><br><span class="line">q, err := channel.QueueDeclare(</span><br><span class="line">	name,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">nil</span>,</span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to declare queue&quot;</span>)</span><br><span class="line"></span><br><span class="line">err = channel.QueueBind(</span><br><span class="line">	name,     <span class="comment">// 队列名称</span></span><br><span class="line">	name,     <span class="comment">// routing key ，这里使用和队列名称一样的key</span></span><br><span class="line">	exchange, <span class="comment">// 交换机名称</span></span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">nil</span>,</span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to bind queue with exchange&quot;</span>)</span><br><span class="line"></span><br><span class="line">msgs, err := channel.Consume(</span><br><span class="line">	q.Name, <span class="comment">// 队列名称</span></span><br><span class="line">	name,   <span class="comment">// 消费者名称，这里使用和队列名称一样的消费者名称</span></span><br><span class="line">	<span class="literal">true</span>,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">nil</span>)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to consume message&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> m := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s Received a message: %s\n&quot;</span>, d.ConsumerTag, m.Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h3><p>生产者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">   <span class="string">&quot;quick.orange.rabbit&quot;</span>:      <span class="string">&quot;I am a quick.orange.rabbit&quot;</span>,</span><br><span class="line">   <span class="string">&quot;lazy.orange.elephant&quot;</span>:     <span class="string">&quot;I am a lazy.orange.elephant&quot;</span>,</span><br><span class="line">   <span class="string">&quot;quick.orange.fox&quot;</span>:         <span class="string">&quot;I am a quick.orange.fox&quot;</span>,</span><br><span class="line">   <span class="string">&quot;lazy.brown.fox&quot;</span>:           <span class="string">&quot;I am a lazy.brown.fox&quot;</span>,</span><br><span class="line">   <span class="string">&quot;lazy.pink.rabbit&quot;</span>:         <span class="string">&quot;I am a lazy.pink.rabbit&quot;</span>,</span><br><span class="line">   <span class="string">&quot;quick.brown.fox&quot;</span>:          <span class="string">&quot;I am a quick.brown.fox&quot;</span>,</span><br><span class="line">   <span class="string">&quot;quick.orange.male.rabbit&quot;</span>: <span class="string">&quot;I am a quick.orange.male.rabbit&quot;</span>,</span><br><span class="line">   <span class="string">&quot;lazy.orange.male.rabbit&quot;</span>:  <span class="string">&quot;I am a lazy.orange.male.rabbit&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn, err := amqp.Dial(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to init a connection&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> consumerTopic(conn, <span class="string">&quot;queue1&quot;</span>, <span class="string">&quot;*.orange.*&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> consumerTopic(conn, <span class="string">&quot;queue2&quot;</span>, <span class="string">&quot;*.*.rabbit&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> consumerTopic(conn, <span class="string">&quot;queue2&quot;</span>, <span class="string">&quot;lazy.#&quot;</span>)</span><br><span class="line"></span><br><span class="line">pChan, err := conn.Channel()</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to init a publish channel&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> pChan.Close()</span><br><span class="line"></span><br><span class="line">err = pChan.ExchangeDeclare(</span><br><span class="line">	exchange, <span class="comment">// 交换机名称</span></span><br><span class="line">	<span class="string">&quot;topic&quot;</span>,  <span class="comment">// 交换机类型，topic主题模式</span></span><br><span class="line">	<span class="literal">true</span>,     <span class="comment">// 是否持久化</span></span><br><span class="line">	<span class="literal">false</span>,    <span class="comment">// 是否自动删除</span></span><br><span class="line">	<span class="literal">false</span>,    <span class="comment">// 是否是内部交换机，内部交换机外部无法发送，只有内部交换机之间能够发送消息</span></span><br><span class="line">	<span class="literal">false</span>,    <span class="comment">// 与交换机交互，是否要等待响应</span></span><br><span class="line">	<span class="literal">nil</span>,      <span class="comment">// 其他参数</span></span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to declare a exchange&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> message &#123;</span><br><span class="line">		body := fmt.Sprintf(<span class="string">&quot;%s: %d&quot;</span>, v, i)</span><br><span class="line"></span><br><span class="line">		err = pChan.Publish(</span><br><span class="line">			exchange, <span class="comment">// 指定交换机 // 发送到交换机</span></span><br><span class="line">			k,        <span class="comment">// 不同的routing key，发送到不同的队列</span></span><br><span class="line">			<span class="literal">false</span>,    <span class="comment">// 强制，指定交换机时有用，如果设置为true，当没有绑定与routing key匹配的队列，则消息无法发送出去</span></span><br><span class="line">			<span class="literal">false</span>,    <span class="comment">// 立即接受，设置为true时，如果队列对端没有消费者，则消费不会发送过去</span></span><br><span class="line">			amqp.Publishing&#123;</span><br><span class="line">				ContentType: <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">				Body:        []<span class="type">byte</span>(body),</span><br><span class="line">			&#125;)</span><br><span class="line">		failOnError(err, <span class="string">&quot;Failed to publish a message&quot;</span>)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">channel, err := conn.Channel()</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to init a consumer channel&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> channel.Close()</span><br><span class="line"></span><br><span class="line">q, err := channel.QueueDeclare(</span><br><span class="line">	name,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">nil</span>,</span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to declare a queue&quot;</span>)</span><br><span class="line"></span><br><span class="line">err = channel.QueueBind(</span><br><span class="line">	q.Name,</span><br><span class="line">	key,</span><br><span class="line">	exchange,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">nil</span>,</span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to bind a queue with exchange&quot;</span>)</span><br><span class="line"></span><br><span class="line">msgs, err := channel.Consume(</span><br><span class="line">	q.Name,</span><br><span class="line">	name,</span><br><span class="line">	<span class="literal">true</span>,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">nil</span>,</span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to consume a message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s Received a message: %s\n&quot;</span>, m.ConsumerTag, m.Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">queue1 Received a message: I am a quick.orange.rabbit: 0</span><br><span class="line">queue2 Received a message: I am a quick.orange.rabbit: 0</span><br><span class="line">queue2 Received a message: I am a lazy.orange.elephant: 0</span><br><span class="line">queue1 Received a message: I am a lazy.orange.elephant: 0</span><br><span class="line">queue1 Received a message: I am a quick.orange.fox: 0</span><br><span class="line">queue2 Received a message: I am a lazy.brown.fox: 0</span><br><span class="line">queue2 Received a message: I am a lazy.pink.rabbit: 0</span><br><span class="line">queue1 Received a message: I am a quick.orange.fox: 1</span><br><span class="line">queue2 Received a message: I am a lazy.brown.fox: 1</span><br><span class="line">queue2 Received a message: I am a lazy.pink.rabbit: 1</span><br><span class="line">queue2 Received a message: I am a lazy.orange.male.rabbit: 1</span><br><span class="line">queue2 Received a message: I am a quick.orange.rabbit: 1</span><br><span class="line">queue1 Received a message: I am a quick.orange.rabbit: 1</span><br><span class="line">queue2 Received a message: I am a lazy.orange.elephant: 1</span><br><span class="line">queue1 Received a message: I am a lazy.orange.elephant: 1</span><br></pre></td></tr></table></figure>

<ol>
<li>当一个消息匹配多个key时，只会发送一个到队列</li>
<li>当消息没有匹配任何key时，会丢弃消息</li>
</ol>
<h3 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h3><p>声明队列</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch *Channel)</span></span> QueueDeclare(name <span class="type">string</span>, durable <span class="type">bool</span>, autoDelete <span class="type">bool</span>, exclusive <span class="type">bool</span>, noWait <span class="type">bool</span>, args Table) (Queue, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>name：队列名称，如果为空，会生成一个唯一随机的名称</p>
<p>durable：是否持久化，当服务器重启时，持久化为true，代表会队列会被恢复，为false，则会被删掉</p>
<p>autoDelete：队列是否自动删除，当最后一个监听被移除后，true时，会自动被删除</p>
<p>exclusive：排他，true时，独占队列只能由声明它们的连接访问，并且在连接关闭时将被删除。尝试声明、绑定、使用、清除或删除同名队列时，其他连接上的通道将收到错误。</p>
<p>noWait：是否等待，队列将假定在服务器上声明。如果满足现有队列的条件或尝试从不同连接修改现有队列，则会出现通道异常。</p>
<p>args：可选<code>amqp</code>。对于需要额外参数的交换类型，可以发送特定于服务器交换实现的参数表。</p>
<p>交换机声明</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch *Channel)</span></span> ExchangeDeclare(name <span class="type">string</span>, kind <span class="type">string</span>, durable <span class="type">bool</span>, autoDelete <span class="type">bool</span>, internal <span class="type">bool</span>, noWait <span class="type">bool</span>, args Table) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>name：交换机名称，如果交换不存在，服务器将创建它。如果交换存在，服务器将验证它是否具有提供的类型、持久性和自动删除标志。</p>
<p>kind：类型，支持类型：direct路由模式，fanout发布订阅模式，topic主题模式，headers（<code>headers exchange主要通过发送的request message中的header进行匹配，其中匹配规则（x-match）又分为all和any，all代表必须所有的键值对匹配，any代表只要有一个键值对匹配即可。headers exchange的默认匹配规则（x-match）是any。</code>），</p>
<p>durable：是否持久化，当服务器重启时，持久化为true，代表会交换机会被恢复，为false，则会被删掉</p>
<p>autoDelete：交换机是否自动删除，当最后一个监听被移除后，true时，会自动被删除</p>
<p>internal：是否是内部交换机，如果是true，则无法通过<code>publisher</code>发送消息</p>
<p>noWait：当<code>noWait</code>为<code>true</code>时，在不等待服务器确认的情况下声明。通道可能因错误而关闭。添加<code>NotifyClose</code>侦听器以响应任何异常。</p>
<p>args：可选<code>amqp</code>。对于需要额外参数的交换类型，可以发送特定于服务器交换实现的参数表。</p>
<p>消息发送</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch *Channel)</span></span> Publish(exchange <span class="type">string</span>, key <span class="type">string</span>, mandatory <span class="type">bool</span>, immediate <span class="type">bool</span>, msg Publishing) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>exchange：指定发送的交换机，空代表使用队列的默认交换机</p>
<p>key：队列名称，将单个消息传递到单个队列时，可以使用队列名称的routingKey发布到默认交换。这是因为每个声明的队列都获得到默认交换的隐式路由。</p>
<p>mandatory：强制性</p>
<p>immediate：立即发布</p>
<blockquote>
<p>由于发布是异步的，任何无法传递的消息都将由服务器返回。当mandatory或immediate为true时，使用带有Channel.NotifyReturn的监听者，用于在调用发布时处理任何无法传递的消息。<br>当mandatory为true且未绑定与key匹配的队列时，或者当immediate为true，且匹配队列中没有消费者准备接受传递时，发布可能无法传递。<br>这可能会在通道、连接或套接字关闭时返回错误。错误或缺少错误并不表示服务器是否已收到此发布。<br>如果底层套接字关闭而未从内核缓冲区中清除挂起的发布包，则发布可能无法到达代理。使所有发布内容都可能到达服务器的简单方法是始终在终止发布应用程序之前调用Connection.Close。确保所有发布到达服务器的方法是向Channel.NotifyPublish添加一个监听者，并使用Channel.Confirm将channel设置为确认模式。发布交付标签及其相应的确认从1开始。确认所有发布后退出。<br>当发布未返回错误且通道处于确认模式时，具有第一次确认的DeliveryTags的内部计数器从1开始。</p>
</blockquote>
<p>msg：消息内容</p>
<p>mssage结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Publishing <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Application or exchange specific fields,</span></span><br><span class="line">	<span class="comment">// the headers exchange will inspect this field.</span></span><br><span class="line">	Headers Table <span class="comment">// 应用程序或交换特定字段，标头交换将检查此字段。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Properties</span></span><br><span class="line">	ContentType     <span class="type">string</span>    <span class="comment">// MIME content type 一般为txt</span></span><br><span class="line">	ContentEncoding <span class="type">string</span>    <span class="comment">// MIME content encoding 编码</span></span><br><span class="line">	DeliveryMode    <span class="type">uint8</span>     <span class="comment">// Transient (0 or 1) or Persistent (2) 分发模式，0或者1代表非持久化，2代表持久化</span></span><br><span class="line">	Priority        <span class="type">uint8</span>     <span class="comment">// 0 to 9 优先级</span></span><br><span class="line">	CorrelationId   <span class="type">string</span>    <span class="comment">// correlation identifier 消息唯一ID，一般用于ACK，路由等</span></span><br><span class="line">	ReplyTo         <span class="type">string</span>    <span class="comment">// address to to reply to (ex: RPC) 重会队列，消息失败了返回到哪个队列</span></span><br><span class="line">	Expiration      <span class="type">string</span>    <span class="comment">// message expiration spec	消息到期时间，如果设置过期时间，消息设置持久化，当没有消费者，消息会持久化到队列中，过期之后就会被删掉</span></span><br><span class="line">	MessageId       <span class="type">string</span>    <span class="comment">// message identifier 消息ID</span></span><br><span class="line">	Timestamp       time.Time <span class="comment">// message timestamp</span></span><br><span class="line">	Type            <span class="type">string</span>    <span class="comment">// message type name </span></span><br><span class="line">	UserId          <span class="type">string</span>    <span class="comment">// creating user id - ex: &quot;guest&quot;</span></span><br><span class="line">	AppId           <span class="type">string</span>    <span class="comment">// creating application id</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The application specific payload of the message</span></span><br><span class="line">	Body []<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费消息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch *Channel)</span></span> Consume(queue <span class="type">string</span>, consumer <span class="type">string</span>, autoAck <span class="type">bool</span>, exclusive <span class="type">bool</span>, noLocal <span class="type">bool</span>, noWait <span class="type">bool</span>, args Table) (&lt;-<span class="keyword">chan</span> Delivery, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>queue：消费队列名称</p>
<p>consumer：消费者由一个字符串标识，该字符串对于该频道上的所有消费者都是唯一的，并且具有范围</p>
<p>autoAck：为true时，服务器将在将消息写入网络之前向该消费者确认消息。动确认交付意味着，如果消费者在消息交付后无法处理交付，则某些消息可能会丢失。</p>
<p>exclusive：排他，服务器将确保这是此队列中的唯一使用者。当exclusive为false时，服务器将在多个消费者之间公平分配交付。</p>
<p>noLocal：RabbitMQ不支持noLocal标志。建议为Channel.Publish和Channel.Consume使用单独的连接。使用此参数，以避免发布时的TCP推送影响使用消息的能力，因此此参数主要用于完整性。</p>
<p>noWait：当<code>noWait</code>为<code>true</code>时，不会等待消费者确认请求并立即开始投递消息。</p>
<p>args：可选<code>amqp</code>。对于需要额外参数的交换类型，可以发送特定于服务器交换实现的参数表。</p>
<blockquote>
<p>投递中的信息，受Channel.Qos个数限制，将被缓冲，直到从返回的chan接收到。<br>当通道或连接关闭时，所有缓冲和投递中的消息将被丢弃。<br>当消费者标签被取消时，所有机上信息都将被发送，直到返回的通道关闭。</p>
</blockquote>
<h3 id="Return消息机制"><a href="#Return消息机制" class="headerlink" title="Return消息机制"></a>Return消息机制</h3><p>当消息发送到交换机，通过key匹配，匹配上之后，消息会发送到对应队列中，如果没有匹配上，则会被丢弃，通过Return消息机制，可以获取到被丢弃的消息。</p>
<p>需要注意，消息发送时，<code>mandatory</code>必须设置为<code>true</code>，不然消息会被直接丢弃。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> return_msg := <span class="keyword">range</span> pChan.NotifyReturn(<span class="built_in">make</span>(<span class="keyword">chan</span> amqp.Return)) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%+v&quot;</span>, return_msg)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h3 id="qos限流"><a href="#qos限流" class="headerlink" title="qos限流"></a>qos限流</h3><p>在非自动ack前提下，如果一定数目的消息未被确认前，不进行消费新的消息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch *Channel)</span></span> Qos(prefetchCount <span class="type">int</span>, prefetchSize <span class="type">int</span>, global <span class="type">bool</span>) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>prefetchSize：限制的字节大小，默认为0</p>
<p>prefetchCount：会告诉rabbitmq不要同时给一个消费者推送多于N个消息，即一旦有N个消息还没有ack，则该consumer将block掉，直到有一条消息ack后，再推送下一条消息。</p>
<p>global：如果未真，该<code>qos</code>的设置将用于一个<code>connection</code>中所有<code>channel</code>的<code>consumer</code>中，如果为<code>false</code>，只应用于当前<code>channel</code>的已存在的以及未来定义的<code>consumer</code>中。</p>
<p>自动ack下，qos不生效。</p>
<blockquote>
<p>Qos控制服务器在收到送达确认之前，将尝试在网络上为消费者保留多少消息或多少字节。Qos的目的是确保服务器和客户端之间的网络缓冲区保持满。<br>如果预取计数大于零，则服务器将在收到确认之前向消费者传递这么多消息。当消费者使用noAck启动时，服务器会忽略此选项，因为不会预期或发送任何确认。<br>如果预取大小大于零，服务器将尝试在收到消费者的确认之前，将至少有那么多字节的传递刷新到网络。当消费者开始使用noAck时，此选项将被忽略。<br>当global为true时，这些Qos设置适用于同一连接上所有频道上的所有现有和未来消费者。如果为false，则为Channel。Qos设置将应用于此频道上的所有现有和未来消费者。<br>请参阅RabbitMQ Consumer Prefetch文档，了解如何在Rabbit MQ中实现全局标志，因为它与AMQP 0.9.1规范的不同之处在于，全局Qos设置的范围仅限于通道，而非连接(<span class="exturl" data-url="aHR0cHM6Ly93d3cucmFiYml0bXEuY29tL2NvbnN1bWVyLXByZWZldGNoLmh0bWw=">https://www.rabbitmq.com/consumer-prefetch.html<i class="fa fa-external-link-alt"></i></span> ).<br>要在不同连接上从同一队列消费的消费者之间获得循环行为，请将预取计数设置为1，服务器上的下一条可用消息将传递给下一个可用消费者。<br>如果您的消费者工作时间相当一致，并且不超过网络往返时间的两倍，您将看到显著的吞吐量提高，从RabbitMQ上的基准测试所描述的预取计数2或稍大开始。</p>
</blockquote>
<h3 id="ack消息确认机制"><a href="#ack消息确认机制" class="headerlink" title="ack消息确认机制"></a>ack消息确认机制</h3><p>在消费端确保消息已经收到，通常会使用手动ack的机制。</p>
<p>注册Consume时，将autoACK设置为false，使用手动ack。消费消息时，通过执行Ack实现手动ack。</p>
<p>ack：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Delivery)</span></span> Ack(multiple <span class="type">bool</span>) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>multiple：是否批量ack，当<code>multiple</code>为<code>true</code>时，将确认当前消息和所有同channel上先前未确认的消息。这对于批量处理消息很有用。</p>
<p>Nack：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Delivery)</span></span> Nack(multiple <span class="type">bool</span>, requeue <span class="type">bool</span>) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>multiple：是否批量nack，当<code>multiple</code>为<code>true</code>时，将不确认当前消息和所有同channel上先前未确认的消息。这对于批量处理消息很有用。</p>
<p>requeue：是否返回给队列，当<code>requeue</code>为<code>true</code>时，请求消息队列将此消息传递给其他消费者（如果只有一个消费者，那么会放入队尾）。如果不可能或<code>requeue</code>为false，则消息将被丢弃或传递到服务器配置的死信队列。</p>
<p>此方法不能用于将客户端不希望处理的消息选择或重新入队，而是通知服务器客户端此时无法处理此消息。<br>每次未自动确认的消息都必须调用Delivery.Ack，Delivery.Reject，Delivery.Nack。</p>
<p>通过Acknowledger接口拒绝委派的否定确认。<br>如果requeue为true，则将此消息排队，以便在其他通道上传递给使用者。如果重新排队为false或服务器无法对此消息进行排队，则会将其删除。<br>如果您正在批量处理交付，并且您的服务器支持它，请选择Delivery.Nack。<br>每个未自动确认的交付都必须调用Delivery.Ack、Delivery.Reject或Delivery.Nack。</p>
<blockquote>
<p>Reject和Nack<br>消息确认可以让RabbitMQ知道消费者已经接受并处理完消息。但是如果消息本身或者消息的处理过程出现问题怎么办？需要一种机制，通知RabbitMQ，这个消息，我无法处理，请让别的消费者处理。这里就有两种机制，Reject和Nack。</p>
<p>Reject</p>
<p>Reject在拒绝消息时，可以使用requeue标识，告诉RabbitMQ是否需要重新发送给别的消费者。不重新发送，一般这个消息就会被RabbitMQ丢弃。Reject一次只能拒绝一条消息。</p>
<p>Nack</p>
<p>Nack则可以一次性拒绝多个消息。这是RabbitMQ对AMQP规范的一个扩展。</p>
<p>通过RejectRequeuConsumer可以看到当requeue参数设置为true时，消息发生了重新投递。</p>
</blockquote>
<h3 id="TTL队列、消息"><a href="#TTL队列、消息" class="headerlink" title="TTL队列、消息"></a>TTL队列、消息</h3><p>TTL是Time To Live的缩写，也就是生存时间。</p>
<p>消息的过期时间，可以在发送消息时指定；</p>
<p>队列的过期时间，从消息入队开始计算，超过队列的超时时间，那么消息会自动清除。</p>
<p><code>Publishing.Expiration</code>指定。</p>
<h3 id="死信队列-DLX-Dead-letter-Exchange"><a href="#死信队列-DLX-Dead-letter-Exchange" class="headerlink" title="死信队列 DLX Dead-letter-Exchange"></a>死信队列 DLX Dead-letter-Exchange</h3><p>消息变成一个死信，说明这个消息没有消费者消费了。</p>
<p>在rabbitmq中，可以利用DLX，当消息在一个队列中变成死信之后，能被重新<code>publish</code>到另一个交换机，这个交换机就是DLX。</p>
<p>消息变成死信友这几种情况：</p>
<ul>
<li>消息被拒绝，Delivery.Reject，Delivery.Nack，并且requeue&#x3D;false</li>
<li>消息TTL过期</li>
<li>队列达到最大长度</li>
</ul>
<p>死信队列特点：</p>
<ul>
<li>DLX也是一个正常的交换机，和一般的交换机没有区别，可以在任何队列上被指定，实际上就是设置某个队列的属性</li>
<li>当这个队列中有死信时，<code>rabbitmq</code>会自动将这个消息重新发布到设置的DLX上，进而被路由到另一个队列。</li>
<li>可以监听这个队列中消息做相应的处理，这个特性可以弥补rabbitmq 3.0以前支持的<code>immediate</code>参数的功能</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumerRouting</span><span class="params">(conn *amqp.Connection, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	channel, err := conn.Channel()</span><br><span class="line">	failOnError(err, <span class="string">&quot;Failed to init a consumer channel&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> channel.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义参数</span></span><br><span class="line">	args := amqp.Table&#123;</span><br><span class="line">		<span class="comment">// 参数中设置死信交换机名称</span></span><br><span class="line">		<span class="string">&quot;x-dead-letter-exchange&quot;</span>: <span class="string">&quot;dlx_exchange&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 声明消费队列</span></span><br><span class="line">	q, err := channel.QueueDeclare(</span><br><span class="line">		name,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		args,</span><br><span class="line">	)</span><br><span class="line">	failOnError(err, <span class="string">&quot;Failed to declare queue&quot;</span>)</span><br><span class="line"></span><br><span class="line">	err = channel.QueueBind(</span><br><span class="line">		name,     <span class="comment">// 队列名称</span></span><br><span class="line">		name,     <span class="comment">// routing key ，这里使用和队列名称一样的key</span></span><br><span class="line">		exchange, <span class="comment">// 交换机名称</span></span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	)</span><br><span class="line">	failOnError(err, <span class="string">&quot;Failed to bind queue with exchange&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 死信交换机和死信队列</span></span><br><span class="line">	<span class="comment">// 声明死信交换机</span></span><br><span class="line">	err = channel.ExchangeDeclare(</span><br><span class="line">		<span class="string">&quot;dlx_exchange&quot;</span>,</span><br><span class="line">		<span class="string">&quot;topic&quot;</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明绑定死信交换机的队列</span></span><br><span class="line">	dlxQueue, err := channel.QueueDeclare(</span><br><span class="line">		<span class="string">&quot;dlx_queue&quot;</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	)</span><br><span class="line">	failOnError(err, <span class="string">&quot;Failed to declare queue&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将死信交换机和死信队列绑定</span></span><br><span class="line">	err = channel.QueueBind(</span><br><span class="line">		dlxQueue.Name, <span class="comment">// 队列名称</span></span><br><span class="line">		name,          <span class="comment">// routing key ，这里使用和队列名称一样的key</span></span><br><span class="line">		exchange,      <span class="comment">// 交换机名称</span></span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	)</span><br><span class="line">	failOnError(err, <span class="string">&quot;Failed to bind queue with exchange&quot;</span>)</span><br><span class="line"></span><br><span class="line">	msgs, err := channel.Consume(</span><br><span class="line">		q.Name, <span class="comment">// 队列名称</span></span><br><span class="line">		name,   <span class="comment">// 消费者名称，这里使用和队列名称一样的消费者名称</span></span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>)</span><br><span class="line">	failOnError(err, <span class="string">&quot;Failed to consume message&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> m := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s Received a message: %s\n&quot;</span>, m.ConsumerTag, m.Body)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>Rabbitmq高可用方案是以主备的集群形式，集群有两种模式，默认模式和镜像模式。</p>
<h3 id="普通集群模式"><a href="#普通集群模式" class="headerlink" title="普通集群模式"></a>普通集群模式</h3><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/1620.png" alt="img" style="zoom:50%;" />

<p>元数据包含以下内容：</p>
<ul>
<li>队列元数据：队列的名称及属性</li>
<li>交换器：交换器的名称及属性</li>
<li>绑定关系元数据：交换器与队列或者交换器与交换器</li>
<li>vhost元数据：为vhost内的队列，交换器和绑定提供命名空间及安全属性之间的绑定关系</li>
</ul>
<p>在普通集群模式下，集群中各个节点之间只会相互同步元数据，也就是说，消息数据不会被同步。那么问题就来了，假如我们连接到 <code>A</code> 节点，但是消息又存储在 <code>B</code> 节点又怎么办呢？</p>
<p>不论是生产者还是消费者，假如连接到的节点上没有存储队列数据，那么内部会将其转发到存储队列数据的节点上进行存储。虽然说内部可以实现转发，但是因为消息仅仅只是存储在一个节点，那么假如这节点挂了，消息是不是就没有了？这个问题确实存在，所以这种普通集群模式并没有达到高可用的目的。</p>
<h3 id="镜像队列模式"><a href="#镜像队列模式" class="headerlink" title="镜像队列模式"></a>镜像队列模式</h3><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/1620-20221024102352276.png" alt="img" style="zoom:50%;" />

<p>镜像队列模式下，节点之间不仅仅会同步元数据，消息内容也会在镜像节点间同步，可用性更高。这种方案提升了可用性的同时，因为同步数据之间也会带来网络开销从而在一定程度上会影响到性能。</p>
<p>slave会准确地按照maste执行命令地顺序进行动作，故slave和master上维护的状态应该是相同的。如果master由于某种原因失效，那么“资历最老”（基于slave加入cluster的时间排序）的slave会被提升为新的master。发送到镜像队列的所有消息会被同时发往 master和所有的slave上，如果此时master挂掉了，消息还会在slave上，这样slave提升为 master的时候消息也不会丢失</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/10/2226025-20210527172158028-453119641.png" alt="img"></p>
<p>集群中的每个 Broker 节点都包含 1 个队列的 master 和 2 个队列的 slave， Q1 的负载大多都在 broker1 上，Q2 的负载大多都集中在 broker2 上，Q3 的负载大多都集中在 broker3 上，只要确保队列的 master 节点均匀散落在集群中的各个 Broker 节点即可确保很大程度的负载均衡。</p>
<p>master提供读写服务，在slave上的操作都会路由到master上，slave只做备份-主备切换。也就是说slave队列先将消费者的请求转发给master队列，然后再由master队列准备好数据返回给slave队列，最后由slave队列将消息返回给消费者。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/1460000038432420-20221101173426296.png" alt="img"></p>
<p>镜像队列基本上就是一个特殊的BackingQueue，它内部包裹了一个普通的BackingQueue做本地消息持久化处理，在此基础上增加了将消息和ack复制到所有镜像的功能。所有对mirror_queue_master的操作，会通过组播GM的方式同步到各slave节点。GM负责消息的广播，mirror_queue_slave负责回调处理，而master上的回调处理是由coordinator负责完成。mirror_queue_slave中包含了普通的BackingQueue进行消息的存储，master节点中BackingQueue包含在mirror_queue_master中由AMQQueue进行调用。</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>镜像队列主要的问题是消息同步的性能。由于使用了一种低效的消息复制方法，镜像队列的性能会比较低下。</p>
<p>镜像队列会选择一个主队列和多个从队列，主队列会将自己接收的读、写请求同步给所有从队列。当所有的从队列保存消息之后，主队列才会向生产者发送确认。如果主队列挂掉，其中一个从队列会晋升成主队列，让整个镜像队列仍然保持可用，避免消息丢失。</p>
<p>当一个节点下线，然后恢复上线之后，它保存的所有从队列的镜像数据都会丢失。</p>
<ul>
<li><p>缺陷1：此时从队列重新上线，但是它是空的，运维人员必须做出选择，是否要将数据同步到这个队列。如果选择同步，那么就意味着要将当前所有的消息从主队列同步到从队列。</p>
</li>
<li><p>缺陷2：同步是阻塞的，它会让整个队列不可用。通常情况下，如果生产和消费的速度能够基本匹配，那么队列应该是没有消息堆积或者堆积非常少的，这样同步只会阻塞很短的时间。但是有时有些队列有时会存在大量堆积，可能是由于故意设计成这样，也可能是因为消费端或者下游服务非常慢或者挂掉，但是上游生产者仍然不停生产消息。</p>
</li>
</ul>
<h3 id="仲裁队列"><a href="#仲裁队列" class="headerlink" title="仲裁队列"></a>仲裁队列</h3><blockquote>
<p>RabbitMQ 3.8 版本中最重要的改动那非仲裁队列（Quorum Queues）莫属。它提供队列复制的能力，保障数据的高可用和安全性。使用仲裁队列可以在 RabbitMQ 节点间进行队列数据的复制，从而达到在一个节点宕机时，队列仍然可以提供服务的效果。</p>
<p>其实 RabbitMQ 已经有一个高可用队列的实现，那就是镜像队列（Mirror Queues）。在 RabbitMQ 3.8 版本问世之前，镜像队列是实现数据高可用的唯一手段，但是它有一些设计上的缺陷，这也是 RabbitMQ 提供仲裁队列的原因。</p>
</blockquote>
<p>Raft 共识协议逐渐成为了工业上大量使用的分布式共识协议，仲裁队列就是基于 Raft 共识算法的一个变种。它比镜像队列更安全、性能更好。</p>
<p>每个仲裁队列都有多个副本，它包含一个主和多个从副本。replication factor 为 5 的仲裁队列将会有 1 个主副本和 4 个从副本。每个副本都在不通的 RabbitMQ 节点上。</p>
<p>客户端（生产者和消费者）只会与主副本进行交互，主副本再将这些命令复制到从副本。与镜像队列类似，从副本不与客户端进行交互，它们仅仅作为一个冗余备份，在节点挂掉或重启时提供高可用的能力。当主副本所在的节点下线，其中一个在另外节点的从副本会被选举成为主副本，继续提供服务。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/rabbitmq-quorum-queues-raft-consensus-illustration.png" alt="图 3 - Raft 共识协议"></p>
<p>消息复制和主副本选举的操作，需要超过半数的副本同意，所以我管它叫做仲裁队列。当生产者发送一条消息，需要超过半数的队列副本都将消息写入磁盘以后才会向生产者进行确认。这意味着少部分比较慢的副本不会影响整个队列的性能。同样地，主副本的选举也需要超过半数的副本同意才行，这会避免出现网络分区时 2 个主副本，所以说仲裁队列相对于可用性更看重一致性。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>客户端创建队里时，增加属性即可，改动少</li>
<li>节点上线，从从副本复制消息，复制过程非阻塞</li>
<li>数据写入更加可靠，超过半数不会造成脑裂</li>
<li>Raft 协议比镜像队列的算法更有效率，可以提供更好的消息吞吐量。</li>
</ul>
<p>总结起来，仲裁队列可以提供更高的性能、更好的数据安全性、更容易进行节点的滚动升级。</p>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><h5 id="特性更少"><a href="#特性更少" class="headerlink" title="特性更少"></a>特性更少</h5><p>这些特性在仲裁队列的第一个版本中不会提供</p>
<ul>
<li>非持久化消息</li>
<li>排它队列</li>
<li>队列&#x2F;消息 TTL（超时时间）</li>
<li>一些规则（Policy）不可用，只有死信队列、队列长度限制可用</li>
<li>优先级</li>
<li>惰性队列</li>
<li>非全局的消息预取（Qos）</li>
</ul>
<h5 id="磁盘使用——写入放大"><a href="#磁盘使用——写入放大" class="headerlink" title="磁盘使用——写入放大"></a>磁盘使用——写入放大</h5><p>仲裁队列的磁盘和内存配置与普通队列不同。</p>
<ul>
<li>普通队列：普通队列使用“共享”存储模型，对于一条要投递到多个队列的消息，只会存储一次，其他队列只会保存这条消息的引用。也就是说，在发布-订阅模型下，一条将要投递到多个队列的消息，它的存储大小不会随着投递到的队列变多而线性增长。</li>
<li>仲裁队列：仲裁队列使用在内存中“共享”的存储模型，在磁盘中，每条消息都会分别被存储。所以发布-订阅模型会造成更严重的写入放大，可能导致更大的磁盘使用，甚至不得不放弃使用仲裁队列。</li>
</ul>
<h5 id="内存使用——所有消息一直保存在内存中"><a href="#内存使用——所有消息一直保存在内存中" class="headerlink" title="内存使用——所有消息一直保存在内存中"></a>内存使用——所有消息一直保存在内存中</h5><p>仲裁队列的所有消息一直会保存在内存中，这会增加内存的使用量，最终可能导致集群不可用。如果不进行一些检查和监控，队列消息不断堆积，可能会导致生产停止（内存高水位），直到消息被消费或者从内存中删除。所以当使用仲裁队列时，设置队列的长度限制非常重要。此外还有必要用惰性队列作为仲裁队列的死信队列，通过死信交换器将这些消息转发到死信队列中。</p>
<p>因此，队列的规划和监控边得比普通场景下更为重要。下游（消费者和下游服务）的中断或者变慢可能导致多个队列消息堆积，需要有对应的规划和措施。你需要多少个仲裁队列、它们的写入速率时多少，当集群达到内存高水位时其他队列会不会收到影响？</p>
<h5 id="失去多数节点时意味着队列不可用"><a href="#失去多数节点时意味着队列不可用" class="headerlink" title="失去多数节点时意味着队列不可用"></a>失去多数节点时意味着队列不可用</h5><p>如果仲裁队列超过半数的副本永久丢失，那么队列数据就永久丢失了。即便有小部分的副本仍然可用，队列仍然没有办法恢复，只能被强制删除。虽然这种场景出现的可能性较小，但是仍有这样的危险存在。所以，推荐使用可靠的磁盘，并且把复制因子设置为 5 ~ 3。</p>
<h5 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h5><p>尽管仲裁队列的吞吐量更高，但是延迟也可能更高，这是由于使用了 Raft 协议。在仲裁队列中，所有消息都是持久化的，所有消息都会保存到每个副本的磁盘中。安全性是仲裁队列的主要目标。</p>
<h2 id="通过kubernetes搭建高可用RabbitMQ集群"><a href="#通过kubernetes搭建高可用RabbitMQ集群" class="headerlink" title="通过kubernetes搭建高可用RabbitMQ集群"></a>通过kubernetes搭建高可用RabbitMQ集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加repo库</span></span><br><span class="line">helm repo add bitnami https://charts.bitnami.com/bitnami</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检索 rabbitmq 的helm包</span></span><br><span class="line">helm search repo rabbitmq</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉包到本地，拉取指定版本，坑会少一些</span></span><br><span class="line">helm pull bitnami/rabbitmq --version 9.0.8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar zxvf rabbitmq-9.0.8.tgz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入目录修改配置文件</span></span><br><span class="line">cd rabbitmq/</span><br></pre></td></tr></table></figure>

<p>修改配置文件 <code>vim values.yaml</code>，需要修改或者注意的配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改成debug模式，可以查看到更多日志</span></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 配置登录账号密码</span></span><br><span class="line"><span class="attr">auth:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="comment"># 调整集群配置</span></span><br><span class="line"><span class="attr">clustering:</span></span><br><span class="line">	<span class="comment"># rabbitmq集群意外宕机强制启动 当rabbitmq启用持久化存储时，若rabbitmq所有pod同时宕机，将无法重新启动，因此有必要提前开启clustering.forceBoot</span></span><br><span class="line">  <span class="attr">forceBoot:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 调整时区</span></span><br><span class="line"><span class="attr">extraEnvVars:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TZ</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line"><span class="comment"># 调整副本数</span></span><br><span class="line"><span class="attr">replicaCount:</span> <span class="number">3</span></span><br><span class="line"><span class="comment"># 设置持久化（这里需要注意，要提前准备好sc）</span></span><br><span class="line"><span class="attr">persistence:</span></span><br><span class="line">  <span class="attr">storageClass:</span> <span class="string">&quot;local-path&quot;</span></span><br><span class="line"><span class="comment"># 修改svc，为了演示过程方便，这里改成 NodePort，生产环境不建议暴露出来，维持ClusterIP即可</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="comment"># 集群模式会自动将pod分配到不同的容器中，默认开启了软亲和性</span></span><br><span class="line"><span class="attr">podAntiAffinityPreset:</span> <span class="string">soft</span></span><br><span class="line"><span class="comment"># 如果k8s的cluster名称不是默认，则需要修改</span></span><br><span class="line"><span class="attr">clusterDomain:</span> <span class="string">cluster.local</span></span><br></pre></td></tr></table></figure>

<p>创建ns，并且安装rabbitmq</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create ns rabbitmq</span><br><span class="line">helm install rabbitmq -f values.yaml ./</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl get all</span></span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/rabbitmq-0   1/1     Running   0          17m</span><br><span class="line">pod/rabbitmq-1   1/1     Running   0          17m</span><br><span class="line">pod/rabbitmq-2   1/1     Running   0          6m19s</span><br><span class="line"></span><br><span class="line">NAME                        TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)                                                         AGE</span><br><span class="line">service/rabbitmq            NodePort    10.0.204.87   &lt;none&gt;        5672:31568/TCP,4369:30672/TCP,25672:32739/TCP,15672:31982/TCP   17m</span><br><span class="line">service/rabbitmq-headless   ClusterIP   None          &lt;none&gt;        4369/TCP,5672/TCP,25672/TCP,15672/TCP                           17m</span><br><span class="line"></span><br><span class="line">NAME                        READY   AGE</span><br><span class="line">statefulset.apps/rabbitmq   3/3     17m</span><br></pre></td></tr></table></figure>

<p>可能出现镜像没有拉下来，导致容器状态卡在 <code>ErrImagePull</code>，则更换镜像地址，从dockerhub上拉取</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认</span></span><br><span class="line">docker pull docker.io/bitnami/rabbitmq:3.9.17-debian-10-r0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改成</span></span><br><span class="line">docker pull bitnami/rabbitmq:3.9.17-debian-10-r0</span><br></pre></td></tr></table></figure>

<p>拉取之后，修改tag即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 7bc4ce9af795 docker.io/bitnami/rabbitmq:3.9.17-debian-10-r0</span><br></pre></td></tr></table></figure>

<p>排错：</p>
<p>当使用配置中的账号密码登录，弹出页面 <code>你与此网站的连接不是私密连接</code>，此时需要进入容器，重置权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it rabbitmq-0 bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取用户admin的权限</span></span><br><span class="line">rabbitmqctl list_user_permissions admin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置用户admin的权限，这里设置前后没有区别，但是设置之后就可以正常登录</span></span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure>

<p>将三个pod的端口映射出来，可以更加细致查看页面</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl port-forward --address=0.0.0.0 pod/rabbitmq-0 15672:15672 &amp;</span><br><span class="line">kubectl port-forward --address=0.0.0.0 pod/rabbitmq-1 15673:15672 &amp;</span><br><span class="line">kubectl port-forward --address=0.0.0.0 pod/rabbitmq-2 15674:15672</span><br></pre></td></tr></table></figure>

<h3 id="普通集群模式-1"><a href="#普通集群模式-1" class="headerlink" title="普通集群模式"></a>普通集群模式</h3><p>安装完成，默认就是普通集群模式</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101165313406.png" alt="image-20221101165313406"></p>
<p>在node2的页面在每个节点上都创建一个queue，在其他节点页面上可以看到queue信息已经被同步过来</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101174856959.png" alt="image-20221101174856959"></p>
<p>queue信息可以看到是普通模式</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101180228811.png" alt="image-20221101180228811"></p>
<p>在node0中向所有的queue发送message，选择持久化的投递方式</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101175016438.png" alt="image-20221101175016438" style="zoom:25%;" />

<img src="../../../../../Library/Application%20Support/typora-user-images/image-20221101175138523.png" alt="image-20221101175138523" style="zoom:25%;" />

<img src="../../../../../Library/Application%20Support/typora-user-images/image-20221101175203161.png" alt="image-20221101175203161" style="zoom:25%;" />

<p>在node1上可以看到queue信息</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101175236843.png" alt="image-20221101175236843"></p>
<p>在node1和node2上，分别获取message，都可以获取到。验证普通集群模式下，连接任何一个节点都可以使用。</p>
<p>将node3关机</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=2 statefulset.apps/rabbitmq</span><br></pre></td></tr></table></figure>

<p>node状态停止</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101175508511.png" alt="image-20221101175508511"></p>
<p>队列状态down</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101175559718.png" alt="image-20221101175559718"></p>
<p>无法通过queue2获取到message</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101175624932.png" alt="image-20221101175624932"></p>
<p>总结：</p>
<p>普通模式集群下，节点之间元数据同步，并且node之间可读写消息，但是message数据不同步，当节点宕机，数据也就无法访问。</p>
<h3 id="镜像队里模式"><a href="#镜像队里模式" class="headerlink" title="镜像队里模式"></a>镜像队里模式</h3><p>恢复节点个数为3个</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=3 statefulset.apps/rabbitmq</span><br></pre></td></tr></table></figure>

<p>修改策略</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入rabbitmq</span></span><br><span class="line">kubectl exec -it rabbitmq-0 bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">罗列当前policy，普通集群模式下，policy为空</span></span><br><span class="line">rabbitmqctl list_policies</span><br><span class="line"></span><br><span class="line">Listing policies for vhost &quot;/&quot; ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置镜像模式，同步方式改为自动</span></span><br><span class="line">rabbitmqctl set_policy ha-all &quot;^&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot; , &quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">Setting policy &quot;ha-all&quot; for pattern &quot;^&quot; to &quot;&#123;&quot;ha-mode&quot;:&quot;all&quot; , &quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&quot; with priority &quot;0&quot; for vhost &quot;/&quot; ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次查看policy</span></span><br><span class="line">rabbitmqctl list_policies</span><br><span class="line"></span><br><span class="line">Listing policies for vhost &quot;/&quot; ...</span><br><span class="line">vhost	name	pattern	apply-to	definition	priority</span><br><span class="line">/	ha-all	^	all	&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;	0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 策略说明</span><br><span class="line">    rabbitmqctl set_policy [-p ] [--priority ] [--apply-to ]    </span><br><span class="line">    -p Vhost： 可选参数，针对指定vhost下的queue进行设置</span><br><span class="line">    Name:     policy的名称</span><br><span class="line">    Pattern: queue的匹配模式(正则表达式)</span><br><span class="line">    Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode</span><br><span class="line">                ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes</span><br><span class="line">                        all：表示在集群中所有的节点上进行镜像</span><br><span class="line">                        exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span><br><span class="line">                        nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</span><br><span class="line">                ha-params：ha-mode模式需要用到的参数</span><br><span class="line">                ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual</span><br><span class="line">                priority：可选参数，policy的优先级</span><br></pre></td></tr></table></figure>

<p>再查看页面，可以看到队列状态变成HA</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101180601759.png" alt="image-20221101180601759"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101180629694.png" alt="image-20221101180629694"></p>
<p>测试，node2上的master有queue2</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101180945564.png" alt="image-20221101180945564"></p>
<p>将node2关闭</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=2 statefulset.apps/rabbitmq</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181444396.png" alt="image-20221101181444396"></p>
<p>关闭之后，queue2的master切换到node0上</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181123405.png" alt="image-20221101181123405"></p>
<p>在node1上获取queue2上的message</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181229790.png" alt="image-20221101181229790"></p>
<p>在queue0、queue1、queue2上分别发送信息</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181425946.png" alt="image-20221101181425946"></p>
<p>再将node2启动起来</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=3 statefulset.apps/rabbitmq</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181531898.png" alt="image-20221101181531898"></p>
<p>获取队列信息</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181610421.png" alt="image-20221101181610421"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181630242.png" alt="image-20221101181630242"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181640713.png" alt="image-20221101181640713"></p>
<p>可以看到，新的node加进来之后，不会将原先队列的master切换到新的node上</p>
<p>在node3上获取信息，都可以正常获取到，验证高可用完成。</p>
<h3 id="仲裁队列-1"><a href="#仲裁队列-1" class="headerlink" title="仲裁队列"></a>仲裁队列</h3><p>创建一个仲裁队列</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181915439.png" alt="image-20221101181915439"></p>
<p>仲裁信息</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101181936703.png" alt="image-20221101181936703"></p>
<p>发送数据</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101182146762.png" alt="image-20221101182146762"></p>
<p>默认将node0作为Leader，通过关闭node0的docker实现模拟node0宕机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod rabbitmq-0 | grep &quot;Container ID:&quot;</span><br><span class="line">    Container ID:   docker://c7b2194001c93947d5ad6dff9064347928f09093232e4714a9ad8e328a07a3c2</span><br><span class="line"></span><br><span class="line">docker stop c7b2194001c93</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101182301229.png" alt="image-20221101182301229"></p>
<p>master切换</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221101182331051.png" alt="image-20221101182331051"></p>
<p>并且可以获取到message。</p>
<p>推荐阅读：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yYWJiaXRtcS5tci1waW5nLmNvbS8=">RabbitMQ中文文档<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucmFiYml0bXEuY29tL2dldHN0YXJ0ZWQuaHRtbA==">RabbitMQ Tutorials<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbG9uZWx5LXdvbGYvcC8xNDM5NzcwNC5odG1s">高可用RabbitMQ集群的搭建及原理分析 <i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNjMxMTQ4">RabbitMQ集群和高可用方案<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDc2NzU2OTE=">AMQP协议学习<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ibG9namF2YS5uZXQvcWJuYTM1MDgxNi9hcmNoaXZlLzIwMTYvMDgvMTIvNDMxNTU0Lmh0bWw=">AMQP-0-9-1中文规范<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW1xcC5vcmcvc2l0ZXMvYW1xcC5vcmcvZmlsZXMvYW1xcC5wZGY=">amqp 1.0<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDI1NzgwMTUxODIwNDg0NjIx">K8S部署RabbitMQ集群+镜像模式实现高可用<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vemhvdWdhbnFpbmcvcC8xNDgxODkzOS5odG1s">RabbitMQ集群（镜像队列）原理详解 <i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3cTU1MDk3NzM1OS9hcnRpY2xlL2RldGFpbHMvMTIzMjIwOTYx">RabbitMQ脑裂的模拟和分析<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYnMuaHVhd2VpY2xvdWQuY29tL2Jsb2dzLzM2NDY3Mg==">RabbitMQ 3.8 特性聚焦：仲裁队列（Quorum Queues）<i class="fa fa-external-link-alt"></i></span></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Reference/" rel="tag"># 学习笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/191e.html" rel="prev" title="JWT教程">
                  <i class="fa fa-chevron-left"></i> JWT教程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/1560.html" rel="next" title="k8s使用NFS作为sc">
                  k8s使用NFS作为sc <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mitaka xu</span>
</div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"TVx6Wkfs8VJGOwYPurtjWY2e-9Nh9j0Va","app_key":"c7VvaRnyF8r3DUIPq1x2KJ7Q","server_url":"https://tvx6wkfs.lc-cn-e1-shared.com","security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"xiaoyeshiyu","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
