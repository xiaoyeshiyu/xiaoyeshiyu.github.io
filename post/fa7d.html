<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="S_5aoPFd3QQihrUOLiKdVR0Mj4fj6n6qJojwyjj9cAY">
  <meta name="msvalidate.01" content="9032A67FCF787F07CB04374E59E518A9">
  <meta name="baidu-site-verification" content="code-Onlniop0d6">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.xiaoyeshiyu.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="这是学习MySQL的笔记事务和锁篇，主要包含数据库的事务、锁和MVCC机制。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL学习笔记事务和锁篇">
<meta property="og:url" content="https://www.xiaoyeshiyu.com/post/fa7d.html">
<meta property="og:site_name" content="小夜时雨">
<meta property="og:description" content="这是学习MySQL的笔记事务和锁篇，主要包含数据库的事务、锁和MVCC机制。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122205527852.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122215224984.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122215425596.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122215607038.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122215842827.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122225953987.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122225935399.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123145613755.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123151948870.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123154701699.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123155107531.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123204441117.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123204009071.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123204221137.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123203800462.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123203948900.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123205341477.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123205503134.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123205825888.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123205921819.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123210521940.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123210721287.png">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221123210845713.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123215755143.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123215850385.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123220108591.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123220420343.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123220458824.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123220621018.png">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221123210859630.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123222646322.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123222905492.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123223103358.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124093251289.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124115442357.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124155836072.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124155941944.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124163809373.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124164354310.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124164630676.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124170709408.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124204516590.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124212206988.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124221958830.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124222511565.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124222545821.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124223838600.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124224534753.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221125102136430.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221125102316103.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221125102729824.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221125103220778.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221125110751171.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221125112340543.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221125112730129.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221125114343122.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221125115601339.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221125114343122.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221125115601339.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221125121001971.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221125121611519.png">
<meta property="article:published_time" content="2022-11-23T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-08T01:48:25.612Z">
<meta property="article:author" content="Mitaka xu">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122205527852.png">


<link rel="canonical" href="https://www.xiaoyeshiyu.com/post/fa7d.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.xiaoyeshiyu.com/post/fa7d.html","path":"post/fa7d.html","title":"MySQL学习笔记事务和锁篇"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MySQL学习笔记事务和锁篇 | 小夜时雨</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MBVJ11TVHH"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBVJ11TVHH","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?573725610fbc6ff9b42032bd13615370"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="小夜时雨" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小夜时雨</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">君子敬其在己者，而不慕其在天者，是以日进也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">事务概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">事务的ACID特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.</span> <span class="nav-text">事务的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.3.</span> <span class="nav-text">使用事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">1.4.</span> <span class="nav-text">隐式提交数据的情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">事务操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1-1"><span class="nav-number">2.1.</span> <span class="nav-text">使用事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E5%92%8CMyISAM%E5%9C%A8%E4%BA%8B%E5%8A%A1%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.</span> <span class="nav-text">InnoDB和MyISAM在事务下的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E7%82%B9-SAVEPOINT"><span class="nav-number">2.3.</span> <span class="nav-text">保存点 SAVEPOINT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">事务的隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.</span> <span class="nav-text">数据并发问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">3.2.</span> <span class="nav-text">SQL中的四种隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">MySQL支持的四种隔离级别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E4%B9%8Bredo%E6%97%A5%E5%BF%97"><span class="nav-number">4.</span> <span class="nav-text">MySQL事务日志之redo日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redo%E6%97%A5%E5%BF%97"><span class="nav-number">4.1.</span> <span class="nav-text">redo日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log%E7%9A%84%E5%A5%BD%E5%A4%84%E3%80%81%E7%89%B9%E7%82%B9"><span class="nav-number">4.2.</span> <span class="nav-text">redo log的好处、特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redo%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">4.3.</span> <span class="nav-text">redo的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">4.4.</span> <span class="nav-text">整体流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log-%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="nav-number">4.5.</span> <span class="nav-text">redo log 刷盘策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%85%A5redo-log-buffer%E8%BF%87%E7%A8%8B"><span class="nav-number">4.6.</span> <span class="nav-text">写入redo log buffer过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log-file"><span class="nav-number">4.7.</span> <span class="nav-text">redo log file</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84"><span class="nav-number">4.8.</span> <span class="nav-text">日志文件组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E4%B9%8Bundo%E6%97%A5%E5%BF%97"><span class="nav-number">5.</span> <span class="nav-text">MySQL事务日志之undo日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undo%E6%97%A5%E5%BF%97"><span class="nav-number">5.1.</span> <span class="nav-text">undo日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-log-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">undo log 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.</span> <span class="nav-text">undo 的存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BB%9A%E6%AE%B5%E4%B8%8E%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.4.</span> <span class="nav-text">回滚段与事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BB%9A%E6%AE%B5%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB"><span class="nav-number">5.5.</span> <span class="nav-text">回滚段中的数据分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undo%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.6.</span> <span class="nav-text">undo的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-log%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">5.7.</span> <span class="nav-text">undo log的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B"><span class="nav-number">5.8.</span> <span class="nav-text">详细生成过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-log-%E5%9B%9E%E6%BB%9A"><span class="nav-number">5.9.</span> <span class="nav-text">undo log 回滚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undo-log%E5%88%A0%E9%99%A4"><span class="nav-number">5.10.</span> <span class="nav-text">undo log删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%B0%8F%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">日志小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">7.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%90%8C%E8%AE%B0%E5%BD%95"><span class="nav-number">7.1.</span> <span class="nav-text">并发事务访问相同记录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="nav-number">7.1.1.</span> <span class="nav-text">读-读情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99-%E5%86%99%E6%83%85%E5%86%B5"><span class="nav-number">7.1.2.</span> <span class="nav-text">写-写情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB-%E5%86%99%E6%88%96%E5%86%99-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="nav-number">7.1.3.</span> <span class="nav-text">读-写或写-读情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">7.1.4.</span> <span class="nav-text">并发问题解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86"><span class="nav-number">7.2.</span> <span class="nav-text">从数据操作的类型划分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="nav-number">7.2.1.</span> <span class="nav-text">锁定读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">7.2.2.</span> <span class="nav-text">写操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%92%E5%88%86%EF%BC%9A%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81"><span class="nav-number">7.3.</span> <span class="nav-text">从数据操作的粒度划分：表级锁、页级锁、行锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E9%94%81"><span class="nav-number">7.3.1.</span> <span class="nav-text">表锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E7%BA%A7%E5%88%AB%E7%9A%84S%E9%94%81%E3%80%81X%E9%94%81"><span class="nav-number">7.3.1.1.</span> <span class="nav-text">表级别的S锁、X锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88intention-lock%EF%BC%89"><span class="nav-number">7.3.1.2.</span> <span class="nav-text">意向锁（intention lock）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E9%94%81%EF%BC%88AUTO-INC%E9%94%81%EF%BC%89"><span class="nav-number">7.3.1.3.</span> <span class="nav-text">自增锁（AUTO-INC锁）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="nav-number">7.3.1.4.</span> <span class="nav-text">元数据锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E9%94%81"><span class="nav-number">7.3.2.</span> <span class="nav-text">行锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%88Record-Locks%EF%BC%89"><span class="nav-number">7.3.2.1.</span> <span class="nav-text">记录锁（Record Locks）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Locks%EF%BC%89"><span class="nav-number">7.3.2.2.</span> <span class="nav-text">间隙锁（Gap Locks）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%B4%E5%BB%BA%E9%94%81%EF%BC%88Next-Key-Locks%EF%BC%89"><span class="nav-number">7.3.2.3.</span> <span class="nav-text">临建锁（Next-Key Locks）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88Insert-Intention-Locks%EF%BC%89"><span class="nav-number">7.3.2.4.</span> <span class="nav-text">插入意向锁（Insert Intention Locks）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%94%81"><span class="nav-number">7.3.3.</span> <span class="nav-text">页锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%AF%B9%E5%BE%85%E9%94%81%E7%9A%84%E6%80%81%E5%BA%A6%E5%88%92%E5%88%86%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">7.4.</span> <span class="nav-text">从对待锁的态度划分：乐观锁、悲观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%88Pessimistic-Locking%EF%BC%89"><span class="nav-number">7.4.1.</span> <span class="nav-text">悲观锁（Pessimistic Locking）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%88Optimistic-Locking%EF%BC%89"><span class="nav-number">7.4.2.</span> <span class="nav-text">乐观锁（Optimistic Locking）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="nav-number">7.4.2.1.</span> <span class="nav-text">乐观锁的版本号机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3%E6%9C%BA%E5%88%B6"><span class="nav-number">7.4.2.2.</span> <span class="nav-text">乐观锁的时间戳机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E9%94%81%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">7.4.2.3.</span> <span class="nav-text">两种锁的适用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E5%8A%A0%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86%EF%BC%9A%E6%98%BE%E5%BC%8F%E9%94%81%E3%80%81%E9%9A%90%E5%BC%8F%E9%94%81"><span class="nav-number">7.5.</span> <span class="nav-text">按照加锁的方式划分：显式锁、隐式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E9%94%81"><span class="nav-number">7.5.1.</span> <span class="nav-text">隐式锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E9%94%81"><span class="nav-number">7.5.2.</span> <span class="nav-text">显式锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="nav-number">7.6.</span> <span class="nav-text">全局锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">7.7.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">7.7.1.</span> <span class="nav-text">产生死锁的必要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">7.7.2.</span> <span class="nav-text">死锁的解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">7.7.3.</span> <span class="nav-text">避免死锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">8.</span> <span class="nav-text">锁的内存结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%9B%91%E6%8E%A7"><span class="nav-number">9.</span> <span class="nav-text">锁监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">10.</span> <span class="nav-text">MVCC 多版本并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="nav-number">10.1.</span> <span class="nav-text">快照读与当前读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="nav-number">10.1.1.</span> <span class="nav-text">快照读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="nav-number">10.1.2.</span> <span class="nav-text">当前读</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5%E3%80%81Undo-Log%E7%89%88%E6%9C%AC%E9%93%BE"><span class="nav-number">10.2.</span> <span class="nav-text">隔离级别和隐藏字段、Undo Log版本链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadView"><span class="nav-number">10.3.</span> <span class="nav-text">ReadView</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="nav-number">10.3.1.</span> <span class="nav-text">设计思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadView%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-number">10.3.2.</span> <span class="nav-text">ReadView的规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC%E6%95%B4%E4%BD%93%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">10.4.</span> <span class="nav-text">MVCC整体操作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadView%E7%9A%84%E7%94%9F%E6%88%90%E8%8A%82%E7%82%B9"><span class="nav-number">10.4.1.</span> <span class="nav-text">ReadView的生成节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8MVCC"><span class="nav-number">10.5.</span> <span class="nav-text">使用MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#READ-COMMITTED%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B"><span class="nav-number">10.5.1.</span> <span class="nav-text">READ COMMITTED隔离级别下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#REPEATABLE-READ%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B"><span class="nav-number">10.5.2.</span> <span class="nav-text">REPEATABLE READ隔离级别下</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="nav-number">10.6.</span> <span class="nav-text">MVCC解决幻读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">10.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mitaka xu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mitaka xu</p>
  <div class="site-description" itemprop="description">Golang开发博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">103</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaoyeshiyu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/fa7d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="MySQL学习笔记事务和锁篇 | 小夜时雨">
      <meta itemprop="description" content="这是学习MySQL的笔记事务和锁篇，主要包含数据库的事务、锁和MVCC机制。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL学习笔记事务和锁篇
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-24 00:00:00" itemprop="dateCreated datePublished" datetime="2022-11-24T00:00:00+08:00">2022-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-08 09:48:25" itemprop="dateModified" datetime="2023-09-08T09:48:25+08:00">2023-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
    <span id="/post/fa7d.html" class="post-meta-item leancloud_visitors" data-flag-title="MySQL学习笔记事务和锁篇" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/post/fa7d.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="post/fa7d.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

            <div class="post-description">这是学习MySQL的笔记事务和锁篇，主要包含数据库的事务、锁和MVCC机制。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="事务概述"><a href="#事务概述" class="headerlink" title="事务概述"></a>事务概述</h2><p>事务是数据库区别于文件系统的重要特性之一，当有了事务，就会让数据库使用保持一致性，同时还能通过事务的机制恢复到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p>
<p>存储引擎支持事务的情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> Engine             <span class="operator">|</span> Support <span class="operator">|</span> Comment                                                        <span class="operator">|</span> Transactions <span class="operator">|</span> XA   <span class="operator">|</span> Savepoints <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> ndbcluster         <span class="operator">|</span> <span class="keyword">NO</span>      <span class="operator">|</span> Clustered, fault<span class="operator">-</span>tolerant tables                               <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FEDERATED          <span class="operator">|</span> <span class="keyword">NO</span>      <span class="operator">|</span> Federated MySQL storage engine                                 <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MEMORY             <span class="operator">|</span> YES     <span class="operator">|</span> Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables      <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB             <span class="operator">|</span> <span class="keyword">DEFAULT</span> <span class="operator">|</span> Supports transactions, <span class="type">row</span><span class="operator">-</span>level locking, <span class="keyword">and</span> <span class="keyword">foreign</span> keys     <span class="operator">|</span> YES          <span class="operator">|</span> YES  <span class="operator">|</span> YES        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> PERFORMANCE_SCHEMA <span class="operator">|</span> YES     <span class="operator">|</span> Performance Schema                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MyISAM             <span class="operator">|</span> YES     <span class="operator">|</span> MyISAM storage engine                                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ndbinfo            <span class="operator">|</span> <span class="keyword">NO</span>      <span class="operator">|</span> MySQL Cluster <span class="keyword">system</span> information storage engine                <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MRG_MYISAM         <span class="operator">|</span> YES     <span class="operator">|</span> Collection <span class="keyword">of</span> identical MyISAM tables                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLACKHOLE          <span class="operator">|</span> YES     <span class="operator">|</span> <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> storage engine (anything you write <span class="keyword">to</span> it disappears) <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CSV                <span class="operator">|</span> YES     <span class="operator">|</span> CSV storage engine                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ARCHIVE            <span class="operator">|</span> YES     <span class="operator">|</span> Archive storage engine                                         <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，只有<code>InnoDB</code>支持事务。</p>
<p>事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
<p>事务的处理原则：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交（<code>commit</code>），那么这些修改就<strong>永久</strong>地保存下来；要么数据库管理系统将<strong>放弃</strong>所做的所有<strong>修改</strong>，整个事务回滚（<code>rollback</code>）到最初状态。</p>
<h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><ul>
<li><p>原子性 <code>Atomicity</code>：原子性指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚，没有中间状态</p>
</li>
<li><p>一致性 <code>Consistency</code>：一致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态，这种状态是语义上的而不是语法上的，跟具体业务有关。事务执行前后的状态，都是合法的，就是一致性。</p>
</li>
<li><p>隔离性 <code>Isolation</code>：隔离性是指事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。</p>
</li>
<li><p>持久性 <code>Durability</code>：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是<strong>永久性的</strong>，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
<p>持久性是通过<strong>事务日志</strong>来保证的，日志包括了<strong>重做日志</strong>和<strong>回滚日志</strong>，当通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样的好处是即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
</li>
</ul>
<p><code>ACID</code>是事务的四大特性，原子性是基础，隔离性是手段，一致性是约束条件，持久性是目的。</p>
<h3 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h3><p>MySQL根据对事务的一个或多个操作阶段，把事务大致划分几个状态：</p>
<ul>
<li>活动的 <code>active</code>：事务对应的数据库操作<strong>正在执行</strong>过程中时，就说该事务处在活动的状态。</li>
<li>部分提交的 <code>partially committed</code>：当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并<strong>没有刷新到磁盘</strong>时，该事务处在部分提交状态。</li>
<li>失败的<code>failed</code>：当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，该事务处于失败的状态。</li>
<li>中止的 <code>aborted</code>：事务执行了一部分而变成失败的状态，那么就需要把已经修改的事务中的操作还原到初始状态，也就是需要撤销操作。这个撤销的过程称之为回滚，当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，该事务处在了中止的状态。</li>
<li>提交的 commit：当一个处在部分提交的状态的事务将修改后的数据都<strong>同步到磁盘</strong>上之后，该事务处在了提交的状态。</li>
</ul>
<p>事务状态转换图：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122205527852.png" alt="image-20221122205527852"></p>
<h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><p>事务的完整过程</p>
<p>显式事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显式事务 </span></span><br><span class="line"><span class="comment">-- 步骤1：开启事务</span></span><br><span class="line"><span class="comment">-- START TRANSACTION 可以限制事务操作 </span></span><br><span class="line"><span class="comment">-- 当前事务是只读事务，不能增删改，只是不允许修改那些其他事务也能访问到的表的数据，对于临时表(CREATE TEMPORARY TABLE)来说，是可以进行增删改的 </span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION READ <span class="keyword">ONLY</span>;</span><br><span class="line"><span class="comment">-- 读写，默认 </span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION READ WRITE;</span><br><span class="line"><span class="comment">-- 开启一致性读 </span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION READ CONSISTENT SNAPSHOT;</span><br><span class="line"><span class="comment">-- 或者  </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 步骤2：一系列的DML操作</span></span><br><span class="line"><span class="comment">-- 步骤3：提交或者中止状态  </span></span><br><span class="line"><span class="comment">-- 提交事务 </span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 回滚事务  </span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p>隐式事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式事务  </span></span><br><span class="line"><span class="comment">-- 通过 autocommit 设置 ,默认 on，代表每一条DML都是一个独立的操作，执行之后，默认会自动提交。</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%autocommit%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 关闭自动提，只针对DML，对DDL是无效的  </span></span><br><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="literal">FALSE</span>; </span><br><span class="line"><span class="comment">-- 执行操作，构成一个独立的事务   </span></span><br><span class="line"><span class="comment">-- 提交  </span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 当 autocommit 为 true，START TRANSACTION或者BEGIN之后，都不会将DML操作作为单个事务，而是作为整体一个事务。</span></span><br></pre></td></tr></table></figure>

<p>保存点：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 保存点 SAVEPOINT ： 事务操作中设置的一个状态，在事务结束之前，可以回到保存点继续操作失误。</span></span><br><span class="line"><span class="comment">-- 设置保存点 </span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> save1;</span><br><span class="line"><span class="comment">-- 回滚到保存点 </span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> save1;</span><br><span class="line"><span class="comment">-- 删除保存点 </span></span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> save1;</span><br></pre></td></tr></table></figure>

<h3 id="隐式提交数据的情况"><a href="#隐式提交数据的情况" class="headerlink" title="隐式提交数据的情况"></a>隐式提交数据的情况</h3><ul>
<li><p>数据定义语言 <code>DDL</code> ：例如操作数据库、表、视图、存储过程等结构，<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>等语句</p>
</li>
<li><p>隐式使用或修改MySQL数据库中的表：使用 <code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句也会隐式提交前面语句所属于的事务</p>
</li>
<li><p>事务控制或关于锁定的语句：在一个事务中没有提交或者回滚，又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>开启一个新的事物，会隐式的提交上一个事务</p>
</li>
<li><p>将 <code>autocommit</code> 设置为<code>true</code>，也会隐式提交前边语句所属的事务</p>
</li>
<li><p>使用 <code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>加载数据的语句：LOAD DATA语句来批量往数据库中导入数据时，也会隐式的提交前面语句所属的事务。</p>
</li>
<li><p>关于MySQL复制的一些语句：<code>START SLAVE</code>、<code>STOP SLAVE</code>、<code>RESET SLAVE</code>、<code>CHANGE MASTER TO</code>等语句，也会隐式的提交前面语句所属的事务。</p>
</li>
<li><p>其他的一些语句：使用 <code>ANALYZE TABLE</code>，<code>CACHE INDEX</code>、<code>CHECK TABLE</code>、<code>FLUSH</code>、<code>LOAD INDEX INTO CACHE</code>、<code>OPTIMIZE TABLE</code>、<code>REPAIR TABLE</code>、<code>RESET</code>等语句也会隐式的提交前面语句所属的事务。</p>
</li>
</ul>
<h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><h3 id="使用事务-1"><a href="#使用事务-1" class="headerlink" title="使用事务"></a>使用事务</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用事务 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user3(name <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">PRIMARY</span> KEY);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user3;</span><br><span class="line"><span class="comment">-- 开启事务 </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">-- 获取数据，可以获取到 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user3;</span><br><span class="line"><span class="comment">-- 提交 </span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 获取数据，也可以获取到 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user3;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启事务 </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">-- 收到主键影响，会插入失败  </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- DDL 操作会自动提交数据，不受 autocommit 变量的影响 </span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> user3;</span><br><span class="line"><span class="comment">-- autocommit为默认状态   </span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%autocommit%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 默认一条DML为一个事务，可以提交成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>); </span><br><span class="line"><span class="comment">-- 由于主键原因，操作失败，处于 failed 状态 </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">-- 回滚，回滚到失败状态之间</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="comment">-- 只插入了1条记录  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user3;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- completion_type的使用  </span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@completion</span>_type;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@completion</span>_type <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- autocommit为默认状态   </span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%autocommit%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 默认一条DML为一个事务，可以提交成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;b&#x27;</span>); </span><br><span class="line"><span class="comment">-- 由于主键原因，操作失败，处于 failed 状态 </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">-- 回滚</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="comment">-- 还是只有a这1条记录，这就是由于   @@completion_type 的影响 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user3;</span><br></pre></td></tr></table></figure>

<p><code>completion_type</code>的使用</p>
<ol>
<li><code>completion_type=0</code>，默认情况，当执行<code>COMMIT</code>的时候会提交事务，执行下一个事务时，还需要用<code>START TRANSACTION</code>或者<code>BEGIN</code>来开启。</li>
<li><code>completion_type=1</code>，提交事务之后，相当于执行了 <code>COMMIT AND CHAIN</code>，也就是开启一个链式事物，即提交事务之后会开启一个相同隔离级别的事务。</li>
<li><code>completion_type=2</code>，这种情况下 <code>COMMIT=COMMIT AND RELEASE</code>，也就是当事务提交时，会自动与服务器断开连接。</li>
</ol>
<h3 id="InnoDB和MyISAM在事务下的区别"><a href="#InnoDB和MyISAM在事务下的区别" class="headerlink" title="InnoDB和MyISAM在事务下的区别"></a>InnoDB和MyISAM在事务下的区别</h3><p>MyISAM不支持事务</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表  </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1(i <span class="type">INT</span>) ENGINE <span class="operator">=</span> INNODB;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test2(i <span class="type">INT</span>) ENGINE <span class="operator">=</span> MYISAM;</span><br><span class="line"><span class="comment">-- 针对 InnoDB </span></span><br><span class="line"><span class="keyword">BEGIN</span>; </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test1 <span class="keyword">VALUES</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="comment">-- 回滚之后，没有数据 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 针对 MyISAM </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test2 <span class="keyword">VALUES</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="comment">-- 回滚之后，数据还在，事务对MyISAM无效 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test2;</span><br></pre></td></tr></table></figure>

<h3 id="保存点-SAVEPOINT"><a href="#保存点-SAVEPOINT" class="headerlink" title="保存点 SAVEPOINT"></a>保存点 SAVEPOINT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user4(NAME <span class="type">VARCHAR</span>(<span class="number">10</span>),balance <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>));</span><br><span class="line"><span class="comment">-- 操作事务 </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user4(NAME,balance) <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次操作事务  </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> user4 <span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="number">-100</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> user4 <span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="number">-100</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">-- 设置保存点 </span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> s1;</span><br><span class="line"><span class="keyword">UPDATE</span> user4 <span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">-- 单独回滚 +1 的操作，回滚到保存点 s1  </span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> s1;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user4;</span><br><span class="line"><span class="comment">-- 此时事务没有完成  </span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="comment">-- 或者  </span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>实际使用场景中，可能出现多线程并发操作，而且可能出现多个线程同时使用事务，这种情况下，需要保障事务的<code>ACID</code>，此时就需要通过隔离性，某个事务对某个数据进行访问时，其他事务应该进行排队，当事务提交之后，其他事务才可以就行访问这个数据。但是这样对性能影响很大，因此需要权衡。 </p>
<p>数据准备</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">studentno <span class="type">INT</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">class <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(studentno)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;小谷&#x27;</span>,<span class="string">&#x27;1班&#x27;</span>);</span><br><span class="line"><span class="comment">-- 获取数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span> studentno <span class="operator">|</span> name   <span class="operator">|</span> class <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span> 小谷   <span class="operator">|</span> <span class="number">1</span>班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="数据并发问题"><a href="#数据并发问题" class="headerlink" title="数据并发问题"></a>数据并发问题</h3><ol>
<li><p>脏写（<code>Dirty Write</code>）</p>
<p>对于两个事务<code>Session A</code>、<code>Session B</code>，如果事务<code>Session A</code>修改了另一个未提交事务<code>Session B</code>修改过的数据，那就意味着发生了脏写</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122215224984.png" alt="image-20221122215224984"></p>
</li>
<li><p>脏读（<code>Dirty Read</code>）</p>
<p>对于两个事务<code>Session A</code>、<code>Session B</code>，<code>Session A</code>读取了<strong>已经被<code>Session B</code>更新但还没有被提交</strong>的字段。之后若<code>Session B</code>回滚，<code>Session A</code>读取的内容就是临时且无效的。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122215425596.png" alt="image-20221122215425596"></p>
</li>
<li><p>不可重复读（<code>Non-Repeatable Read</code>）</p>
<p>对于两个事务<code>Session A</code>、<code>Session B</code>，**<code>Session A</code>读取了一个字段，然后<code>Session B</code>更新了该字段。之后<code>Session A</code>再次读取同一个字段，值就不同**，就意味着发生了不可重复读。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122215607038.png" alt="image-20221122215607038"></p>
</li>
<li><p>幻读（<code>Phantom</code>）</p>
<p>对于两个事务<code>Session A</code>、<code>Session B</code>，<code>Session A</code>从一个表中读取了一个字段，然后<code>Session B</code>在该表中插入了一些新的行。之后，如果<code>Session A</code>再次读取同一个表，就会多出几行。那就意味着发生了幻读。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122215842827.png" alt="image-20221122215842827"></p>
<p>注意1：如果<code>Session B</code>删除了一些记录，导致<code>Session A</code>读取的记录变少了，这个现象不属于幻读，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</p>
<p>注意2：对于先前已经读到的记录，之后又读取不到，这相当于每一条记录都发生了不可重复读的现象。</p>
</li>
</ol>
<h3 id="SQL中的四种隔离级别"><a href="#SQL中的四种隔离级别" class="headerlink" title="SQL中的四种隔离级别"></a>SQL中的四种隔离级别</h3><p>上面的问题按照严重性排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脏写 <span class="operator">&gt;</span> 脏读 <span class="operator">&gt;</span> 不可重复读 <span class="operator">&gt;</span> 幻读</span><br></pre></td></tr></table></figure>

<p>可以舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。</p>
<p>SQL标准设立了4个隔离级别：</p>
<ul>
<li><p><code>READ UNCOMMIT</code>：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果（没有提交，但是可以看到结果，也就意味着发生了脏读，因为如果另外一个事务回滚，则出现前后不一致。）。不能避免脏读、不可重复读、幻读。</p>
</li>
<li><p><code>READ COMMIT</code>：读已提交，满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变（没有提交，则读取不到，提交，则读取到），这是大多数数据库系统的默认隔离级别（Oracle默认隔离级别）。可以避免脏读，但不可重复读、幻读问题仍然存在。</p>
</li>
<li><p><code>REPEATABLE READ</code>：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容（先读一条数据，后续无论其他事务是否提交，都按照这条已经读到的数据处理）（这里与脏读的差别是脏读提交之后可读取到，提交之前读取不到；可重复读是读取的都是第一次读取的数据。）。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</p>
</li>
<li><p><code>SERIALIZABLE</code>：可串行化，确保事务可以从一个表中读取相同的行。这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但是性能很低。能避免脏读、不可重复读和幻读。</p>
</li>
</ul>
<p>SQL标准中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122225953987.png" alt="image-20221122225953987"></p>
<p>脏读是最为严重的，因此这四种隔离级别，都解决了脏读的问题。</p>
<p>不同隔离级别有不同的锁和并发机制，隔离级别与并发性能关系如下：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221122225935399.png" alt="image-20221122225935399"></p>
<h3 id="MySQL支持的四种隔离级别"><a href="#MySQL支持的四种隔离级别" class="headerlink" title="MySQL支持的四种隔离级别"></a>MySQL支持的四种隔离级别</h3><p>MySQL虽然都支持四种隔离级别，但是跟SQL标准中的定义有些出入。MySQL在<code>REPEATABLE READ</code>隔离级别下，是可以禁止幻读问题的发生，主要是通过<code>MVCC</code>实现。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="comment">-- 设置隔离级别  </span></span><br><span class="line"><span class="comment">-- 当前会话  </span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line"><span class="comment">-- 全局 </span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"><span class="comment">-- 或者  </span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;READ-UNCOMMITTED&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;READ-COMMITTED&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;REPEATABLE-READ&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>GLOBAL</code>：当前已经存在的会话无效，只对执行完该语句之后产生的会话起作用；</p>
<p><code>SESSION</code>：对当前会话的所有后续事务有效，如果在事务之间执行，对后续的事务有效，该语句可以在当前事务中间执行，但不会影响当前正在执行的事务</p>
<p>重启之后，都会恢复成默认隔离级别。</p>
<p>演示脏读的问题</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 解决读未提交 </span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启事务 </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span>balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 回滚 </span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启的另外一个会话  </span></span><br><span class="line">USE dbtest2;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="comment">-- 修改隔离级别 </span></span><br><span class="line"><span class="comment">-- 修改成读未提交  </span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;READ-UNCOMMITTED&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="comment">-- 此时另外一个session的事务未提交 </span></span><br><span class="line"><span class="comment">-- 可以获取到数据，出现了脏读  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="comment">-- 另外一个session的事务回滚之后，再次读取数据，此时数据又发生变更 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br></pre></td></tr></table></figure>

<p>演示不可重复读的问题</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="comment">-- 更改隔离级别，改成读已提交 </span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;READ-COMMITTED&#x27;</span>;</span><br><span class="line"><span class="comment">-- 开启事务 </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 扣除1中500 </span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">500</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查询此时数据，数据正常 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="comment">-- 提交 </span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="comment">-- 更改隔离级别，改成读已提交 </span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;READ-COMMITTED&#x27;</span>;</span><br><span class="line"><span class="comment">-- 开启事务 </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 开启事务之后先获取一次数据，起初状态都是 1000   </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="comment">-- 另外一个session操作事物之后，获取到的还是 1000，此时就避免了脏读     </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="comment">-- 事务没有结束，另一个session提交之后，再次读取，读取的是提交之后的数据，出现了不可重复读  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>解决不可重复度的问题，使用可重复读的隔离级别</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更改隔离级别，改成可重复度</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;REPEATABLE-READ&#x27;</span>;</span><br><span class="line"><span class="comment">-- 同时开启事务 </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 开启之后就获取一次数据  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="comment">-- 另一个回话事务修改之后，再次获取数据，与上次获取的是一样的，脏读避免了 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="comment">-- 另一个回话事务提交之后，再次获取数据，与上次获取的是一样的，也解决了不可重复读的问题  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更改隔离级别，改成可重复度</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;REPEATABLE-READ&#x27;</span>;</span><br><span class="line"><span class="comment">-- 同时开启事务 </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 开启之后就获取一次数据  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="comment">-- 另一个回话事务修改之后，再次获取数据，与上次获取的是一样的，脏读避免了 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="comment">-- 另一个回话事务提交之后，再次获取数据，与上次获取的是一样的，也解决了不可重复读的问题  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br></pre></td></tr></table></figure>

<p>幻读的问题：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更改隔离级别，改成可重复度</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;REPEATABLE-READ&#x27;</span>;</span><br><span class="line"><span class="comment">-- 插入数据 </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account(id,`NAME`,balance) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更改隔离级别，改成可重复度</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;REPEATABLE-READ&#x27;</span>;</span><br><span class="line"><span class="comment">-- 开启事务  </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 获取个数，最开始为0个 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 另一个session插入之后，再次获取个数，依然是0个，此时验证了可重复读  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 但是如果此时3的记录插入，会出现报错   1062 - Duplicate entry &#x27;3&#x27; for key &#x27;account.PRIMARY&#x27; ，也就是记录3是存在的，出现了幻读  </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account(id,`NAME`,balance) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">200</span>);</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p>通过<code>SERIALIZABLE</code>串行化解决幻读的问题</p>
<p><code>SERIALIZABLE</code>隔离级别下，如果在<code>session A</code>的事务中插入数据，此时会加上一个隐式的行<strong>（X）锁</strong>&#x2F;<strong>gap（X）锁</strong>，而<code>session B</code>的事务中再次插入会被阻塞，<code>session A</code> 的事务结束之后，<code>session B</code>的锁才会被释放。</p>
<p>MySQL在 <code>REPEATABLE-READ</code>隔离级别下，也是可以避免幻读的，主要也是对<code>select</code>操作手动<strong>加行X锁（独占锁）</strong>，从而在<code>session A</code>的 <code>insert</code>操作时会阻塞。即便当前记录不存在，比如<code>id=3</code>不存在，当前事务也会获得一把记录锁（因为InnoDB的行锁锁定的是索引，故记录实体存在与否没关系，存在就加行X锁，不存在就加间隙锁。），从而解决幻读的问题。</p>
<h2 id="MySQL事务日志之redo日志"><a href="#MySQL事务日志之redo日志" class="headerlink" title="MySQL事务日志之redo日志"></a>MySQL事务日志之<code>redo</code>日志</h2><p>事务的ACID特性实现机制：</p>
<ul>
<li>隔离性：通过锁机制实现</li>
<li>原子性、一致性、持久性由事务的<code>redo</code>日志和<code>undo</code>日志来保证<ul>
<li><code>REDO LOG</code>称为重做日志，提供再写入操作，恢复提交事务修改的页操作（如果事务写入到一半，服务器宕机，重启之后，能够保证事务写入完整，保证数据的可靠性），用来保证事务的持久性。</li>
<li><code>UNDO LOG</code>称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li>
</ul>
</li>
</ul>
<p><code>REDO</code>和<code>UNDO</code>都可以视为一种恢复操作，但是：</p>
<ul>
<li><p><code>redo log</code>：存储引擎<code>InnoDB</code>生成的日志，记录的是物理级别上的页的修改操作，比如<code>页号xxx</code>、<code>偏移量yyy</code>写入了<code>数据zzz</code>。主要是为了保证数据的可靠性。</p>
</li>
<li><p><code>undo log</code>：存储引擎<code>InnoDB</code>生成的日志，记录的是<strong>逻辑操作</strong>日志，比如对某一行数据进行了<code>INSERT</code>语句的操作，那么<code>undo log</code>就记录一条与之相反的<code>DELETE</code>操作。主要用于<strong>事务的回滚</strong>（<code>undo log</code>记录的是每个修改操作的<strong>逆操作</strong>）和一<strong>致性非锁定读</strong>（<code>undo log</code>回滚行记录到某种特定的版本–<code>MVCC</code>，即多版本并发控制）。</p>
</li>
</ul>
<h3 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a><code>redo</code>日志</h3><p><code>InnoDB</code>存储引擎是<strong>以页为单位</strong>来管理存储空间的。早真正访问页面之前，需要把<strong>磁盘上</strong>的页缓存到内存中的<code>buffer pool</code>之后才可以访问。所有变更都必须<strong>先更新缓冲池</strong>中的数据，然后把缓冲池中的<strong>脏页</strong>会以一定的频率被刷入磁盘（<strong>checkpoint机制</strong>），通过缓冲池来优化CPU和磁盘之间的鸿沟，来保证整体的性能不会下降太快。</p>
<p>为什么需要&#96;&#96;redo log&#96;？</p>
<p>由于<code>checkpoint</code>机制不是每次变更的时候触发，当事务没有提交，事务中的操作只是修改了缓冲池中的数据，此时服务器宕机，缓冲池中的数据丢失，此时就无法保证事务的持久性。或者说事务执行到一半宕机，恢复之后，能够从继续从中断的部分继续开始。</p>
<p>事务的持久性特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p>
<p>一个简单的做法：通过在事务提交之前，把该事务所修改的所有页面都刷新到磁盘，但是这个做法有些问题：</p>
<ul>
<li>修改量与刷新磁盘工作量严重不成比例：修改缓冲池可能只有<code>1Byte</code>，但是一个页修改磁盘会修改<code>16KB</code>，这样会大大的增加成本。</li>
<li>随机<code>IO</code>刷新较慢：一个事务可能操作很多页，每一个页都去操作可能导致大量的随机<code>IO</code>，成本也很高。</li>
</ul>
<p>针对这种情况，可以将修改了的数据记录一下。</p>
<p><code>InnoDB</code>引擎的事务采用<strong>WAL技术</strong>（<code>Write-Ahead Log</code>），先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是<code>redo log</code>。当发生宕机，且数据未刷到磁盘的时候，可以通过<code>redo log</code>恢复，保证<code>ACID</code>中的<code>D</code>。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123145613755.png" alt="image-20221123145613755"></p>
<h3 id="redo-log的好处、特点"><a href="#redo-log的好处、特点" class="headerlink" title="redo log的好处、特点"></a><code>redo log</code>的好处、特点</h3><p>好处：</p>
<ul>
<li><code>redo log</code>降低刷盘频率</li>
<li><code>redo log</code>日志占用的空间非常小：保存<code>表空间id</code>、<code>页号</code>、<code>偏移量</code>以及<code>需要更新的值</code></li>
</ul>
<p>特定：</p>
<ul>
<li><code>redo log</code>是顺序写入的：按照产生的顺序写入磁盘</li>
<li>事务执行过程中，<code>redo log</code>不断记录</li>
</ul>
<h3 id="redo的组成"><a href="#redo的组成" class="headerlink" title="redo的组成"></a><code>redo</code>的组成</h3><p><code>redo log</code>可以简单分为两个部分：</p>
<ul>
<li><p>重做日志的缓冲（<code>redo log buffer</code>）：保存在内存中，是易失的。服务器启动时，就向操作系统申请了一大片称之为 <code>redo log buffer</code>的连续内存空间，这片空间被划分成若干个连续的 <code>redo log block</code>，一个 <code>redo log block</code>占用<code>512字节</code>大小。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123151948870.png" alt="image-20221123151948870"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 redo log buffer </span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%innodb_log_buffer_size%&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重做日志文件（<code>redo log file</code>）：保存在磁盘中，是持久的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----  1 mysql mysql 3.2M Nov 23 02:14 &#x27;#ib_redo753&#x27;</span></span><br><span class="line">bash<span class="number">-4.4</span># pwd</span><br><span class="line"><span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>#innodb_redo</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123154701699.png" alt="image-20221123154701699"></p>
<p>更新事务过程如下：</p>
<ol>
<li>将原始数据从磁盘加到到内存中，修改内存中的数据</li>
<li>生成一条<code>redo log</code>，写入<code>redo log buffer</code>，记录的是数据被修改后的值</li>
<li>当事务<code>commit</code>时，将<code>redo log buffer</code> 中的内存刷新到 <code>redo log file</code>，对 <code>redo log file</code> 采用追加写的方式</li>
<li>定期将内存中修改的数据刷新到磁盘中</li>
</ol>
<h3 id="redo-log-刷盘策略"><a href="#redo-log-刷盘策略" class="headerlink" title="redo log 刷盘策略"></a><code>redo log</code> 刷盘策略</h3><p><code>redo log buffer</code>中的数据，会以一定频率刷入到真正的<code>redo log file</code> 中。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123155107531.png" alt="image-20221123155107531"></p>
<p><code>redo log buffer</code> 刷盘到<code>redo log file</code>过程是刷到文件系统缓存，真正的写入会交给系统自己来决定。<code>InnoDB</code>也可以通过<code>innodb_flush_log_at_trx_commit</code>参数控制<code>commit</code>提交事务时，如何将<code>redo log buffer</code> 中的日志刷新到<code>redo log file</code>中。</p>
<ul>
<li><p>0：表示每次事务提交时不进行刷盘操作。（默认 <code>master thread</code> 每隔 1s 进行一次重做日志的同步）</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123204441117.png" alt="image-20221123204441117"></p>
<p>IO效率高于1，安全性低于2，只将数据写入 <code>redo log buffer</code>，是一个折中方案。</p>
</li>
<li><p>1：表示每次事务提交时都将进行同步，刷盘操作（默认值）</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123204009071.png" alt="image-20221123204009071"></p>
<p>这种情况主要事务提交，就会刷到磁盘，效率虽然差，但是安全性高。</p>
</li>
<li><p>2：表示每次事务提交都只把 <code>redo log buffer</code> 内容写入 <code>page cache</code>，不进行同步，由 <code>os</code> 自己决定什么时候同步到磁盘。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123204221137.png" alt="image-20221123204221137"></p>
<p>只要事务提交成功，<code>redo log buffer</code> 中的文件会写入<code>page cache</code>。</p>
</li>
</ul>
<p>查看和设置配置</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%innodb_flush_log_at_trx_commit%&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_flush_log_at_trx_commit<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><code>InnoDB</code>存储引擎有一个后台线程，每隔<code>1s</code>，就会把<code>redo log buff</code>内容写入<code>page cache</code>，然后调用刷盘操作。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123203800462.png" alt="image-20221123203800462"></p>
<p>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘，因为事务执行过程 <code>redo log</code>记录是会写入 <code>redo log buffer</code> 中，这些 <code>redo log</code> 记录会被后台线程刷盘。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123203948900.png" alt="image-20221123203948900"></p>
<h3 id="写入redo-log-buffer过程"><a href="#写入redo-log-buffer过程" class="headerlink" title="写入redo log buffer过程"></a>写入<code>redo log buffer</code>过程</h3><p><code>MySQL</code>把底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如向某个索引对应的<code>B+</code>树中插入一条记录的过程就是一个<code>mtr</code>。一个所谓的<code>mtr</code>可以包含一组<code>redo log</code>，在进行崩溃时，这一组<code>redo log</code>日志作为一个不可分割的整体。</p>
<p>一个事务可以包含多个语句，每个语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条<code>redo log</code>。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123205341477.png" alt="image-20221123205341477"></p>
<p>向<code>log buffer</code>中写入<code>redo log</code>的过程是顺序的，也就是先往前边的<code>block</code>写，当该<code>block</code>的空闲空间用完之后，再往下一个<code>block</code>写。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123205503134.png" alt="image-20221123205503134"></p>
<p>一个<code>mtr</code>执行过程的<code>redo log</code>作为一个不可分割的组。每个<code>mtr</code>运行过程中产生的日志先暂存到一个地方，当该<code>mtr</code>结束的时候，将过程中产生的一组<code>redo log</code>全部复制到<code>log buffer</code>中。</p>
<p>例如两个交叉的事务日志记录 </p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123205825888.png" alt="image-20221123205825888"></p>
<p><code>redo log block</code>由三个部分组成，日志头、日志体、日志尾，一共是<code>512字节</code>。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123205921819.png" alt="image-20221123205921819"></p>
<h3 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a><code>redo log file</code></h3><p>日志目录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 redo log file 存放位置 </span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_log_group_home_dir&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看 redo log file 个数  </span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_log_files_in_group&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看单个redo log file 大小，总大小就是 innodb_log_file_size * innodb_log_files_in_group，单个默认值 48M ，总最大值512G</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_log_file_size&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h3><p>写入日志文件的顺序是先写0号日志，写满了再往下一个日志文件中写 </p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123210521940.png" alt="image-20221123210521940"></p>
<p>循环使用的方式可能导致后写入的<code>redo</code>日志覆盖前面的<code>redo</code>日志，因此<code>InnoDB</code>提出<code>checkpoint</code>的概念。</p>
<p>整个日志文件组中还有两个重要的属性，分别是 <code>write pos</code>、<code>checkpoint</code></p>
<ul>
<li><code>write pos</code>：当前记录的位置，一边写一边后移</li>
<li><code>checkpoint</code>：当前要擦除的位置，也是往后推移</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123210721287.png" alt="image-20221123210721287"></p>
<p>如果 <code>write pos</code>追上<code>checkpoint</code>，表示日志文件组满了，这时候就不能再写入新的<code>redo log</code>，<code>MySQL</code>需要清空一些记录，把<code>checkpoint</code>推进一下。 </p>
<p><img src="/../../../../../Library/Application%20Support/typora-user-images/image-20221123210845713.png" alt="image-20221123210845713"></p>
<h2 id="MySQL事务日志之undo日志"><a href="#MySQL事务日志之undo日志" class="headerlink" title="MySQL事务日志之undo日志"></a>MySQL事务日志之<code>undo</code>日志</h2><h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a><code>undo</code>日志</h3><p><code>redo log</code> 是事务持久性的保证，<code>undo log</code> 是事务原子性的保证。在事务中更新数据的前置操作其实是要先写入一个<code>undo log</code> 。</p>
<p>事务需要原子性，当事务需要回滚或者服务器突然断电，需要将数据改变到原先的样子，这个过程就是<strong>回滚</strong>。</p>
<p>当做改动（<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>）时（查询不会记录<code>undo log</code>），会将回滚时所需的东西记录下来：</p>
<ul>
<li>插入时，会记录一个基于主键的删除操作</li>
<li>删除时，会记录全部内容的一个插入操作</li>
<li>修改时，会记录一个相反的更新操作</li>
</ul>
<p>MySQL把这些为了回滚而记录的这些内容称之为撤销日志或者回滚日志（<code>undo log</code>）。此外，<code>undo log</code> 会产生 <code>redo log</code>，也就是<code>undo log</code> 的产生会伴随着<code>redo log</code> 的产生，这是因为<code>undo log</code> 也需要持久化。</p>
<h3 id="undo-log-的作用"><a href="#undo-log-的作用" class="headerlink" title="undo log 的作用"></a><code>undo log</code> 的作用</h3><ul>
<li>作用1：回滚数据：<code>undo</code>是逻辑层面，而不是物理层面，当新的数据开辟新的页，<code>undo</code>之后，不会回收新的页。</li>
<li>作用2：<code>MVCC</code>：当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过<code>undo</code>读取之前的行版本信息，以此实现非锁定读取。</li>
</ul>
<h3 id="undo-的存储结构"><a href="#undo-的存储结构" class="headerlink" title="undo 的存储结构"></a><code>undo</code> 的存储结构</h3><p>回滚段与<code>undo</code>页：<code>InnoDB</code>对<code>undo log</code>的管理采用段的方式，每个回滚段记录了<code>1024</code>个<code>undo log segment</code>，在每个<code>undo log segment</code>段中进行<code>undo</code>页的申请</p>
<p>1个<code>undo log segment</code>可支持1个事务，查看回滚段的个数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_undo%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name            <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_directory    <span class="operator">|</span> .<span class="operator">/</span>    <span class="operator">|</span> <span class="comment">-- 日志存放位置</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_log_encrypt  <span class="operator">|</span> OFF   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_log_truncate <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_tablespaces  <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span> <span class="comment">-- undo log segment都存储于共享表空间ibdata中</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="回滚段与事务"><a href="#回滚段与事务" class="headerlink" title="回滚段与事务"></a>回滚段与事务</h3><ol>
<li>每个事务会使用一个回滚段，一个回滚段同一时刻可能会服务于多个事务</li>
<li>一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段</li>
<li>回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前盘区不沟通，事务会在段中请求下一个盘区，如果所有已分配的盘区都用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用</li>
<li>回滚段存于<code>undo</code>表空间中，在数据库中可以存在多个<code>undo</code>表空间，但同一时刻只能使用一个<code>undo</code> 表空间。</li>
<li>当事务提交时，<code>InnoDB</code>存储引擎会做以下两件事情：<ol>
<li>将<code>undo log</code> 放入列表中，以供之后的<code>purge</code>操作</li>
<li>判断<code>undo log</code>所在的页是否可以重用（<code>undo log</code> 在<code>commit</code> 之后，会被放到一个链表中，然后判断<code>undo</code> 页的使用空间是否小于<code>3/4</code>，小于的话则代表当前<code>undo</code> 页可以重用），若可以分配给下个事务使用</li>
</ol>
</li>
</ol>
<h3 id="回滚段中的数据分类"><a href="#回滚段中的数据分类" class="headerlink" title="回滚段中的数据分类"></a>回滚段中的数据分类</h3><ol>
<li>未提交的回滚数据：用于实现读一致性，因此数据不能被其他事务的数据覆盖</li>
<li>已经提交但未过期的回滚数据：关联的事务已经提交，但是仍受到 <code>undo retention</code>参数的保持时间的影响。（可能有其他事务需要通过<code>undo log</code> 来得到记录之前的版本）</li>
<li>事务已经提交并过期的数据：事务已经提交，并且已经超过<code>undo retention</code>参数的保持时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖”事务已经提交并过期的数据“</li>
</ol>
<h3 id="undo的类型"><a href="#undo的类型" class="headerlink" title="undo的类型"></a><code>undo</code>的类型</h3><ul>
<li><code>insert undo log</code> ：insert操作中产生的<code>undo log</code>。这个操作只对事务本身可见，对其他事务不可见（满足事务隔离性要求），因此<code>undo log</code> 可以在事务提交之后直接删除。</li>
<li><code>update undo log</code>：对<code>update</code>和<code>delete</code>操作中产生的<code>undo log</code> 。该<code>undo log</code> 可能需要提供<code>MVCC</code>机制，因此不能在事务提交时就进行删除。提交时放入<code>undo log</code> 链表，等待<code>purge</code> 线程进行最后的删除。</li>
</ul>
<h3 id="undo-log的生命周期"><a href="#undo-log的生命周期" class="headerlink" title="undo log的生命周期"></a><code>undo log</code>的生命周期</h3><p><code>A=1</code>和<code>B=2</code>，将A修改为3，B修改为4</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">记录 A<span class="operator">=</span><span class="number">1</span> 到 undo log;</span><br><span class="line"><span class="keyword">update</span> A<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">记录 A<span class="operator">=</span><span class="number">3</span> 到 redo log;</span><br><span class="line">记录 B<span class="operator">=</span><span class="number">2</span> 到 undo log;</span><br><span class="line"><span class="keyword">update</span> B<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">记录 B<span class="operator">=</span><span class="number">4</span> 到 redo log;</span><br><span class="line">将 redo log 刷新到磁盘;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>1-8步的任意一步系统宕机，事务未提交，该事务不会对磁盘上的数据做任何影响；</li>
<li>如果8-9之间宕机，恢复之后，可以选择回滚，也可以选择继续完成事务提交，因此此时<code>redo log</code> 已经持久化；</li>
<li>9之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据<code>redo log</code> 把数据刷回磁盘。</li>
</ul>
<p>没有<code>redo log</code>和<code>undo log</code>，只有<code>Buffer Pool</code>的流程：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123215755143.png" alt="image-20221123215755143"></p>
<p>有 <code>redo log</code>和 <code>undo log</code>之后</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123215850385.png" alt="image-20221123215850385"></p>
<h3 id="详细生成过程"><a href="#详细生成过程" class="headerlink" title="详细生成过程"></a>详细生成过程</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123220108591.png" alt="image-20221123220108591"></p>
<p>每一条数据的列式存储时，有隐藏的三个字段：</p>
<ul>
<li><code>DB_ROW_ID</code>：如果乜有显示的主键，也没有唯一索引，那么<code>InnoDB</code>会自动添加一个<code>row_id</code>的隐藏列作为主键</li>
<li><code>DB_TRX_ID</code>：每个事务都会有一个<code>id</code>，当记录发生变更时，记录这个事务的<code>ID</code></li>
<li><code>DB_ROLL_PTR</code>：回滚指针，指向<code>undo log</code>的指针</li>
</ul>
<p>当执行<code>INSERT</code>时</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(name) <span class="keyword">values</span>(&quot;tom&quot;);</span><br></pre></td></tr></table></figure>

<p>插入一条数据会生成一条<code>undo log</code>，</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123220420343.png" alt="image-20221123220420343"></p>
<p>执行<code>UPDATE</code>时</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name<span class="operator">=</span>&quot;Sun&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123220458824.png" alt="image-20221123220458824"></p>
<p>将老的记录写入新的 <code>undo log</code>，让回滚指针指向新的 <code>undo log</code></p>
<p>此时更新</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123220621018.png" alt="image-20221123220621018"></p>
<p>实际上是将原先的数据的删除标记打开，然后在后面插入一条新的数据，新的数据回滚指针指向产生的 <code>undo log</code> 。<code>undo log</code>每次都是递增，按照序号依次向前推，就可以找到原始数据。</p>
<h3 id="undo-log-回滚"><a href="#undo-log-回滚" class="headerlink" title="undo log 回滚"></a><code>undo log</code> 回滚</h3><ol>
<li>通过<code>undo no=3</code>的日志把<code>id=2</code>的数据删除</li>
<li>通过<code>undo no=2</code>的日志把<code>id=1</code>的数据的<code>deletemark</code>还原成<code>0</code></li>
<li>通过<code>undo no=1</code>的日志把<code>id=1</code>的数据的<code>name</code>还原成<code>Tom</code></li>
<li>通过<code>undo no=0</code>的日志把<code>id=1</code>的数据删除</li>
</ol>
<h3 id="undo-log删除"><a href="#undo-log删除" class="headerlink" title="undo log删除"></a><code>undo log</code>删除</h3><ul>
<li>针对 <code>insert undo log</code>：事务提交之后直接删除</li>
<li>针对 <code>update undo log</code>：提交之后可能需要提供<code>MVCC</code>机制，提交时放到 <code>undo log</code>链表，等待 <code>purge</code>线程进行最后的删除</li>
</ul>
<p><code>purge</code>线程的作用有两个：</p>
<ol>
<li>清理<code>undo</code>页</li>
<li>清除<code>page</code>里面带有<code>Delete_Bit</code>标识的数据行</li>
</ol>
<h2 id="日志小结"><a href="#日志小结" class="headerlink" title="日志小结"></a>日志小结</h2><p><img src="/../../../../../Library/Application%20Support/typora-user-images/image-20221123210859630.png" alt="image-20221123210859630"></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是多个线程或进程<strong>并发访问</strong>某一资源的机制。为保证数据的<strong>一致性</strong>，需要对并发操作进行控制，因此产生了锁。同时锁机制也为<strong>实现MySQL的各个隔离级别</strong>提供了保证。<strong>锁冲突</strong>也是影响数据库并发访问性能的一个重要因素。</p>
<h3 id="并发事务访问相同记录"><a href="#并发事务访问相同记录" class="headerlink" title="并发事务访问相同记录"></a>并发事务访问相同记录</h3><h4 id="读-读情况"><a href="#读-读情况" class="headerlink" title="读-读情况"></a>读-读情况</h4><p>并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会出现问题，所以允许这种情况。</p>
<h4 id="写-写情况"><a href="#写-写情况" class="headerlink" title="写-写情况"></a>写-写情况</h4><p>并发事务相继对相同的记录做出改动。</p>
<p>这种情况下会发生脏写的问题。在多个未提交事务相继对一条记录做改动时，需要让他们排队执行，这个排队过程其实是通过锁来实现的。这个锁其实是一个内存中的结构。</p>
<p>当这个事务对这个记录做改动时，首先看内存中有没有与这条记录挂链的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123222646322.png" alt="image-20221123222646322"></p>
<ul>
<li><code>trx</code>信息：代表这个锁结构是哪个事务生成的</li>
<li><code>is_waiting</code>：代表当前事务是否在等待</li>
</ul>
<p><code>T1</code>加锁成功之后，继续执行操作。另外一个事务<code>T2</code>获取锁失败，则等待锁结构释放。并且<code>T2</code>对应的锁结构的<code>is_waiting</code>属性为true</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123222905492.png" alt="image-20221123222905492"></p>
<p>当事务<code>T1</code>提交之后，就会把该事务生成的锁结构释放，然后看看还有没有别的事务在等待锁，发现事务<code>T2</code>在等待获取锁，将事务T2对应的锁结构的<code>is_wating</code>改为<code>false</code>，唤醒事务<code>T2</code>对应的线程，此时<code>T2</code>就算获取到锁。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221123223103358.png" alt="image-20221123223103358"></p>
<h4 id="读-写或写-读情况"><a href="#读-写或写-读情况" class="headerlink" title="读-写或写-读情况"></a>读-写或写-读情况</h4><p>即一个事务进行读取操作，另一个事务进行改动操作。这种情况可能发生脏读、不可重复读、幻读的问题。MySQL在<code>REPEATABLE READ</code>隔离级别上已经解决了幻读问题。</p>
<h4 id="并发问题解决方案"><a href="#并发问题解决方案" class="headerlink" title="并发问题解决方案"></a>并发问题解决方案</h4><ul>
<li><p>方案一：读操作利用多版本并发控制（<code>MVCC</code>），写操作进行加锁</p>
<p><code>MVCC</code>，生成一个<code>ReadView</code>，通过<code>ReadView</code>找到符合条件的记录版本（历史版本由<code>undo</code>日志构建），查询语句只能读到在生成<code>ReadView</code>之前已提交事务所做的更改，生成<code>ReadView</code>之前为提交的事务或者之后才开启的新事务所做的更改是看不到的。而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用<code>MVCC</code>时，<strong>读-写操作</strong>并不冲突。</p>
<blockquote>
<p>普通的<code>SELECT</code>语句在<code>READ COMMITED</code>和<code>REPEATABLE READ</code>隔离级别下会使用到<code>MVCC</code>读取记录。</p>
<ul>
<li>在<code>READ COMMITED</code>隔离级别下，一个事务在执行过程中每次执行<code>SELECT</code>操作时都会生成一个<code>ReadView</code>，<code>ReadView</code>的存在保证了事务不可读取到未提交的事务所做的更改，避免了脏读现象；</li>
<li>在<code>REPEATABLE READ</code>隔离级别下，一个事务在执行过程中只有第一次执行<code>SELECT</code>操作才会生成一个<code>ReadView</code>，之后的<code>SELECT</code>操作都复用这个<code>ReadView</code>，避免了不可重复读和幻读的问题；</li>
</ul>
</blockquote>
</li>
<li><p>方案二：读写都加锁</p>
<p>有些业务不允许读取到记录的旧版本，此时就需要加锁。这种情况下，脏读、不可重复读、幻读（幻读加锁会比较麻烦，主要是无法确定新的记录如何加锁）的问题就全部都解决了，事务没有提交时，无法读取或者修改数据。</p>
</li>
</ul>
<p>汇总：</p>
<ul>
<li><p>采用<code>MVCC</code>的话，读-写操作并不冲突，性能更高。</p>
</li>
<li><p>采用加锁方式的话，读-写操作彼此需要排队，影响性能。</p>
</li>
</ul>
<p>一般情况下采用<code>MVCC</code>，业务特殊情况下，采用加锁的方式。</p>
<h3 id="从数据操作的类型划分"><a href="#从数据操作的类型划分" class="headerlink" title="从数据操作的类型划分"></a>从数据操作的类型划分</h3><p>读锁（<code>read lock</code>）、写锁（<code>write lock</code>），也称作共享锁（<code>Shared Lock，S Lock</code>）和排他锁（<code>Exclusive Lock，X Lock</code>）</p>
<ul>
<li>读锁：也称为<strong>共享锁</strong>、英文用<code>S</code>表示。表示同一份数据，多个事务的读操作可以同时进行而不会互相影响，互相不阻塞。</li>
<li>写锁：也称为<strong>排它锁</strong>、英文用<code>X</code>表示。当前写操作没有完成前，它会阻塞其他写锁和读锁，防止其他用户读取正在写入的同一资源。</li>
</ul>
<p>对于<code>InnoDB</code>引擎来说，读锁和写锁可以加在表上，也可以加在行上。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124093251289.png" alt="image-20221124093251289"></p>
<h4 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h4><p>采用加锁方式解决脏读、不可重复读、幻读这些问题时，读取一条记录时需要获取该记录的<code>S锁</code>，其实是不严谨的，有时候需要在读取记录时就获取记录的<code>X锁</code>，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的<code>SELECT</code>语句格式：</p>
<ul>
<li><p>对读取的记录加<code>S锁</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="comment">-- 或者，在 8.0 中 </span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE;</span><br></pre></td></tr></table></figure>

<p>如果当前事务执行该<code>SELECT</code>，会为读取到的记录加<code>S锁</code>，这样允许别的事务继续获取这些记录的<code>S锁</code>（比如别的记录也使用 <code>SELECT ... LOCK IN SHARE LOCK;</code>）。但是不能获取这些记录的X锁，获取<code>X锁</code>的时候会阻塞，直到当前事务提交之后将这些记录的<code>S锁</code>释放掉。</p>
</li>
<li><p>对读取的记录加<code>X锁</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>当前事务执行该语句，那么会对读取到的记录加<code>X锁</code>，这样既不允许别的事务获取这些记录的<code>S锁</code>，也不允许获取这些记录的<code>X锁</code>。如果别的事务想要获取这些记录的<code>S锁</code>或者<code>X锁</code>，那么会阻塞，直到当前事务提交之后将这些记录的<code>X锁</code>释放掉。</p>
</li>
</ul>
<p><code>session A</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">-- 加读锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>

<p><code>session B</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee; <span class="comment">-- 可获取数据 </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee LOCK <span class="keyword">IN</span> SHARE MODE; <span class="comment">-- 可获取数据 </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; <span class="comment">-- 报错</span></span><br><span class="line">ERROR <span class="number">3024</span> (HY000): Query execution was interrupted, maximum statement execution <span class="type">time</span> exceeded</span><br></pre></td></tr></table></figure>

<p>超过了最大执行时间</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@max</span>_execution_time;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@max</span>_execution_time <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="operator">|</span>                 <span class="number">2000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"><span class="comment">-- 在MySQL调优中修改过。全局修改不会对已经连接的会话生效，改成0则是关闭。</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@max</span>_execution_time<span class="operator">=</span><span class="number">60000</span>;</span><br></pre></td></tr></table></figure>

<p><code>session B</code>关闭<code>max_execution_time</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; <span class="comment">-- 进入阻塞状态</span></span><br></pre></td></tr></table></figure>

<p><code>MySQL 8.0</code>特性：</p>
<p>5.7 及之前版本，<code>SELECT ... FOR UPDATE;</code>如果获取不到锁，会一直等待，直到 <code>innodb_lock_wait_timeout</code>超时。</p>
<p>8.0版本中，<code>SELECT ... FOR SHARE;</code>和 <code>SELECT ... FOR UPDATE;</code>可以添加 <code>NOWAIT</code>、<code>SKIP LOCKED</code>语法，跳过等待，或者跳过锁定，立即返回。</p>
<p>如果查询的行已经加锁：</p>
<ul>
<li><code>NOWAIT</code>会立即返回报错</li>
<li><code>SKIP LOCKED</code>也会立即返回，只是返回的结果中不包含被锁定的行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 报错： Statement aborted because lock(s) could not be acquired immediately and NOWAIT is set.</span></span><br><span class="line"><span class="comment">-- navicate 可能将返回优化，在  SELECT * FROM employee FOR UPDATE nowait; 不会返回报错，而是返回空行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> emp_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> nowait;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> emp_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">SKIP</span> LOCKED;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><p>写操作就直接使用<code>X锁</code>。</p>
<ul>
<li><p><code>DELETE</code>：在<code>B+</code>树中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行<code>delete mark</code>操作。</p>
</li>
<li><p><code>UPDATE</code>：分三种情况</p>
<ul>
<li><p>情况1：未修改该记录的键值（主键值），并且被更新的列占用的存储空间在修改前后未发生变化。</p>
<p>在B+树中定位到这条记录的位置，然后获取该记录的<code>X锁</code>，然后在原纪录的位置进行修改操作。</p>
</li>
<li><p>情况2：未修改记录的键值（主键值），并且至少有一个被更新的列占用的存储空间在修改前后发生变化。</p>
<p>在B+树中定位到这条记录的位置，然后获取该记录的<code>X锁</code>，将该记录彻底删除掉（把记录移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在<code>B+树</code>中位置的过程看成是一个获取<code>X锁</code>的锁定读，新插入的记录由<code>INSERT</code>提供的<code>隐式锁</code>进行保护。</p>
</li>
<li><p>情况3：修改了该记录的键值（主键值），则相当于在原记录上做<code>DELETE</code>操作之后再来一次<code>INSERT</code>操作，加锁操作就需要按照<code>DELETE</code>和<code>INSERT</code>的规则进行。</p>
</li>
</ul>
</li>
<li><p><code>INSERT</code>：一般情况下，新插入一条记录的操作并不加锁，这一种称之为<code>隐式锁</code>的结构来保护这条新插入的记录在本事务提交之前不会被其他事务访问。</p>
</li>
</ul>
<h3 id="从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="从数据操作的粒度划分：表级锁、页级锁、行锁"></a>从数据操作的粒度划分：表级锁、页级锁、行锁</h3><p>为了提高数据库的并发，每次锁定的数据范围越少越好，这样就产生了锁粒度（<code>Lokc granularity</code>）的概念。</p>
<p>对一条记录加锁只影响这条记录，这个锁的粒度比较细，这个就是<code>行锁</code>。</p>
<p>一个事务在表级别进行加锁，粒度就比较粗，这个就是<code>表锁</code>。</p>
<p>介于行锁和表锁之间，针对一个页进行操作的加锁，就是<code>页锁</code>。</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>会锁住整张表，不依赖存储引擎，而且表锁是开销最小的策略，由于一次性将整个格表锁定，也可以很好的避免<code>死锁</code>的问题。锁的粒度大带来的负面影响就是出现锁资源争用的概率最高，导致并发率大打折扣。</p>
<h5 id="表级别的S锁、X锁"><a href="#表级别的S锁、X锁" class="headerlink" title="表级别的S锁、X锁"></a>表级别的<code>S锁</code>、<code>X锁</code></h5><p><code>InnoDB</code>提供<code>行锁</code>，因此使用表级<code>S锁</code>、<code>X锁</code>时，一般不会选择<code>InnoDB</code>，但是<code>InnoDB</code>中也会有表级锁存储，例如元数据锁。在一个事务对表进行增删改查时，如果另外一个会话修改表、删除表操作，会出现阻塞，这个过程其实是通过在<code>server</code>层使用的元数据锁（<code>Metadata Locks</code>，简称<code>MDL</code>）。</p>
<p>另外，在一些特殊情况下，也会使用<code>InnoDB</code>的表级别锁，例如崩溃回复过程。在系统变量<code>autocommit=0,innodb_table_locks=1</code>时，手动获取<code>InnoDB</code>提供的表的<code>S锁</code>或者<code>X锁</code>可以这样写。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES t READ; <span class="comment">-- 对表t加表级别S锁</span></span><br><span class="line">LOCK TABLES t WRITE; <span class="comment">-- 对表t加表级别X锁</span></span><br></pre></td></tr></table></figure>

<p>使用<code>MyISAM</code>使用表锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建 MyISAM表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mylock(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY auto_increment,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">)ENGINE<span class="operator">=</span>myisam;</span><br><span class="line"><span class="comment">-- 插入数据 </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mylock(`name`) <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查看表上的锁  </span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">WHERE</span> `<span class="keyword">Table</span>` <span class="operator">=</span> <span class="string">&#x27;mylock&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> Database <span class="operator">|</span> <span class="keyword">Table</span>  <span class="operator">|</span> In_use <span class="operator">|</span> Name_locked <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> mitaka   <span class="operator">|</span> mylock <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------+--------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"><span class="comment">-- 加读锁  </span></span><br><span class="line">LOCK TABLES mylock READ;</span><br><span class="line"><span class="comment">-- 查看锁</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">WHERE</span> `<span class="keyword">Table</span>` <span class="operator">=</span> <span class="string">&#x27;mylock&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> Database <span class="operator">|</span> <span class="keyword">Table</span>  <span class="operator">|</span> In_use <span class="operator">|</span> Name_locked <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> mitaka   <span class="operator">|</span> mylock <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------+--------+-------------+</span></span><br><span class="line"><span class="comment">-- 加写锁</span></span><br><span class="line">LOCK TABLES mylock WRITE;</span><br><span class="line"><span class="comment">-- 查看锁 </span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">WHERE</span> `<span class="keyword">Table</span>` <span class="operator">=</span> <span class="string">&#x27;mylock&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> Database <span class="operator">|</span> <span class="keyword">Table</span>  <span class="operator">|</span> In_use <span class="operator">|</span> Name_locked <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> mitaka   <span class="operator">|</span> mylock <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------+--------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="comment">-- 释放当前会话持有的锁 </span></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<p>对表加<code>读锁</code>之后</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自己读取，可读</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mylock;</span><br><span class="line"><span class="comment">-- 自己写入，报错 &gt; 1099 - Table &#x27;mylock&#x27; was locked with a READ lock and can&#x27;t be updated</span></span><br><span class="line"><span class="keyword">UPDATE</span> mylock <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;b&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 自己操作其他表，报错  &gt; 1100 - Table &#x27;employee&#x27; was not locked with LOCK TABLES</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 他人可读，可读</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mylock;</span><br><span class="line"><span class="comment">-- 他人可写 ,阻塞  </span></span><br><span class="line"><span class="keyword">UPDATE</span> mylock <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;b&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>对表加<code>写锁</code>之后</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 自己读取，可读</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mylock;</span><br><span class="line"><span class="comment">-- 自己写入，可写</span></span><br><span class="line"><span class="keyword">UPDATE</span> mylock <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;a&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 自己操作其他的表，报错 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee LIMIT <span class="number">1</span>;</span><br><span class="line">ERROR <span class="number">1100</span> (HY000): <span class="keyword">Table</span> <span class="string">&#x27;employee&#x27;</span> was <span class="keyword">not</span> locked <span class="keyword">with</span> LOCK TABLES</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 他人可读，阻塞 </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mylock;</span><br><span class="line"><span class="comment">-- 他人可写，阻塞</span></span><br><span class="line"><span class="keyword">UPDATE</span> mylock <span class="keyword">SET</span> `name`<span class="operator">=</span><span class="string">&#x27;b&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p><code>MyISAM</code>在执行查询语句（<code>SELECT</code>）前，会给涉及的所有表加读锁，执行增删改操作前，会给涉及的表加<code>写锁</code>。<code>InnoDB</code>存储引擎是不会为这个表添加表级别的<code>读锁</code>或者<code>写锁</code>的。</p>
<p>MySQL的表锁有两种模式：</p>
<ul>
<li>表共享<code>读锁</code></li>
<li>表独占<code>写锁</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124115442357.png" alt="image-20221124115442357"></p>
<h5 id="意向锁（intention-lock）"><a href="#意向锁（intention-lock）" class="headerlink" title="意向锁（intention lock）"></a>意向锁（<code>intention lock</code>）</h5><p><code>InnoDB</code>只支持<code>多粗粒度锁（multiple granularity locking）</code>，它允许<code>行级锁</code>与<code>表级锁</code>共存，而<strong>意向锁</strong>就是其中的一种<code>表锁</code>。</p>
<ol>
<li>意向锁的存在是为了协调行锁和表锁的的关系，支持多粗粒度（表锁与行锁）的锁并存</li>
<li>意向锁是一种<code>不予行级锁冲突表级锁</code></li>
<li>表明“某个事务正在某些行吃有了锁或该事务准备去持有锁”</li>
</ol>
<p>意向锁分为两种：</p>
<ul>
<li><p><strong>意向共享锁</strong>（<code>intention shared lock，IS</code>）：事务有意向对表中的某些行加<strong>共享锁</strong>（<code>S锁</code>）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>意向排他锁</strong>（<code>intention Exclusi lock，IX</code>）：事务有意向对表中的某些行加<strong>排他锁</strong>（<code>X锁</code>）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>意向锁是由存储引擎自己维护的，用户无法手动操作意向锁，在为数据进行加共享、排他锁之前，<code>InnoDB</code>会先获取<strong>该数据行所在数据表的意向锁。</strong></p>
<p>意向锁要解决的问题：两个事务t1和t2，当t1在某一行上加一个<code>X锁</code>，此时会在这个表上加一个意向锁，当t2在这个表上加<code>X锁</code>时，就会被阻塞。简单来说，就是给更大一级别的空间示意里面是否已经上过锁了。</p>
<p><strong>如果给某一行数据加上了排他锁，数据库会自动给更大一级的空间，比如数据页或者数据表加上意向锁，告诉其他线程这个数据页或者表已经有人上过排它锁了。</strong>这样其他人要获取数据表排他锁时，就无需遍历表，只需要获取这个表的意向排他锁即可。</p>
<ul>
<li>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。</li>
<li>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- t1 中</span></span><br><span class="line"><span class="comment">-- 获取 隔离级别  ，默认是  REPEATABLE-READ </span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="comment">-- 开启事务 </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 在这一行上加排它锁  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> emp_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- t2 中 </span></span><br><span class="line"><span class="comment">-- 加表读锁，阻塞</span></span><br><span class="line">lock tables employee read;</span><br></pre></td></tr></table></figure>

<p>意向共享锁之间是互相兼容的</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124155836072.png" alt="image-20221124155836072"></p>
<p>但是会与普通的<code>排他</code>、<code>共享锁</code>互斥</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/11/image-20221124155941944.png" alt="image-20221124155941944"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- t1 </span></span><br><span class="line"><span class="comment">-- 开启事务 </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 在这一行上加排它锁  </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> emp_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- t2 </span></span><br><span class="line"><span class="comment">-- 开启事务 </span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 在另外一行上加共享锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> emp_id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">FOR</span> SHARE;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+--------+------------+----------+-----------------+---------+----------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> emp_id <span class="operator">|</span> fname <span class="operator">|</span> lname  <span class="operator">|</span> start_date <span class="operator">|</span> end_date <span class="operator">|</span> superior_emp_id <span class="operator">|</span> dept_id <span class="operator">|</span> title          <span class="operator">|</span> assigned_branch_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+--------+------------+----------+-----------------+---------+----------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span> Susan <span class="operator">|</span> Barker <span class="operator">|</span> <span class="number">2002</span><span class="number">-09</span><span class="number">-12</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span>               <span class="number">1</span> <span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span> Vice President <span class="operator">|</span>                  <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+--------+------------+----------+-----------------+---------+----------------+--------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>但是同一行的时候，就不是意向锁兼容，而是行锁之间互斥。</p>
<h5 id="自增锁（AUTO-INC锁）"><a href="#自增锁（AUTO-INC锁）" class="headerlink" title="自增锁（AUTO-INC锁）"></a>自增锁（AUTO-INC锁）</h5><p>给某个列添加自增属性时，在插入语句时不需要为其赋值，系统会自动为它赋上自增的值。</p>
<p>实际上数据插入有三种模式：</p>
<ul>
<li><code>Simple inserts</code>（简单插入）：<code>insert ... values(),()</code>和 <code>replace</code>语句，已经确定要插入的行数。</li>
<li><code>Bulk inserts</code>（批量插入）：<code>insert ... select</code>,<code>replace ... select</code>和<code>load data</code>语句，不确定插入行数，每一行插入时，为<code>AUTO_INCREMENT</code>列分配一个新值。</li>
<li><code>Mixed-mode inserts</code>（混合模式插入）：<code>insert into xx(id,name) values(1,&#39;a&#39;),(5,&#39;b&#39;)</code>指定了部分id的值，另外一种是 <code>insert ... on duplicate key update</code></li>
</ul>
<p><code>AUTO-INC锁</code>是当想含有<code>AUTO_INCREMENT</code>列的表中插入数据时需要获取的一种特殊的表级锁，插入数据时，在表级别加一个<code>AUTO-INC锁</code>，然后为每条待插入记录<code>AUTO_INCREMENT</code>修饰的列分配递增的值，语句执行结束后释放锁。</p>
<p>一个事务在持有<code>AUTO-INC</code>锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。</p>
<p>因此，并发性不高，当向一个有<code>AUTO_INCREMENT</code>关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争。因此<code>InnoDB</code>通过 <code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来提高SQL语句的可伸缩性和性能。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%innodb_autoinc_lock_mode%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>0</code>：代表<code>传统锁定</code>模式，也就是上述的竞争方式。</p>
</li>
<li><p><code>1</code>：代表<code>连续锁定</code>模式，MySQL 8.0之前的默认模式，在简单插入的情况下，获取锁，一次性获取所需个数，然后释放锁，再插入。但是其他两种插入情况下还是与模式0一致。性能有部分提高。</p>
</li>
<li><p><code>2</code>：代表<code>交错锁定</code>模式，MySQL 8.0的默认模式，所有<code>INSERT</code>语句都不会使用表级<code>AUTO-INC</code>锁，并且可以同时执行多个语句。但是当使用基于语句的复制或恢复方案时，从二进制日志重播SQL语句时，这是不安全的。</p>
<p>这个模式下，自动递增值保证所有并发执行的<code>insert</code>语句是唯一且单调递增的，但是不一定连续。</p>
</li>
</ul>
<h5 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h5><p>MySQL 5.5引入<code>meta data lock</code>，简称<code>MDL锁</code>，属于锁范畴。MDL的作用是，保证读写的正确性。比如如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<strong>表结构做变更</strong>，增加一列，那么查询线程拿到的结果就会出问题。</p>
<p><strong>当对一个表做增删改查操作的时候，加MDL读锁；</strong></p>
<p><strong>当对一个表做结构变更曹锁的时候，加MDL写锁；</strong></p>
<p>读锁之间不互斥，因此可以多个线程多一张表同时增删改查。读写锁之间、写锁之间互斥。不需要显式使用，在访问一个表的时候会自动加上。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- t1 加读锁 </span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- t2 加写锁</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">column</span> name <span class="type">varchar</span>(<span class="number">10</span>); <span class="comment">-- 阻塞</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取状态 </span></span><br><span class="line"><span class="keyword">show</span> processlist;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+------------------+--------+---------+-------+---------------------------------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Id <span class="operator">|</span> <span class="keyword">User</span>            <span class="operator">|</span> Host             <span class="operator">|</span> db     <span class="operator">|</span> Command <span class="operator">|</span> <span class="type">Time</span>  <span class="operator">|</span> State                           <span class="operator">|</span> Info                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+------------------+--------+---------+-------+---------------------------------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> root            <span class="operator">|</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">58358</span> <span class="operator">|</span> mitaka <span class="operator">|</span> Query   <span class="operator">|</span>     <span class="number">8</span> <span class="operator">|</span> Waiting <span class="keyword">for</span> <span class="keyword">table</span> metadata lock <span class="operator">|</span> <span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">column</span> name <span class="type">varchar</span>(<span class="number">10</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">17</span> <span class="operator">|</span> root            <span cla