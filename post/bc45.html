<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="S_5aoPFd3QQihrUOLiKdVR0Mj4fj6n6qJojwyjj9cAY">
  <meta name="msvalidate.01" content="9032A67FCF787F07CB04374E59E518A9">
  <meta name="baidu-site-verification" content="code-Onlniop0d6">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.xiaoyeshiyu.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录一些golang学习过程中没有详细关注到，遗漏的知识点。">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang知识补充">
<meta property="og:url" content="https://www.xiaoyeshiyu.com/post/bc45.html">
<meta property="og:site_name" content="小夜时雨">
<meta property="og:description" content="记录一些golang学习过程中没有详细关注到，遗漏的知识点。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/06/image-20220623004223727.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/06/image-20220623004445749.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/07/image-20220701011654889.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/07/image-20220701111024462.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/07/image-20220701141652787.png">
<meta property="article:published_time" content="2022-06-21T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-08T02:05:50.813Z">
<meta property="article:author" content="Mitaka xu">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/06/image-20220623004223727.png">


<link rel="canonical" href="https://www.xiaoyeshiyu.com/post/bc45.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.xiaoyeshiyu.com/post/bc45.html","path":"post/bc45.html","title":"Golang知识补充"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Golang知识补充 | 小夜时雨</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MBVJ11TVHH"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBVJ11TVHH","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?573725610fbc6ff9b42032bd13615370"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="小夜时雨" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小夜时雨</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">君子敬其在己者，而不慕其在天者，是以日进也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rune"><span class="nav-number">1.1.1.</span> <span class="nav-text">rune</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E5%AD%98%E5%82%A8"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">编码与存储</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">匿名变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E8%BE%93%E5%85%A5"><span class="nav-number">1.1.3.</span> <span class="nav-text">格式化输出输入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.</span> <span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">1.3.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.4.</span> <span class="nav-text">条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">1.5.</span> <span class="nav-text">参数传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.6.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87"><span class="nav-number">1.7.</span> <span class="nav-text">切片</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#append"><span class="nav-number">1.7.1.</span> <span class="nav-text">append</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">1.8.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">1.9.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.10.</span> <span class="nav-text">指针类型和值类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new%E5%92%8Cmake"><span class="nav-number">1.11.</span> <span class="nav-text">new和make</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89-type"><span class="nav-number">1.12.</span> <span class="nav-text">类型定义 type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95"><span class="nav-number">1.13.</span> <span class="nav-text">结构体方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.14.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">1.15.</span> <span class="nav-text">包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="nav-number">1.16.</span> <span class="nav-text">依赖管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.17.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.17.1.</span> <span class="nav-text">内部接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">1.18.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer"><span class="nav-number">1.19.</span> <span class="nav-text">defer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.20.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">1.21.</span> <span class="nav-text">测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pprof-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.21.1.</span> <span class="nav-text">pprof 性能优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http%E6%B5%8B%E8%AF%95"><span class="nav-number">1.21.2.</span> <span class="nav-text">http测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%A1%A3"><span class="nav-number">1.22.</span> <span class="nav-text">文档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">2.</span> <span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="nav-number">2.1.</span> <span class="nav-text">逃逸分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Goroutine-%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">3.1.</span> <span class="nav-text">Goroutine 间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSP%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">CSP模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sync-Wait"><span class="nav-number">3.3.</span> <span class="nav-text">sync.Wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select"><span class="nav-number">3.4.</span> <span class="nav-text">select</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">3.4.1.</span> <span class="nav-text">定时器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">3.5.</span> <span class="nav-text">同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">3.5.1.</span> <span class="nav-text">原子操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">3.5.2.</span> <span class="nav-text">锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">3.6.</span> <span class="nav-text">并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87chanel%E5%AE%9E%E7%8E%B0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="nav-number">3.6.1.</span> <span class="nav-text">通过chanel实现广度优先算法</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mitaka xu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mitaka xu</p>
  <div class="site-description" itemprop="description">Golang开发博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaoyeshiyu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/bc45.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Golang知识补充 | 小夜时雨">
      <meta itemprop="description" content="记录一些golang学习过程中没有详细关注到，遗漏的知识点。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Golang知识补充
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-22 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-22T00:00:00+08:00">2022-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-08 10:05:50" itemprop="dateModified" datetime="2023-09-08T10:05:50+08:00">2023-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GoLearningNote/" itemprop="url" rel="index"><span itemprop="name">Go学习笔记</span></a>
        </span>
    </span>

  
    <span id="/post/bc45.html" class="post-meta-item leancloud_visitors" data-flag-title="Golang知识补充" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

            <div class="post-description">记录一些golang学习过程中没有详细关注到，遗漏的知识点。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>记录一些golang学习过程中没有详细关注到，遗漏的知识点。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>内建变量</p>
<p><code>bool</code>：内存占用1个字节</p>
<p><code>string</code>：用的比较多，内存占用2个字节，string数据结构是一个指针和int类型长度，指针是uintptr类型的8位int，长度也是int类型，一共16位，2个字节</p>
<p><code>(u)int,(u)int8,(u)int16,(u)int32,(u)int64</code> 整形,占用内存就是后面指定的位数</p>
<p><code>uintptr</code> 指针，int类型，</p>
<p><code>byte：uint8</code>的别名，占1个字节</p>
<p><code>rune</code>：字符型（类似char，是int32的别名 ），占4个字节</p>
<p><code>Float32,float64</code> 浮点，占用内存是后面指定的位数</p>
<p><code>complex64,complex128</code> 复数，占用内存是后面指定的位数 </p>
<h4 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h4><p><code>golang</code>支持 <code>Unicode</code>的字符集，通过 <code>UTF-8</code>规则存储，一个英文占1字节，中文占3字节。字符称为<code>rune</code>，<code>int32</code>的别称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;hello世界!&quot;</span><br><span class="line">fmt.Println(len(s)) // 获得字节长度 12，汉字6个字符</span><br><span class="line">for i, j := range []byte(s) &#123;</span><br><span class="line">	fmt.Printf(&quot;(%d:%x)&quot;, i, j) // (0:68)(1:65)(2:6c)(3:6c)(4:6f)(5:e4)(6:b8)(7:96)(8:e7)(9:95)(10:8c)(11:21) // unicode编码，直接使用unicode编码转义，会出现错乱字符</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">for i, j := range s &#123;</span><br><span class="line">	fmt.Printf(&quot;(%d:%x)&quot;, i, j) // (0:68)(1:65)(2:6c)(3:6c)(4:6f)(5:4e16)(8:754c)(11:21) // UTF8编码，一个汉字占三个字节，因此无法获取索引为 6 7 9 10 </span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">for i, j := range []rune(s) &#123;</span><br><span class="line">	fmt.Printf(&quot;(%d:%c)&quot;, i, j) // (0:h)(1:e)(2:l)(3:l)(4:o)(5:世)(6:界)(7:!) // 类型转换，每一个rune占4个字节，重新分配内存	</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(utf8.RuneCountInString(s)) // 8 获得字符数</span><br></pre></td></tr></table></figure>

<h5 id="编码与存储"><a href="#编码与存储" class="headerlink" title="编码与存储"></a>编码与存储</h5><p>例如一个字符 “中”</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	x := <span class="string">&quot;中&quot;</span></span><br><span class="line"><span class="comment">// Unicode编码</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;中 Unicode: %x\n&quot;</span>, []<span class="type">rune</span>(x)[<span class="number">0</span>]) <span class="comment">// 中 Unicode: 4e2d</span></span><br><span class="line"><span class="comment">// UTF-8存储</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;中 UTF-8: %x\n&quot;</span>, x)							<span class="comment">// 中 UTF-8: e4b8ad</span></span><br></pre></td></tr></table></figure>

<h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_,a := 10,20 // 匿名变量不占用内存空间，不会分配内存。匿名变量和匿名变量之间不会因为多次声明而无法使用</span><br></pre></td></tr></table></figure>

<h4 id="格式化输出输入"><a href="#格式化输出输入" class="headerlink" title="格式化输出输入"></a>格式化输出输入</h4><table>
<thead>
<tr>
<th>格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%%</td>
<td>返回%，一个%字面量</td>
</tr>
<tr>
<td>%b</td>
<td>整数，返回一个整数的二进制</td>
</tr>
<tr>
<td>%c</td>
<td>整数，返回字符集对应整数序号的字符</td>
</tr>
<tr>
<td>%d</td>
<td>整数，返回一个整数的十进制</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数或者复数，返回一个浮点数或者复数</td>
</tr>
<tr>
<td>%o</td>
<td>整数，返回一个整数的八进制</td>
</tr>
<tr>
<td>%p</td>
<td>指针变量，返回一个十六进制的地址</td>
</tr>
<tr>
<td>%q</td>
<td>整形，返回单引号围绕的字符字面值，由Go语法安全地转义，</td>
</tr>
<tr>
<td>%s</td>
<td>字符串或者字节切片，返回一个字符串</td>
</tr>
<tr>
<td>%t</td>
<td>bool，返回true或者false</td>
</tr>
<tr>
<td>%T</td>
<td>变量，返回这个变量的类型</td>
</tr>
<tr>
<td>%v</td>
<td>变量，返回这个变量的值，配合%+v %#v可以详细打印字段名</td>
</tr>
<tr>
<td>%x</td>
<td>整形或者[]byte，返回以a-f小写表示的十六进制</td>
</tr>
<tr>
<td>%X</td>
<td>整形或者[]byte，返回以A-F大写表示的十六进制</td>
</tr>
</tbody></table>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b := 3, 4</span><br><span class="line">var c int</span><br><span class="line">c = int(math.Sqrt(float64(a*a + b*b))) // float 转int，如果浮点计算出4.999转int可能答案是4</span><br></pre></td></tr></table></figure>

<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量的类型只能是整形、字符串、bool，常量定义之后，可以不使用。</p>
<p>常量分无类型常量和有类型常量，无类型常量在使用的时候，可作为各种类型使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = 1</span><br><span class="line">const b int64 = a</span><br><span class="line">var c float64 = a</span><br><span class="line">fmt.Println(b)</span><br><span class="line">fmt.Println(c)</span><br></pre></td></tr></table></figure>

<p>枚举类型</p>
<p><code>iota</code>：当<code>iota</code>第一次在<code>const</code>中出现的时候，是0，在<code>const</code>块后续中，<code>iota</code>自增；当后续常量复制没有指定，则默认与上面一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">	a = iota      // iota = 0</span><br><span class="line">	_ // _ = iota // iota = 1</span><br><span class="line">	b // b = iota // iota = 2</span><br><span class="line">	c</span><br><span class="line">	d</span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d)</span><br><span class="line">// b, kb, mb, gb, tb, pb</span><br><span class="line">const (</span><br><span class="line">	byte = 1 &lt;&lt; (10 * iota)</span><br><span class="line">	kb</span><br><span class="line">	mb</span><br><span class="line">	bg</span><br><span class="line">	tb</span><br><span class="line">	pb</span><br><span class="line">)</span><br><span class="line">fmt.Println(byte, kb, mb, bg, tb, pb)</span><br></pre></td></tr></table></figure>

<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if a, err := newerr(); err != nil &#123; // if条件中赋值，作用域是这个条件语句中</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) // 出错</span><br></pre></td></tr></table></figure>

<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p><code>Golang</code>中的传递都是值传递，没有引用传递。即使是传递的指针变量，也是拷贝一个指针变量，只是这个指针变量指向的内存地址是同一个，所以函数内部修改会作用到相同的内存地址。</p>
<p>值类型：<code>int</code>、<code>float</code>、<code>bool</code>、<code>string</code>、数组、结构体</p>
<p>引用类型：指针、<code>slice</code>切片、<code>map</code>、<code>channel</code>、<code>interface</code>、函数</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组关注的比较少，相比切片而言。</p>
<p>数组特点是，数组的长度是固定的不可改变，数组的个数不可以是变量，可以是常量。数组中每个元素的地址是连续的。<code>[5]int</code>和<code>[10]int</code>是不同类型，因此这两个数组不能相互比较；</p>
<p>数组是值传递，被函数调用的时候，会拷贝数组到函数中；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func newerr(a [2]int) &#123; // 值传递，传入的是拷贝后的一个数组</span><br><span class="line">	a[0] = 100</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line">// 当然，如果传入的是一个指针，那么函数中的改动，会影响变量本身。go中一般不使用数组。</span><br><span class="line">func main() &#123;</span><br><span class="line">	a := [2]int&#123;1, 2&#125;</span><br><span class="line">	newerr(a)</span><br><span class="line">	fmt.Println(a) // [1 2] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组的地址为首元素地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := [3]int&#123;1, 2, 3&#125;</span><br><span class="line">fmt.Printf(&quot;%p\n&quot;, &amp;a)			// 0x1400012e000</span><br><span class="line">fmt.Printf(&quot;%p\n&quot;, &amp;a[0])		// 0x1400012e000</span><br></pre></td></tr></table></figure>

<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>本身是指针类型变量，由一个指向底层切片的指针、长度、容量组成。</p>
<p>切片的类型定义，在<code>runtime</code>包的<code>slice.go</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type slice struct &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	len   int</span><br><span class="line">	cap   int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以由数组的位置值定义，左开右闭</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := []int&#123;0, 1, 2, 3, 4, 5, 6&#125;</span><br><span class="line">fmt.Println(a[2:7]) // 这里使用7，代表到6，其实7是超过了长度的，a[7]会panic //panic: runtime error: index out of range [7] with length 7</span><br></pre></td></tr></table></figure>

<p>切片对数组的引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func newerr(a []int) &#123;</span><br><span class="line">	a[0] = 100</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	a := [7]int&#123;0, 1, 2, 3, 4, 5, 6&#125;</span><br><span class="line">	b := a[3:5]</span><br><span class="line">	newerr(b)</span><br><span class="line">	c := a[:]</span><br><span class="line">	newerr(c)</span><br><span class="line">	fmt.Println(a) // [100 1 2 100 4 5 6]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片对数组的引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">b := a[2:6]</span><br><span class="line">c := b[3:5]</span><br><span class="line">fmt.Println(c) // [5 6] 通过下标可以获取到底层灰色部分的数组</span><br><span class="line">fmt.Println(c[2]) // panic: runtime error: index out of range [2] with length 2 直接通过下标访问不到底层数组</span><br><span class="line">fmt.Println(len(c)) // 2</span><br><span class="line">fmt.Println(cap(c)) // 3</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/06/image-20220623004223727.png" alt="image-20220623004223727"></p>
<p>切片和数组的关系</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/06/image-20220623004445749.png" alt="image-20220623004445749"></p>
<p>slice可以向后扩展，不能向前扩展。</p>
<p>切片对底层数组的引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := [3]int&#123;1&#125;</span><br><span class="line">s2 := s1[1:]</span><br><span class="line">fmt.Printf(&quot;%p\n%p\n&quot;, &amp;s1, &amp;s1[0]) // 0x1400012e000 0x1400012e000</span><br><span class="line">fmt.Printf(&quot;%p\n%p\n%p\n&quot;, s2, &amp;s2, &amp;s2[0]) // 0x1400012e008 0x1400011e018 0x1400012e008</span><br></pre></td></tr></table></figure>

<p>通过索引访问切片中的内容需要注意，范围可以访问到cap，但是索引只能访问len</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">	fmt.Println(s[<span class="number">0</span>])			<span class="comment">// panic: runtime error: index out of range [0] with length 0</span></span><br><span class="line">	fmt.Println(s[<span class="number">5</span>:<span class="number">8</span>])		<span class="comment">// [0,0,0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p><code>append</code>只能接受切片，而且是值传递（拷贝指针），需要有变量接收返回值。</p>
<p>当切片没有扩容，则指向的内存是同一块，因此改动切片中的内容会同步修改原数组，当切片发生扩容，则需要开辟新的内存空间用于存储新的切片，此时改动切片的内容，原数组不会变化。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">b := a[2:6] // [2,3,4,5]</span><br><span class="line">c := b[3:5] // [5,6]</span><br><span class="line">fmt.Println(c) // [5,6]</span><br><span class="line">fmt.Println(len(c)) // 2</span><br><span class="line">fmt.Println(cap(c)) // 3 这里的3是因为底层的数组</span><br><span class="line">d := append(c, 10) // [5,6,10]</span><br><span class="line">// 从这里开始，d到d1，由于cap发生变化，底层的数组就不是同一个，d1底层的数组会重新拷贝一个出来</span><br><span class="line">d1 := append(d, 10) // [5,6,10,10] </span><br><span class="line">d[0] = 300 // 此处改变的是a数组 [300 6 10]</span><br><span class="line">d1[0] = 200 // 数组已经发生拷贝，原先的a数组不会发生变化，新的数组 [200，6，10，10]</span><br><span class="line">d2 := append(d1, 10) // [200,6,10,10,10] // 由于值传递，必须接受append的返回值</span><br><span class="line">d3 := append(d2, 10) // [200,6,10,10,10,10]</span><br><span class="line">d4 := append(d3, 10) // [200,6,10,10,10,10,10] </span><br><span class="line">fmt.Println(d, d1, d2, d3) // </span><br><span class="line">fmt.Println(len(d4)) // 7 ，有元素的个数</span><br><span class="line">fmt.Println(cap(d4)) // 12 ，从6到12，翻倍扩容cap</span><br><span class="line">fmt.Println(a) //  [0 1 2 3 4 300 6 10] // 原先的a是300，后续改变的200改的不是这个a // 另外，如果这里没有使用a，a会被gc</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func ChangeSlice(slice []int) &#123; // 引用传递，函数内部改变，引起变量本身改变</span><br><span class="line">	slice[0] = 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func AppendSlice(slice []int) &#123; // 引用传递，但是函数内部赋值不会改变指向的底层数组</span><br><span class="line">	fmt.Printf(&quot;slice:%v, len: %d,cap: %d\n&quot;, slice, len(slice), cap(slice))</span><br><span class="line">	slice = append(slice, 100) // append会扩容切片，并且是值传递，首先拷贝slice的值，扩容之后有一个新的值,接受到的slice是一个新的slice，新的slice被赋值不会改变入参</span><br><span class="line">	fmt.Printf(&quot;newslice:%v, len: %d,cap: %d\n&quot;, slice, len(slice), cap(slice))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func AppendSlicePtr(slice *[]int) &#123;</span><br><span class="line">	fmt.Printf(&quot;slice:%v, len: %d,cap: %d\n&quot;, *slice, len(*slice), cap(*slice))</span><br><span class="line">	*slice = append(*slice, 100) // append扩容切片，拷贝的是地址，赋值的也是地址，因此底层数据会改变</span><br><span class="line">	fmt.Printf(&quot;newslice:%v, len: %d,cap: %d\n&quot;, *slice, len(*slice), cap(*slice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数内部append需要注意，在函数内部进行append的时候，修改了slice的len，但是这个修改不影响函数外部，因此外部的slice的len还是1</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	arr = <span class="built_in">append</span>(arr, <span class="number">666</span>) <span class="comment">// 函数内容发生append，但是没有扩容，但是len变成2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">	arr = <span class="built_in">append</span>(arr, <span class="number">123</span>)</span><br><span class="line">	changeSlice(arr) <span class="comment">// 函数是copy传递，函数内部len变成2，不影响函数外部，因此只会打印1个</span></span><br><span class="line">	fmt.Println(arr) <span class="comment">// output ??</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reslut: </span></span><br><span class="line"><span class="comment">// [123]</span></span><br></pre></td></tr></table></figure>

<p>切片声明和初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	s1 := make([]int, 1) 	// 初始化，完成内存分配，0x1400018c008</span><br><span class="line">	var s1 []int					// 只有声明，没有分配内存，0x0</span><br><span class="line">	fmt.Printf(&quot;%p\n&quot;, s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片扩容时先判断容量是否满足，不满足则容量翻倍（容量增加算法不是一直翻倍，golang版本更迭，append的源码有变更 ），然后将数据拷贝到新的切片中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := make([]int, 0)</span><br><span class="line">	for i := 0; i &lt; 2048; i++ &#123;</span><br><span class="line">		s1 = append(s1, i)</span><br><span class="line">		fmt.Printf(&quot;%p,%d %d\n&quot;, s1, len(s1), cap(s1))</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0x1400012c008,1 1</span><br><span class="line">0x1400012c020,2 2</span><br><span class="line">0x14000130020,3 4</span><br><span class="line">0x14000130020,4 4</span><br><span class="line">0x14000132000,5 8</span><br><span class="line">0x1400013e000,512 512  </span><br><span class="line">0x14000142000,513 848 // 512 -&gt; 848   1.65倍</span><br><span class="line">0x14000142000,848 848</span><br><span class="line">0x14000150000,849 1280 // 848 -&gt; 1280 1.5倍</span><br><span class="line">0x14000150000,1280 1280</span><br><span class="line">0x1400015e000,1281 1792 // 1280 -&gt; 1792 1.4倍</span><br><span class="line">0x1400015e000,1792 1792</span><br><span class="line">0x14000172000,1793 2560 // 1792 -&gt; 2560 1.4倍</span><br></pre></td></tr></table></figure>

<p>copy</p>
<p>copy可以实现深层拷贝，拷贝底层数组，然后赋值。copy的过程不发生内存拷贝，也就是不会改变数组的len和cap</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s1 := [...]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">s2 := s1[4:] //5  6  7  8  9        size 5 cap 5</span><br><span class="line">s3 := s1[6:] //7  8  9              size 3 cap 3</span><br><span class="line">fmt.Println(s2, s3)</span><br><span class="line">copy(s2, s3) // 1 2 3 4 7 8 9 8 9</span><br><span class="line">//copy(s3, s2)</span><br><span class="line">fmt.Println(s2, s3) // 7 8 9 8 9   // 9 8 9ca</span><br><span class="line"></span><br><span class="line">s1 := [...]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">s2 := s1[4:] //5  6  7  8  9        size 5 cap 5</span><br><span class="line">s3 := s1[6:] //7  8  9              size 3 cap ®ca3</span><br><span class="line">fmt.Println(s2, s3)</span><br><span class="line">//copy(s2, s3)</span><br><span class="line">copy(s3, s2)        // 1 2 3 4 5 6 5 6 7</span><br><span class="line">fmt.Println(s2, s3) // 5 6 5 6 7   // 5 6 7</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>源码在runtime&#x2F;map.go中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// A header for a Go map.</span><br><span class="line">type hmap struct &#123;</span><br><span class="line">	// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.</span><br><span class="line">	// Make sure this stays in sync with the compiler&#x27;s definition.</span><br><span class="line">	count     int // # live cells == size of map.  Must be first (used by len() builtin)</span><br><span class="line">	flags     uint8</span><br><span class="line">	B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span><br><span class="line">	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details</span><br><span class="line">	hash0     uint32 // hash seed</span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.</span><br><span class="line">	oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing</span><br><span class="line">	nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)</span><br><span class="line"></span><br><span class="line">	extra *mapextra // optional fields</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// mapextra holds fields that are not present on all maps.</span><br><span class="line">type mapextra struct &#123;</span><br><span class="line">	// If both key and elem do not contain pointers and are inline, then we mark bucket</span><br><span class="line">	// type as containing no pointers. This avoids scanning such maps.</span><br><span class="line">	// However, bmap.overflow is a pointer. In order to keep overflow buckets</span><br><span class="line">	// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.</span><br><span class="line">	// overflow and oldoverflow are only used if key and elem do not contain pointers.</span><br><span class="line">	// overflow contains overflow buckets for hmap.buckets.</span><br><span class="line">	// oldoverflow contains overflow buckets for hmap.oldbuckets.</span><br><span class="line">	// The indirection allows to store a pointer to the slice in hiter.</span><br><span class="line">	overflow    *[]*bmap</span><br><span class="line">	oldoverflow *[]*bmap</span><br><span class="line"></span><br><span class="line">	// nextOverflow holds a pointer to a free overflow bucket.</span><br><span class="line">	nextOverflow *bmap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// A bucket for a Go map.</span><br><span class="line">type bmap struct &#123;</span><br><span class="line">	// tophash generally contains the top byte of the hash value</span><br><span class="line">	// for each key in this bucket. If tophash[0] &lt; minTopHash,</span><br><span class="line">	// tophash[0] is a bucket evacuation state instead.</span><br><span class="line">	tophash [bucketCnt]uint8</span><br><span class="line">	// Followed by bucketCnt keys and then bucketCnt elems.</span><br><span class="line">	// NOTE: packing all the keys together and then all the elems together makes the</span><br><span class="line">	// code a bit more complicated than alternating key/elem/key/elem/... but it allows</span><br><span class="line">	// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span><br><span class="line">	// Followed by an overflow pointer.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kv</code>存储，无序，如果<code>k</code>不在，返回的<code>value</code>是对应类型的初始值。</p>
<p>两个map不能比较是否相等；map的key或者value都不能取地址。</p>
<p><code>map</code>使用哈希表，必须可以比较相等或者不想等。除了<code>slice map function</code>之外的内建类型都可以做<code>key</code>。（<code>slice</code>和<code>map</code>都是引用类型，无法相互比较）（<code>strcut</code>可以比较的话，也可以做<code>key</code>，因此作为<code>key</code>的<code>struct</code>内不包含上面三个类型即可）。</p>
<p>另：float类型作为key，编译器不会报错，但是由于精确度问题，使用浮点型作为map的key，可能会出现数据访问不准确。</p>
<p>声明和初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">m := map[struct &#123;</span><br><span class="line">	A int</span><br><span class="line">	B string</span><br><span class="line">	C IA       // key可以是一个带方法的interface</span><br><span class="line">	//D func() int  // key 不可以是函数</span><br><span class="line">	E interface&#123;&#125; 	// key也可以是一个不带方法的空interface</span><br><span class="line">	//F []int			// key不可以是切片</span><br><span class="line">&#125;]int&#123;&#125;</span><br><span class="line">fmt.Printf(&quot;%p\n&quot;, m)											// 0x14000106180</span><br><span class="line">fmt.Printf(&quot;m ==  nil %t\n&quot;, m == nil)  	// false</span><br><span class="line">var m1 map[int]int</span><br><span class="line">fmt.Printf(&quot;%p\n&quot;, m1)										// 0x0</span><br><span class="line">fmt.Printf(&quot;m1 ==  nil %t\n&quot;, m1 == nil)	// true</span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针包含两个部分，类型和地址。指针的默认值是nil 。</p>
<p>nil和nil不能判断是否相等，编译器不会报错，运行和编译的时候会报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(nil == nil)</span><br><span class="line">// invalid operation: nil == nil (operator == not defined on untyped nil)</span><br></pre></td></tr></table></figure>

<p>不同类型的 nil 指针是一样的，都是0x0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a *int</span><br><span class="line">var b []int</span><br><span class="line">fmt.Printf(&quot;%p %p\n&quot;, a, b) // 0x0 0x0</span><br></pre></td></tr></table></figure>

<p>不同类型的 nil指针，不能判断是否相等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a *int</span><br><span class="line">var b []int</span><br><span class="line">fmt.Println(a == b) // invalid operation: a == b (mismatched types *int and []int)</span><br></pre></td></tr></table></figure>

<p>即使是同类型指针，如果类型不能判断是否相等，则两个 nil 指针也不能判断是否相等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a *string</span><br><span class="line">var c *string</span><br><span class="line">fmt.Println(a == c)  // true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a []int</span><br><span class="line">var c []int</span><br><span class="line">fmt.Println(a == c) // invalid operation: a == c (slice can only be compared to nil)</span><br></pre></td></tr></table></figure>

<p>nil 是 map slice pointer channel func interface的零值，不同类型的零值占用的内存不一致。</p>
<p>各种数据类型初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a int</span><br><span class="line">fmt.Printf(&quot;%p %v\n&quot;, &amp;a, a)					// 0x1400012c008 0</span><br><span class="line">var b string</span><br><span class="line">fmt.Printf(&quot;%p %v\n&quot;, &amp;b, b)					// 0x14000110210</span><br><span class="line">var c [1]int</span><br><span class="line">fmt.Printf(&quot;%p %v\n&quot;, &amp;c, c)					// 0x1400012c020 [0]</span><br><span class="line">var d []int</span><br><span class="line">fmt.Printf(&quot;%p %v %p\n&quot;, &amp;d, d, d)		// 0x1400011e018 [] 0x0</span><br><span class="line">var e map[int]int</span><br><span class="line">fmt.Printf(&quot;%p %v %p\n&quot;, &amp;e, e, e)		// 0x14000126020 map[] 0x0</span><br><span class="line">var f chan int</span><br><span class="line">fmt.Printf(&quot;%p %v %p\n&quot;, &amp;f, f, f)		// 0x14000126028 &lt;nil&gt; 0x0</span><br><span class="line">var g func()</span><br><span class="line">fmt.Printf(&quot;%p %v %p\n&quot;, &amp;g, f, g)		// 0x14000126030 &lt;nil&gt; 0x0</span><br></pre></td></tr></table></figure>

<h3 id="指针类型和值类型"><a href="#指针类型和值类型" class="headerlink" title="指针类型和值类型"></a>指针类型和值类型</h3><p>指针类型和值类型有时候可以相互转换，但是需要注意。值类型一直都可以转换为引用类型，值是零值在编译器下可以寻址。但是引用类型只有在可以寻址的情况下才可以转换成值类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	Addresses []*Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := User&#123;</span><br><span class="line">		name:      <span class="string">&quot;test&quot;</span>,</span><br><span class="line">		Addresses: <span class="built_in">make</span>([]*Address,<span class="number">10</span>), <span class="comment">// 即使这里初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	u.Addresses[<span class="number">0</span>].s = <span class="string">&quot;local&quot;</span>  <span class="comment">// 访问u.Addresses[0]是一个nil，无法访问到u.Addresses[0].s，是一个空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要改成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	Addresses []Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := User&#123;</span><br><span class="line">		name:      <span class="string">&quot;test&quot;</span>,</span><br><span class="line">		Addresses: <span class="built_in">make</span>([]Address,<span class="number">10</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	u.Addresses[<span class="number">0</span>].s = <span class="string">&quot;local&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	Addresses []*Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := User&#123;</span><br><span class="line">		name:      <span class="string">&quot;test&quot;</span>,</span><br><span class="line">		Addresses: <span class="built_in">make</span>([]*Address,<span class="number">0</span>,<span class="number">10</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	address :=  Address&#123;s: <span class="string">&quot;local&quot;</span>&#125;</span><br><span class="line">	u.Addresses = <span class="built_in">append</span>(u.Addresses,&amp;address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h3><p>new：为一个类型T分配空间，并且初始化为T的零值，返回的是新值的地址，传递给new函数的是一个类型，而不是值。</p>
<p>make：返回初始化之后T类型的值，而不是零值，也不是地址。只能用于slice map channel</p>
<p>例如通过new初始化一个slice，返回的是指向这个slice的指针，而slice本身是nil。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n1 := new([]int)</span><br><span class="line">fmt.Printf(&quot;%v %p\n&quot;, *n1, *n1) // [] 0x0</span><br><span class="line">fmt.Println(*n1 == nil)					// true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1 := make([]int, 0)</span><br><span class="line">fmt.Printf(&quot;%v %p\n&quot;, m1, m1) // [] 0x1023d2fe8</span><br><span class="line">fmt.Println(m1 == nil)				// false</span><br></pre></td></tr></table></figure>

<p>注意：作为函数的返回值，返回值定义了类型，并没有分配地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func returnSlice() (s []int) &#123;</span><br><span class="line">	fmt.Printf(&quot;%v %p\n&quot;, s, s)  // [] 0x0</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型定义-type"><a href="#类型定义-type" class="headerlink" title="类型定义 type"></a>类型定义 type</h3><p>类型定义有以下几种：</p>
<ul>
<li>type 类型名 类型</li>
<li>type 类型名 &#x3D; 类型名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type S struct &#123;</span><br><span class="line">	a int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type T1 = S			// 定义别名，别名和原类型一致，别名可以调用原类型方法</span><br><span class="line">type T2 S				// 重新定义一个新的类型</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var s1 = S&#123;a: 1&#125;</span><br><span class="line">	var s2 = T1&#123;a: 1&#125;</span><br><span class="line">	var s3 = T2&#123;a: 2&#125;</span><br><span class="line">	fmt.Println(s1 == s2)</span><br><span class="line">	fmt.Println(s1 == s3)	// 无效运算: s1 == s3(类型 S 和 T2 不匹配)</span><br><span class="line">	fmt.Println(s2 == s3)	// 无效运算: s2 == s3(类型 T1 和 T2 不匹配)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="结构体方法"><a href="#结构体方法" class="headerlink" title="结构体方法"></a>结构体方法</h3><p>结构体方法需要将结构体变量作为参数，有两种方式，一种是值传递，一种是指针传递。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u *User) changeAge(age int) &#123;</span><br><span class="line">	fmt.Printf(&quot;ptr: %p\n&quot;, u)</span><br><span class="line">	u.age = age</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u User) changeName(name string) &#123;</span><br><span class="line">	fmt.Printf(&quot;value: %p\n&quot;, &amp;u)</span><br><span class="line">	u.name = name</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在声明变量的时候，无论变量是值类型还是指针类型，在调用方法的时候，会按照方法定义时候做出改变。</p>
<ul>
<li>值类型，在值传递，会拷贝一份变量，传递的是拷贝后的值。</li>
<li>值类型，在引用传递，会使用变量的地址，传递的是变量的地址。</li>
<li>指针类型，在值传递，会拷贝一份指针类型指向的变量，传递的是拷贝后的变量。</li>
<li>指针类型，在引用传递，会使用指针类型的值，传递的是指针类型的值。</li>
</ul>
<p>需要注意的是，如果如果是声明一个类型变量之后隐式调用，即无法准确获取到变量的指针，此时无法使用引用传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">User&#123;</span><br><span class="line">	name: &quot;&quot;,</span><br><span class="line">	age:  0,</span><br><span class="line">&#125;.changeName(&quot;abc&quot;)</span><br><span class="line"></span><br><span class="line">User&#123;</span><br><span class="line">	name: &quot;&quot;,</span><br><span class="line">	age:  1,</span><br><span class="line">&#125;.changeAge(18)  // cannot call pointer method changeAge on User</span><br></pre></td></tr></table></figure>

<p>另外，虽然值类型也可以使用引用传递，但是在接口定义的时候，会严格验证接口内方法实现，接口内方法定义传参是值类型，则实现函数必须是传值，接口内方法定义传参是引用类型，则实现函数必须是传指针。</p>
<p>另外：</p>
<ul>
<li><p>结构体只能判断&#x3D;&#x3D; !&#x3D; ，不能比较大小</p>
</li>
<li><p>判断&#x3D;&#x3D;、!&#x3D;的前提是两个结构体是同一个类型，不同的类型无法判断，即使结构体里面的成员一样也无法判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u := User&#123;</span><br><span class="line">	name: &quot;&quot;,</span><br><span class="line">	age:  0,</span><br><span class="line">&#125;</span><br><span class="line">u1 := User1&#123;</span><br><span class="line">	name: &quot;&quot;,</span><br><span class="line">	age:  0,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(u == u1)  // invalid operation: u == u1 (mismatched types User and User1)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>Golang仅支持封装，不支持继承和多态。通过结构体的方法实现封装。</p>
<p>构造函数（工厂方法）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Node struct &#123;</span><br><span class="line">	value int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewNode(va int) *Node &#123;</span><br><span class="line">	return &amp;Node&#123;value: va&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，构造函数内部创建一个局部变量，返回这个局部变量的指针。当这个局部变量会被其他函数引用，则会被编译器分配到堆上。</p>
<p>值传递，传递指针或者拷贝的变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func (n Node) setValue(va int) &#123; // golang 都是值传递，传入的是拷贝的node</span><br><span class="line">	n.value = va</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (n *Node) setValueNew(va int) &#123; // 拷贝的是node的指针，改动指针指向的地址</span><br><span class="line">	n.value = va</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	node := NewNode(1)</span><br><span class="line">	node.setValue(10)				</span><br><span class="line">	node.print() 						// 1</span><br><span class="line">	node.setValueNew(100)   // 不需要使用&amp;node来调用setValueNew方法，golang自动传入指针</span><br><span class="line">	node.print() 						// 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node1 := Node&#123;2&#125;    // node1是指针类型</span><br><span class="line">node1.setValue(20)  // 调用时候，会获取到node1的值，拷贝值，将拷贝后的值作为参数</span><br><span class="line">node1.print() 			// 2</span><br><span class="line">node1.setValueNew(200) </span><br><span class="line">node1.print() 			// 200 </span><br></pre></td></tr></table></figure>

<p>nil指针也可以调用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var node2 *Node</span><br><span class="line">node2.print() // 这里会将node2的值拷贝进去，但是由于node2是nil指针，无法访问对象对应的值，因此会报错：panic: runtime error: invalid memory address or nil pointer dereference</span><br></pre></td></tr></table></figure>

<p>值接受者和指针接受者：</p>
<ul>
<li>改变内容必须使用指针接受者</li>
<li>结构过大也考虑指针接受者</li>
<li>已有指针接受者，最好都是指针接受者</li>
</ul>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>扩展其他的包的方法，定义别名和使用组合、内嵌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用组合</span><br><span class="line">type myNode struct &#123;</span><br><span class="line">	node *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *myNode) Print() &#123; // 重写方法</span><br><span class="line">	fmt.Println()</span><br><span class="line">	m.node.print() // 调用内部对象的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内嵌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type myNode struct &#123;</span><br><span class="line">	*Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *myNode) Print() &#123; // 同名方法会覆盖子类的方法</span><br><span class="line">	fmt.Println()</span><br><span class="line">	m.Node.Print() // 调用Node的Print方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p><code>GOPATH</code>：最开始的方案，将依赖放到<code>GOPATH</code>中，会将所有第三方的库都放在<code>src</code>下。使用依赖的时候，会往<code>GOROOT</code>和<code>GOPATH</code>的<code>src</code>中查询。</p>
<p>劣势：所有的依赖全部放在<code>src</code>中，<code>src</code>会非常庞杂，而且无法解决不同的包依赖不同的版本问题。</p>
<p><code>VENDER</code>：将本服务的依赖包放在本服务目录的<code>vendor</code>下。。使用依赖的时候，会往<code>VENDER</code>目录、<code>GOROOT</code>和<code>GOPATH</code>的<code>src</code>中查询。</p>
<p>劣势：出现大量第三方依赖管理工具，管理过程也是非常冗杂，而且代码需要附带<code>vender</code>，<code>vender</code>中可能还有<code>vendor</code>。</p>
<p><code>GO MODULE</code>：在开启<code>GO MODULE</code>时，使用<code>go get -u xxx</code>即可将这个包的某个版本加入到<code>GO MODULE</code>中。默认使用最新版，可通过<code>go get -u xxx@version</code> 指定版本。由go统一管理，</p>
<p>​	<code>go.mod</code>：记录所有依赖的包，以及对应版本</p>
<p>​	<code>go.sum</code>：记录所有依赖包以及这些包的依赖</p>
<p>使用方法：</p>
<ol>
<li>创建项目的时候创建<code>go mod</code> </li>
<li><code>go mod init xxx &amp;&amp; go build ./...</code></li>
</ol>
<p>在当前项目中，使用<code>go build</code> 和<code>go install</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build main.go 编译main.go文件，编译成功将编译的结果放到当前目录</span><br><span class="line">go build ./... 检查所有的代码的main函数是否可以正常编译</span><br><span class="line">go install ./... 将所有代码中包含main函数的代码编译到go path的bin目录下</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>抽象的概念</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Retriver interface &#123;</span><br><span class="line">	Get(string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Retrive struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*Retrive) Get(url string) string &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>类型断言 <code>type assertion</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">testretrive := r.(test.TestRetrive)</span><br><span class="line">fmt.Println(testretrive.Content)</span><br><span class="line"></span><br><span class="line">if testretrive, ok := r.(retrive.Retrive); ok &#123;</span><br><span class="line">	fmt.Println(testretrive.TimeOut)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	fmt.Println(&quot;retrive.Retrive is not a testretrive&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以接口变量里面，有两个内容，一个是实现者的类型，一个是实现者的值。</p>
<p>接口变量自带指针；接口变量采用值传递，几乎不需要使用接口的指针；指针接受者实现只能以指针方式使用，值接受者都可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var r1 retrive.Retriver</span><br><span class="line">r1 = &amp;retrive.Retrive&#123;&#125; // 由于Retrive只实现了指针的Get方法，因此此处只能是指针</span><br><span class="line">r1 = retrive.Retrive&#123;&#125; // 无法将 &#x27;retrive.Retrive&#123; UserAgent: &quot;&quot;, TimeOut: 0, &#125;&#x27; (类型 retrive.Retrive) 用作类型 retrive.Retriver 类型未实现 &#x27;retrive.Retriver&#x27;，因为 &#x27;Get&#x27; 方法有指针接收器</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r2 = test.TestRetrive&#123;Content: &quot;test&quot;&#125;      </span><br><span class="line">// r2 = &amp;test.TestRetrive&#123;Content: &quot;test&quot;&#125; // TestRetrive 是值实现Get方法，因此无论指针接受者还是值接受者都可以</span><br><span class="line">fmt.Println(r2.Get(&quot;test&quot;))</span><br></pre></td></tr></table></figure>

<p>接口组合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ReadCloser is the interface that groups the basic Read and Close methods.</span><br><span class="line">type ReadCloser interface &#123;</span><br><span class="line">	Reader  // 将多个接口组合成一个接口</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// WriteCloser is the interface that groups the basic Write and Close methods.</span><br><span class="line">type WriteCloser interface &#123;</span><br><span class="line">	Writer</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内部接口"><a href="#内部接口" class="headerlink" title="内部接口"></a>内部接口</h4><p>三个重要的内部接口</p>
<p><code>Stringer</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line">	String() string</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">fmt.Println(r1) // this is String: r1 retrive 实现String方法，打印时则打印内容</span><br><span class="line">fmt.Println(r2) // &amp;&#123;test&#125; 没有实现String方法，打印本身</span><br></pre></td></tr></table></figure>

<p><code>Reader</code>和<code>Writer</code>，抽象文件，不仅可以读写文件，还可以读字符串一样读文件或者一个网络io</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader := strings.NewReader(str)</span><br></pre></td></tr></table></figure>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>函数和外部环境（例如变量）</p>
<p>特点1：可接受值传递或者引用传递。会一直保留外部变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">func foo1(x *int) func() &#123;</span><br><span class="line">	return func() &#123;</span><br><span class="line">		*x = *x + 1</span><br><span class="line">		fmt.Printf(&quot;foo1 val = %d\n&quot;, *x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func foo2(x int) func() &#123;</span><br><span class="line">	return func() &#123;</span><br><span class="line">		x = x + 1</span><br><span class="line">		fmt.Printf(&quot;foo2 val = %d\n&quot;, x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	x := 133</span><br><span class="line">	f1 := foo1(&amp;x)</span><br><span class="line">	f2 := foo2(x)</span><br><span class="line">	f1() // x 134 print 134 指针拷贝</span><br><span class="line">	f2() // x 134 print 134 值拷贝，拷贝的是当时的133</span><br><span class="line">	f1() // x 135 print 135 指针拷贝，传入的是134，加1，成为135</span><br><span class="line">	f2() // x 135 print 135 闭包，值拷贝，拷贝的是上一个f2()的134，会记录外部环境的值</span><br><span class="line">	// Q1第二组</span><br><span class="line">	x = 233</span><br><span class="line">	f1() // x = 234 print 234</span><br><span class="line">	f2() // 136 print 136 拷贝的是上一个f2()的135</span><br><span class="line">	f1() // x = 235 print 235</span><br><span class="line">	f2() // 137 print 137 拷贝的是上一个f2()的136</span><br><span class="line">	// Q1第三组 x = 235</span><br><span class="line">	foo1(&amp;x)() // 236 print 236</span><br><span class="line">	foo2(x)()  // 237 print 237 将236当前x拷贝进去</span><br><span class="line">	// x = 236</span><br><span class="line">	foo1(&amp;x)() // 237 print 237</span><br><span class="line">	foo2(x)()  // 237 print 238</span><br><span class="line">	foo2(x)()  // 238 print 239</span><br></pre></td></tr></table></figure>

<p><strong>特点2：延迟调用，在函数被调用的时候，才会去获取外部环境的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func foo7(x int) []func() &#123;</span><br><span class="line">	var fs []func()</span><br><span class="line">	values := []int&#123;1, 2, 3, 5&#125;</span><br><span class="line">	for _, val := range values &#123;</span><br><span class="line">		fs = append(fs, func() &#123;</span><br><span class="line">			fmt.Printf(&quot;foo7 val = %d\n&quot;, x+val)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	return fs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	fs := foo7(3)</span><br><span class="line">	for _, f := range fs &#123;</span><br><span class="line">		f() // 被调用的时候去获取x和val，其中x是传入的3，val是values中最后一个值5，最终都是8</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p><code>defers</code>后的函数压栈，先进后出。在函数中，defer是在return之后执行。</p>
<p>一般用于文件打开之后<code>defer file.Close()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Create(&quot;./test.txt&quot;)</span><br><span class="line">defer file.Close()</span><br><span class="line"></span><br><span class="line">reader := bufio.NewWriter(file)</span><br><span class="line">defer reader.Flush()</span><br></pre></td></tr></table></figure>

<p>参数在<code>defer</code>语句时计算。出现<code>defer</code>，计算参数的值，存储在<code>defer</code>语句中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a int</span><br><span class="line">a = 1</span><br><span class="line">b := &amp;a</span><br><span class="line">*b = 2</span><br><span class="line">fmt.Println(&quot;a:&quot;, a) 									// a: 2</span><br><span class="line">defer fmt.Println(&quot;defer a:&quot;, a)     	// defer a: 2 </span><br><span class="line">defer fmt.Println(&quot;defer *b:&quot;, *b)		// defer *b: 2</span><br><span class="line">*b = 3																</span><br><span class="line">fmt.Println(&quot;last a:&quot;, a)							// last a: 3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func double(i int) int &#123;</span><br><span class="line">	return i * 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func x(i int) (r int) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		fmt.Println(&quot;defer: &quot;, r)   // 16  defer在return之后执行</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(r)             // 0 </span><br><span class="line">	return double(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>封装函数，封装过程中处理报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func wraperError(handle handler) func(writer http.ResponseWriter, request *http.Request) &#123;</span><br><span class="line">	return func(writer http.ResponseWriter, request *http.Request) &#123;</span><br><span class="line">		err := handle(writer, request)</span><br><span class="line">		switch &#123;</span><br><span class="line">		case os.IsNotExist(err):</span><br><span class="line">			log.Println(err)</span><br><span class="line">			http.Error(writer, http.StatusText(http.StatusNotFound), http.StatusNotFound)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fibo(writer http.ResponseWriter, request *http.Request) error &#123;&#125;</span><br><span class="line"></span><br><span class="line">http.HandleFunc(&quot;/text/&quot;, wraperError(fibo))</span><br></pre></td></tr></table></figure>

<p>使用<code>type assetion</code>类型断言，对错误进行判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if !strings.Contains(request.URL.Path, prefix) &#123;</span><br><span class="line">	return userError(&quot;path must contains &quot; + prefix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if userErr, ok := err.(userError); ok &#123;</span><br><span class="line">	http.Error(writer, userErr.Message(), http.StatusInternalServerError)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试分为<code>testing.T</code>和<code>testing.B</code>，前者重点在测试功能和代码覆盖率，后者重点在测试性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func TestBest(t *testing.T) &#123;</span><br><span class="line">	tests := []struct &#123;  // 表格驱动测试</span><br><span class="line">		s   string</span><br><span class="line">		num int</span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;&quot;abc&quot;, 3&#125;,        // 测试用例通过数组话</span><br><span class="line">		&#123;&quot;a&quot;, 1&#125;,</span><br><span class="line">		&#123;&quot; &quot;, 1&#125;,</span><br><span class="line">		&#123;&quot;abcabcabcd&quot;, 4&#125;,</span><br><span class="line">		&#123;&quot;aabbccddef&quot;, 3&#125;,</span><br><span class="line">		&#123;&quot;abcabcbb&quot;, 3&#125;,</span><br><span class="line">		&#123;&quot;bbbbb&quot;, 1&#125;,</span><br><span class="line">		&#123;&quot;pwwkew&quot;, 3&#125;,</span><br><span class="line">		&#123;&quot;abba&quot;, 2&#125;,</span><br><span class="line"></span><br><span class="line">		// chinese test case</span><br><span class="line">		&#123;&quot;你好呀世界&quot;, 5&#125;,</span><br><span class="line">		&#123;&quot;你从哪里来，我的朋友，好像一只蝴蝶~&quot;, 12&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	for _, tt := range tests &#123;</span><br><span class="line">		if res := findlongeststr(tt.s); res != tt.num &#123;</span><br><span class="line">			t.Errorf(&quot;findlongeststr with str %s get %d inpect %d&quot;, tt.s, res, tt.num) // 测试结果通过t给出</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➜  findLongestStr go test     // 命令行</span><br><span class="line">PASS</span><br><span class="line">ok      gostudy/findLongestStr  0.093s</span><br><span class="line"></span><br><span class="line">➜  findLongestStr go test -coverprofile=c.out // 将覆盖报告生成一个文件</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line"></span><br><span class="line">➜  findLongestStr go tool cover -html=c.out // html的方式展示</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkBest(b *testing.B) &#123;</span><br><span class="line">	for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">		s, num := &quot;你从哪里来，我的朋友，好像一只蝴蝶~&quot;, 12</span><br><span class="line">		if res := findlongeststr(s); res != num &#123;</span><br><span class="line">			b.Errorf(&quot;findlongeststr with str %s get %d inpect %d&quot;, s, res, num)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➜  findLongestStr go test -bench . // 命令行</span><br><span class="line"></span><br><span class="line">BenchmarkBest-10    	 1441500	       833.6 ns/op // 测试144万次，平均一次833ns</span><br></pre></td></tr></table></figure>

<h4 id="pprof-性能优化"><a href="#pprof-性能优化" class="headerlink" title="pprof 性能优化"></a>pprof 性能优化</h4><p>测试过程采集CPU性能指标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  findLongestStr go test -bench . -cpuprofile cpu.out</span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  findLongestStr go tool pprof cpu.out</span><br><span class="line">(pprof) web 通过svg的形式打开页面</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/07/image-20220701011654889.png" alt="image-20220701011654889"></p>
<p>通过svg图可以看到耗费时间的步骤在什么地方，可以针对性优化。例如上图耗时在<code>map</code>的<code>hash</code>、插入、扩容，可以通过空间换时间，换成使用一个很大的数组，将内容填充到数组的index上。</p>
<h4 id="http测试"><a href="#http测试" class="headerlink" title="http测试"></a>http测试</h4><p>使用假的Request Response做测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f := wraperError(tt.errorHandler) // 测试函数</span><br><span class="line">writer := httptest.NewRecorder() // 假的response</span><br><span class="line">request := httptest.NewRequest(http.MethodGet, &quot;https://www.baidu.com&quot;, nil) // 假的request</span><br><span class="line">f(writer, request)</span><br><span class="line">bytes, _ := ioutil.ReadAll(writer.Body)</span><br><span class="line">data := string(bytes)</span><br></pre></td></tr></table></figure>

<p>起服务器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f := wraperError(tt.errorHandler)</span><br><span class="line">server := httptest.NewServer(http.HandlerFunc(f))</span><br><span class="line">resp, _ := http.Get(server.URL) // 使用http服务测试</span><br><span class="line">bytes, _ := ioutil.ReadAll(resp.Body)</span><br></pre></td></tr></table></figure>

<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p><code>go doc</code>查看某个包的文档</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ptrinterface go doc fmt.Println  // 获取某一个包中某个方法的文档</span><br><span class="line">package fmt // import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func Println(a ...any) (n int, err error)</span><br><span class="line">    Println formats using the default formats for its operands and writes to</span><br><span class="line">    standard output. Spaces are always added between operands and a newline is</span><br><span class="line">    appended. It returns the number of bytes written and any write error</span><br><span class="line">    encountered.</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>godoc</code>打开说明文档</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  findLongestStr godoc -http localhost:6060</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/07/image-20220701111024462.png" alt="image-20220701111024462"></p>
<p><code>example</code> : 实例代码，并且可以检查输出是否正确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func ExampleQueue_Pop() &#123;</span><br><span class="line">	q := Queue1&#123;&#125;</span><br><span class="line">	q.Push(1)</span><br><span class="line">	q.Push(2)</span><br><span class="line">	q.Push(3)</span><br><span class="line">	q.Push(4)</span><br><span class="line">	fmt.Println(q.Pop())</span><br><span class="line">	fmt.Println(q.Pop())</span><br><span class="line">	fmt.Println(q.Pop())</span><br><span class="line">	fmt.Println(q.Pop())</span><br><span class="line"></span><br><span class="line">	// OutPut:</span><br><span class="line">	// 1</span><br><span class="line">	// 2</span><br><span class="line">	// 3</span><br><span class="line">	// 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/07/image-20220701141652787.png" alt="image-20220701141652787"></p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>golang中的内存分配有两种方式，一种是分配在栈上，一种是分配在堆上。</p>
<p>栈的数据结构是先进后出，分配和回收速度快，在golang中会将一些局部变量分配在栈上，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func calc(a, b int) int &#123;</span><br><span class="line">	c := a + b</span><br><span class="line">	x := c * 10</span><br><span class="line">	return x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用函数calc时，会将变量c和x分配在栈上，函数调用完成，变量c和x的内存会被自动回收。</p>
<p>堆是无序的，堆分配内存按照变量大小分配，容易造成内存碎片，相比栈分配，堆适合大小不可预知的内存分配，因此分配和回收速度较慢。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>通过编译器分析代码的特征和代码的生命周期，决定应该使用堆还是使用栈进行内存分配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func calc(a, b int) int &#123;</span><br><span class="line">	c := a + b</span><br><span class="line">	x := c * 10</span><br><span class="line">	return x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func cacl1(a int) int &#123;  </span><br><span class="line">	var b int   // b 是整形，通过返回值&quot;逃出&quot;了cacl1函数，但是是b的值的拷贝作为返回值，即使b被回收，也不影响在main()中使用返回值</span><br><span class="line">	b = a</span><br><span class="line">	return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func none() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var a int     </span><br><span class="line">	none()</span><br><span class="line">	fmt.Println(calc(1, a))</span><br><span class="line">	fmt.Println(a, cacl1(10))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags &quot;-m -l&quot; main.go </span><br></pre></td></tr></table></figure>

<ul>
<li>-gcflags 编译参数，-m 进行内存分配分析 -l 表示避免程序内联，避免程序优化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./main.go:24:13: ... argument does not escape</span><br><span class="line">./main.go:24:18: calc(1, a) escapes to heap    // calc(1,a)逃逸到堆上，由于函数有返回值，被fmt.Println使用后还是会在main()函数中继续存在。</span><br><span class="line">./main.go:25:13: ... argument does not escape</span><br><span class="line">./main.go:25:13: a escapes to heap      // a 逃逸到堆上</span><br><span class="line">./main.go:25:22: cacl1(10) escapes to heap</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了通过逃逸分析，还可以通过取地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Data struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewData() *Data &#123;</span><br><span class="line">	var a Data              // moved to heap: a    </span><br><span class="line">	return &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(NewData())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags &quot;-m -l&quot; main.go</span><br><span class="line">./main.go:25:6: moved to heap: a     // 变量a在函数外部也会被使用，移动到堆上     </span><br><span class="line">./main.go:30:13: ... argument does not escape</span><br></pre></td></tr></table></figure>

<p>编译器觉得变量应该分配在堆和栈上的原则是：</p>
<ul>
<li>变量是否被取地址</li>
<li>变量是否发生逃逸</li>
</ul>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>协程：轻量级“线程”；非抢占式多任务处理，由协程主动交出控制权；编译器、解释器、虚拟机层面的多任务；多个协程可以在一个或多个线程上运行。</p>
<ul>
<li><p>非抢占式：线程是抢占式，当CPU中断切换线程时，会保存当前现成的上下文。协程非抢占，当一个协程执行过程中，如果不释放CPU，则其他的写成会阻塞住</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">	go func() &#123;</span><br><span class="line">		for &#123;</span><br><span class="line">			fmt.Println(&quot;hello go routine: &quot;, i) // 闭包，当外部i变更，函数内部i的值也会随着变化。fmt.Println需要调用io，会发生goroutine切换，切换到main goroutine会终止主进程</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(1 * time.Second)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	slice1 := make([]int, 11) // 此处需要注意，如果是10，则当i最终加到10的时候，无法访问slice1[10]，会出现报错。现在的CPU</span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for &#123;</span><br><span class="line">				slice1[i]++  // 闭包，外部i改变，影响函数内部，最终i的值是10，当slice1的len是10，则会出现out of range</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(1 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去掉闭包的影响</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(2)   // 指定GOMAXPROCS个数2</span><br><span class="line">slice1 := make([]int, 10)</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">	go func(i int) &#123;</span><br><span class="line">		for &#123;</span><br><span class="line">			slice1[i]++   // 在go 1.12.17版本中，协程进入死循环，无法被抢占，main goroutine无法被调度，会导致进程阻塞。  ps： 实测1.14.15以及后续版本不会，需要进一步考究golang版本更新。</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决<code>goroutine</code>死循环无法被调度，可以手动调度，通过<code>runtime.Gosched()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slice1 := make([]int, 10)</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">	go func(i int) &#123;</span><br><span class="line">		for &#123;</span><br><span class="line">			slice1[i]++</span><br><span class="line">			runtime.Gosched() // 强制该goroutine被调度</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>竞态检测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> go run -race goroutine.go</span><br><span class="line">slice1 address: 0xc0000be000==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Read at 0x00c0000be000 by main goroutine:</span><br><span class="line">Previous write at 0x00c0000be000 by goroutine 7:</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		go func(i int) &#123;</span><br><span class="line">			for &#123;</span><br><span class="line">				slice1[i]++							// write at 0x00c0000be000 by goroutine 7:</span><br><span class="line">				runtime.Gosched()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(1 * time.Second)</span><br><span class="line">	fmt.Println(slice1)						// Read at 0x00c0000be000 by main goroutine:</span><br></pre></td></tr></table></figure>

<p>可以看到变量<code>slice1</code>出现竞争读写，<code>main goroutine</code> 在读，<code>goroutine</code> 在写入</p>
<p>闭包情况下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 10; i++ &#123; 				// main goroutine 写i</span><br><span class="line">	fmt.Printf(&quot;i address: %p&quot;, i)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		for &#123;</span><br><span class="line">			slice1[i]++  								// goroutine 读i</span><br><span class="line">			runtime.Gosched()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Goroutine-间通信"><a href="#Goroutine-间通信" class="headerlink" title="Goroutine 间通信"></a>Goroutine 间通信</h3><p><code>Goroutine</code> 通过<code>channel</code>实现通信</p>
<p><code>channel</code>分为有缓冲<code>channel</code>和无缓冲<code>channel</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c := make(chan int)</span><br><span class="line">c &lt;- 1 // fatal error: all goroutines are asleep - deadlock! 无缓冲channel没有协程接收时会发生死锁</span><br></pre></td></tr></table></figure>

<p><code>channel</code>有方向区分，默认可接受可发送，定义时可定义只能接收或只能发送</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c := make(chan&lt;- int)</span><br><span class="line">d := make(&lt;-chan int)</span><br></pre></td></tr></table></figure>

<p>关闭的<code>channel</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)</span><br><span class="line">close(ch)</span><br><span class="line">fmt.Printf(&quot;get %d from close channel&quot;, &lt;-ch) // get 0 from close channel</span><br></pre></td></tr></table></figure>

<p>从关闭的<code>channel</code>种可以一直获取值，获取到的是类型的零值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)</span><br><span class="line">go func() &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		data, ok := &lt;-ch</span><br><span class="line">		if ok &#123;</span><br><span class="line">			fmt.Printf(&quot;get %d from channel\n&quot;, data) 			// get 1 from channel</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			fmt.Printf(&quot;get %d from close channel\n&quot;, &lt;-ch) // get 0 from close channel</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line">ch &lt;- 1</span><br><span class="line">close(ch)</span><br></pre></td></tr></table></figure>

<p>通过<code>range</code>可以检测到<code>channel</code>关闭</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)</span><br><span class="line">go func() &#123;</span><br><span class="line">	for data := range ch &#123;</span><br><span class="line">		fmt.Printf(&quot;get %d from channel\n&quot;, data)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line">ch &lt;- 1</span><br><span class="line">close(ch) // 当ch关闭，range也结束完成</span><br></pre></td></tr></table></figure>

<p>当<code>chanel</code>不关闭</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)</span><br><span class="line">go func() &#123;</span><br><span class="line">	ch &lt;- 1</span><br><span class="line">&#125;()</span><br><span class="line">for data := range ch &#123; // fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">	fmt.Printf(&quot;get %d from channel\n&quot;, data)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="CSP模型"><a href="#CSP模型" class="headerlink" title="CSP模型"></a>CSP模型</h3><p>不通过共享内存通信，通过通信来共享内存。</p>
<p>“使用共享内存通信”：这句话可以理解为对某个变量<code>flag</code>变更，通知其他的<code>goroutine</code>获取到变更</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var flag bool = false	 															// 公共变量（共享内存）</span><br><span class="line"></span><br><span class="line">func worker(id int, ch chan int) &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		data := &lt;-ch</span><br><span class="line">		fmt.Printf(&quot;from worker %d get %d\n&quot;, id, data)</span><br><span class="line">		if data == 2 &#123;</span><br><span class="line">			flag = true</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	ch := make(chan int)</span><br><span class="line">	go worker(0, ch)</span><br><span class="line">	ch &lt;- 1</span><br><span class="line">	ch &lt;- 2</span><br><span class="line">	for &#123;</span><br><span class="line">		if flag &#123;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>channel</code>通信</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func worker(id int, ch chan int, reschan chan bool) &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		data := &lt;-ch</span><br><span class="line">		fmt.Printf(&quot;from worker %d get %d\n&quot;, id, data)</span><br><span class="line">		if data == 2 &#123;</span><br><span class="line">			reschan &lt;- true</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	ch := make(chan int)</span><br><span class="line">	reschan := make(chan bool)</span><br><span class="line">	go worker(0, ch, reschan)</span><br><span class="line">	ch &lt;- 1</span><br><span class="line">	ch &lt;- 2</span><br><span class="line">	&lt;-reschan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>chanel</code>通信的几种情况：</p>
<p>​	<code>go routine</code> 乱序执行，即使<code>channel</code>有序推送信息，不同的<code>go routine</code>接收也是乱序的，如果要顺序执行，可以借助另外的<code>channel</code>实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func WorkerDo(id int, c chan int, done chan struct&#123;&#125;) &#123;</span><br><span class="line">	for i := range c &#123;</span><br><span class="line">		fmt.Printf(&quot;get %c from worker %d\n&quot;, i, id) // 先接收</span><br><span class="line">		done &lt;- struct&#123;&#125;&#123;&#125;													// 	再发送</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	for i, w := range workers &#123;</span><br><span class="line">		w.in &lt;- &#x27;a&#x27; + i						// 一个发送，发送完成之后，对端有人接收</span><br><span class="line">		&lt;-w.done 									// 一个接收，接收到了之后再处理下一个，实现顺序执行</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>乱序，将发送和接收错开</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for i, w := range workers &#123; </span><br><span class="line">	w.in &lt;- &#x27;a&#x27; + i							// 直接发送，对端接受乱序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, w := range workers &#123;</span><br><span class="line">	&lt;-w.done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>goroutine</code>间通过<code>channel</code>通信需要注意阻塞问题，当没有缓冲的<code>channel</code>往里面发送，对端没有接受者就会出现阻塞，或者通过<code>for</code>获取<code>channel</code>里面的内容，当没有内容也会出现阻塞，除非<code>channel</code>被<code>close</code>掉。</p>
<p>代码规范中，定义<code>channel</code>有两种情况，一种是有<code>buffer</code>，<code>buffer</code>为1，一种是没有<code>buffer</code>，需要被阻塞住。</p>
<h3 id="sync-Wait"><a href="#sync-Wait" class="headerlink" title="sync.Wait"></a>sync.Wait</h3><p>除了使用<code>channel</code>通信通知，官方提供的<code>go routine</code>运行完成之前<code>main goroutine</code> 等待的方法是使用<code>sync.Wait</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(10) 						// 10个</span><br><span class="line">wg.Wait()							// 等待所有的wg.Done</span><br><span class="line"></span><br><span class="line">func WorkerDo(id int, c chan int, wg *sync.WaitGroup) &#123;</span><br><span class="line">   for i := range c &#123;</span><br><span class="line">     fmt.Printf(&quot;get %c from worker %d\n&quot;, i, id)</span><br><span class="line">     wg.Done()				</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般会将<code>wg</code>封装到对象中，也可以通过函数式编程封装<code>done</code>的功能为一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Worker struct &#123;</span><br><span class="line">	id   int</span><br><span class="line">	in   chan int</span><br><span class="line">	done func()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workers = append(workers, Worker&#123;</span><br><span class="line">			id: i,</span><br><span class="line">			in: in,</span><br><span class="line">			done: func() &#123;</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>可以同时从多个<code>channel</code>中接收数据，哪个<code>channel</code>先有数据则先接收哪个。</p>
<p>阻塞式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">		case n := &lt;-ch1:</span><br><span class="line">			fmt.Printf(&quot;get %d from ch1\n&quot;, n)</span><br><span class="line">		case n := &lt;-ch2:</span><br><span class="line">			fmt.Printf(&quot;get %d from ch2\n&quot;, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>default</code>非阻塞式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case n := &lt;-ch1:</span><br><span class="line">	fmt.Printf(&quot;get %d from ch1\n&quot;, n)</span><br><span class="line">case n := &lt;-ch2:</span><br><span class="line">	fmt.Printf(&quot;get %d from ch2\n&quot;, n)</span><br><span class="line">default:</span><br><span class="line">	fmt.Println(&quot;select default get nothing&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般配合<code>for</code>使用，循环监听</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case n := &lt;-ch1:</span><br><span class="line">			fmt.Printf(&quot;get %d from ch1\n&quot;, n)</span><br><span class="line">		case n := &lt;-ch2:</span><br><span class="line">			fmt.Printf(&quot;get %d from ch2\n&quot;, n)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如果监听<code>nil channel</code>，则不会接收数据，也就不会处理对应逻辑。可用于做一些数据准备相关的逻辑。</p>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p><code>select</code>有时候搭配定时器使用，可以设置最长时间、超时、定时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tm := time.After(time.Duration(5) * time.Second) // 返回一个channel，时间到会往channel发送一个Time数据</span><br><span class="line">tt := time.Tick(time.Duration(1) * time.Second) // 返回一个channel，每隔一段时间往channel里面发送一个Timer数据，可以用于定时器</span><br><span class="line">for &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case n := &lt;-ch1:</span><br><span class="line">		fmt.Printf(&quot;get %d from ch1\n&quot;, n)</span><br><span class="line">	case n := &lt;-ch2:</span><br><span class="line">		fmt.Printf(&quot;get %d from ch2\n&quot;, n)</span><br><span class="line">	case &lt;-time.After(time.Duration(rand.Intn(400)) * time.Millisecond): // 每次循环定义一个计时器，可用于计算超时</span><br><span class="line">		fmt.Println(&quot;time out&quot;)</span><br><span class="line">	case &lt;-tt:</span><br><span class="line">		fmt.Println(&quot;1s gone&quot;)</span><br><span class="line">	case &lt;-tm:</span><br><span class="line">		fmt.Println(&quot;5s gone bye&quot;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>使用协程算加法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 10000; i++ &#123;</span><br><span class="line">	go func() &#123;</span><br><span class="line">		sum += int32(i)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的结果会不一样。<code>go run -race xxx.go</code>可以看到有两处数据竞态，一个是变量<code>i</code>，一个是变量<code>sum</code>。</p>
<p>解决<code>sum</code>竞态的的方法有很多，下面一一讨论，先解决闭包的问题。</p>
<p>闭包：</p>
<p>将函数外部的变量通过参数传递到函数内部</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 10000; i++ &#123;</span><br><span class="line">	go func(i int) &#123;</span><br><span class="line">		sum += int32(i)</span><br><span class="line">	&#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>Golang提供<code>atomic</code>包，<code>atomic.AddInt32</code>是原子操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 10000; i++ &#123;</span><br><span class="line">	go func(i int) &#123;</span><br><span class="line">		atomic.AddInt32(&amp;sum, int32(i))</span><br><span class="line">	&#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>多个<code>goroutine</code>同时操作一个对象时，通过加锁和解锁解决竞态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock := sync.Mutex&#123;&#125;</span><br><span class="line">for i := 0; i &lt; 10000; i++ &#123;</span><br><span class="line">	go func() &#123;</span><br><span class="line">		lock.Lock()</span><br><span class="line">		defer lock.Unlock()</span><br><span class="line">		sum++</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>阻塞：获取了一个协程的数据之后再处理其他的协程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;get message: &quot;, &lt;-m1)</span><br><span class="line">fmt.Println(&quot;get message: &quot;, &lt;-m2)</span><br></pre></td></tr></table></figure>

<p>非阻塞：通过内部多个协程或者<code>select</code>做非阻塞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func nonBlockingWait(c chan string) (string, bool) &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case m := &lt;-c:</span><br><span class="line">		return m, true</span><br><span class="line">	default:</span><br><span class="line">		return &quot;&quot;, false</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>超时机制：在<code>select</code>过程中通过超时时间判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func timeoutWait(c chan string, timeout time.Duration) (string, bool) &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case &lt;-time.After(timeout):</span><br><span class="line">		return &quot;&quot;, false</span><br><span class="line">	case m := &lt;-c:</span><br><span class="line">		return m, true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>退出，以及优雅的退出，通过<code>done</code>信道获得退出信号。一般情况退出之后主进程无法判断协程是否正常退出，可以通过<code>done</code>信道双向通信。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">go func() &#123;</span><br><span class="line">	i := 0</span><br><span class="line">	for &#123;</span><br><span class="line">		time.Sleep(time.Duration(rand.Intn(2000)) * time.Millisecond)</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-done:</span><br><span class="line">			fmt.Printf(&quot;service %s done\n&quot;, name)</span><br><span class="line">			done &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">			fmt.Printf(&quot;service %s already done\n&quot;, name)</span><br><span class="line">			return</span><br><span class="line">		default:</span><br><span class="line">			c &lt;- fmt.Sprintf(&quot;service %s send message %d&quot;, name, i)</span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h4 id="通过chanel实现广度优先算法"><a href="#通过chanel实现广度优先算法" class="headerlink" title="通过chanel实现广度优先算法"></a>通过chanel实现广度优先算法</h4><p>广度优先的思想，就是一层一层的计算，将计算出的一层的结果放到队列中，从队列中获取这一层的结果进行计算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// 走迷宫</span><br><span class="line"></span><br><span class="line">// 走的方向，上，右，下，左</span><br><span class="line">var dirs = [4]point&#123;</span><br><span class="line">	&#123;-1, 0&#125;,</span><br><span class="line">	&#123;0, -1&#125;,</span><br><span class="line">	&#123;1, 0&#125;,</span><br><span class="line">	&#123;0, 1&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type point struct &#123;</span><br><span class="line">	i, j int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p point) add(r point) point &#123;</span><br><span class="line">	return point&#123;</span><br><span class="line">		i: p.i + r.i,</span><br><span class="line">		j: p.j + r.j,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func walk(maze [][]int, start point, end point) [][]int &#123;</span><br><span class="line">// 定义路径，跟迷宫一样的数据结构</span><br><span class="line">	steps := make([][]int, len(maze))</span><br><span class="line">	for i := range steps &#123;</span><br><span class="line">		steps[i] = make([]int, len(maze[i]))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 定义队列，初始值是起始位置</span><br><span class="line">	// 上下左右最大有四个可以走的</span><br><span class="line">	Q := make(chan point, 4)</span><br><span class="line">	Q &lt;- start</span><br><span class="line">	steps[start.i][start.j] = 1</span><br><span class="line">	// 队列只要有值</span><br><span class="line">	for len(Q) &gt; 0 &#123;</span><br><span class="line">		count := &lt;-Q // 获取当前point</span><br><span class="line">		// 如果这个点是终点</span><br><span class="line">		if count == end &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		for _, dir := range dirs &#123;</span><br><span class="line">			next := count.add(dir) // 计算出来的下一个点</span><br><span class="line">			// 下一个点满足这几个条件才可以放到queue中</span><br><span class="line"></span><br><span class="line">			// 不能超过最外面的一层</span><br><span class="line">			if next.j &lt; 0 || next.i &lt; 0 || next.i &gt; len(maze)-1 || next.j &gt; len(maze[next.i])-1 &#123;</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// 位置值不能是1，不能走在墙上</span><br><span class="line">			if maze[next.i][next.j] == 1 &#123;</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// 位置不能是前面走过来的</span><br><span class="line">			if steps[next.i][next.j] != 0 &#123;</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">			// 将脚步记录下来</span><br><span class="line">			steps[next.i][next.j] = steps[count.i][count.j] + 1</span><br><span class="line">			// 这一个点可以走下去，丢到队列中</span><br><span class="line">			Q &lt;- next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return steps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Reference/" rel="tag"># 学习笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/6b2c.html" rel="prev" title="快速排序、二分法以及一些变形的思考">
                  <i class="fa fa-chevron-left"></i> 快速排序、二分法以及一些变形的思考
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/1ead.html" rel="next" title="Golang中常用的标准库之http">
                  Golang中常用的标准库之http <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mitaka xu</span>
</div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"TVx6Wkfs8VJGOwYPurtjWY2e-9Nh9j0Va","app_key":"c7VvaRnyF8r3DUIPq1x2KJ7Q","server_url":"https://tvx6wkfs.lc-cn-e1-shared.com","security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"xiaoyeshiyu","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
