<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="S_5aoPFd3QQihrUOLiKdVR0Mj4fj6n6qJojwyjj9cAY">
  <meta name="msvalidate.01" content="9032A67FCF787F07CB04374E59E518A9">
  <meta name="baidu-site-verification" content="code-Onlniop0d6">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.xiaoyeshiyu.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="数据结构和算法是程序员的基础，而且是一个很重要的基础。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构和算法初识">
<meta property="og:url" content="https://www.xiaoyeshiyu.com/post/79b0.html">
<meta property="og:site_name" content="小夜时雨">
<meta property="og:description" content="数据结构和算法是程序员的基础，而且是一个很重要的基础。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221212180817930.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221211233041574.png">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221212180917113.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212180958673.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212110147658.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212110340885.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212111147012.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212112708607.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212114134808.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212114840010.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212115133160.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212115255293.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212171916859.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212171745511.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212172050483.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/deque.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213170420074.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213170522848.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213170820506.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213174159016.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213174748681.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213174957329.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213181228162.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215165518116.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215165636052.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215165649621.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215174927132.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215174943002.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175041845.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175049825.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175128743.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175154914.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/Tree_Rebalancing.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203032328.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203103195.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203243856.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203223503.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203309163.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203746054.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203806433.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216093933925.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216094301929.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216094513742.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216101833319.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213204352351.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213211610933.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214103122667.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214103531661.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214105138027.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214105946104.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214110048812.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214135650823.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214135808104.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214143305811.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214143544513.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214145242758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214145426297.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214145854501.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214150158043.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215100815784.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215102021321.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215102034053.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215112656150.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215112720564.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215112740618.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215114752354.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215141621887.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215141701546.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215141748310.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216102928839.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216102957766.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015224719590-1433219824.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015225645277-1151100000.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20180331170017421-364506073.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015223238449-2146169197.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015230936371-1413523412.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015230557043-37375010.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015231308699-356134237.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015231740840-6968181.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015232107090-1920702011.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015232453668-1397662527.gif">
<meta property="article:published_time" content="2022-06-10T16:00:00.000Z">
<meta property="article:modified_time" content="2023-07-24T07:09:28.894Z">
<meta property="article:author" content="Mitaka xu">
<meta property="article:tag" content="Golang, 微服务，数据库，中间件, 算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221212180817930.png">


<link rel="canonical" href="https://www.xiaoyeshiyu.com/post/79b0.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.xiaoyeshiyu.com/post/79b0.html","path":"post/79b0.html","title":"数据结构和算法初识"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据结构和算法初识 | 小夜时雨</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MBVJ11TVHH"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBVJ11TVHH","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?573725610fbc6ff9b42032bd13615370"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="小夜时雨" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小夜时雨</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">君子敬其在己者，而不慕其在天者，是以日进也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.3.</span> <span class="nav-text">时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%AE%9A%E7%90%86"><span class="nav-number">1.3.1.</span> <span class="nav-text">主定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A3%80%E7%B4%A2%E6%97%B6%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.3.2.</span> <span class="nav-text">不同数据结构检索时的时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.3.3.</span> <span class="nav-text">不同数组排序算法的时间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4"><span class="nav-number">2.1.</span> <span class="nav-text">一维</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-array"><span class="nav-number">2.1.1.</span> <span class="nav-text">数组 array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8-Linked-List"><span class="nav-number">2.1.2.</span> <span class="nav-text">链表 Linked List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8-Skip-List"><span class="nav-number">2.1.3.</span> <span class="nav-text">跳表 Skip List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE"><span class="nav-number">2.1.4.</span> <span class="nav-text">典型题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88-stack"><span class="nav-number">2.1.5.</span> <span class="nav-text">栈 stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97-queue"><span class="nav-number">2.1.6.</span> <span class="nav-text">队列 queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-deque%EF%BC%9Adouble-end-queue"><span class="nav-number">2.1.7.</span> <span class="nav-text">双端队列 deque：double end queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">2.1.8.</span> <span class="nav-text">优先队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-1"><span class="nav-number">2.1.9.</span> <span class="nav-text">典型题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%92%8C%E9%9B%86%E5%90%88%E4%BB%A5%E5%8F%8A%E6%98%A0%E5%B0%84"><span class="nav-number">2.1.10.</span> <span class="nav-text">哈希表和集合以及映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-2"><span class="nav-number">2.1.11.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4"><span class="nav-number">2.2.</span> <span class="nav-text">二维</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91-Tree"><span class="nav-number">2.2.1.</span> <span class="nav-text">树 Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree"><span class="nav-number">2.2.2.</span> <span class="nav-text">二叉树 Binary Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE-Graph"><span class="nav-number">2.2.3.</span> <span class="nav-text">图 Graph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-Binary-Search-Tree"><span class="nav-number">2.2.4.</span> <span class="nav-text">二叉搜索树 Binary Search Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-3"><span class="nav-number">2.2.5.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">高级数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%A0%91"><span class="nav-number">2.3.1.</span> <span class="nav-text">高级树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AVL%E6%A0%91"><span class="nav-number">2.3.2.</span> <span class="nav-text">AVL树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91-Red-Black-Tree"><span class="nav-number">2.3.3.</span> <span class="nav-text">红黑树 Red-Black Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-Bloom-Filter"><span class="nav-number">2.3.4.</span> <span class="nav-text">布隆过滤器 Bloom Filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98-Cache"><span class="nav-number">2.3.5.</span> <span class="nav-text">缓存 Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU-Cache"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">LRU Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">替换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-4"><span class="nav-number">2.3.5.3.</span> <span class="nav-text">典型题目</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-number">3.</span> <span class="nav-text">算法思想</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">3.1.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-5"><span class="nav-number">3.1.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%B2%BB-Divide-amp-Conquer"><span class="nav-number">3.2.</span> <span class="nav-text">分治 Divide &amp; Conquer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF"><span class="nav-number">3.3.</span> <span class="nav-text">回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-6"><span class="nav-number">3.3.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS"><span class="nav-number">3.4.</span> <span class="nav-text">深度优先搜索 DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS"><span class="nav-number">3.5.</span> <span class="nav-text">广度优先搜索 BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-7"><span class="nav-number">3.5.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-Greedy"><span class="nav-number">3.6.</span> <span class="nav-text">贪心算法 Greedy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-8"><span class="nav-number">3.6.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">3.7.</span> <span class="nav-text">二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-9"><span class="nav-number">3.7.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Dynamic-Programming"><span class="nav-number">3.8.</span> <span class="nav-text">动态规划 Dynamic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-10"><span class="nav-number">3.8.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91-Trie"><span class="nav-number">3.9.</span> <span class="nav-text">字典树 Trie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-11"><span class="nav-number">3.9.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">3.10.</span> <span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98"><span class="nav-number">3.10.1.</span> <span class="nav-text">典型问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2"><span class="nav-number">3.11.</span> <span class="nav-text">高级搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E7%BA%A7%E6%90%9C%E7%B4%A2"><span class="nav-number">3.11.1.</span> <span class="nav-text">初级搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2-1"><span class="nav-number">3.11.2.</span> <span class="nav-text">高级搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="nav-number">3.11.3.</span> <span class="nav-text">回溯法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-12"><span class="nav-number">3.11.3.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91BFS"><span class="nav-number">3.11.4.</span> <span class="nav-text">双向BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-13"><span class="nav-number">3.11.4.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2-A-Search"><span class="nav-number">3.11.5.</span> <span class="nav-text">启发式搜索 A* Search</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-14"><span class="nav-number">3.11.5.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">3.12.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%88%96-XOR"><span class="nav-number">3.12.1.</span> <span class="nav-text">异或 XOR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A6%81%E7%82%B9"><span class="nav-number">3.12.2.</span> <span class="nav-text">位运算要点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-15"><span class="nav-number">3.12.2.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">3.13.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F-O-n-2"><span class="nav-number">3.13.1.</span> <span class="nav-text">初级排序 O(n^2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F-O-nlog-n"><span class="nav-number">3.13.2.</span> <span class="nav-text">高级排序 O(nlog(n))</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%8E%92%E5%BA%8F-O-n"><span class="nav-number">3.13.3.</span> <span class="nav-text">特殊排序 O(n)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-16"><span class="nav-number">3.13.4.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">3.14.</span> <span class="nav-text">高级动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%8F%90%E5%8D%87"><span class="nav-number">3.14.1.</span> <span class="nav-text">复杂度提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98-1"><span class="nav-number">3.14.2.</span> <span class="nav-text">典型问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.15.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">3.15.1.</span> <span class="nav-text">字符串匹配算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98-2"><span class="nav-number">3.15.2.</span> <span class="nav-text">典型问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB"><span class="nav-number">4.</span> <span class="nav-text">推荐阅读</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mitaka xu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mitaka xu</p>
  <div class="site-description" itemprop="description">Golang开发博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaoyeshiyu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/79b0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数据结构和算法初识 | 小夜时雨">
      <meta itemprop="description" content="数据结构和算法是程序员的基础，而且是一个很重要的基础。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构和算法初识
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-11 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-11T00:00:00+08:00">2022-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-07-24 15:09:28" itemprop="dateModified" datetime="2023-07-24T15:09:28+08:00">2023-07-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/algorithm/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
    <span id="/post/79b0.html" class="post-meta-item leancloud_visitors" data-flag-title="数据结构和算法初识" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/post/79b0.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="post/79b0.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

            <div class="post-description">数据结构和算法是程序员的基础，而且是一个很重要的基础。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>一维：</p>
<ul>
<li>基础：数组 array（string），链表 linked list</li>
<li>高级：栈 stack，队列 queue，双端队列 deque，集合 set，映射 map（hash or map），etc</li>
</ul>
<p>二维：</p>
<ul>
<li>基础：树 tree，图 graph</li>
<li>高级：二叉搜索树 binary search tree（red-black tree，AVL），堆 heap，并查集 disjoint set，字典树 Trie，etc</li>
</ul>
<p>特殊：</p>
<ul>
<li>位运算 Bitwise，不用过滤器 BloomFilter</li>
<li>LRU Cache</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>以下三种方式，是几乎所有算法和数据结构的基石</p>
<ul>
<li>if-else,switch:branch</li>
<li>for.while loop:lteration</li>
<li>递归 Recursion(Divide &amp; Conquer, Backtrace)</li>
</ul>
<p>在基石上的扩展</p>
<ul>
<li>搜索 Search：深度优先搜索 Depth first search，广度优先搜索 Breadth first search,A*,etc</li>
<li>动态规划 Dynamic Programming </li>
<li>二分查找 Binary Search </li>
<li>贪心算法 Greedy </li>
<li>数学 Math，集合 Geometry</li>
</ul>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度用Big O notation表示，也就是<code>O()</code>表示。时间复杂度有这么几种：</p>
<p><code>O(1)</code>：表示Constant Complexity 常数复杂度</p>
<p><code>O(log n)</code>：表示Logarithmic Complexity 对数复杂度</p>
<p><code>O(n)</code>：表示Linear Complexity 线性时间复杂度</p>
<p><code>O(n^2)</code>：表示N Square Complexity 平方</p>
<p><code>O(n^3)</code>：表示N Cube Complexity 立方</p>
<p><code>O(2^n)</code>：表示Exponential Growth 指数</p>
<p><code>O(n!)</code>：表示 Factorial 阶乘</p>
<p>查看一个函数的时间复杂度，主要跟N有关，而且会去掉前面的常数，也就是<code>O(2)</code>、<code>O(3)</code>统称为常数复杂度，也就是<code>O(1)</code></p>
<p>例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10000</span></span><br><span class="line">fmt.Println(n)</span><br><span class="line"><span class="keyword">return</span> </span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(1)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10000</span></span><br><span class="line">fmt.Println(n)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello + &quot;</span>,n)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello golang : &quot;</span>,n)</span><br><span class="line"><span class="keyword">return</span> </span><br></pre></td></tr></table></figure>

<p>时间复杂度也是 <code>O(1)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello &quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(n)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello &quot;</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(n^2)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello &quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello &quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然执行的时候，是 <code>O(2n)</code>，但是时间复杂度会去掉前面的常数，也就是 <code>O(n)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i=i*<span class="number">2</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello &quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(log(n))</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fib(n<span class="number">-2</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(k^n)</code></p>
<p>时间复杂度是衡量一段代码效率的重要指标</p>
<p><img src="/../../../../../Library/Application%20Support/typora-user-images/image-20221212180817930.png" alt="image-20221212180817930"></p>
<p>可以看到，不同的时间复杂度，在n增大时，所需要的时间增大服务不一样，其中最快的是 <code>O(1)</code>，但是实际上几乎不会是这种，其次是 <code>O(log(n))</code>。</p>
<p>使用到 <code>O(1)</code>的情况，例如求和</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	s := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		s += i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(n)</code>，但是使用求和公式，可以直接获取结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sumFormula(n int) int &#123;</span><br><span class="line">	return (1 + n) * n / 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(1)</code></p>
<h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>一些常用的搜索算法，可以通过主定理直接得到时间复杂度</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221211233041574.png" alt="image-20221211233041574"></p>
<p>通过主定理，可以得到：</p>
<ul>
<li>二叉树遍历-前序、中序、后序的时间复杂度都是 <code>O(n)</code>，因为要遍历每一个结点，n代表二叉树中的每一个结点</li>
<li>图的遍历的时间复杂度是 <code>O(n)</code>，n代表图里面的每一个结点</li>
<li>搜索算法，DFS、BFS时间复杂度都是 <code>O(n)</code>，n代表搜索空间里面的结点总数</li>
<li>二分查找法的时间复杂度是 <code>O(log(n))</code></li>
</ul>
<h3 id="不同数据结构检索时的时间复杂度"><a href="#不同数据结构检索时的时间复杂度" class="headerlink" title="不同数据结构检索时的时间复杂度"></a>不同数据结构检索时的时间复杂度</h3><p><img src="/../../../../../Library/Application%20Support/typora-user-images/image-20221212180917113.png" alt="image-20221212180917113"></p>
<h3 id="不同数组排序算法的时间复杂度"><a href="#不同数组排序算法的时间复杂度" class="headerlink" title="不同数组排序算法的时间复杂度"></a>不同数组排序算法的时间复杂度</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212180958673.png" alt="image-20221212180958673"></p>
<p>汇总：<span class="exturl" data-url="aHR0cDovL3d3dy5yZWRidWJibGUuY29tL3Blb3BsZS9pbW1vcnRhbGxvb20vd29ya3MvMjI5Mjk0MDgtb2ZmaWNpYWwtYmlnLW8tY2hlYXQtc2hlZXQtcG9zdGVyP3A9cG9zdGVyJmZpbmlzaD1zZW1pX2dsb3NzJnNpemU9bGFyZ2U=">http://www.redbubble.com/people/immortalloom/works/22929408-official-big-o-cheat-sheet-poster?p=poster&amp;finish=semi_gloss&amp;size=large<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h2><h3 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 array</h3><p>在<code>golang</code>中定义数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">string</span></span><br><span class="line">b := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>数据会在内存中开辟一段连续的空间，<code>占用的字节数 = 元素类型字节 * 元素个数</code>，例如上例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(unsafe.Sizeof(a))		<span class="comment">// 48，string底层由一个指向数据的指针和int类型长度组成，占16个字节</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(b))		<span class="comment">// 16，int类型占8个字节</span></span><br></pre></td></tr></table></figure>

<p>因此，访问第一个元素和访问中间的某一个元素的时间复杂度，是一样的，都是 <code>O(1)</code>。</p>
<p>数组的特点是访问快，但是插入、删除慢</p>
<p>例如要在<code>index=3</code>的位置插入一个元素，需要将后续的<code>E\F\G</code>都往后挪动（前提是数组有空余位置）</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212110147658.png" alt="image-20221212110147658"></p>
<p>此时的时间复杂度取决于位置值，是 <code>O(n)</code></p>
<p>删除操作也是一样的，先将 <code>index=3</code>的值取出来，然后将 <code>EFG</code>的值往前挪动</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212110340885.png" alt="image-20221212110340885"></p>
<p>此时的时间复杂度取决于位置值，也是 <code>O(n)</code></p>
<p>当然，在<code>golang</code>中，数组的长度是无法扩展的，因此通常是在切片中操作。在切片中，如果长度不足，首先会扩容，将老数组中的内容拷贝到新数组中。</p>
<h3 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表 Linked List"></a>链表 Linked List</h3><p>链表通过指针指向下一个结点，这种数据结构可以弥补数组中数据插入和数据删除导致的性能问题。</p>
<p>链表根据指针的不同指向，分多种：</p>
<ul>
<li><p>单链表：指针指向下一个结点的地址，尾结点的指针指向<code>none</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">  value <span class="type">int</span></span><br><span class="line">  next  *LinkedList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212111147012.png" alt="image-20221212111147012"></p>
</li>
<li><p>双链表：一个指针指向下一个结点的地址，另外一个指针指向上一个结点的地址，尾结点的<code>next</code>指向<code>none</code>，头结点的<code>pre</code>指向<code>none</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">  value     <span class="type">int</span></span><br><span class="line">  pre, next *LinkedList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>环形链表：单链表下，尾结点的<code>next</code>指向头结点的地址</p>
</li>
</ul>
<p>代码实现</p>
<p>List定义：</p>
<p>单链表：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List holds the elements, where each element points to the next element</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;					<span class="comment">// list 记录头和尾结点，以及list中元素个数</span></span><br><span class="line">	first *element</span><br><span class="line">	last  *element</span><br><span class="line">	size  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> element <span class="keyword">struct</span> &#123;				<span class="comment">// 结点</span></span><br><span class="line">	value <span class="keyword">interface</span>&#123;&#125;					<span class="comment">// 结点中使用interface包含所有类型元素</span></span><br><span class="line">	next  *element						<span class="comment">// 下一个结点的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双链表：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List holds the elements, where each element points to the next and previous element</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *element</span><br><span class="line">	last  *element</span><br><span class="line">	size  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> element <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	prev  *element</span><br><span class="line">	next  *element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表实现的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> List <span class="keyword">interface</span> &#123;</span><br><span class="line">	Get(index <span class="type">int</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>)</span><br><span class="line">	Remove(index <span class="type">int</span>)</span><br><span class="line">	Add(values ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Contains(values ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span></span><br><span class="line">	Sort(comparator utils.Comparator)</span><br><span class="line">	Swap(index1, index2 <span class="type">int</span>)</span><br><span class="line">	Insert(index <span class="type">int</span>, values ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Set(index <span class="type">int</span>, value <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	containers.Container</span><br><span class="line">	<span class="comment">// Empty() bool</span></span><br><span class="line">	<span class="comment">// Size() int</span></span><br><span class="line">	<span class="comment">// Clear()</span></span><br><span class="line">	<span class="comment">// Values() []interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>增加结点</p>
<p>在第一个<code>node</code>和第二个<code>node</code>中间插入一个<code>node</code></p>
<ol>
<li>记录前一个<code>node</code>指向的下一个<code>node</code>的指针</li>
<li>将前一个<code>node</code>的指针改成指向新的<code>node</code></li>
<li>将新的<code>node</code>的指针，指向记录的指针</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212112708607.png" alt="image-20221212112708607"></p>
<p>这个操作是常数操作，事件复杂度是 <code>O(1)</code></p>
</li>
<li><p>删除结点</p>
<p>将前<code>node</code>的<code>next</code>指向被删结点的<code>next</code>即可</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212114134808.png" alt="image-20221212114134808"></p>
</li>
</ul>
<p>	</p>
<p>增加、删除的操作都不会导致其他的<code>node</code>迁移，在增删操作频繁的场景下，有很大的优势。</p>
<p>一些操作的时间复杂度：</p>
<ul>
<li><code>prepend</code>:<code>O(1)</code></li>
<li><code>append</code>:<code>O(1)</code></li>
<li><code>lookup</code>:<code>O(n)</code>，查询操作需要逐个遍历，时间复杂度取决于便利的node个数</li>
<li><code>insert</code>:<code>O(1)</code></li>
<li><code>delete</code>:<code>O(1)</code></li>
</ul>
<h3 id="跳表-Skip-List"><a href="#跳表-Skip-List" class="headerlink" title="跳表 Skip List"></a>跳表 Skip List</h3><p>跳表可以解决链表中查询操作慢的问题</p>
<p>针对链表中查询慢的情况，通过升维，或者说以空间换时间的概念，给<code>node</code>添加多个<code>next</code></p>
<p>在跳表中，增加索引的概念，通过多层索引，实现一次性跨越多个元素，增加查找效率</p>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212114840010.png" alt="image-20221212114840010"></p>
<p>第一级索引的个数是 <code>n/2</code>，第二级索引个数是 <code>n/4</code>，以此类推，第k级别索引结点的个数就是 <code>n/(2^k)</code></p>
<p>那么，当最高级的索引有2个结点，索引层级是<code>h</code>,那么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n/(2^n) = 2</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = log2(n) - 1</span><br></pre></td></tr></table></figure>

<p>也就是说，在跳表中查询数据的时间复杂度是 <code>O(log(n))</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212115133160.png" alt="image-20221212115133160"></p>
<p>当跳表在增加、删除结点之后，有些结点的指针可能指向为<code>none</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212115255293.png" alt="image-20221212115255293"></p>
<p>因此，跳表的维护成本相对而言是比较高的。</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>假设原始链表大小为n，每2个结点抽1个，每层索引的结点数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n/2,n/4,...,8,4,2</span><br></pre></td></tr></table></figure>

<p>假设原始链表大小为n，每3个结点抽1个，每层索引的结点数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n/3,n/9,...,9,3,1</span><br></pre></td></tr></table></figure>

<p>空间复杂度是 <code>O(n)</code></p>
<h3 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h3><p>在一维数据结构中，有一些典型题目</p>
<ul>
<li><p>两数之和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS8=">https://leetcode-cn.com/problems/two-sum/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双循环，便利每两个元素，时间复杂度 <code>O(n^2)</code></p>
<p>解法2：使用hash，便利的时候获取是否有<code>target-i位置元素</code>的数字在hash中，时间复杂度 <code>O(n)</code>，更优</p>
</li>
<li><p>盛水最多的容器：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udGFpbmVyLXdpdGgtbW9zdC13YXRlci8=">https://leetcode-cn.com/problems/container-with-most-water/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双循环，便利每两个元素，时间复杂度 <code>O(n^2)</code></p>
<p>解法2：头尾双角标，判断角标数字小的，该角标向中间移动，时间复杂度 <code>O(n)</code>，更优</p>
</li>
<li><p>移动0：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbW92ZS16ZXJvZXMv">https://leetcode-cn.com/problems/move-zeroes/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：再创建一个等长数组，便利数组，将非0的数字拷贝到另一个数组中，时间复杂度 <code>O(1)</code>，但是空间复杂度 <code>O(n)</code></p>
<p>解法2：双角标便利，第一个角标记录非0，第二个角标往后移动，将非0的数字移动到第一个角标上，最后将剩余数字改为0，时间复杂度 <code>O(n)</code>，空间复杂度 <code>O(1)</code></p>
</li>
<li><p>爬楼梯：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzLw==">https://leetcode.com/problems/climbing-stairs/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：找到规律，例如第3阶楼梯方法次数，为第1阶加上第2阶的总和，<code>f(n)=f(n-1)+f(n-2)</code>，类似斐波那契，而且这里不能使用递归，因为递归的时候会有很多重复的计算，因此要使用循环遍历，从1,2，…，一直计算到n，时间复杂度 <code>O(n)</code>。为了代码渐变，可以将结果放在数组里面，角标0为1，角标1为2，以此类推。</p>
<p>解法2：直接推到斐波那契公式，时间复杂度 <code>O(log(n))</code>，这个比较复杂</p>
</li>
<li><p>三数之和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvM3N1bS8=">https://leetcode-cn.com/problems/3sum/<i class="fa fa-external-link-alt"></i></span>(高频老题）</p>
<p>解法1：先排序，然后三角标，第一个角标选择i，从0开始往右直到大于0，第二个角标从i+1开始，第三个角标从最右边开始，相加之后的结果如果大于0，则将第三个角标往左边移动，减小总和；如果相加之后的结果小于0，则将第二个角标往右边移动，增大总和。总共时间复杂度为 <code>O(n^2)</code>。这题需要注意的是要去重，去重的方法可以是在便利过程中，去掉和前一次便利相同的时刻。</p>
</li>
<li><p>反转链表：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC8=">https://leetcode.com/problems/reverse-linked-list/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：迭代，由于指针要指向前一个节点，因此，迭代过程中保存前一个节点，然后迭代当前节点，时间复杂度 <code>O(n)</code>，注意，判断条件为当前节点是否为<code>nil</code>，返回的是前一个节点<code>pre</code></p>
<p>解法2：递归，将当前节点传到递归函数中进行处理，递归函数中一方面，将 <code>node.Next.Next = node</code>， 第二方面，将 <code>node.Next=nil</code>将首个<code>node</code>的<code>next</code>指向<code>nil</code>，第三方面，将最后一个<code>node</code>作为 函数返回值，从最底层递归函数返回到最上层。</p>
</li>
<li><p>两两交换链表中的节点：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc3dhcC1ub2Rlcy1pbi1wYWlycw==">https://leetcode.com/problems/swap-nodes-in-pairs<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：迭代，记录一个虚拟的<code>head</code>，用于返回<code>head.Next</code>，每次用两个<code>node</code>，<code>head.Next</code>和<code>head.Next.Next</code>进行迭代，终止条件是<code>node.Next</code>为<code>nil</code>或者<code>node.Next.Next</code>为<code>nil</code>，迭代过程中是将链表进行转换，时间复杂度 <code>O(n)</code></p>
<p>解法2：递归，两两节点处理，返回的时候，将交换后的head节点返回，用于前一对指定</p>
</li>
<li><p>环形链表：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS8=">https://leetcode.cn/problems/linked-list-cycle/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：遍历链表中所有结点，将数据存储到<code>map</code>中，查看是否有重复的</p>
<p>解法2：快慢指针，一个一次走两个结点，一个一次走一个结点，如果重叠，则表示有环</p>
</li>
<li><p>环形链表II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS1paS8=">https://leetcode.cn/problems/linked-list-cycle-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：与上一个问题一样，记录map的value为结点索引</p>
<p>解法2：与上一个问题一样，但是需要注意的是，快指针从头开始，并且每次走1步，第二次相遇的结点，即是循环开始的结点</p>
</li>
<li><p>K 个一组翻转链表：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLW5vZGVzLWluLWstZ3JvdXAvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/reverse-nodes-in-k-group/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：将链表拆开成已翻转链表和待翻转链表，在判断后续的链表是否能翻转的时候，可以确定下一个head在哪，将链表进行翻转之后，将指针一起往后移动，pre代表开始翻转链表的上一个节点，next代表需要翻转的链表</p>
<p>解法2：递归，将第k+1个节点传递到函数中进行递归，如果这个节点不存在，则返回当前节点，如果存在，则传递到函数中。递归终止条件是不满足k个节点，如果满足，则将这个节点递归，递归返回的是翻转后的head，然后将自己这个链表进行反转，最终返回的是翻转之后的头结点。</p>
</li>
<li><p>删除有序数组中的重复项：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWR1cGxpY2F0ZXMtZnJvbS1zb3J0ZWQtYXJyYXkv">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双指针，一个指针记录不同数字，另外一个指针扫描后续数字，当数字不同，将第一个指针往后移动，并且将第二个指针的数字拷贝到第一个指针的位置</p>
</li>
<li><p>轮转数组：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcm90YXRlLWFycmF5Lw==">https://leetcode-cn.com/problems/rotate-array/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：新开辟一个数组，将原数组拷贝到新的数组中，原数组中(i+k)%len的位置就是新数组的位置</p>
<p>解法2：反转数组，先反转所有元素，再翻转两个区间内<code>[:k%len]</code>和<code>[k%length:]</code>的元素，注意，这里可以将反转的函数提取出来，会简单很多</p>
</li>
<li><p>合并两个有序链表：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWVyZ2UtdHdvLXNvcnRlZC1saXN0cy8=">https://leetcode-cn.com/problems/merge-two-sorted-lists/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：迭代，遍历两个链表，选择小的一个作为next，理解简单，但是写法复杂</p>
<p>解法2：递归，比较将更大的元素和小元素的下一个丢到递归函数中，返回的是最大的，小元素的下一个指向返回的，然后返回这个小的元素</p>
</li>
<li><p>合并两个有序数组：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWVyZ2Utc29ydGVkLWFycmF5Lw==">https://leetcode-cn.com/problems/merge-sorted-array/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：比较，放入到新数组中，这个方法理解简单，但是需要额外的内存</p>
<p>解法2：逆序三指针，一个指针放在数值末尾，另外的两个指针分别是两个数组的数字末尾，两个比较之后将较大的放在第一个指针的位置，指针往前移动，最后，如果有任意一个数字为0，则直接将非0的数组拷贝到前对应数组中</p>
</li>
<li><p>两数之和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS8=">https://leetcode-cn.com/problems/two-sum/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用map记录，然后遍历数组</p>
<p>解法2：暴力枚举</p>
</li>
<li><p>移动零：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbW92ZS16ZXJvZXMv">https://leetcode-cn.com/problems/move-zeroes/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双指针，将非0的数字拷贝到前面，便利结束之后，将剩余的位置全部置0</p>
<p>解法2：双指针，将非0的数字和前面换位置，换了之后，指针向后移动</p>
</li>
<li><p>加一：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGx1cy1vbmUv">https://leetcode-cn.com/problems/plus-one/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：找到最长子串9，然后处理+1</p>
</li>
</ul>
<h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 stack</h3><p>类似于一个容器，先进后出（FIFO），添加、删除皆为 <code>O(1)</code>，查询是 <code>O(n)</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212171916859.png" alt="image-20221212171916859"></p>
<p>基于数组实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List holds the elements in a slice</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	size     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack holds elements in an array-list</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">	list *List</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于单链表实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List holds the elements, where each element points to the next element</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *element</span><br><span class="line">	last  *element</span><br><span class="line">	size  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> element <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	next  *element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack holds elements in a singly-linked-list	</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">	list *List				<span class="comment">// 由 单链表构成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈提供的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stack interface that all stacks implement</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">interface</span> &#123;</span><br><span class="line">	Push(value <span class="keyword">interface</span>&#123;&#125;)									<span class="comment">// 推入一个元素</span></span><br><span class="line">	Pop() (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)			<span class="comment">// 吐出一个元素</span></span><br><span class="line">	Peek() (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)			<span class="comment">// 获取长度</span></span><br><span class="line"></span><br><span class="line">	containers.Container</span><br><span class="line">	<span class="comment">// Empty() bool</span></span><br><span class="line">	<span class="comment">// Size() int</span></span><br><span class="line">	<span class="comment">// Clear()</span></span><br><span class="line">	<span class="comment">// Values() []interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列 queue"></a>队列 queue</h3><p>先进先出，添加、删除皆为 <code>O(1)</code>，查询是 <code>O(n)</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212171745511.png" alt="image-20221212171745511"></p>
<p>基于数组实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List holds the elements in a slice</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	size     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue holds elements in an array-list</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	list *List</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于环实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue holds values in a slice.</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	values  []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	start   <span class="type">int</span></span><br><span class="line">	end     <span class="type">int</span></span><br><span class="line">	full    <span class="type">bool</span></span><br><span class="line">	maxSize <span class="type">int</span></span><br><span class="line">	size    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于单向链表实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List holds the elements, where each element points to the next element</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *element</span><br><span class="line">	last  *element</span><br><span class="line">	size  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> element <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	next  *element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue holds elements in a singly-linked-list</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	list *List</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双端队列-deque：double-end-queue"><a href="#双端队列-deque：double-end-queue" class="headerlink" title="双端队列 deque：double end queue"></a>双端队列 deque：double end queue</h3><p>可以看做是栈和队列的结合，可以从头插入或者删除，也可以从尾部插入或者删除，添加、删除皆为 <code>O(1)</code>，查询是 <code>O(n)</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212172050483.png" alt="image-20221212172050483"></p>
<p>基于数组实现</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/deque.png" alt="双端队列图"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deque represents a single instance of the deque data structure. A Deque</span></span><br><span class="line"><span class="comment">// instance contains items of the type specified by the type argument.</span></span><br><span class="line"><span class="keyword">type</span> Deque[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	buf    []T</span><br><span class="line">	head   <span class="type">int</span></span><br><span class="line">	tail   <span class="type">int</span></span><br><span class="line">	count  <span class="type">int</span></span><br><span class="line">	minCap <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支持的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Cap() <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Len() <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> PushBack(elem T)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> PushFront(elem T)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> PopFront() T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> PopBack() T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Front() T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Back() T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> At(i <span class="type">int</span>) T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Set(i <span class="type">int</span>, item T)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Clear()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Rotate(n <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Index(f <span class="function"><span class="keyword">func</span><span class="params">(T)</span></span> <span class="type">bool</span>) <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> RIndex(f <span class="function"><span class="keyword">func</span><span class="params">(T)</span></span> <span class="type">bool</span>) <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Insert(at <span class="type">int</span>, item T)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Remove(at <span class="type">int</span>) T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> SetMinCapacity(minCapacityExp <span class="type">uint</span>)</span><br></pre></td></tr></table></figure>

<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>和所有的队列、stack一致，插入操作是 <code>O(1)</code>，取出操作是 <code>O(log(n))</code>，取出按照元素的优先级取出，底层具体实现的数据结构较为多样和复杂，例如通过列表实现的堆</p>
<p>基于列表实现堆，通过堆实现优先级，基于堆和比较器实现优先级队列，此时插入操作就不是 <code>O(1)</code>，而是 <code>O(nlogn)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue holds elements in an array-list</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	heap       *Heap</span><br><span class="line">	Comparator Comparator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Heap holds elements in an array-list</span></span><br><span class="line"><span class="keyword">type</span> Heap <span class="keyword">struct</span> &#123;</span><br><span class="line">	list       *List</span><br><span class="line">	Comparator Comparator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List holds the elements in a slice</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	size     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparator will make type assertion (see IntComparator for example),</span></span><br><span class="line"><span class="comment">// which will panic if a or b are not of the asserted type.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Should return a number:</span></span><br><span class="line"><span class="comment">//    negative , if a &lt; b</span></span><br><span class="line"><span class="comment">//    zero     , if a == b</span></span><br><span class="line"><span class="comment">//    positive , if a &gt; b</span></span><br><span class="line"><span class="keyword">type</span> Comparator <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>队列的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue interface that all queues implement</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">interface</span> &#123;</span><br><span class="line">	Enqueue(value <span class="keyword">interface</span>&#123;&#125;)								<span class="comment">// 入队</span></span><br><span class="line">	Dequeue() (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)		<span class="comment">// 出队</span></span><br><span class="line">	Peek() (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)				<span class="comment">// 获取队列长度</span></span><br><span class="line"></span><br><span class="line">	containers.Container</span><br><span class="line">	<span class="comment">// Empty() bool</span></span><br><span class="line">	<span class="comment">// Size() int</span></span><br><span class="line">	<span class="comment">// Clear()</span></span><br><span class="line">	<span class="comment">// Values() []interface&#123;&#125;</span></span><br><span class="line">	<span class="comment">// String() string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型题目-1"><a href="#典型题目-1" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>有效的括号：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYXJlbnRoZXNlcy9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/valid-parentheses/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力法，不断地将字符串中的 <code>()</code>,<code>&#123;&#125;</code>,<code>[]</code>替换成空字符串，最终看是否是空字符串</p>
<p>解法2：使用栈，将符号压栈，下一个符号是否与栈顶元素对比，栈顶记录一个随机的符号。这个方法时间复杂度 <code>O(n)</code></p>
</li>
<li><p>最小栈：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tc3RhY2sv">https://leetcode.cn/problems/min-stack/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用两个栈，一个栈放正常数据，第二个栈存放最小值</p>
</li>
<li><p>柱状图中最大的矩形：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXJnZXN0LXJlY3RhbmdsZS1pbi1oaXN0b2dyYW0v">https://leetcode.cn/problems/largest-rectangle-in-histogram/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：枚举法，从头开始索引，每次获取左右边界，也就是比他自身矮的，左边边界中间就是面积，每次记录最大面积，时间复杂度是 <code>O(n^3)</code>，会超时</p>
<p>解法2：快速枚举法，也需要利用栈的思想，核心理解逻辑是柱子的左边界，如果比左边柱子高，则左边界就是左边柱子，如果比左边低或者相等，则左边界就是比自己低的</p>
<p>解法3：使用栈，每次压入数据与栈顶数据对比，如果比栈顶数据大，则压入，如果小，则弹出栈顶元素，此时可以确定栈顶元素的右边界，为新元素，左边界为栈中下面的元素。以此计算每一个元素的大小，时间复杂度是<code>O(n)</code></p>
</li>
<li><p>滑动窗口最大值：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtLw==">https://leetcode.cn/problems/sliding-window-maximum/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力求解，嵌套循环，时间复杂度是 <code>O(n*k)</code>，这种方法会超时</p>
<p>解法2：使用单调队列，确保新加入的元素是队列中最小的，将窗口中的数据加入到单调队列中，如果新加进来的数据大于单调队列尾部，则将队列尾部的值丢掉，直到队列单调，如果小于队列尾部，则直接加入到队列尾部。当窗口移动时，需要确定单调队列头部元素是否在窗口中，因此队列中的数据为索引，并且当队列头部数据不在窗口范围内，则去掉头部。</p>
</li>
<li><p>设计循环双端队列：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZXNpZ24tY2lyY3VsYXItZGVxdWUv">https://leetcode.cn/problems/design-circular-deque/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用数组实现，左边为头部，右边为尾部，但是这种做法在插入时，或者删除时，会拷贝所有元素，可能会超时</p>
<p>解法2：使用数组加上双角标实现，一个记录头部，一个记录尾部，形成一个环，此时需要注意，<strong>环的长度是k+1，头指向的是待加入的数字，尾指向的是加入数字的前一位</strong>。Golang中的channel就是这种结构。</p>
<p>解法3：双向链表，时间复杂度都是 <code>O(1)</code>，这个是最快的</p>
</li>
<li><p>接雨水：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmFwcGluZy1yYWluLXdhdGVyLw==">https://leetcode.cn/problems/trapping-rain-water/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：将所有位置的左边高墙和右边高墙求出来，最终计算总的结果，需要注意的是，如何确定这个位置的高墙，要满足两个条件，一个条件是左边位置有高墙，第二个条件是左边位置高墙高于自身，否则左边没有高墙。</p>
<p>解法2：获取每一层能够蓄水的个数，一个一个加起来，得到最终结果，例如第一层能够蓄水的个数，第i个格子能够蓄水，条件是这个格子的左边和右边，都要高于0的墙，也就是两边向中间靠拢，寻找第一个高于0的位置，然后再在这两个位置之间找到小于等于0的个数，加起来就是第1层蓄水的个数，然后顺序找第二层蓄水的个数，依然是从左边找到第一个大于2的数，从右边找到第一个大于2的数，然后找到这两个数之间小于等于1的位置的个数，加起来就是第二层蓄水的个数，以此一直循环到最高的一层。</p>
<p>解法3：使用单调栈，如果放进去的数字比顶上的数字小，则可以直接放进去，否则将顶的数字拿出来，直到顶部的数字不小于新的数字，获取将要放进去的数字和此时顶部数字的最小值，这个最小值和拿出来的数字差就是水池高度。注意，如果栈取空了，则最后一个取出来的数字是最小值。</p>
</li>
</ul>
<h3 id="哈希表和集合以及映射"><a href="#哈希表和集合以及映射" class="headerlink" title="哈希表和集合以及映射"></a>哈希表和集合以及映射</h3><p>Hash Table，也叫散列表，是根据关键码值（Key value）而言，直接进行访问的数据结构。查询、插入、删除的时间复杂度一般是 <code>O(1)</code></p>
<p>通过把关键码值映射到表中一个为止来访问记录，以加快查找的速度</p>
<p>这个映射函数叫做<strong>散列函数</strong>（Hash Function，也叫做哈希函数），存放记录的数组叫做哈希表（或散列表）</p>
<p>例如，<code>lies</code>通过hash函数处理，总数为429，对20取模，则将这个值放到位置值为9上</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213170420074.png" alt="image-20221213170420074"></p>
<p>Hash Collisions 哈希碰撞</p>
<p>对于不同的数据，经过相同的哈希函数处理之后，得到相同的下标，这种情况就是哈希碰撞。</p>
<p>一般的处理方式是放一个链表，但是当碰撞过多，查找效率会从 <code>O(1)</code>退化到 <code>O(n)</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213170522848.png" alt="image-20221213170522848"></p>
<p>Hash表的完整结构</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213170820506.png" alt="image-20221213170820506"></p>
<p>Set，集合：不重复元素的集合，相比哈希表，没有值，只有键。</p>
<p>映射：从查找的资料看，很少单独说映射，可以理解为映射也是hash map的一种，只是相比hash map的线程不安全，映射是线程安全的。（有的资料说是通过锁实现线程安全）</p>
<h3 id="典型题目-2"><a href="#典型题目-2" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>有效的字母异位词：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtYW5hZ3JhbS9kZXNjcmlwdGlvbi8=">https://leetcode-cn.com/problems/valid-anagram/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：字符串排序，然后看排序后的字符串是否相等</p>
<p>解法2：使用hash表</p>
</li>
<li><p>字母异位词分组：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZ3JvdXAtYW5hZ3JhbXMv">https://leetcode-cn.com/problems/group-anagrams/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：先排序，然后放到hash表中</p>
</li>
<li><p>两数只和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS9kZXNjcmlwdGlvbi8lRUYlQkMlOEMlRTQlQkIlQTUlRTUlOEYlOEElRTQlQjglODklRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMlRUYlQkMlOEMlRTUlOUIlOUIlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEM=">https://leetcode-cn.com/problems/two-sum/description/，以及三数之和，四数之和<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用hash，获取target-A是不是也存在于hash中</p>
</li>
</ul>
<h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树 Tree"></a>树 Tree</h3><p>相比一维的链表或者跳表，是为了解决检索问题，通过升维的思想加快检索。</p>
<p>利用这种升维的思想，一个节点可以同时指向多个节点，这样就形成了树形结构。</p>
<p>注意：树没有环。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213174159016.png" alt="image-20221213174159016"></p>
<h3 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树 Binary Tree"></a>二叉树 Binary Tree</h3><p>在实际开发过程中，用到的最多树形结构就是二叉树，二叉树也就是说每个节点最多只有两个子节点，分别是左子结点和右子节点。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213174748681.png" alt="image-20221213174748681"></p>
<p>二叉树的遍历方式可以分为三种，都是基于递归，当没有子节点时结束递归，根据递归的顺序可以分为这三种：</p>
<p>前序（Pre-order）：根-左-右</p>
<p>中序（In-order）：左-根-右</p>
<p>后序（Post-order）：左-右-根</p>
<h3 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图 Graph"></a>图 Graph</h3><p>图也是一种树形结构，但是相比树而言，图有环形结构</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213174957329.png" alt="image-20221213174957329"></p>
<p>因此，可以这样理解，链表就是特殊化的树，树就是特殊化的图。</p>
<h3 id="二叉搜索树-Binary-Search-Tree"><a href="#二叉搜索树-Binary-Search-Tree" class="headerlink" title="二叉搜索树 Binary Search Tree"></a>二叉搜索树 Binary Search Tree</h3><p>二叉搜索树（Binary Search Tree），也称二叉查找树，有序二叉树（Ordered Binary Tree），排序二叉树（Sorted Binary Tree），是指一颗空树或者具有下列性质的二叉树：</p>
<ul>
<li>左子树上<strong>所有节点</strong>的值，均小于它的根节点的值；</li>
<li>右子树上<strong>所有节点</strong>的值，均大于它的根节点的值；</li>
<li>以此类推；左、右子树也分别为二叉搜索树。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213181228162.png" alt="image-20221213181228162"></p>
<p>使用<strong>中序遍历</strong>时，就是<strong>升序排列</strong>。</p>
<p>查询、插入操作，都是 <code>O(log(n))</code></p>
<h3 id="典型题目-3"><a href="#典型题目-3" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>二叉树的中序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1pbm9yZGVyLXRyYXZlcnNhbC8=">https://leetcode.cn/problems/binary-tree-inorder-traversal/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，按照“左-中-右”的顺序递归</p>
<p>解法2：迭代，使用栈。判断当前节点是否为空，不为空，就压栈，然后处理左边节点，不为空就压栈，直到节点为空，说明左边结束了，然后从栈中取出结点，就是便利的节点，然后处理右边的节点，处理过程与上面一致，判断是否为空，不为空就压栈。</p>
</li>
<li><p>二叉树的前序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wcmVvcmRlci10cmF2ZXJzYWwv">https://leetcode.cn/problems/binary-tree-preorder-traversal/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，这个解法比较简单，按照“中-左-右”的顺序递归</p>
<p>解法2：迭代，使用栈，判断当前节点是否为空，不为空，则放到结果中，然后将右结点压栈，节点往左边移动，直到节点为空。处理完之后，左边处理完毕，只剩下右边节点，开始接触栈，只要栈不为空，从栈中取出数据，然后按照前面的逻辑处理，判断当前节点是否为空，不为空，则当道结果中，然后将右节点压栈。这里一开始直接将root压入栈中，代码会更加漂亮。</p>
</li>
<li><p>N叉树的后序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLWFyeS10cmVlLXBvc3RvcmRlci10cmF2ZXJzYWwv">https://leetcode.cn/problems/n-ary-tree-postorder-traversal/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，按照先子节点，然后本节点的顺序递归</p>
<p>解法2：迭代，使用栈，如果有子节点，则入栈，但是还需要加一个map，用于记录循环的tag</p>
</li>
<li><p>N叉树的前序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLWFyeS10cmVlLXByZW9yZGVyLXRyYXZlcnNhbC8=">https://leetcode.cn/problems/n-ary-tree-preorder-traversal/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归</p>
<p>解法2：迭代，使用栈，如果有子节点，则入栈，便利子节点的时候，先加入到res中，然后再判断该子节点是否有子节点，依然使用map记录便利的tag</p>
</li>
<li><p>N叉树的层序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLWFyeS10cmVlLWxldmVsLW9yZGVyLXRyYXZlcnNhbC8=">https://leetcode.cn/problems/n-ary-tree-level-order-traversal/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：广度优先遍历，写一个BFS算法，入参是数组，出参数数组，过程是将入参的子节点全部都便利出来</p>
</li>
</ul>
<h2 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h2><h3 id="高级树"><a href="#高级树" class="headerlink" title="高级树"></a>高级树</h3><p>二叉树本质是一种链表，通过升维形成树结构。</p>
<p>二叉树有三种遍历方式：前序（<code>Pre-order</code>）、中序（<code>In-order</code>）、后续（<code>Post-order</code>），（可以通过根节点的顺序来理解和记忆）</p>
<p>在二叉树的基础上，满足顺序要求，左子树所有节点均小于根节点；右子树所有节点均大于根节点；其他节点以此类推。则这棵树是一个搜索二叉树，在搜索时效率很高。此时进行中序遍历就是一个升序排列。</p>
<p>但是，当搜索树的结构部平衡，变成一根棍子，此时搜索速度就会从<code>O(log(n))</code>退化到<code>O(n)</code>。那么保证二叉树的平衡性，就很重要了。</p>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>AVL树是一种自平衡二叉树，具有以下特点：</p>
<ul>
<li><p>Balance Factor（平衡因子）：</p>
<p>左子树的高度减去右子树的高度（有时相反）。balance factor &#x3D; {-1,0,1}</p>
</li>
<li><p>通过旋转操作来进行平衡（四种）</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215165518116.png" alt="image-20221215165518116"></p>
<p>为了维持平衡因子，在加入元素时</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215165636052.png" alt="image-20221215165636052" style="zoom:25%;" />

<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215165649621.png" alt="image-20221215165649621" style="zoom:25%;" />

<p>通过四种旋转操作，维持平衡因子。</p>
<ol>
<li>左旋</li>
<li>右旋</li>
<li>左右旋</li>
<li>右左旋</li>
</ol>
<p>右右子树：左旋</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215174927132.png" alt="image-20221215174927132"></p>
<p>左左子树：右旋</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215174943002.png" alt="image-20221215174943002"></p>
<p>左右子树：左右旋</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175041845.png" alt="image-20221215175041845"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175049825.png" alt="image-20221215175049825"></p>
<p>右左子树：右左旋</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175128743.png" alt="image-20221215175128743"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175154914.png" alt="image-20221215175154914"></p>
<p>总结之后：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/Tree_Rebalancing.gif" alt="Tree_Rebalancing"></p>
<p>带有子树的旋转</p>
<p>增加15	</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203032328.png" alt="image-20221215203032328" style="zoom:25%;" />

<p>加到末尾</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203103195.png" alt="image-20221215203103195" style="zoom:25%;" />

<p>先右旋</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203243856.png" alt="image-20221215203243856" style="zoom:25%;" />

<p>然后左旋</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203223503.png" alt="image-20221215203223503" style="zoom:25%;" />

<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203309163.png" alt="image-20221215203309163" style="zoom:25%;" />

<p>AVL是一个平衡二叉搜索树。（深度差距很小）</p>
<p>每个节点需要存放 <code>balcen factor = &#123;-1,0,1&#125;</code>，因此不足的是需要存储额外信息、且调整次数频繁。</p>
<p>会拥有四种旋转操作。</p>
<p>对于AVL深度差距小的平衡二叉树，衍生出来深度差距不小而二叉树，也就是近似平衡二叉树。</p>
<h3 id="红黑树-Red-Black-Tree"><a href="#红黑树-Red-Black-Tree" class="headerlink" title="红黑树 Red-Black Tree"></a>红黑树 Red-Black Tree</h3><p>红黑树是一种近似平衡的二叉搜索树（Binary Search Tree），它能够确保任何一个结点的左右子树的高度差小于两倍。具体来说，红黑树是满足如下条件的二叉搜索树：</p>
<ul>
<li>每个节点要么是红色，要么是黑色</li>
<li>根节点是黑色</li>
<li>每个叶结点（NIL结点，空结点）是黑色</li>
<li>不能有相邻的两个红色节点</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203746054.png" alt="image-20221215203746054"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203806433.png" alt="image-20221215203806433"></p>
<p>关键性质：</p>
<p>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</p>
<p>AVL树和红黑树对比</p>
<ul>
<li>AVL树比红黑树更严格的平衡，因此AVL树的查询效率更高</li>
<li>AVL树比红黑树在插入、删除操作上性能差，这也是由于AVL更严格的平衡性，会有更多的旋转操作</li>
<li>AVL树的结点上需要存储平衡因子或者高度，这些都是整数，而红黑树只需要在节点上用1个bit存储颜色</li>
<li>AVL树会运用在数据库上，会有更好的查询效率，而红黑树运用在一些语言的库中，例如<code>map</code>、映射这些数据结构中</li>
</ul>
<h3 id="布隆过滤器-Bloom-Filter"><a href="#布隆过滤器-Bloom-Filter" class="headerlink" title="布隆过滤器 Bloom Filter"></a>布隆过滤器 Bloom Filter</h3><p>在过滤重复数据的场景中，会经常使用<code>HashTable</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216093933925.png" alt="image-20221216093933925"></p>
<p>但是，在HashTable中会存储数据的<code>key</code>和<code>value</code>，相比而言，存储<code>value</code>的意义不大，并且在大数据量下，Hash冲突也会影响数据性能。因此，在这种场景下，更加适合布隆过滤器。</p>
<p>布隆过滤器由一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。</p>
<p>优点是空间效率和查询时间都远远超过一般的算法。</p>
<p>缺点是有一定的误识别率和删除困难。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216094301929.png" alt="image-20221216094301929"></p>
<p>图中，将x、y、z通过三个hash函数，得到对应的二进制位，添加到布隆过滤器中。判断w的时候，会通过hash函数判断对应二进制位是否都为1</p>
<p>存在误差的情况</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216094513742.png" alt="image-20221216094513742"></p>
<p>例如元素B，布隆过滤器查询到两个位都为1，此时会误判B已存在于布隆过滤器中。</p>
<p>因此，布隆过滤器一般用于缓存中，真正判断一个数据是否已存在，需要更准确的系统，例如数据库。</p>
<p>Golang实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个二进制数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add函数，hash之后，将对应的位置为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find函数</span></span><br><span class="line"><span class="comment">// 能找到说明可能存在</span></span><br></pre></td></tr></table></figure>

<h3 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存 Cache"></a>缓存 Cache</h3><p>缓存是为了加速数据访问，在一些性能有较大差距的情况下会使用到，例如从数据库读取数据在高并发大访问量场景下性能不高，会引入Redis缓存，又例如CPU直接访问硬盘中的数据性能低，会以内存作为缓存，又例如CPU处理数据使用内存性能低，会有L1 Cache，L2 Cache等。</p>
<p>缓存的要素取决于两个：缓存大小和替换策略。</p>
<h4 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h4><p><code>Least Recently Used</code>：最少最近优先</p>
<p>一般缓存会以<code>HashTable+Double ListedList</code>实现</p>
<p>具有 <code>O(1)</code>的查询效率</p>
<p>同时具有 <code>O(1)</code>的修改、更新效率</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216101833319.png" alt="image-20221216101833319"></p>
<h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><p>LRU：least recently used</p>
<p>LFU：least frequently used</p>
<p>更多替换算法：<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfcmVwbGFjZW1lbnRfcG9saWNpZXM=">https://en.wikipedia.org/wiki/Cache_replacement_policies<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="典型题目-4"><a href="#典型题目-4" class="headerlink" title="典型题目"></a>典型题目</h4><ul>
<li><p>LRU缓存：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9scnUtY2FjaGUvIy8=">https://leetcode.cn/problems/lru-cache/#/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：Hash表+双向链表</p>
</li>
</ul>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>在树的数据结构中，一些算法的核心操作就是利用递归。</p>
<p>递归：通过函数体来进行的循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(factorial(<span class="number">6</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际过程</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213204352351.png" alt="image-20221213204352351"></p>
<p>递归代码的结构：</p>
<ol>
<li>终止条件</li>
<li>业务逻辑</li>
<li>将一些参数传到下一层</li>
<li>清理当前层</li>
</ol>
<p>递归的思维要点：</p>
<ul>
<li>找最近<strong>重复子问题</strong>，拆解成可重复解决的问题，通过递归实现</li>
<li>使用数学归纳法思维</li>
</ul>
<h3 id="典型题目-5"><a href="#典型题目-5" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>爬楼梯：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jbGltYmluZy1zdGFpcnMv">https://leetcode.cn/problems/climbing-stairs/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归的题目，找最近重复性。例如第三级台阶等于第二级台阶的次数+第一级台阶的次数。可以用缓存递归，时间复杂度是 <code>O(n)</code></p>
<p>解法2：使用动态规划</p>
</li>
<li><p>括号生成：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZW5lcmF0ZS1wYXJlbnRoZXNlcy8=">https://leetcode.cn/problems/generate-parentheses/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用递归，递归的方法有两种，主要是根据判断条件不同，第一种方式是 <code>f(n)</code>从 <code>f(n-1)</code>中，获取插入括号的方式，注意需要去重；第二种方式是 <code>f(2n)</code>从 <code>f(2n-1)</code>中可以增加的方式，要么增加一个 <code>(</code>要么增加一个 <code>)</code>，判断增加之后是否合理即可。</p>
</li>
<li><p>反转二叉树：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnZlcnQtYmluYXJ5LXRyZWUvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/invert-binary-tree/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，反转自己的两个子节点，然后将子节点传到下一层</p>
</li>
<li><p>验证二叉搜索树：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUv">https://leetcode.cn/problems/validate-binary-search-tree/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：利用二叉树的中序遍历有序性，先便利，然后检验排序是否正确。排序检验可以使用<code>sort.SliceIsSorted</code>方法</p>
</li>
<li><p>二叉树的最大深度：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">https://leetcode.cn/problems/maximum-depth-of-binary-tree/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：深度优先，递归，将子节点传入下一层，返回最深的子节点+1</p>
</li>
<li><p>二叉树的最小深度：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">https://leetcode.cn/problems/minimum-depth-of-binary-tree/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：广度优先，迭代，迭代的是子节点</p>
</li>
<li><p>二叉树的序列化与反序列化：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZXJpYWxpemUtYW5kLWRlc2VyaWFsaXplLWJpbmFyeS10cmVlLw==">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：深度优先，题目是传入一个结点，先进行序列化，然后再进行反序列化，先通过中序遍历进行排序，反序列化成中序，然后再通过相同的方式进行反序列化，使用递归</p>
<p>解法2：广度优先，使用迭代，先进行前序遍历进行序列化，反序列化的时候需要注意，节点拿出来的时候处理这个节点的子节点</p>
</li>
<li><p>二叉树的最近公共祖先：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUv">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力法，便利两次，记录对应节点的上面所有父节点，然后获取最后一个重叠的父节点</p>
<p>解法2：DFS，使用前序遍历，先便利自身，然后左节点，然后遍历右节点，将父节点作为结果返回，需要注意的是判断条件，当自身满足，则返回自身，否则便利左节点和右节点，如果命中其中之一则返回该节点，否则判断子节点是否命中两个如果命中则返回自身，如果没有，则判断左节点是否为空（为空代表没有命中），不为空则返回左节点，否则返回右节点（这种判断条件会简化代码）</p>
</li>
<li><p>从前序与中序遍历序列构造二叉树：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtaW5vcmRlci10cmF2ZXJzYWwv">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，将数组切开，切割成左节点的数组和右节点的数组，传递到左节点和右节点中</p>
</li>
<li><p>组合：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbnMv">https://leetcode.cn/problems/combinations/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，<code>f(n,k)</code>和 <code>f(n,k-1)</code>的关系，这里需要注意，在便利数组的时候，使用append操作，可能会导致原数组扩容，出现结果异常的情况</p>
</li>
<li><p>全排列：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMv">https://leetcode.cn/problems/permutations/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，<code>f(nums)</code>和 <code>f(nums[1:])</code>的关系，每次往结果中插入一个数字，在任何地方插入</p>
</li>
<li><p>全排列 II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMtaWkv">https://leetcode.cn/problems/permutations-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：在上一题的基础上，增加数组去重</p>
</li>
</ul>
<h2 id="分治-Divide-amp-Conquer"><a href="#分治-Divide-amp-Conquer" class="headerlink" title="分治 Divide &amp; Conquer"></a>分治 Divide &amp; Conquer</h2><p>分治是从递归的思想分化而来，递归是将大问题分解为重复的小的子问题。而分治是将大问题分解为小问题，寻找小问题的重复性，最终将子问题组合，从而解决大问题。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213211610933.png" alt="image-20221213211610933"></p>
<p>分治代码模板（与递归差不多）：</p>
<ol>
<li>终止条件，也就是子问题没有了</li>
<li>处理当前逻辑</li>
<li>调用函数，下探到下一层</li>
<li>将结果组合起来</li>
<li>清理当前层状态</li>
</ol>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>采用试错的思想，尝试分步的区解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其他的可能的分步解答再来尝试寻找问题的答案。</p>
<p>回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ul>
<li>找到一个可能存在的正确的答案</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案</li>
</ul>
<p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。</p>
<h3 id="典型题目-6"><a href="#典型题目-6" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>Pow(x,n)：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3d4LW4v">https://leetcode.cn/problems/powx-n/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力法，乘以n次，时间复杂度是 <code>O(n)</code></p>
<p>解法2：分治法，将n每次对半拆开，需要注意的是需要n的奇偶性和正负性，时间复杂度是 <code>O(log(n))</code></p>
</li>
<li><p>子集：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzLw==">https://leetcode.cn/problems/subsets/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DFS，一层一层往下，产生子集，最终汇总到一起</p>
<p>解法2：两个循环，一个循环数字，另外一个循环循环已经添加上的元素</p>
<p>解法3：位运算，位数为数组长度</p>
</li>
<li><p>多数元素：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYWpvcml0eS1lbGVtZW50L2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/majority-element/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用HashMap</p>
<p>解法2：先排序，然后取中值</p>
<p>解法3：投票法，先将 <code>[0]</code>登记为答案，票数为1，然后遍历到最后，相同的数，票数+1，不同的数，票数-1，票数为0，则将下一个数登记为答案，票数为1，直到最后，剩下的数就是答案</p>
</li>
<li><p>电话号码的字母组合：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZXR0ZXItY29tYmluYXRpb25zLW9mLWEtcGhvbmUtbnVtYmVyLw==">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：分治法加迭代</p>
<p>解法2：递归，<code>f(&quot;12&quot;)</code>为1代表的字母，和 <code>f(&quot;2&quot;)</code>的组合，需要注意的是，初始化的时候，使用<code>map[uint8][]string</code></p>
</li>
<li><p>N皇后：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLXF1ZWVucy8=">https://leetcode.cn/problems/n-queens/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力回溯，先放1格，然后判断第二格是否满足，满足的时候继续下，不满足的时候，将前一格踢出去，从前一格的位置往后下</p>
<p>解法2：递归加回溯，一排一排遍历，便利的时候判断从0到n哪一个点满足放皇后，满足的话，继续递归到下一层，最终全部满足则为结果</p>
</li>
</ul>
<h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h2><p>在树或者图结构中，需要遍历所有节点、并且每个节点仅访问一次的情况下，可以使用深度优先或者广度优先处理。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214103122667.png" alt="image-20221214103122667"></p>
<p>DFS实例代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _,ok := visited[node];ok &#123;</span><br><span class="line">		<span class="comment">// already visited </span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	visited[node] = <span class="literal">true</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">// process current node </span></span><br><span class="line">  <span class="comment">// logic </span></span><br><span class="line">  <span class="comment">// 如果是一个多叉树，则需要便利所有的多叉树</span></span><br><span class="line">	dfs(node.Left)</span><br><span class="line">	dfs(node.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历顺序：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214103531661.png" alt="image-20221214103531661"></p>
<p>先从左节点（或者右节点）往下遍历，便利到最底层，最底层没有数据之后，再访问另外一边。</p>
<p>图中的遍历顺序也是一样的</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214105138027.png" alt="image-20221214105138027"></p>
<p>图中使用递归，则需要判断当前节点是否被遍历过</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _,ok := visited[node];ok &#123;</span><br><span class="line">		<span class="comment">// already visited </span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// process </span></span><br><span class="line">	visited[node] = <span class="literal">true</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// next level </span></span><br><span class="line">	<span class="keyword">for</span> _,nextNode:= <span class="keyword">range</span> node.Children &#123;</span><br><span class="line">		<span class="keyword">if</span> _,ok := visited[nextNode];!ok &#123;</span><br><span class="line">			dfs(nextNode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归写法，使用栈模拟递归</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *Node)</span></span> []*Node &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">	&#125;</span><br><span class="line">	visited := <span class="built_in">make</span>(<span class="keyword">map</span>[*Node]<span class="type">bool</span>)</span><br><span class="line">	stack := NewStack(*Node)</span><br><span class="line">	stack.Push(root)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> stack.Len != <span class="number">0</span> &#123;</span><br><span class="line">		node = stack.Pop()</span><br><span class="line">		visited[node]=<span class="literal">true</span> </span><br><span class="line"></span><br><span class="line">		process(node)</span><br><span class="line"></span><br><span class="line">		nodes := generate_related_nodes(node)</span><br><span class="line">		stack.push(nodes)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索 BFS"></a>广度优先搜索 BFS</h2><p>广度优先遍历就需要使用队列</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214105946104.png" alt="image-20221214105946104"></p>
<p>广度优先相比深度优先的顺序：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214110048812.png" alt="image-20221214110048812"></p>
<p>使用队列迭代：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(start *Node)</span></span> &#123;</span><br><span class="line">	queue := NewQueue(*Node)</span><br><span class="line">  <span class="comment">// 将start入队</span></span><br><span class="line">	queue.Push(start)</span><br><span class="line"></span><br><span class="line">	visited[start]=<span class="literal">true</span> </span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 从队列中取出，队列，先入先出</span></span><br><span class="line">		node := queue.Pop()</span><br><span class="line"></span><br><span class="line">		process(node)</span><br><span class="line"></span><br><span class="line">		nodes := generate_related_nodes(node)</span><br><span class="line">    <span class="comment">// 将子node放到队列中</span></span><br><span class="line">		queue.Push(nodes)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型题目-7"><a href="#典型题目-7" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>二叉树的层序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwvIy9kZXNjcmlwdGlvbg==">https://leetcode.cn/problems/binary-tree-level-order-traversal/#/description<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：BFS</p>
<p>解法2：使用DFS，然后记录层树</p>
<p>解法3：骚操作，直接通过脚标便利，每一层开始是<code>2^(n-1)</code>，结尾是 <code>2^(n-1)-1</code></p>
</li>
<li><p>最小基因变化：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWdlbmV0aWMtbXV0YXRpb24vIy9kZXNjcmlwdGlvbg==">https://leetcode.cn/problems/minimum-genetic-mutation/#/description<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：BFS，但是需要注意，不能往回走</p>
</li>
<li><p>在每个树行中找到最大值：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWxhcmdlc3QtdmFsdWUtaW4tZWFjaC10cmVlLXJvdy8jL2Rlc2NyaXB0aW9u">https://leetcode.cn/problems/find-largest-value-in-each-tree-row/#/description<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：BFS，使用数组记录下一层节点，记录这层节点的最大值，直到没有下一层，需要注意的是放入数组的条件</p>
</li>
<li><p>单词接龙：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLWxhZGRlci9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/word-ladder/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：与上面最小基因变化的代码一样，将start放到数组里面，然后比较数组里面能够变化而成的字母，放到新的数组里面，以此变化，注意，不能往回走，因此需要将所有便利过的单词记录下来</p>
<p>解法2：双向BFS，头和尾两端一起BFS</p>
</li>
<li><p>单词接龙 II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLWxhZGRlci1paS9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/word-ladder-ii/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：这题目相比上一题，需要打印出路径，因此最好是选择使用树形结构记录下产生的树，要使用hashmap去重。将节点与总hashmap中的元素对比查看是否可以作为子节点，如果能够作为子节点，则去掉总HashMap，但是这种解法，一般会超时</p>
<p>解法2：双向BFS</p>
</li>
<li><p>岛屿数量：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtaXNsYW5kcy8=">https://leetcode.cn/problems/number-of-islands/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DFS，删除最边缘的1</p>
<p>解法2：BFS，往上、下、左、右扩散，碰到1，就将1和周边的1全部变成0，一直到全部变成0，次数就是岛屿数量</p>
</li>
<li><p>扫雷游戏：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5lc3dlZXBlci9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/minesweeper/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DFS，递归，先判断点是不是雷，如果是，修改标记，返回，如果不是，则获取周围个数，如果个数是0，该标记，将八个方向的点递归，如果个数大于0，则标记个数，返回。</p>
</li>
</ul>
<h2 id="贪心算法-Greedy"><a href="#贪心算法-Greedy" class="headerlink" title="贪心算法 Greedy"></a>贪心算法 Greedy</h2><p>贪心算法是一种在每一步选择中都采取在<strong>当前状态下最好或最优（即最有利）的选择</strong>，从而希望导致结果是全局最好或最优的算法。</p>
<p>贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p>
<p>贪心算法可以解决一些最优化问题，如：求图中的最小生成树，求哈夫曼编码等。然后对于工程和生活中的问题，贪心算法一般不能得到所求的答案。</p>
<p>一旦一个问题可以通过贪心算法来解决，那么贪心算法一般是解决这个问题的最好办法。由于贪心算法的高效性以及其所求得的答案比较接近最有结果，贪心算法可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。比如最小生成树。</p>
<p>适用贪心算法的场景：</p>
<ul>
<li>问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。</li>
<li>相比动态规划，每个子问题的解决方案做出选择，不能回退；</li>
</ul>
<h3 id="典型题目-8"><a href="#典型题目-8" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>零钱兑换：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS8=">https://leetcode.cn/problems/coin-change/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：贪心算法，先用最大匹配，再用次大匹配。这是由于硬币是倍数。当硬币不是倍数，则不一定能使用贪心算法</p>
<p>解法2：递归，<code>f（n）=min(f(n-5),f(n-2),f(n-1)) +1</code>，也就是某一个数，等于对应硬币的最小次数，加上这枚硬币。自上而下的递归会超时，需要自下而上。</p>
</li>
<li><p>柠檬水找零：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZW1vbmFkZS1jaGFuZ2UvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/lemonade-change/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：记录5、10、20块面额钱的个数，因为只需要找5、15的面额，分别讨论即可。需要注意，贪心的是如果找15，则尽量先试用10块的面额。</p>
</li>
<li><p>买卖股票的最佳时机II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWlpL2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>重点是想到如何获取最大时机，是比较相邻两天。</p>
<p>解法1：贪心算法，只要后面1天比前面1天高，就前1天买，后1天卖。</p>
<p>解法2：动态规划，DP，其中，dp定义是一个二维数组，一位代表天数，二维代表手上有股票还是没有股票，状态转移方程是：如果今天不持有股票，则手上的钱是要么昨天有股票，将股票卖掉，要么是昨天没有股票，今天也没有，两者取最大值，<code>dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i])</code>；如果今天要持有股票，则手上的钱是昨天不持有股票的情况再买股票，或者昨天有股票的时候，两者取最小值，<code>dp[i][1] = max(dp[i-1][0]-prices[i],dp[i-1][1])</code>。</p>
</li>
<li><p>分发饼干：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3NpZ24tY29va2llcy9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/assign-cookies/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：贪心算法，先排序，优先满足胃口小的孩子，双指针，一个代表孩子，一个代表饼干</p>
</li>
<li><p>模拟行走机器人：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93YWxraW5nLXJvYm90LXNpbXVsYXRpb24vZGVzY3JpcHRpb24v">https://leetcode.cn/problems/walking-robot-simulation/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：模拟走格子即可，需要注意的是要将环境准备好，这里不需要准备二元数组作为格子，而是准备好方向，由于障碍物要一直判断，因此，需要将障碍物加入到map中</p>
</li>
<li><p>跳跃游戏：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUv">https://leetcode.cn/problems/jump-game/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：按照层数递归，贪心算法，能跳到最后一层则为true，不能则回溯，然后步数-1</p>
<p>解法2：两重循环，通过步数，更新能跳到的点，记录为true，，时间复杂度 <code>O(n^2)</code></p>
<p>解法3：贪心算法，从后往前进行贪心，时间复杂度是 <code>O(n)</code></p>
<p>解法4：记录最大的能到的地方，便利这些地方，如果有比最大的更大，则最大能到的地方更新，直接便利完最大的地方，还没有到达终点，则为不可达，便利的时候，如果最大的地点大于或者等于终点，则代表可达</p>
</li>
<li><p>跳跃游戏II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUtaWkv">https://leetcode.cn/problems/jump-game-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双指针，第一个指针从0开始，第二个指针是最大当前能够走到的步数，从指针1便利到指针2，更新最小步数，最小步数为第一个指针的步数+1，同时获取能够走到的最大下一步。更新完成之后，第一个指针移动到第二个指针的位置，第二个指针移动到最大的位置，继续便利。</p>
</li>
</ul>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找的前提：</p>
<ol>
<li>目标函数单调性（单调递增或者递减）</li>
<li>存在上下界（bounded）</li>
<li>能够通过索引访问（index accessible）（排除单链表）</li>
</ol>
<p>Golang代码模板</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearch</span><span class="params">(array []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	left, right := <span class="number">0</span>, <span class="built_in">len</span>(array)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">		mid := (left + right) / <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> array[mid] == target &#123;</span><br><span class="line">			<span class="keyword">return</span> left</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> array[mid] &gt; target &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>				<span class="comment">// 注意，这里要 -1 ，防止最终找不到</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214135650823.png" alt="image-20221214135650823"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214135808104.png" alt="image-20221214135808104"></p>
<h3 id="典型题目-9"><a href="#典型题目-9" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>x的平方根：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcXJ0eC8=">https://leetcode.cn/problems/sqrtx/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用二分法，这里的二分法需要注意，<code>end</code>为<code>x/2+1</code>，条件是<code>start&lt;=end</code>，返回的是<code>start-1</code></p>
<p>解法2：牛顿迭代法</p>
</li>
<li><p>有效的完全平方根：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wZXJmZWN0LXNxdWFyZS8=">https://leetcode.cn/problems/valid-perfect-square/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用二分法，<code>end</code>为<code>x/2+1</code>，条件是<code>start&lt;=end</code></p>
</li>
<li><p>搜索旋转排序数组：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tcm90YXRlZC1zb3J0ZWQtYXJyYXkv">https://leetcode.cn/problems/search-in-rotated-sorted-array/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用二分法和迭代，<code>(nums[start] &lt;= target &amp;&amp; target &lt;= nums[mid]) || (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[end])</code>时，说明<code>target</code>在升序的数组之间，使用二分法查找即可。其他的情况，说明也是一个旋转的数组，将头和尾再进行迭代即可，需要注意的是要判断一下当<code>target</code>不存在于这个区间的情况，</p>
</li>
<li><p>搜索二维矩阵：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtYS0yZC1tYXRyaXgv">https://leetcode.cn/problems/search-a-2d-matrix/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：先试用二分法确定行，这个其实就是将每一行的第一个元素取出来，找到最大的小于<code>target</code>的数，也就是目的行，然后再到这一行中使用二分法，是否能查询到数字</p>
</li>
<li><p>寻找旋转排序数组中的最小值：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLW1pbmltdW0taW4tcm90YXRlZC1zb3J0ZWQtYXJyYXkv">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：先排序</p>
<p>解法2：直接二分查找，关键在于需要确定小的数字在左边部分还是右边部分，时间复杂度是 <code>O(log(n))</code>。不停地寻找左边大于右边的数组，直到查找到<code>[2,1]</code>这样子的，需要注意的是，左角标往<code>mid+1</code>移动，而右角标等于<code>mid</code></p>
</li>
</ul>
<h2 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划 Dynamic Programming"></a>动态规划 Dynamic Programming</h2><p>又叫做<strong>动态递推</strong>，将一个复杂的问题，以递归的方式将它分解为简单的子问题。相比分治，分治中每一个子问题中有一个最优解，然后得到全局最优解，但是动态规划中，不需要保存这些值。动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构），共性是<strong>找到重复子问题</strong>。</p>
<p>差异性是最优子结构、中途可以淘汰次优解。</p>
<p>例如：斐波那契数列</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214143305811.png" alt="image-20221214143305811"></p>
<p>时间复杂度是 <code>O(n^2)</code>，每一个节点，都要将下面的节点计算一次，每一个下面的节点，又要将它下面的节点计算一次。</p>
<p>优化方法是做一个缓存，将已经计算过的数字，缓存起来。将时间复杂度降低到 <code>O(n)</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214143544513.png" alt="image-20221214143544513"></p>
<p>有例如走格子问题：</p>
<p>不同路径：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMv">https://leetcode.cn/problems/unique-paths/<i class="fa fa-external-link-alt"></i></span></p>
<p>不同路径II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMtaWkv">https://leetcode.cn/problems/unique-paths-ii/<i class="fa fa-external-link-alt"></i></span></p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214145242758.png" alt="image-20221214145242758" style="zoom:25%;" />

<p>从start到end的做法，其实是从A走到end的做法+从B到end的做法，这种分治的思想。</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214145426297.png" alt="image-20221214145426297" style="zoom:25%;" />

<p>还可以使用递推的思想，从结尾的地方，向上递推，每个格子的做法为相邻两个格子走法的和，</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214145854501.png" alt="image-20221214145854501" style="zoom:25%;" />

<p>边界和墙都无法走向该格子，有相邻的右边格子和下边格子才能走到对应格子，最终可以得到地图上每一个格子到end的走法</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214150158043.png" alt="image-20221214150158043" style="zoom:25%;" />

<p>动态规划关键点：</p>
<ol>
<li><p>最优子结构： <code>opt[n] = best_of(opt[n-1],opt[n-2],...)</code></p>
</li>
<li><p>存储中间状态：<code>opt[i]</code></p>
</li>
<li><p>递推公式（或者叫做状态转移方程或者DP方程）</p>
<p>Fib: <code>opt[n] = opt[n-1] + opt[n-2]</code></p>
<p>二维路径: <code>opt[i,j]=opt[i+1][j]+opt[i][j+1]</code>（且判断 <code>a[i,j]</code>是否空地）</p>
</li>
</ol>
<p>又例如最长公共子序列</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbW1vbi1zdWJzZXF1ZW5jZS8=">https://leetcode.cn/problems/longest-common-subsequence/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力求解，求两个字符串的子序列，然后两个子序列对比是否存在，时间复杂度是 <code>O(2^n)</code></p>
<p>解法2：找到重复性，看最后一个字母是否相同，如果相同，则计算减掉这个字符串之后剩余字符串的最长子序列+1，如果不相同，则随机选择一个字符串去掉一个字符，然后比较。</p>
<h3 id="典型题目-10"><a href="#典型题目-10" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>爬楼梯：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jbGltYmluZy1zdGFpcnMvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/climbing-stairs/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：<code>f(n)=f(n-1)+f(n-2)</code></p>
</li>
<li><p>三角形最小路径和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmlhbmdsZS9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/triangle/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：n层递归，每一层可以左也可以右，但是需要缓存起来</p>
<p>解法2：DP，找到重复性，定义状态数组，列出DP方程。DP可以从上往下，也可以从下往上，相比而言，从上往下理解起来更加简单。状态转移方程，其实就是对应节点的左上和右上最小的路径，外加自身的长度。<code>problem(i,j) = min(sub(i-1,j),sub(i-1,j-1))+a[i,j]</code>，需要注意的是，最左侧和最右侧的路径计算方法不一样，需要独立处理。</p>
<p>国际版推荐解法：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHJpYW5nbGUvc29sdXRpb25zLzM4NzM1L1B5dGhvbi1lYXN5LXRvLXVuZGVyc3RhbmQtc29sdXRpb25zLSh0b3AtZG93bi1ib3R0b20tdXApLi8=">https://leetcode.com/problems/triangle/solutions/38735/Python-easy-to-understand-solutions-(top-down-bottom-up)./<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>最大子数组和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXN1YmFycmF5Lw==">https://leetcode.cn/problems/maximum-subarray/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力法：起点和终点都是正数，时间复杂度是 <code>O(n)</code></p>
<p>解法2：动态规划，找到状态转移方程，其实就是看<code>dp[i-1]</code>是否大于0，如果大于0，则 <code>dp[i]=dp[i-1]+nums[i]</code>，如果小于0，则 <code>dp[i]=nums[i]</code>，<code>dp</code>记录的是数组中的最大和，最终的结果是<code>dp</code>中的最大值</p>
</li>
<li><p>乘积最大子数组：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXByb2R1Y3Qtc3ViYXJyYXkvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/maximum-product-subarray/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：动态规划，这里需要思考状态转移方程，由于有正负数和0的存在，加上这一个数字之后，要保留一个最大值和一个最小值，为了后续的负数存在，最大值乘以<code>nums[i]</code>，或者最小值乘以<code>nums[i]</code>，或者<code>nums[i]</code>本身的最大值，就是带有这个数字的数组的最大值，<code>dp[i][0]= maxInt(dp[i-1][0]*nums[i], dp[i-1][1]*nums[i], nums[i])</code>，<code>dp[i][1] =minInt(dp[i-1][0]*nums[i], dp[i-1][1]*nums[i], nums[i])</code>，最终需要便利dp，获取真正的最大值。</p>
</li>
<li><p>零钱兑换：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS8=">https://leetcode.cn/problems/coin-change/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：广度优先，寻找节点为0的节点个数</p>
<p>解法2：递归，时间复杂度 <code>O(n^2)</code></p>
<p>解法3：DP，状态转移方程是 <code>f(n) = min(f(n-1),f(n-2),f(n-5))+1</code>，也就是可以通过硬币获得本数的前一个数的最小值，这里注意，可以将amount+1作为最大值，如果无法兑换，则为最大值，最终返回结果判断是否是这个最大值，如果是最大值，则代表无法兑换。</p>
</li>
<li><p>打家劫舍：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ob3VzZS1yb2JiZXIv">https://leetcode.cn/problems/house-robber/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力法</p>
<p>解法2：DP，重复性是指每个房子可以选择偷不偷；定义状态数组从0到i间房子中偷和不偷的最大值，<code>dp[i][0]</code>代表没有偷，<code>dp[i][1]</code>代表偷了，确定第 <code>i</code>个房子偷还是不偷，不偷，则是前一个房子偷或者不偷的最大值 <code>dp[i][0] = max(dp[i-1][1],dp[i-1][0])</code>，如果偷，则是前一个房子不偷加上现在这个房子钱的总和 <code>dp[i][1] = dp[i-1][0] + nums[i]</code>，取最后一个房子偷或者不偷之间的最大值 <code>max(dp[length-1][0],dp[length-1][1])</code></p>
</li>
<li><p>打家劫舍II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ob3VzZS1yb2JiZXItaWkvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/house-robber-ii/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，但是要拆开讨论，讨论0号偷还是不偷，当0号偷的时候，那么1号就只能不偷，此时就需要从2号开始讨论dp，2号开始可以选择偷还是不偷，这个时候的最大值就是最后一家不偷。当0号不偷的时候，那么1号可以开始选择偷还是不偷，此时从2号开始讨论dp，这个之后的最大值就是最后一家偷或者不偷的最大值。最终结果就是两种情况下的最大值。</p>
</li>
<li><p>买卖股票的最佳时机：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLyMvZGVzY3JpcHRpb24=">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/#/description<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用栈，如果比栈顶小，入栈，如果比栈顶大，则说明有利润，则记录利润的数字，最终取利润的最大值</p>
<p>解法2：使用动态规划，记录第i天的利润，以及到第i天的最小值，第i天的利润要么是前一天的利润，要么是今天的价格减去最小数，两者取最大值，最终结果取利润的最大值</p>
</li>
<li><p>买卖股票的最佳时机II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWlpLw==">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用DP，二维数组，第二个维度记录当前有股票或者是没有股票对应的利润，今天有股票的利润是前一天没有股票的情况下的利润购入股票或者是前一天有股票的情况下前一天的利润，两者最大值；今天没有股票的利润是前一天没有股票的利润或者是前一天有股票今天卖掉股票的利润，两者取最大值。</p>
</li>
<li><p>买卖股票的最佳时机III：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWlpaS8=">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，二维数组，第二个维度记录当前状态，也就是第一次购入股票的最大收益、第一次卖出股票的最大收益、第二次购入股票的最大收益、第二次卖出股票的最大收益，初始化状态可以理解为第1天购入、卖出、购入、卖出，<code>dp[0] = [4]int&#123;-prices[0], 0, -prices[0], 0&#125;</code>，状态转移方程是：第i天第一次购入的最大收益，为前一天购入的最大收益和今天的价格之间，取最大值，<code>dp[i][0] = max(dp[i-1][0], -prices[i])</code>，第i天第一次售出的最大收益，收益为前一天购入的最大收益+今天的价格，最大值为前面一天售出的最大收益和今天售出的最大收益之前取最大值，<code>dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i])</code>，第i天第二次购入的最大收益，为前面一天第一次卖出的最大收益-今天的价格，和前一天第二次购入的最大收益之间的最大值，<code>dp[i][2] = max(dp[i-1][2], dp[i-1][1]-prices[i])</code>，第i天第二次售出的最大收益，为前面一天第二次购入的最大收益+今天的价格，和前一天第二次卖出之间的最大值，<code>dp[i][3] = max(dp[i-1][3],dp[i-1][2] + prices[i])</code>。</p>
</li>
<li><p>最佳买卖股票时机含冷冻期：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLXdpdGgtY29vbGRvd24v">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，二维数组，第二个维度记录当前状态，0表示今天有股票的最大收益，1表示今天没有股票的最大收益，2表示冷冻期的最大收益，初始化条件，也就是今天买入股票，或者今天不购入股票，<code>dp[0] = [3]int&#123;-prices[0], 0, 0&#125;</code>，状态转移方程，第i天有股票的最大收益，是昨天冷冻期的收益-今天股票价格，或者昨天有股票的收益，取最大值，<code>dp[i][0] = max(dp[i-1][2]-prices[i], dp[i-1][0])</code>，第i天没有股票的最大收益，是把持有的股票卖出，和昨天冷冻期，今天不购入取最大值，<code>dp[i][1] = max(dp[i-1][0]+prices[i], dp[i-1][2])</code>，第i天冷冻期的最大收益，是昨天没有股票，和昨天冷冻期的最大收益，<code>dp[i][2] = max(dp[i-1][1],dp[i-1][2])</code>，结果值是最后一天卖出或者最后一天冷冻期两者的最大值，<code>max(dp[length-1][1], dp[length-1][2])</code></p>
</li>
<li><p>买卖股票的最佳时机IV：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWl2Lw==">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，二维数组，第二个维度代表当天第i次购入的最大收益，当天第i次卖出的最大收益，第二个维度长度是2k。初始化条件是今天一次性购入k次，一次性卖出k次，这个时候的收益，也就是第1天，购入1次，卖出1次的最大收益，再次购入2次，卖出2次的最大收益，状态转移方程，需要注意的是，第i天，第一次购入的最大收益，是比较前一天第一次购入的最大收益和今天的是第一次购入的最大收益的最大值，<code>dp[i][0] = max(dp[i-1][0], -prices[i])</code>，任何一天的第一次卖出的最大收益，是比较前一天第一次购入的最大收益+今天的价格，和前一天第一次卖出的最大收益，<code>dp[i][1] = max(dp[i-1][0]+prices[i], dp[i-1][1])</code>。第i天的第j次购入的最大收益，是昨天第j-1次卖出的收益，要么昨天买了，要么昨天没买，那么今天价格，或者昨天第j次购入，和今天第j次购入，两者的最大值，<code>dp[i][2*j] = max(dp[i-1][2*(j-1)+1]-prices[i], dp[i-1][2*j])</code>，第i天的第j次卖出的最大收益，是昨天第j次购入+今天的价格，或者昨天第j次卖出，两者的最大值，<code>dp[i][2*j+1] = max(dp[i-1][2*j]+prices[i], dp[i-1][2*j+1])</code>，最终返回结果是最后1天的第k次交易 <code>dp[length-1][2*(k-1)+1]</code></p>
</li>
<li><p>买卖股票的最佳时机含手续费：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLXdpdGgtdHJhbnNhY3Rpb24tZmVlLw==">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，二维数组，第二个维度代表当天是否持有股票的最大收益，这里取卖出的时候缴纳手续费，0 代表持有股票的钱，1 代表不持有股票的钱。初始化条件，第1天购入的最大收益，卖出的最大收益，<code>dp[0] = [2]int&#123;-prices[0], 0&#125;</code>，状态转移方程，第i天，持有的最大收益，要么今天买，要么今天不买，用昨天的股票，两者取最大值，今天买，就是昨天卖出的收益-今天的价格，今天不买，就是昨天买的收益，<code>dp[i][0] = max(dp[i-1][1]-prices[i], dp[i-1][0])</code>，第i天，不持有的最大收益，要么是将昨天持有的今天卖掉，要么今天不卖，两者取最大值，今天卖，就是昨天持有的最大收入+今天的价格-今天的手续费，今天不卖，就是昨天不持有股票的最大收益，<code>dp[i][1] = max(dp[i-1][0]+prices[i]-fee, dp[i-1][1])</code>，最终结果，取最后1天不持有股票的最大收益，<code>dp[length-1][1]</code>。</p>
</li>
<li><p>完全平方根：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJmZWN0LXNxdWFyZXMv">https://leetcode.cn/problems/perfect-squares/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，一维数组，代表从0到n这几个数字的结果，从0到n计算即可。首先判断n是否是完全平方根，如果是，则结果为1，如果不是，则需要二次便利，依次减去最小平方根的数字的结果，取这些结果的最小值，<code>f(n)=min(f(n-1),f(n-4),f(n-9)...)</code>，结果为最小值+1</p>
</li>
<li><p>编辑距离：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lZGl0LWRpc3RhbmNlLw==">https://leetcode.cn/problems/edit-distance/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，二维数组，代表两个字符串，长度分别是两个字符串的长度+1，代表一个字符串转变成另外一个字符串的次数。例如s1是””，s2是””，则是0；例如s1是””，s2是”r”，则是1；例如s1是””，s2是”ro”，则是2；例如s1是””，s2是”ros”，则是3；同理，例如s1是”h”，s2是””，则是1，以此类推，就是初始化。状态转移方程，从s1到s2有三种情况，要么是加1个字符，要么是删除1个字符，要么是修改1个字符，从短到长，可以理解为s1加1个字符变成s2，s2加1个字符变成s1，s1和s2都加1个字符之后相等。如果两个字符相同，例如”ho”和”ro”，则是从”h”到”ro”，”ho”到”r”，”h”到”r”-1之间，取最小1个+1，也就是min（2,2，1-1）+1，<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]-1) + 1</code>，如果两个字符串不相同，例如”hor”和”ros”，则是从”ho”到”ros”，”hor”到”ro”，”ho”，”ro”之间，取最小1个+1，也就是min（2，,2，1）+1，<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</code>。</p>
</li>
<li><p>跳跃游戏：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUv">https://leetcode.cn/problems/jump-game/<i class="fa fa-external-link-alt"></i></span> </p>
<p>解法1：DP，一维数组，记录当前这一步是否可以达到，往数组后面便利的时候，更新能够达到的最远地点。</p>
</li>
<li><p>跳跃游戏II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUtaWkv">https://leetcode.cn/problems/jump-game-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，一维数组，记录当前这一步能够达到的最小步数，用 <code>map[int][]int</code>记录对应地点能够达到的前一个地点的最小步数，<code>dp[i]</code>为<code>map</code>中对应地点最小步数+1，初始化条件是<code>dp[0]=0</code>。</p>
</li>
<li><p>不同路径：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMv">https://leetcode.cn/problems/unique-paths/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，二维数组，记录当前这点能够达到的走法只和。初始化条件，因为只能往右和往下走，因此第0行和第0列的走法，都是1。状态转移方程，这个点，只能通过往右走和往下走能走到，因此，走到这个点的走法，就是这个点的上面和左边的点走法只和，<code>dp[i][j] = dp[i-1][j]+dp[i][j-1]</code>，最后的结果就是这个点的值，<code>dp[m-1][n-1]</code></p>
</li>
<li><p>不同路径II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMtaWkv">https://leetcode.cn/problems/unique-paths-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，二维数组，代表当前节点能够走到的方式。初始化条件，也就是初始化左边界和上边界，需要注意石头的位置，出现石头则不能再往右走或者往下走，更右边的或者更下面的，都是0。条件转移方程，有石头的地方路线为0，其他的地方，依然是左边的+上面的，<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>，最终结果为最后一个点，<code>dp[length-1][tmpl-1]</code>。</p>
</li>
<li><p>不同路径III：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMtaWlpLw==">https://leetcode.cn/problems/unique-paths-iii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DFS+回溯，先将数组遍历一遍，确定起始位置、结束位置、需要走的格子个数，这里需要注意，由于要从起始位置走到结束位置，也就是结束的位置也算1步，要走的格子个数从1算起。然后进行dfs，返回结果，dfs中，先判断是否超过格子，然后判断当前是否是障碍，再判断当前障碍是否是终点，如果是终点，判断是否一个空的格子都没有，没有格子，返回1，代表这个方案可以，如果还有空格子，就回溯，都不是，则代表这个格子可以走，将这个格子标记为-1，代表后面不能再走回来，然后将四个方向继续DFS，进行DFS的时候，除了传入下一步的格子，还有步数-1，当四个方向都DFS完，结果汇总起来，最终的结果个数就是次数。</p>
</li>
<li><p>零钱兑换：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS8=">https://leetcode.cn/problems/coin-change/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，方程为 <code>f(n)=min(f(n-1),f(n-2),f(n-5))+1</code></p>
</li>
<li><p>零钱兑换II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS1paS8=">https://leetcode.cn/problems/coin-change-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，定义一维数组，长度是<code>amount+1</code>，代表第i个数字使用钱币组成的个数。那么，第n个数组成的次数<code>f(n)=f(n-1)+f(n-2)+f(n-5)</code>，但是这里不能直接便利coins，会出现去重，思路应该是当使用<code>coins[i]</code>硬币时<code>f(n)</code>的组成个数，等于使用<code>coins[i-1]</code>硬币时n组成的次数+使用<code>coins[i]</code>时<code>f(n-coins[i])</code>的使用次数。也就是说，例如3，先用1组成，组成0有1次，组成1有1次，组成2有1次，组成3有1次，在加一块硬币2，此时，组成0有1次，组成1有1次，组成2有2次（2-2&#x3D;0,组成0的次数+使用1硬币组成2的次数&#x3D;2次），组成3有2次（3-2&#x3D;1，组成1的次数+使用1个硬币组成3的次数&#x3D;2次）。先通过遍历硬币，再便利数字，就不会出现重复，应为大硬币都是后面加上的。总结下来，思路就是要么这个数字，是小硬币组成的，要么这个数字是使用小硬币+大硬币组成，<code>dp[i] += dp[i-coin]</code>。</p>
</li>
<li><p>最长有效括号：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXZhbGlkLXBhcmVudGhlc2VzLw==">https://leetcode.cn/problems/longest-valid-parentheses/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，定义一维数组，长度是字符串的长度，代表当结尾是这个字符串时，最长合法括号字符串的长度。初始化条件，<code>（（</code>、<code>））</code>、<code>）（</code>的情况，最长都是0，只有<code>（）</code>时，<code>dp[1]</code>是2，此时最长的就是2。状态转移方程从2开始，当最后1位是）,才是一个合法的括号，倒数第二位是（，例如（（），则是2+再往前数2位的长度，倒数第二位是），例如 （（）），则要往前数1位的dp值，在字符串中查询这个dp值前1位的字符是否是（，是（，才是一个合法的括号，此时的长度就是前1位的dp+2。结果取数组中的最大值。</p>
</li>
<li><p>最小路径和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXBhdGgtc3VtLw==">https://leetcode.cn/problems/minimum-path-sum/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，定义二维数组，值是记录到该点的最短距离。初始化条件是将<code>i=0</code>和<code>j=0</code>的值确定下来，确定的方法就是加上上一个数字或者左边一个数字的值。状态转移方程是从<code>i=1</code>到<code>j=1</code>开始，结果是左边的<code>dp</code>和上面的<code>dp</code>，两者取一个小的数，加上该点本身的数。最终取右下角的数。</p>
</li>
<li><p>解码方法：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtd2F5cy8=">https://leetcode.cn/problems/decode-ways/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，定义一维数组，是加上一个字符的时候，代表的解码总数，<code>dp := make([]int, len(s)+1)</code>。初始化条件，注意，默认0位置是1，代表一个字符都没有，也是1种，用于后续给两个字符的时候相叠加，只有1个字符也是1，排除了0为首的情况，<code>dp[0], dp[1] = 1, 1</code>。状态转移方程，如果当前字符合法，则数目为加上<code>f(n-1)</code>，<code>dp[i+1] += dp[i]</code>。如果与前一个字符一起合法，则数目为加上<code>f(n-2)</code>，<code>dp[i+1] += dp[i-1]</code>。</p>
</li>
<li><p>最大正方形：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXNxdWFyZS8=">https://leetcode.cn/problems/maximal-square/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，定义dp，二维数组，代表这个点的最大正方形边长，<code>dp := make([][]int, length)</code>。最长边长为<code>res</code>。先便利两个变成，<code>i == 0 || j == 0</code>，如果为1，则该点最大正方形变长为1，<code>res</code>为1。状态转移方程，只有当本身是1，则可以是一个正方形，<code>matrix[i][j] == &#39;1&#39;</code>，最大正方形的周长，是（左边，上边，左上边）正方形最大周长中的最小值+1，<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</code>，更新最大周长，最后的值即为周长的平方。</p>
</li>
<li><p>矩形区域不超过k的最大数值和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXgtc3VtLW9mLXJlY3RhbmdsZS1uby1sYXJnZXItdGhhbi1rLw==">https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP加暴力。dp为1，1到m，n之间的数字和。先便利一遍所有的格子，计算出所有的dp，和最小值，最小值就是将小于0的数相加。如果 <code> i == 0 &amp;&amp; j == 0</code>，<code>dp[i][j] = matrix[i][j]</code>；如果 <code>i &gt; 0 &amp;&amp; j == 0</code>，<code>dp[i][j] = dp[i-1][j] + matrix[i][j]</code>，如果 <code>i == 0 &amp;&amp; j &gt; 0</code>，<code>dp[i][j] = dp[i][j-1] + matrix[i][j]</code>，都不是，则 <code>dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + matrix[i][j]</code>。这个过程可以直接判断<code>matrix[i][j]</code>和<code>dp[i][j]</code>是不是k，如果是，则直接返回，节约时间。然后开始暴力便利，将每两个格子之间的总和计算出来，逐步缩小到k，四层循环遍历，将i，j遍历两次，如果 <code>x == 0 &amp;&amp; y == 0</code>，<code>tmp = dp[i][j]</code>，如果 <code>x == 0 &amp;&amp; y &gt; 0</code>，<code>tmp = dp[i][j] - dp[i][y-1]</code>，如果 <code>x &gt; 0 &amp;&amp; y == 0</code>，<code>tmp = dp[i][j] - dp[x-1][j]</code>，如果以上都不是，<code>tmp = dp[i][j] - dp[i][y-1] - dp[x-1][j] + dp[x-1][y-1]</code>，比较tmp的最小值、k的大小，逐步靠近k的值。</p>
</li>
<li><p>青蛙过河：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9mcm9nLWp1bXAv">https://leetcode.cn/problems/frog-jump/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，定义dp代表第i个石子能够被跳到时，跳的步数，<code>map[int]map[int]bool</code>。先便利一遍所有的石子，记录石子的位置。初始化，第1颗石子能够达到，并且是0步，这样可以确保第1颗石子可以1步达到，<code>dp[0] = map[int]bool&#123;0: true&#125;</code>。状态转移方程，便利每一颗可以达到的石子的步数，分别记录步数k-1、k、k+1，能够达到的石子，记录这个石子到达的时候的步数，如果达到的石子是最后一个石子，则返回true，否则返回false。</p>
</li>
<li><p>分割数组的最大值：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGxpdC1hcnJheS1sYXJnZXN0LXN1bS8=">https://leetcode.cn/problems/split-array-largest-sum/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP+暴力，定义二维数组，第一维，代表份数，第二维，代表数字长度，值为对应份数和长度下，最大连续数组的和。初始化，第一个数字，份数为1的时候，此时的最大值，也就是直接相加。状态转移方程，从1份开始便利，长度也从i开始，<code>sub:= dp[0][j] - dp[0][m]</code>，<code>t := max(dp[i-1][m], sub)</code>，然后取<code>t</code>的最小值，<code>dp[i][j]</code>为t，结果值为dp的最后一位。</p>
</li>
<li><p>学生出勤记录II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdHVkZW50LWF0dGVuZGFuY2UtcmVjb3JkLWlpLw==">https://leetcode.cn/problems/student-attendance-record-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，定义dp，三位数组，一维代表第n次，二维代表A的次数，三位对应L的连续次数，值是对应的奖励的次数。初始化，第一天A、L、P的情况下的次数，0次A，0次L、1次L，2次L，<code>1,1,0</code>，1次A，0次L、1次L，2次L，<code>1,0,0</code>。状态转移方程，第i天，0次A，0次L，只能是昨天0次L，1次L，2次L，然后今天P，<code>dp[i][0][0] = (dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2]) % 1000000007</code>，第i天，0次A，1次L，只能是昨天0次A，0次L，<code>dp[i][0][1] = dp[i-1][0][0]</code>，第i天，0次A，2次L，只能是昨天0次A，1次L，<code>dp[i][0][2] = dp[i-1][0][1]</code>，第i天，1次A，0次L，可以是昨天0次A，0次L，1次L，2次L，然后今天A，也可以是昨天1次A，0次L，1次L，2次L，然后今天P，<code>dp[i][1][0] = (dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2] + dp[i-1][1][0] + dp[i-1][1][1] + dp[i-1][1][2]) % 1000000007</code>，第i天，1次A，1次L，只能是昨天1次A，0次L，<code>dp[i][1][1] = dp[i-1][1][0]</code>，第i天，1次A，2次L，只能是昨天1次A，1次L，<code>dp[i][1][2] = dp[i-1][1][1]</code>，最终的结果是dp最后一列的所有数之和，<code>(dp[n-1][0][0] + dp[n-1][0][1] + dp[n-1][0][2] + dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][1][2]) % 1000000007</code></p>
</li>
<li><p>任务调度器：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90YXNrLXNjaGVkdWxlci8=">https://leetcode.cn/problems/task-scheduler/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：利用桶的思想，先便利出最大值和最大值相同的数的个数。这个最大值就是桶的个数，意味着至少要循环这么多次，桶的深度是n+1，桶里面就已经放了一个任务，然后将其他的任务往里面填。最终的结果有两种情况，要么是桶子没有满，要么是桶子满了出去。当桶子没有满，则是<code>（桶子个数-1)*桶子容量</code>+最后一个桶子的容量，如果桶子满了，则代表不会出现卡主的情况，满出来的任务，可以直接在桶子之间运行，此时的时间，就是任务的总数。最终结果，取这两种情况下的最大值。</p>
</li>
<li><p>回文子串：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21pYy1zdWJzdHJpbmdzLw==">https://leetcode.cn/problems/palindromic-substrings/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP+暴力，dp定义，一维数组，代表当以第i个字符结尾时，值为回文个数。初始化，只有1个字符，回文个数为1。状态转移，<code>dp[i] = dp[i-1] + 以当前字符串结尾的回文</code>。从i-1开始往前便利，当字符串是这个的时候，判断是否是回文串。结果为<code>dp</code>的最后一个值。</p>
</li>
<li><p>最小覆盖子串：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcv">https://leetcode.cn/problems/minimum-window-substring/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：滑动窗口双指针+HashMap，先便利目标字符串，记录到HashMap中，<code>value</code>是出现次数。逐个遍历<code>s</code>，将HashMap中的<code>value--</code>，当HashMap中的值大于0，说明有一个这个字符都匹配，此时<code>n--</code>，当n为0，说明字符串全匹配，此时开始移动第二个指针，第二个指针也从0开始，往<code>i</code>移动，移动过程中，补充HashMap中的<code>value</code>，并且如果<code>value&gt;0</code>，说明此时就没有包含所有的目标字符串，此时就是最短字符，然后继续移动i，继续按照上面的逻辑。</p>
</li>
<li><p>戳气球：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idXJzdC1iYWxsb29ucy8=">https://leetcode.cn/problems/burst-balloons/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：逆向思维的DP，在<code>[i,j]</code>区间内，要想硬币最多，从后往前推导，也就是可以按照往i,j之间，往里面插入气球，计算硬币。这样的好处是可以将大问题划分为小问题，小问题之间不相互影响。组装新数组，将前后两个1插入进去。定义dp，二维数组，代表区间i，j之间，插入一个气球，得到的最大的硬币数量。初始化，计算出有一个数区间的数字，<code>[0,2],[1,3],[2,4],[3,5]</code>，计算这个区间之内，插入一个气球，得到的硬币数量。在<code>[i,j]</code>之间，插入一个气球，硬币最多，则是k从i+1到j-1的<code>max(dp[i][k]+newNums[i]*newNums[k]*newNums[j]+dp[k][j])</code>。这个里面的子系统就是<code>dp[i][k]</code>，子系统的计算，不会影响<code>dp[i][j]</code>。相比计算戳破气球，会涉及到左边界或者右边界的改动，往里面插入的思想更好。最终的结果，即是 <code>dp[0][newLength-1]</code>。</p>
</li>
</ul>
<h2 id="字典树-Trie"><a href="#字典树-Trie" class="headerlink" title="字典树 Trie"></a>字典树 Trie</h2><p>字典树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。</p>
<p>优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215100815784.png" alt="image-20221215100815784"></p>
<p>基本性质：</p>
<ol>
<li>节点本身不存完整单词；</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串</li>
<li>每个节点的所有子节点路径代表的字符都不相同</li>
</ol>
<p>节点存储额外信息</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215102021321.png" alt="image-20221215102021321"></p>
<p>节点的内部实现</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215102034053.png" alt="image-20221215102034053"></p>
<p>核心思想</p>
<p>Trie树的核心思想是空间换时间。</p>
<p>利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<h3 id="典型题目-11"><a href="#典型题目-11" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>实现Tire（前缀树）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtdHJpZS1wcmVmaXgtdHJlZQ==">https://leetcode.cn/problems/implement-trie-prefix-tree<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：通过数据结构实现。</p>
<p>数据结构中，定义HashMap或者数组，key是字符，value是前缀树，还定义一个字段设置当前是否是结尾。</p>
<p>便利过程是先判断是否有子树，如果有，则递归调用子树的逻辑。</p>
</li>
<li><p>单词搜索：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLXNlYXJjaC8=">https://leetcode.cn/problems/word-search/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力搜索+回溯。先便利数组，找到第一个首字母符合的 <code>[i,j]</code>，然后进行递归回溯，递归中，返回true的条件是 <code>word == &quot;&quot;</code>，如果不是，则说明字符串没有查询完，递归条件是 <code>i &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; n &amp;&amp; board[i][j] == word[0]</code>，如果满足，则将 <code>board[i][j] = &#39;0&#39;</code>，然后四个方向进行递归，如果递归结果为true，则直接返回，如果不为true，将 <code>board[i][j]</code>还原，也就是回溯。</p>
</li>
<li><p>单词搜索II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLXNlYXJjaC1paS8=">https://leetcode.cn/problems/word-search-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力解法，先查找字符，然后往四个反向扩散。但是这个解法，在提交后，会超时。</p>
<p>解法2：由于目标字符串过多，先将目标构建字典树，将所有的字母放到Trie中，进行扩散，然后通过DFS查询目标子串。需要注意的是，字典树的构建，是<code>child</code>下面的字符串是最终字符串，<code>t Tire</code>，如果是<code>a</code>，则是<code>t.child[&#39;a&#39;].word = a</code>。便利数组，如果字符在字典树中可以找到，则进入字典树进行DFS，依然是回溯，判断有结果的条件是 <code>tire.word != &quot;&quot;</code>，此时说明字典树中的字符串是结果。</p>
</li>
</ul>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>解决组团、配对问题，判断两个个体是不是在一个集合当中。</p>
<p>并查集的基本操作</p>
<ul>
<li><code>makeSet(s)</code>：建立一个新的并查集，其中包含s个单元素集合。</li>
<li><code>unionSet(x,y)</code>：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并</li>
<li><code>find(x)</code>：找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。</li>
</ul>
<p>初始化过程：将每个元素指向自身</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215112656150.png" alt="image-20221215112656150"></p>
<p>合并过程：将两个结合的代表结合成一个（可以对比选择小的或者大的元素）</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215112720564.png" alt="image-20221215112720564"></p>
<p>路径压缩</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215112740618.png" alt="image-20221215112740618"></p>
<p>实现并查集</p>
<h3 id="典型问题"><a href="#典型问题" class="headerlink" title="典型问题"></a>典型问题</h3><ul>
<li><p>省份数量：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtcHJvdmluY2VzLw==">https://leetcode.cn/problems/number-of-provinces/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DFS，逐次便利所有的城市，将相邻的城市之间的关联去掉，然后DFS相邻的城市。</p>
<p>解法2：BFS，逐次便利所有的城市，将相邻的城市放在第二层将要便利的待选城市中，每次便利的城市，都将<code>isConnected</code>设置为0。</p>
<p>解法3：并查集，逐次将城市插入到并查集中，最终返回并查集的个数。</p>
</li>
<li><p>岛屿数量：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtaXNsYW5kcy8=">https://leetcode.cn/problems/number-of-islands/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：前面使用了DFS，这里使用并查集，将相邻的岛屿，插入到并查集中，最终获取并查集的个数</p>
</li>
<li><p>被围绕的区域：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdXJyb3VuZGVkLXJlZ2lvbnMv">https://leetcode.cn/problems/surrounded-regions/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DFS，便利所有边界上的<code>O</code>，将这些<code>O</code>标记，最终将所有没有被标记的地方改为<code>X</code>。</p>
<p>解法2：BFS</p>
<p>解法3：并查集，将与边界相连的<code>O</code>，与这个<code>O</code>相连的<code>O</code>，都放到并查集中，最终再次便利，如果在并查集中，就改为<code>O</code>，如果不在，则改为<code>X</code>。</p>
</li>
</ul>
<h2 id="高级搜索"><a href="#高级搜索" class="headerlink" title="高级搜索"></a>高级搜索</h2><h3 id="初级搜索"><a href="#初级搜索" class="headerlink" title="初级搜索"></a>初级搜索</h3><ol>
<li><p>朴素搜索，或者叫做暴力搜索</p>
</li>
<li><p>优化方式：不重复（fibonacci）、剪枝（生成括号问题）</p>
</li>
<li><p>搜索方向：</p>
<ol>
<li>DFS：Deep First Search 深度优先搜索，一般用于判断是否存在某个结果</li>
<li>BFS：Breadth First Search 广度优先搜索，一般用于求出最短或者最优解。</li>
</ol>
<p>双向搜索、启发式搜索（通过优先队列，从优先队列中拿到优先元素进行搜索）</p>
</li>
</ol>
<h3 id="高级搜索-1"><a href="#高级搜索-1" class="headerlink" title="高级搜索"></a>高级搜索</h3><p>剪枝：将状态树中已经处理过的节点减掉。例如<code>fibonacci</code>问题中，将节点缓存起来，然后再计算的时候，就不需要重复计算这个节点。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215114752354.png" alt="image-20221215114752354"></p>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>回溯也就是分治+试错，然后回溯。回溯需要注意：1、满足条件，何时返回true。2、递归结束时，回溯之前，需要将状态还原。</p>
<h4 id="典型题目-12"><a href="#典型题目-12" class="headerlink" title="典型题目"></a>典型题目</h4><ul>
<li><p>爬楼梯：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jbGltYmluZy1zdGFpcnMv">https://leetcode.cn/problems/climbing-stairs/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：转换成<code>fibonacci</code>问题，从3开始计算，<code>f(1)=1,f(2)=2,f(n)=f(n-1)+f(n-2)</code></p>
</li>
<li><p>括号生成：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZW5lcmF0ZS1wYXJlbnRoZXNlcy8=">https://leetcode.cn/problems/generate-parentheses/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，定义长度为n的一维数组，代表括号对数是的组成次数。状态转移方程是<code>dp[n] = dp[i] + dp[n-i-1]</code>,<code>i从0到n-1</code>。</p>
<p>解法2：当做2n个格子，使用回溯法，每一个格子进行左括号和右括号的尝试。</p>
</li>
<li><p>N皇后：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLXF1ZWVucy8=">https://leetcode.cn/problems/n-queens/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：回溯，下一层尝试，通过判断列、45度、135度进行剪枝</p>
<p>推荐解法1（基于C++）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbi1xdWVlbnMvc29sdXRpb25zLzE5ODA4L0FjY2VwdGVkLTRtcy1jKystc29sdXRpb24tdXNlLWJhY2t0cmFja2luZy1hbmQtYml0bWFzay1lYXN5LXVuZGVyc3RhbmQv">https://leetcode.com/problems/n-queens/solutions/19808/Accepted-4ms-c++-solution-use-backtracking-and-bitmask-easy-understand/<i class="fa fa-external-link-alt"></i></span></p>
<p>推荐解法2（基于Python）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbi1xdWVlbnMvc29sdXRpb25zLzE5ODEwL0Zhc3Qtc2hvcnQtYW5kLWVhc3ktdG8tdW5kZXJzdGFuZC1weXRob24tc29sdXRpb24tMTEtbGluZXMtNzZtcy8=">https://leetcode.com/problems/n-queens/solutions/19810/Fast-short-and-easy-to-understand-python-solution-11-lines-76ms/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>有效的数独：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1zdWRva3UvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/valid-sudoku/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：便利数独中每一个数，便利这个数的同一行、同一列、宫内是否出现一次，这里确定了长度，可以使用数组替代map。</p>
</li>
<li><p>解数独：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWRva3Utc29sdmVyLyMvZGVzY3JpcHRpb24=">https://leetcode.cn/problems/sudoku-solver/#/description<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：回溯，暴力破解，需要剪枝，将无法放的数字排除。详细来说，就是先便利出需要填的数字，如果没有这个数字，也就是说没有 <code>.</code>，说明已经写完。如果有，则暴力获取这个地方可以填入的数字，依然是数独的规则，获取一排、一列、宫内可以填的数字，依次尝试这个数字，直到返回true，如果返回false，则替换其他的数字，如果所有的数字都试过了，则还原填入的这一格，然后回溯。</p>
</li>
</ul>
<h3 id="双向BFS"><a href="#双向BFS" class="headerlink" title="双向BFS"></a>双向BFS</h3><p>例如一个双向连接图，寻找A-L的路</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215141621887.png" alt="image-20221215141621887"></p>
<p>如果是BFS，那么就是先分层，然后扩散</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215141701546.png" alt="image-20221215141701546"><br>双向BFS，就是从A扩散，从L扩散，同时扩散，相遇的时候就是最短的</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215141748310.png" alt="image-20221215141748310"></p>
<h4 id="典型题目-13"><a href="#典型题目-13" class="headerlink" title="典型题目"></a>典型题目</h4><ul>
<li><p>单词接龙：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLWxhZGRlci8=">https://leetcode.cn/problems/word-ladder/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：BFS，多次搜索</p>
<p>解法2：双向BFS，从头和尾同时BFS，有相交点即为True</p>
</li>
</ul>
<h3 id="启发式搜索-A-Search"><a href="#启发式搜索-A-Search" class="headerlink" title="启发式搜索 A* Search"></a>启发式搜索 A* Search</h3><p>再BFS的过程中，POP出一个元素的时候，更加智能，采用有限队列，POP出优先级更高的元素，然后再扩散。</p>
<p>启发式搜索：<code>h(n)</code>，用来评价哪些节点最有希望时一个我们要找的节点，<code>h(n)</code>会返回一个非负实数，也可以认为是从节点n的目标节点路径的估计成本。</p>
<p>启发式函数是一种告知搜索方向的方法，提供了一种明智的方法来猜测哪个邻居结点会导向一个目标。</p>
<p>估价函数:<br><code>h(current_state) = distance(current_state, target_state)</code></p>
<h4 id="典型题目-14"><a href="#典型题目-14" class="headerlink" title="典型题目"></a>典型题目</h4><ul>
<li><p>二进制矩阵中的最短路径：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaG9ydGVzdC1wYXRoLWluLWJpbmFyeS1tYXRyaXgv">https://leetcode.cn/problems/shortest-path-in-binary-matrix/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP</p>
<p>解法2：BFS，将能到达的点标记成1，然后依次遍历能到达的八个方向的点。</p>
<p>解法3：<code>A*</code>，更好的扩散方式是斜向下的方向，估价函数是两点之间最小的距离</p>
<p><code>A*</code>的推荐解法：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc2hvcnRlc3QtcGF0aC1pbi1iaW5hcnktbWF0cml4L3NvbHV0aW9ucy8zMTMzNDcvQSotc2VhcmNoLWluLVB5dGhvbi8=">https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/313347/A*-search-in-Python/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>滑动谜题：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXB1enpsZS8=">https://leetcode.cn/problems/sliding-puzzle/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：BFS（DFS也可以，但是BFS更优），将所有位置能交换的位置列出来，</p>
</li>
<li><p>解数独：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWRva3Utc29sdmVyLw==">https://leetcode.cn/problems/sudoku-solver/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力，回溯。</p>
</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>在计算机中，数字表示方式和存储格式都是<strong>二进制</strong>。</p>
<p>十进制和二进制转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4(d): 0100 </span><br><span class="line">8(d): 01000 </span><br><span class="line">5(d): 0101 </span><br><span class="line">6(d): 0110</span><br></pre></td></tr></table></figure>

<p>位运算符</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>运算符</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>左移</td>
<td><code>&lt;&lt;</code></td>
<td><code>0011 =&gt; 0110</code></td>
</tr>
<tr>
<td>右移</td>
<td><code>&gt;&gt;</code></td>
<td><code>0110 =&gt; 0011</code></td>
</tr>
<tr>
<td>按位或</td>
<td>&#96;</td>
<td>&#96;</td>
</tr>
<tr>
<td>按位与</td>
<td><code>&amp;</code></td>
<td>0011  <br />——- &#x3D;&gt; 0011<br />1011</td>
</tr>
<tr>
<td>按位取反</td>
<td><code>~</code></td>
<td><code>0011 =&gt; 1100</code></td>
</tr>
<tr>
<td>按位异或(相同为零不同为一)</td>
<td><code>^</code></td>
<td>0011  <br />——- &#x3D;&gt; 1000<br />1011</td>
</tr>
</tbody></table>
<h3 id="异或-XOR"><a href="#异或-XOR" class="headerlink" title="异或 XOR"></a>异或 XOR</h3><p>相同为0，不同为1，也可用 “不进位加法”来解释。</p>
<p>异或操作的一些特点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x ^ 0 = x</span><br><span class="line">x ^ 1s = ~x  （1s代表全1）(~x代表取反)</span><br><span class="line">x ^ (~x) = 1s</span><br><span class="line">x ^ x = 0 </span><br><span class="line">c = a ^ b ==&gt;  a ^ c = b,b ^ c = a 			// 交换两个数</span><br><span class="line">a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c		// associative，相连的</span><br></pre></td></tr></table></figure>

<p>指定位置的位运算(0开始到n位)</p>
<ol>
<li>将x最右边的n位清零： <code>x &amp;(~0 &lt;&lt; n)</code></li>
<li>获取x的第n位值（0或者1）：<code>(x &gt;&gt; n ) &amp; 1</code></li>
<li>获取x的第n位的幂值：<code>x &amp; (1 &lt;&lt; (n -1 ))</code></li>
<li>仅将第n位置为1：<code>x|(1 &lt;&lt; n)</code></li>
<li>仅将第n位置为0：<code>x&amp;~(1 &lt;&lt; n)</code></li>
<li>将x最高位至第n位（含）清零：<code>x &amp; ((1 &lt;&lt; n) - 1)</code></li>
<li>将第n位至第0位（含）清零：<code>x &amp; (~((1 &lt;&lt; (n + 1)) -1))</code></li>
</ol>
<h3 id="位运算要点"><a href="#位运算要点" class="headerlink" title="位运算要点"></a>位运算要点</h3><ul>
<li><p>判断奇偶</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x % 2 == 1 --&gt; (x &amp; 1) == 1</span><br><span class="line">x % 2 == 0 --&gt; (x &amp; 0) == 0 </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>x &gt;&gt; 1 --&gt; x / 2</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = x / 2  --&gt; y = x &gt;&gt; 1;</span><br><span class="line">// 例如二分法取中间，可以使用位操作</span><br><span class="line">mid  = (left + right) / 2 --&gt; mid = (left + right) &gt;&gt; 1;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>y = x&amp;(x - 1)</code>清零最低位的1</p>
</li>
<li><p><code>x &amp; -x</code>可以得到最低位的1（负数是取反然后+1）</p>
</li>
<li><p><code>x&amp;~x == 0</code></p>
</li>
</ul>
<h4 id="典型题目-15"><a href="#典型题目-15" class="headerlink" title="典型题目"></a>典型题目</h4><ul>
<li><p>位1的个数：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtMS1iaXRzLw==">https://leetcode.cn/problems/number-of-1-bits/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：循环n次，不可取</p>
<p>解法2：向右移动，取模或者与1；或者将1往左移动，与目标数取模，如果等于左移的1，则说明该位有1。</p>
<p>解法3：当x大于0时，打掉最后的1，循环次数为结果，最右</p>
</li>
<li><p>2的幂：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3dlci1vZi10d28v">https://leetcode.cn/problems/power-of-two/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：打掉最后一位的1，然后判断是否为0。或者直接判断这个数字是否是幂，就是<code>n&amp;(n-1)==0</code>，说明是2的幂</p>
</li>
<li><p>颠倒二进制位：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWJpdHMv">https://leetcode.cn/problems/reverse-bits/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：用位运算，从0位开始，如果是1，则将第n位的数字移动到对应<code>31-n</code>位。</p>
</li>
<li><p>N皇后：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLXF1ZWVucy9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/n-queens/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用位运算取代数组</p>
</li>
<li><p>N皇后II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLXF1ZWVucy1paS9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/n-queens-ii/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：与N皇后题目一样，只是返回结题次数。</p>
</li>
<li><p>比特位计数：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudGluZy1iaXRzL2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/counting-bits/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP+位运算</p>
<p>解法2：位运算，不停地打掉最后一位1，也就是 <code>x &amp;= x - 1</code></p>
</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>排序算法分为两类：</p>
<ol>
<li><p>比较类排序</p>
<p>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 <code>O(nlog(n))</code>，因此也称为非线性时间比较类排序。</p>
</li>
<li><p>非比较类排序</p>
<p>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p>
</li>
</ol>
<p>排序算法分类：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216102928839.png" alt="image-20221216102928839"></p>
<p>排序算法的时间复杂度</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216102957766.png" alt="image-20221216102957766"></p>
<p>其中，比较重要的是三种 <code>O(nlog(n))</code>的时间复杂度：堆排序、快速排序、归并排序。</p>
<p>排序过程图：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudXNmY2EuZWR1L35nYWxsZXMvdmlzdWFsaXphdGlvbi9BbGdvcml0aG1zLmh0bWw=">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html<i class="fa fa-external-link-alt"></i></span></p>
<p>【简单明了】9种经典排序算法可视化动画：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2MjUxMzYyNzIv">https://www.bilibili.com/video/av25136272/<i class="fa fa-external-link-alt"></i></span></p>
<p>6分钟看完15种排序算法动画展示：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2NjM4NTEzMzYv">https://www.bilibili.com/video/av63851336/<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="初级排序-O-n-2"><a href="#初级排序-O-n-2" class="headerlink" title="初级排序 O(n^2)"></a>初级排序 <code>O(n^2)</code></h3><ul>
<li><p>选择排序 Selection Sort</p>
<p> <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015224719590-1433219824.gif" alt="img"></p>
<p> 每次找最小值，然后放到待排序数组的起始位置：第1次循环从0开始，找到最小的数字，与位置0互换，第二次循环，从1开始，找到最小的数字，与位置1互换，依次类推</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectSort</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(s); j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> s[j] &lt; s[i] &#123;</span><br><span class="line">				s[i], s[j] = s[j], s[i]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入排序 Insertion Sort</p>
<p> <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015225645277-1151100000.gif" alt="img"></p>
<p> 从前到后逐步构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入：第一次循环，从位置1开始，与位置0排序，第二次循环，从位置2开始，与位置1、位置0比较，查询其中，以此类推</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSort</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		tmp := s[i]</span><br><span class="line">		j := i</span><br><span class="line">		<span class="keyword">for</span> ; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">			<span class="keyword">if</span> tmp &gt; s[j] &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">copy</span>(s[j+<span class="number">2</span>:i+<span class="number">1</span>], s[j+<span class="number">1</span>:i])</span><br><span class="line">		s[j+<span class="number">1</span>] = tmp</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>希尔排序 Shell Sort</p>
<p> <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20180331170017421-364506073.gif" alt="img"></p>
<p> 是简单插入排序的改进版，与插入排序不同之处在于，会优先比较距离远的元素。希尔排序又叫做缩小增量排序</p>
<p> 先将队列个数除以2，作为增量因子，间隔增量因子的数进行选择排序；第二遍将增量因子除以2，再次进行插入排序，依次类推，都进行插入排序，直到增量因子等于1</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(s) / <span class="number">2</span>; i &gt; <span class="number">0</span>; i = i / <span class="number">2</span> &#123;</span><br><span class="line">		<span class="comment">// 切割每一个分段</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">			<span class="comment">// golang 使用插入排序不友好，改成使用选择排序，将每一个间隔进行排序</span></span><br><span class="line">			<span class="keyword">for</span> m := j; m &lt; <span class="built_in">len</span>(s); m += i &#123;</span><br><span class="line">				<span class="keyword">for</span> n := m + i; n &lt; <span class="built_in">len</span>(s); n += i &#123;</span><br><span class="line">					<span class="keyword">if</span> s[m] &gt; s[n] &#123;</span><br><span class="line">						s[m], s[n] = s[n], s[m]</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>冒泡排序 Bubble Sort</p>
<p> <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015223238449-2146169197.gif" alt="img"></p>
<p> 嵌套循环，每次查看相邻的元素如果逆序，则交换：每次选择相邻两个数字排序，将数字大的放在后面，第一次循环之后，最大元素放在最后；下次再从0开始。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="高级排序-O-nlog-n"><a href="#高级排序-O-nlog-n" class="headerlink" title="高级排序 O(nlog(n))"></a>高级排序 <code>O(nlog(n))</code></h3><ul>
<li><p>快速排序 Quick Sort</p>
<p> <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015230936371-1413523412.gif" alt="img"></p>
<p> 数组取标杆 pivot，将小元素放pivot左边，大元素放右边，然后依次对右边和右边的子数组继续快排；以达到整个序列有序。：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
<li><p>归并排序 Merge Sort 分治</p>
<p> <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015230557043-37375010.gif" alt="img"></p>
<p> 可以看作是快排的逆向操作</p>
<ol>
<li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列</li>
<li>对这两个子序列分别采用归并排序</li>
<li>将两个子序列合并成一个最终的排序序列</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
<li><p>堆排序 Heap Sort</p>
<p> <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015231308699-356134237.gif" alt="img"></p>
<p> 堆插入 <code>O(log(n))</code>，取最大&#x2F;小值 <code>O(1)</code></p>
<ol>
<li>数组元素依次建立小顶堆</li>
<li>依次取堆顶元素，并删除</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="特殊排序-O-n"><a href="#特殊排序-O-n" class="headerlink" title="特殊排序 O(n)"></a>特殊排序 <code>O(n)</code></h3><ul>
<li><p>计数排序 Counting Sort</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015231740840-6968181.gif" alt="img"></p>
<p>要求输入的数据必须时有确定范围的整数，将输入的数据值转化为键存储在额外开辟的数组空间中；然后依次把计数大于1的填充回原数组</p>
</li>
<li><p>桶排序 Bucket Sort</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015232107090-1920702011.png" alt="img"></p>
<p>原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）</p>
</li>
<li><p>基数排序 Radix Sort</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015232453668-1397662527.gif" alt="img"></p>
<p>按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。</p>
</li>
</ul>
<h3 id="典型题目-16"><a href="#典型题目-16" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>数组的相对排序：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZWxhdGl2ZS1zb3J0LWFycmF5Lw==">https://leetcode.cn/problems/relative-sort-array/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：hash+排序，其中hash用于区别已经存在的数字，排序是当数字不存在时需要进行升序排序，排序过程方法有很多种，可以是使用堆，也可以用二分法寻找第一个大于本数的index，或者最简单的比较排序，然后copy。</p>
</li>
<li><p>有效的字母异位词：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1hbmFncmFtLw==">https://leetcode.cn/problems/valid-anagram/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用快排，将字符串进行排序</p>
<p>解法2：使用数组，将字节码作为角标，最终判断数组是否相等</p>
</li>
<li><p>合并区间：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1pbnRlcnZhbHMv">https://leetcode.cn/problems/merge-intervals/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：先排序，然后合并</p>
<p>解法2：一个一个往结果中合并，情况有三种，<code>interval[0] &gt;= res[i][0] &amp;&amp; interval[0] &lt;= res[i][1]</code>，<code>interval[1] &gt;= res[i][0] &amp;&amp; interval[1] &lt;= res[i][1]</code>，<code>interval[1] &gt;= res[i][1] &amp;&amp; interval[0] &lt;= res[i][0]</code>，然后进行递归</p>
</li>
<li><p>翻转对：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXBhaXJzLw==">https://leetcode.cn/problems/reverse-pairs/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力法，两个嵌套循环，时间复杂度是 <code>O(n^2)</code>。这种解决方案会超时</p>
<p>解法2：归并排序，<code>O(nlog(n))</code></p>
<p>解法3：树状数组，<code>O(nlog(n))</code></p>
</li>
</ul>
<h2 id="高级动态规划"><a href="#高级动态规划" class="headerlink" title="高级动态规划"></a>高级动态规划</h2><p>DP顺推</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func DP()&#123;</span><br><span class="line">	dp := [][] // 二维情况</span><br><span class="line">	</span><br><span class="line">	for i:=0;i&lt;M;i++ &#123;</span><br><span class="line">		for j = 0;j&lt;M;j++ &#123;	// dp状态方程和递推公式</span><br><span class="line">			dp[i][j] = Function(dp[i][j]...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return dp[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DP在处理一些具有重复子问题的场景非常有效</p>
<p>例如：</p>
<ul>
<li><p>爬楼梯问题</p>
<p>递归公式：<code>f(n) = f(n - 1) + f(n - 2) , f(1) = 1, f(0) = 0</code></p>
</li>
<li><p>爬格子问题</p>
<p>递归公式：<code>f(x, y) = f(x-1, y) + f(x, y-1)</code></p>
</li>
<li><p>打家劫舍问题</p>
<p>状态定义方式：<code>max $ of robbing A[0 -&gt; i]</code></p>
<p>递归公式：<code>dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])</code></p>
<p>通过多加一个维度，记录偷了还是没偷的状态。</p>
<p><code>dp[i][0]</code>状态定义：<code>max $ of robbing A[0 -&gt; i] 且没偷 nums[i]</code></p>
<p><code>dp[i][1]</code>状态定义：<code>max $ of robbing A[0 -&gt; i] 且偷了 nums[i]</code></p>
<p>递归公式：<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);</code></p>
<p><code>dp[i][1] = dp[i - 1][0] + nums[i];</code></p>
<p>这种升维的解法，在高级动态规划的场景中会经常使用到。</p>
</li>
<li><p>最小路径和</p>
<p><code>dp[i][j]</code>状态的定义: <code>minPath(A[1 -&gt; i][1 -&gt; j])</code></p>
<p>递归公式：<code>dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + A[i][j]</code></p>
<p>以及可以再考虑中间有障碍物的情况</p>
</li>
<li><p>股票买卖问题</p>
<p>统一解决思路：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrL3NvbHV0aW9uL3lpLWdlLWZhbmctZmEtdHVhbi1taWUtNi1kYW8tZ3UtcGlhby13ZW4tdGktYnktbC0zLyVFMyU4MCU4Mg==">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/。<i class="fa fa-external-link-alt"></i></span></p>
<p>状态定义：<code>dp[i][k][0 or 1] (0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= K)</code></p>
<p><code>i</code>为天数</p>
<p><code>k</code>为最多交易次数</p>
<p><code>[0,1]</code>为是否持有股票</p>
<p>状态转移方程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) </span><br><span class="line">							max( 选择 rest , 选择 sell )</span><br></pre></td></tr></table></figure>

<p>解释:今天我没有持有股票，有两种可能:</p>
<ol>
<li>我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有; </li>
<li>我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) </span><br><span class="line">							max( 选择 rest , 选择 buy )</span><br></pre></td></tr></table></figure>

<p>解释:今天我持有着股票，有两种可能:</p>
<ol>
<li>我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票;</li>
<li>我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</li>
</ol>
<p>总结出来，初始状态:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[-1][k][0] = dp[i][0][0] = 0</span><br><span class="line">dp[-1][k][1] = dp[i][0][1] = -infinity</span><br></pre></td></tr></table></figure>

<p>状态转移方程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span><br><span class="line">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br></pre></td></tr></table></figure></li>
</ul>
<p>解决DP问题的核心是找到状态定义方式，和递归公式。</p>
<h3 id="复杂度提升"><a href="#复杂度提升" class="headerlink" title="复杂度提升"></a>复杂度提升</h3><ol>
<li>状态拥有更多维度（二维、三位、或者更多、甚至需要压缩）</li>
<li>状态方程更加复杂</li>
</ol>
<p>例如：</p>
<ul>
<li><p>爬楼梯问题改进</p>
<ul>
<li>一次可以走1次、2次和3次：解法差不多</li>
<li>每次步伐限定是某几个整数：解法差不多</li>
<li>前后不能走相同的步伐：需要升维，记录当前阶梯是第几步走上来的</li>
</ul>
</li>
<li><p>编辑距离：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lZGl0LWRpc3RhbmNlLw==">https://leetcode.cn/problems/edit-distance/<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><p>解法1：双端BFS，长度向中间逼近</p>
</li>
<li><p>高级DP：</p>
<p>如果<code>word1[i]</code>与<code>word2[j]</code>相同，则<code>dp[i][i]=dp[i-1][j-1]</code></p>
<p>如果<code>word1[i]</code>与<code>word2[j]</code>不相同，那么 <code>dp[i][j]</code>可以通过</p>
<ol>
<li>在 <code>dp[i-1][j-1]</code>的基础上做<code>replace</code>操作达到目的</li>
<li>在 <code>dp[i-1][j]</code>的基础上做<code>insert</code>操作达到目的</li>
<li>在 <code>dp[i][j-1]</code>的基础上做<code>delete</code>操作达到目的</li>
</ol>
<p>取三者最小情况即可</p>
</li>
</ul>
</li>
</ul>
<h3 id="典型问题-1"><a href="#典型问题-1" class="headerlink" title="典型问题"></a>典型问题</h3><ul>
<li><p>使用最小花费爬楼梯：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tY29zdC1jbGltYmluZy1zdGFpcnMv">https://leetcode.cn/problems/min-cost-climbing-stairs/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，定义DP，为爬到这一层的最少花费；从第二层开始遍历；状态转移方程，第i层，可以由i-1层爬过来，也可以从i-2层爬过来，两者取最小值，<code>dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])</code>；最终返回dp最后一个数。</p>
</li>
<li><p>最长递增子序列：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWluY3JlYXNpbmctc3Vic2VxdWVuY2Uv">https://leetcode.cn/problems/longest-increasing-subsequence/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，dp代表当下序列的最长递增子序列，便利<code>nums</code>时，需要判断之前的<code>dp</code>值，<code>nums[i] &gt; nums[j] &amp;&amp; dp[j] &gt; max</code>时，更新最大值，<code>dp</code>为最大值+1，最终结果取最大值。</p>
</li>
<li><p>解码方法：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtd2F5cy8=">https://leetcode.cn/problems/decode-ways/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，代表当前子字符长度的字符串代表的解码次数，需要注意的是状态转移方程，需要处理的是这个字符是否有二义性，也就是1开头、2开头、0开头。</p>
</li>
<li><p>最长有效括号：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXZhbGlkLXBhcmVudGhlc2VzLw==">https://leetcode.cn/problems/longest-valid-parentheses/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，代表当前字符串长度的最长有效括号长度，状态转移方程，是指右括号结尾，加上左边的符合长度以及做括号，或者左边括号+左边的dp</p>
</li>
<li><p>最大矩阵：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXJlY3RhbmdsZS8=">https://leetcode.cn/problems/maximal-rectangle/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：数据降维和单调栈，先将二维数据降低到多个一维，然后题目变成计算柱状图中最大的矩形。</p>
<p>这里需要额外注意计算柱状图的解法：</p>
<ol>
<li>使用单调递增栈</li>
<li>每一个<code>index</code>都会入栈，也会出栈</li>
<li>出栈的时候，计算面积，因为此时，右边界就是i，高度就是自身的高度，左边界就是新的栈顶，这里需要注意，面积的算法是<code>(i - stack[len(stack)-1]-1) * array[out]</code>，有一个<code>-1</code></li>
<li>便利完了之后，还需要处理最终的栈，将栈中所有元素依次出栈，出栈的时候计算面积，计算方式与上面一样，只是右边界变成了<code>len(array)</code></li>
</ol>
</li>
<li><p>不同的子序列：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaXN0aW5jdC1zdWJzZXF1ZW5jZXMv">https://leetcode.cn/problems/distinct-subsequences/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：dp，二维数组，从空字符串开始，一直到最终两个字符串的结果，当字符相等，<code>dp[i][j] = dp[i-1][j] + dp[i-1][j-1]</code>，当字符不想等，<code>dp[i][j] = dp[i-1][j]</code></p>
</li>
<li><p>赛车：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yYWNlLWNhci8=">https://leetcode.cn/problems/race-car/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，记录到target的次数，首先记录一直加速的情况下，可以达到的距离，加速1次，2次，3次。。。到达的距离，这些点的次数最小就是一直加速。继续加速的下一个地方，就是<code>position</code>，如果是终点，则直接返回。开始便利dp，从2开始。状态转移，从第2个位置开始，走到第i个位置时，要么是加速到k+1次之后，往回走，也是重复子问题；要么走到终点找不到往回走的点，此时就是在position位置返回；要么是加速k-1次之后，往回走，往回走0次、1次、2次，然后重复子问题。至于说往回走多少步，就需要便利。最终结果取dp的target位。</p>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在不同的语言中，字符串属性不同。例如在C#、Python、Java、Golang中，String是不可变的，改变了内容之后，会创建一个新的string。而C++、PHP这些语言中，是可变的。</p>
<p>遍历字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s := <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(s);i++&#123;</span><br><span class="line">  fmt.Println(s[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = &quot;abc&quot;</span><br><span class="line">var y = &quot;abc&quot;</span><br><span class="line">fmt.Println(x == y)</span><br></pre></td></tr></table></figure>

<p>字符串转换大小写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings.ToUpper(s)</span><br><span class="line">strings.ToLower(s)</span><br></pre></td></tr></table></figure>

<p>字符串转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ss := []byte(s)</span><br><span class="line">res := string(ss)</span><br></pre></td></tr></table></figure>

<p>字符串判断是否是字母</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ss := []byte(s)</span><br><span class="line">unicode.IsLetter(rune(ss[i]))</span><br></pre></td></tr></table></figure>

<h3 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h3><p>可以理解为两个字符串，其中一个在另外一个中出现的位置</p>
<ol>
<li><p>暴力法，先循环，匹配第一个首字母之后，再继续匹配后面的字母。这个方法不好，可以优化</p>
</li>
<li><p>Rabin-Karp算法：使用子串的hash值进行对比加速，去掉第二层的循环，解决的巧妙方法是是使用滑动窗口机制取hash</p>
</li>
<li><p>KMP算法：用来找已经匹配上的子串的最大前缀和最大后缀，也就是利用已知短字符串的信息，跳过已经比较过的位置。<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDEzLzA1L0tudXRoJUUyJTgwJTkzTW9ycmlzJUUyJTgwJTkzUHJhdHRfYWxnb3JpdGhtLmh0bWw=">https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2MTE4NjY0NjAvP2Zyb209c2VhcmNoJnNlaWQ9MTc0MjU4NzUzNDU2NTM4NjIxNzE=">https://www.bilibili.com/video/av11866460/?from=search&seid=17425875345653862171<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ol>
<h3 id="典型问题-2"><a href="#典型问题-2" class="headerlink" title="典型问题"></a>典型问题</h3><ul>
<li><p>转换成小写字母：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90by1sb3dlci1jYXNlLw==">https://leetcode.cn/problems/to-lower-case/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：直接 <code>strings.ToLower(s)</code></p>
</li>
<li><p>最后一个单词的长度：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZW5ndGgtb2YtbGFzdC13b3JkLw==">https://leetcode.cn/problems/length-of-last-word/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：便利字符串，从尾到头开始便利，记录开始和结尾。需要注意的是，需要判断是否便利到结尾，如果便利到，结果为 <code>start - end</code>，如果没有便利到，结果为 <code>start + 1</code></p>
</li>
<li><p>宝石与石头：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qZXdlbHMtYW5kLXN0b25lcy8=">https://leetcode.cn/problems/jewels-and-stones/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用数组，记录所有的宝石，代替HashMap，可以节省速度。</p>
</li>
<li><p>字符串中的第一个唯一字符：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maXJzdC11bmlxdWUtY2hhcmFjdGVyLWluLWEtc3RyaW5nLw==">https://leetcode.cn/problems/first-unique-character-in-a-string/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双循环，时间复杂度 <code>O(n^2)</code></p>
<p>解法2：使用map，找重复，性能上，使用有限数组性能更好</p>
<p>解法3：字母对应下标统计，找到第一个下标是1的字母</p>
</li>
<li><p>字符串转换整数：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdHJpbmctdG8taW50ZWdlci1hdG9pLw==">https://leetcode.cn/problems/string-to-integer-atoi/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：便利字符串，通过条件判断出现各种符号时的逻辑</p>
</li>
<li><p>最长公共前缀：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbW1vbi1wcmVmaXgvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/longest-common-prefix/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：纯暴力，选取第一个字符串为初始共同序列和长度，以此遍历第二个字符串，并且更新长度。</p>
<p>解法2：行列遍历</p>
<p>解法3：Trie，将所有字符串放到Trie中</p>
</li>
<li><p>反转字符串：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXN0cmluZy8=">https://leetcode.cn/problems/reverse-string/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：头指针、尾指针转换</p>
</li>
<li><p>反转字符串II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXN0cmluZy1paS8=">https://leetcode.cn/problems/reverse-string-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双指针，第一个指针是k的倍数，第二个指针是第一个指针+k，或者到最末尾，将两个指针之间的字符串反转。</p>
</li>
<li><p>反转字符串中的单词：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXdvcmRzLWluLWEtc3RyaW5nLw==">https://leetcode.cn/problems/reverse-words-in-a-string/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：通过空格切割成数组，然后转换，然后组合成string</p>
<p>解法2：先反转整个字符串，单后单独反转每个单词</p>
</li>
<li><p>反转字符串中的单词III：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXdvcmRzLWluLWEtc3RyaW5nLWlpaS8=">https://leetcode.cn/problems/reverse-words-in-a-string-iii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：先切割成单个字符串，反转该字符串。</p>
</li>
<li><p>仅仅反转字符串：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLW9ubHktbGV0dGVycy8=">https://leetcode.cn/problems/reverse-only-letters/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双指针，转换为数组，然后跟<code>rune</code>格式对比是否是字母，移动双指针</p>
</li>
<li><p>有效的字母异位词：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1hbmFncmFtLw==">https://leetcode.cn/problems/valid-anagram/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用有限数组记录字母个数，然后对比，相比使用HashMap效率更高</p>
</li>
<li><p>字母异位词分组：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncm91cC1hbmFncmFtcy8=">https://leetcode.cn/problems/group-anagrams/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：先排序，然后判断是否相等</p>
<p>解法2：使用有限数组来区分是否是异位词</p>
</li>
<li><p>找到字符串中所有字母异位词：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1hbmFncmFtcy1pbi1hLXN0cmluZy8=">https://leetcode.cn/problems/find-all-anagrams-in-a-string/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：排序，然后判断是否相等在，这种做法会超时</p>
<p>解法2：滑动窗口+有序数组，使用滑动窗口字符组成的数组是否相等，如果相等，则说明是异位词</p>
</li>
<li><p>验证回文串：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYWxpbmRyb21lLw==">https://leetcode.cn/problems/valid-palindrome/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：按照题目意思，先将字符串全部转为小写，然后遍历，通过<code>unicode.IsLetter</code>判断是否为字母，通过<code>unicode.IsDigit</code>判断是否为数字，放入到另一个数组中，最终比较另外一个数组。</p>
</li>
<li><p>验证回文串II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYWxpbmRyb21lLWlpLw==">https://leetcode.cn/problems/valid-palindrome-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力，当出现不同的字符，将去掉左边或者右边的字符进行回文串的判断，只要有一个满足，则满足，否则为不满足。</p>
</li>
<li><p>最长回文子串：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnN0cmluZy8=">https://leetcode.cn/problems/longest-palindromic-substring/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力双循环，将所有的子串都进行回文串判断，时间复杂度 <code>O(n^2)</code></p>
<p>解法2：DP，<code>DP[i][j]</code>代表字符串<code>i</code>到字符串<code>j</code>是否是回文串，然后循环去判断<code>j+1</code>和<code>i-1</code>是否相等，或者判断<code>i</code>和<code>j+1</code>是否相等，再判断<code>dp[i][j]</code>是否是回文串，或者<code>dp[i+1][j]</code>是否是回文串</p>
</li>
<li><p>最长公共子序列：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbW1vbi1zdWJzZXF1ZW5jZS8=">https://leetcode.cn/problems/longest-common-subsequence/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，二维数组，第一个维度是第一个字符串长度，第二个维度是第二个字符串长度，代表对应两个字符串长度时的最长公共子序列长度。需要注意初始化条件，先初始化<code>dp[0]</code>，然后从<code>i=1</code>开始，并且每次便利<code>i</code>的时候，先确定<code>j=0</code>的情况，之后从<code>j=1</code>开始便利。状态转移方程为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> text1[i] == text2[j] &#123;</span><br><span class="line">	dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是求最长公共子串，也就是字符串不能打散</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1] + 1 (if s1[i-1] == s2[j-1]) </span><br><span class="line">else dp[i][j] = 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑距离：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lZGl0LWRpc3RhbmNlLw==">https://leetcode.cn/problems/edit-distance/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：嵌套循环，暴力求解，<code>O(n^3)</code></p>
<p>解法2：暴力情况下加速，枚举中心，向外面扩张时，字符串相同，<code>O(n^2)</code></p>
<p>解法2：DP，二维数组，第一个维度代表第一个字符串的长度，第二个维度代表第二个字符串的长度，值是编辑的距离。</p>
<p>首先定义二维数组，每个维度的第一个数字代表当一个字符串为空字符串时的编辑距离</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp := make([][]int, l1+1)</span><br></pre></td></tr></table></figure>

<p>状态方程：</p>
<p>如果两个字符相同，例如”ho”和”ro”，则是从”h”到”ro”，”ho”到”r”，”h”到”r”-1之间，取最小1个+1，也就是min（2，,2，1-1）+1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]-1) + 1</span><br></pre></td></tr></table></figure>

<p>如果两个字符串不相同，例如”hor”和”ros”，则是从”ho”到”ros”，”hor”到”ro”，”ho”，”ro”之间，取最小1个+1，也就是min（2，,2，1）+1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</span><br></pre></td></tr></table></figure>

<p>最终结果为<code>dp</code>的最后一位</p>
</li>
<li><p>正则表达式匹配：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZWd1bGFyLWV4cHJlc3Npb24tbWF0Y2hpbmcv">https://leetcode.cn/problems/regular-expression-matching/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，<code>[i][j]</code>分别代表前后两个元素的角标，需要注意的是，角标从0开始，也就是从空字符串开始，i从0开始，j从1开始。dp状态转移方程，理解的难度在于需要区分j的字符，如果是 <code>*</code>，则有两种情况，要么是匹配0次，将字符打掉，或者如果字符i和字符j匹配，则判断<code>i-1，j</code>是否匹配，只要两者可以匹配，则代表<code>i</code>到<code>j</code>可以匹配；或者不是 <code>*</code>，那么就判断i和j是否匹配，如果匹配，则是i-1和j-1的匹配情况。</p>
<p>解法思想：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZWd1bGFyLWV4cHJlc3Npb24tbWF0Y2hpbmcvc29sdXRpb24vamkteXUtZ3Vhbi1mYW5nLXRpLWppZS1nZW4teGlhbmcteGktZGUtamlhbmctamllLWIv">https://leetcode.cn/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>不同的子序列：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaXN0aW5jdC1zdWJzZXF1ZW5jZXMv">https://leetcode.cn/problems/distinct-subsequences/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力递归，一般不考虑</p>
<p>解法2：DP，<code>[i][j]</code>代表<code>s</code>前<code>i</code>字符串可组成<code>t</code>前<code>j</code>字符串组成的最多个数。最好是在前面都加上一个空字符串，这样理解起来会更加简单。<code>dp[0][0]=1</code>，代表当都是空字符串时，可以不删除即可集成。状态转移方程，其实就是判断是否删除<code>i</code>的字符串，当相等时，可以选择删除，也可以选择不删除，如果要删除，则是<code>dp[i-1][j]</code>；如果不删除，则是<code>dp[i-1][j-1]</code>；如果不想等，则只能删除。</p>
<p>动态方程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当 S[j] == T[i], dp[i][j] = dp[i-1][j-1] + dp[i-1][j]</span><br><span class="line">当 S[j] != T[i], dp[i][j] = dp[i-1][j]</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串中的第一个唯一字符：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maXJzdC11bmlxdWUtY2hhcmFjdGVyLWluLWEtc3RyaW5nLw==">https://leetcode.cn/problems/first-unique-character-in-a-string/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用hashmap</p>
<p>解法2：使用有限数组代替HashMap，可以节省时间</p>
</li>
<li><p>字符串转换整数：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdHJpbmctdG8taW50ZWdlci1hdG9pLw==">https://leetcode.cn/problems/string-to-integer-atoi/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力便利，需要注意的是，在有符号或者数字的时候，就不能再获取除了数字之外的其他符号，否则就结束。</p>
</li>
<li><p>反转字符串II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXN0cmluZy1paS8=">https://leetcode.cn/problems/reverse-string-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：便利字符串的时候反转</p>
</li>
<li><p>反转字符串中的单词：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXdvcmRzLWluLWEtc3RyaW5nLw==">https://leetcode.cn/problems/reverse-words-in-a-string/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：切割成单词，然后反转单词</p>
</li>
<li><p>反转字符串中的单词III：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXdvcmRzLWluLWEtc3RyaW5nLWlpaS8=">https://leetcode.cn/problems/reverse-words-in-a-string-iii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：切割成单词之后，反转每一个单词</p>
</li>
<li><p>仅仅反转字母：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLW9ubHktbGV0dGVycy8=">https://leetcode.cn/problems/reverse-only-letters/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双指针，出现非单词的时候，指针移动</p>
</li>
<li><p>找到字符串中所有字母异位词：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1hbmFncmFtcy1pbi1hLXN0cmluZy8=">https://leetcode.cn/problems/find-all-anagrams-in-a-string/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：滑动窗口和有限数组，先将目标字符串放到有限数组中，然后开始使用滑动窗口存储到临时有限数组中，比较有限数组。</p>
</li>
<li><p>最长回文子串：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnN0cmluZy8=">https://leetcode.cn/problems/longest-palindromic-substring/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力法，双层循环，然后获取这个字符串的子串是否是回文字符串</p>
<p>解法2：DP，二维数组，代表从角标i到角标j之间的子串是否是回文字符串，间隔从1到2到最大，如果<code>s[i]==s[j]</code>则需要判断<code>dp[i][j]</code>是否是回文串，如果<code>s[i]!=s[j]</code>，则不是回文串，返回最大的<code>j-i</code></p>
</li>
<li><p>同构字符串：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pc29tb3JwaGljLXN0cmluZ3Mv">https://leetcode.cn/problems/isomorphic-strings/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用两个有限数组，记录转换的对应关系，以及已经被转换的字符，便利字符串，如果没有转换过，则判断目标字符是否被转换过，如果被转换过，则返回<code>false</code>，否则记录转换关系。如果已经转换过，则判断是否是之前的转换关系，如果不是之前的转换关系，则返回<code>false</code>。</p>
</li>
<li><p>验证回文串II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYWxpbmRyb21lLWlpLw==">https://leetcode.cn/problems/valid-palindrome-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双指针，如果字符相等，则移动指针，如果字符不相等，则删除左边或者右边指针的字符，判断接下来的字符是否是回文串。</p>
</li>
<li><p>通配符匹配：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93aWxkY2FyZC1tYXRjaGluZy8=">https://leetcode.cn/problems/wildcard-matching/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DP，二维数组，记录两个长度下是否可以匹配。分情况讨论，如果都是字母，相等，则为<code>dp[i][j]=dp[i-1][j-1]</code>；如果是<code>*</code>，<code>dp[i][0]</code>则是<code>dp[i-1][0]</code>，否则就剩下是<code>?</code>，<code>dp[i][j] = dp[i-1][j] || dp[i][j-1]</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">   dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>,n+<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">if</span> p[i<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> unicode.IsLetter(<span class="type">rune</span>(p[i<span class="number">-1</span>])) &#123;</span><br><span class="line">         <span class="keyword">if</span> p[i<span class="number">-1</span>] == s[j<span class="number">-1</span>] &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> p[i<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">         dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i][j<span class="number">-1</span>]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最长有效括号：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXZhbGlkLXBhcmVudGhlc2VzLw==">https://leetcode.cn/problems/longest-valid-parentheses/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：动态规划，记录到<code>i</code>角标的字符串的最长有效括号长度字符只能是<code>)</code>才可能是一个有效的字符，然后判断<code>i-1</code>是否是<code>(</code>，是则代表是一个有效括号，然后再判断<code>dp[i-2]</code>的长度，以及有效长度的左边，肯定是一个无效的括号，判断这个无效的括号是否可以跟<code>i</code>组成有效的括号，最终结果返回<code>dp[i-1]</code></p>
</li>
</ul>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VtaXJwYXNpYy9nb2Rz">golang数据结构源码实现<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlnb2NoZWF0c2hlZXQuY29tLw==">了解时间复杂度<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly92aXN1YWxnby5uZXQvemg=">数据结构和算法动态可视化 (Chinese)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kYXRhYXNwaXJhbnQuY29tL2ZpdmUtbW9zdC1wb3B1bGFyLXNpbWlsYXJpdHktbWVhc3VyZXMtaW1wbGVtZW50YXRpb24taW4tcHl0aG9uLw==">Python中最流行的五种相似性度量实现<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96eGkubXl0ZWNocm9hZC5jb20vYmxvZy9zZWFyY2hpbmcvOC1wdXp6bGVzLWJpZGlyZWN0aW9uYWwtYXN0YXItdnMtYmlkaXJlY3Rpb25hbC1iZnMv">花花酱 8 Puzzles – Bidirectional A* vs Bidirectional BFS<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2VsZi1iYWxhbmNpbmdfYmluYXJ5X3NlYXJjaF90cmVl">Self-balancing binary search tree<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW55YWxlaXhpYW93dS9hcnRpY2xlL2RldGFpbHMvNzQ3MjE4Nzc=">使用BloomFilter布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY3BzZWx2aXMvcC82MjY1ODI1Lmh0bWw=">布隆过滤器(Bloom Filter)的原理和实现<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vb25lcGl4ZWwvcC83Njc0NjU5Lmh0bWw=">十大经典排序算法（动图演示） <i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDEzLzA1L2JveWVyLW1vb3JlX3N0cmluZ19zZWFyY2hfYWxnb3JpdGhtLmh0bWw=">字符串匹配的Boyer-Moore算法<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI1MDU0MzIvYXJ0aWNsZS9kZXRhaWxzLzUyMjEwOTc1">字符串匹配之KMP、BoyerMoore、Sunday算法<i class="fa fa-external-link-alt"></i></span></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/a441.html" rel="prev" title="通过TCPdump等工具排查网络问题以及优化">
                  <i class="fa fa-chevron-left"></i> 通过TCPdump等工具排查网络问题以及优化
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/ac90.html" rel="next" title="Goland 配合air和dlv实现热加载与Debug">
                  Goland 配合air和dlv实现热加载与Debug <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mitaka xu</span>
</div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9tdXNlLw==">NexT.Muse</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.3/algoliasearch-lite.umd.js" integrity="sha256-dyJcbGuYfdzNfifkHxYVd/rzeR6SLLcDFYEidcybldM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.51.1/instantsearch.production.min.js" integrity="sha256-y6I4MY/blLHk4a7G33zp97DcnBFRY2iMId4FObo8toI=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>





  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"TVx6Wkfs8VJGOwYPurtjWY2e-9Nh9j0Va","app_key":"c7VvaRnyF8r3DUIPq1x2KJ7Q","server_url":"https://tvx6wkfs.lc-cn-e1-shared.com","security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"xiaoyeshiyu","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
