<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="S_5aoPFd3QQihrUOLiKdVR0Mj4fj6n6qJojwyjj9cAY">
  <meta name="msvalidate.01" content="9032A67FCF787F07CB04374E59E518A9">
  <meta name="baidu-site-verification" content="code-Onlniop0d6">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.xiaoyeshiyu.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="数据结构和算法是程序员的基础，而且是一个很重要的基础。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构和算法初识">
<meta property="og:url" content="https://www.xiaoyeshiyu.com/post/79b0.html">
<meta property="og:site_name" content="小夜时雨">
<meta property="og:description" content="数据结构和算法是程序员的基础，而且是一个很重要的基础。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221212180817930.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221211233041574.png">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221212180917113.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212180958673.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212110147658.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212110340885.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212111147012.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212112708607.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212114134808.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212114840010.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212115133160.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212115255293.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212171916859.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212171745511.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212172050483.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/deque.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213170420074.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213170522848.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213170820506.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213174159016.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213174748681.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213174957329.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213181228162.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215165518116.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215165636052.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215165649621.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215174927132.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215174943002.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175041845.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175049825.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175128743.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175154914.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/Tree_Rebalancing.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203032328.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203103195.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203243856.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203223503.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203309163.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203746054.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203806433.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216093933925.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216094301929.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216094513742.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216101833319.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213204352351.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213211610933.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214103122667.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214103531661.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214105138027.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214105946104.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214110048812.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214135650823.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214135808104.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214143305811.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214143544513.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214145242758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214145426297.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214145854501.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214150158043.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215100815784.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215102021321.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215102034053.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215112656150.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215112720564.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215112740618.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215114752354.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215141621887.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215141701546.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215141748310.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216102928839.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216102957766.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015224719590-1433219824.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015225645277-1151100000.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20180331170017421-364506073.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015223238449-2146169197.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015230936371-1413523412.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015230557043-37375010.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015231308699-356134237.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015231740840-6968181.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015232107090-1920702011.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/849589-20171015232453668-1397662527.gif">
<meta property="article:published_time" content="2022-06-10T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-08T02:03:32.082Z">
<meta property="article:author" content="Mitaka xu">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221212180817930.png">


<link rel="canonical" href="https://www.xiaoyeshiyu.com/post/79b0.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.xiaoyeshiyu.com/post/79b0.html","path":"post/79b0.html","title":"数据结构和算法初识"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据结构和算法初识 | 小夜时雨</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MBVJ11TVHH"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBVJ11TVHH","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?573725610fbc6ff9b42032bd13615370"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="小夜时雨" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小夜时雨</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">君子敬其在己者，而不慕其在天者，是以日进也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.3.</span> <span class="nav-text">时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%AE%9A%E7%90%86"><span class="nav-number">1.3.1.</span> <span class="nav-text">主定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A3%80%E7%B4%A2%E6%97%B6%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.3.2.</span> <span class="nav-text">不同数据结构检索时的时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.3.3.</span> <span class="nav-text">不同数组排序算法的时间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4"><span class="nav-number">2.1.</span> <span class="nav-text">一维</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-array"><span class="nav-number">2.1.1.</span> <span class="nav-text">数组 array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8-Linked-List"><span class="nav-number">2.1.2.</span> <span class="nav-text">链表 Linked List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8-Skip-List"><span class="nav-number">2.1.3.</span> <span class="nav-text">跳表 Skip List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE"><span class="nav-number">2.1.4.</span> <span class="nav-text">典型题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88-stack"><span class="nav-number">2.1.5.</span> <span class="nav-text">栈 stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97-queue"><span class="nav-number">2.1.6.</span> <span class="nav-text">队列 queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-deque%EF%BC%9Adouble-end-queue"><span class="nav-number">2.1.7.</span> <span class="nav-text">双端队列 deque：double end queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">2.1.8.</span> <span class="nav-text">优先队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-1"><span class="nav-number">2.1.9.</span> <span class="nav-text">典型题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%92%8C%E9%9B%86%E5%90%88%E4%BB%A5%E5%8F%8A%E6%98%A0%E5%B0%84"><span class="nav-number">2.1.10.</span> <span class="nav-text">哈希表和集合以及映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-2"><span class="nav-number">2.1.11.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4"><span class="nav-number">2.2.</span> <span class="nav-text">二维</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91-Tree"><span class="nav-number">2.2.1.</span> <span class="nav-text">树 Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree"><span class="nav-number">2.2.2.</span> <span class="nav-text">二叉树 Binary Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE-Graph"><span class="nav-number">2.2.3.</span> <span class="nav-text">图 Graph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-Binary-Search-Tree"><span class="nav-number">2.2.4.</span> <span class="nav-text">二叉搜索树 Binary Search Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-3"><span class="nav-number">2.2.5.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">高级数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%A0%91"><span class="nav-number">2.3.1.</span> <span class="nav-text">高级树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AVL%E6%A0%91"><span class="nav-number">2.3.2.</span> <span class="nav-text">AVL树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91-Red-Black-Tree"><span class="nav-number">2.3.3.</span> <span class="nav-text">红黑树 Red-Black Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-Bloom-Filter"><span class="nav-number">2.3.4.</span> <span class="nav-text">布隆过滤器 Bloom Filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98-Cache"><span class="nav-number">2.3.5.</span> <span class="nav-text">缓存 Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU-Cache"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">LRU Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">替换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-4"><span class="nav-number">2.3.5.3.</span> <span class="nav-text">典型题目</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-number">3.</span> <span class="nav-text">算法思想</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">3.1.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-5"><span class="nav-number">3.1.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%B2%BB-Divide-amp-Conquer"><span class="nav-number">3.2.</span> <span class="nav-text">分治 Divide &amp; Conquer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF"><span class="nav-number">3.3.</span> <span class="nav-text">回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-6"><span class="nav-number">3.3.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS"><span class="nav-number">3.4.</span> <span class="nav-text">深度优先搜索 DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS"><span class="nav-number">3.5.</span> <span class="nav-text">广度优先搜索 BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-7"><span class="nav-number">3.5.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-Greedy"><span class="nav-number">3.6.</span> <span class="nav-text">贪心算法 Greedy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-8"><span class="nav-number">3.6.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">3.7.</span> <span class="nav-text">二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-9"><span class="nav-number">3.7.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Dynamic-Programming"><span class="nav-number">3.8.</span> <span class="nav-text">动态规划 Dynamic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-10"><span class="nav-number">3.8.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91-Trie"><span class="nav-number">3.9.</span> <span class="nav-text">字典树 Trie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-11"><span class="nav-number">3.9.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">3.10.</span> <span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98"><span class="nav-number">3.10.1.</span> <span class="nav-text">典型问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2"><span class="nav-number">3.11.</span> <span class="nav-text">高级搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E7%BA%A7%E6%90%9C%E7%B4%A2"><span class="nav-number">3.11.1.</span> <span class="nav-text">初级搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2-1"><span class="nav-number">3.11.2.</span> <span class="nav-text">高级搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="nav-number">3.11.3.</span> <span class="nav-text">回溯法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-12"><span class="nav-number">3.11.3.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91BFS"><span class="nav-number">3.11.4.</span> <span class="nav-text">双向BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-13"><span class="nav-number">3.11.4.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2-A-Search"><span class="nav-number">3.11.5.</span> <span class="nav-text">启发式搜索 A* Search</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-14"><span class="nav-number">3.11.5.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">3.12.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%88%96-XOR"><span class="nav-number">3.12.1.</span> <span class="nav-text">异或 XOR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A6%81%E7%82%B9"><span class="nav-number">3.12.2.</span> <span class="nav-text">位运算要点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-15"><span class="nav-number">3.12.2.1.</span> <span class="nav-text">典型题目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">3.13.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F-O-n-2"><span class="nav-number">3.13.1.</span> <span class="nav-text">初级排序 O(n^2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F-O-nlog-n"><span class="nav-number">3.13.2.</span> <span class="nav-text">高级排序 O(nlog(n))</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%8E%92%E5%BA%8F-O-n"><span class="nav-number">3.13.3.</span> <span class="nav-text">特殊排序 O(n)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE-16"><span class="nav-number">3.13.4.</span> <span class="nav-text">典型题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">3.14.</span> <span class="nav-text">高级动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%8F%90%E5%8D%87"><span class="nav-number">3.14.1.</span> <span class="nav-text">复杂度提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98-1"><span class="nav-number">3.14.2.</span> <span class="nav-text">典型问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.15.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">3.15.1.</span> <span class="nav-text">字符串匹配算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98-2"><span class="nav-number">3.15.2.</span> <span class="nav-text">典型问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB"><span class="nav-number">4.</span> <span class="nav-text">推荐阅读</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mitaka xu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mitaka xu</p>
  <div class="site-description" itemprop="description">Golang开发博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">103</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaoyeshiyu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/79b0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数据结构和算法初识 | 小夜时雨">
      <meta itemprop="description" content="数据结构和算法是程序员的基础，而且是一个很重要的基础。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构和算法初识
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-11 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-11T00:00:00+08:00">2022-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-08 10:03:32" itemprop="dateModified" datetime="2023-09-08T10:03:32+08:00">2023-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
    <span id="/post/79b0.html" class="post-meta-item leancloud_visitors" data-flag-title="数据结构和算法初识" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/post/79b0.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="post/79b0.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

            <div class="post-description">数据结构和算法是程序员的基础，而且是一个很重要的基础。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>一维：</p>
<ul>
<li>基础：数组 array（string），链表 linked list</li>
<li>高级：栈 stack，队列 queue，双端队列 deque，集合 set，映射 map（hash or map），etc</li>
</ul>
<p>二维：</p>
<ul>
<li>基础：树 tree，图 graph</li>
<li>高级：二叉搜索树 binary search tree（red-black tree，AVL），堆 heap，并查集 disjoint set，字典树 Trie，etc</li>
</ul>
<p>特殊：</p>
<ul>
<li>位运算 Bitwise，不用过滤器 BloomFilter</li>
<li>LRU Cache</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>以下三种方式，是几乎所有算法和数据结构的基石</p>
<ul>
<li>if-else,switch:branch</li>
<li>for.while loop:lteration</li>
<li>递归 Recursion(Divide &amp; Conquer, Backtrace)</li>
</ul>
<p>在基石上的扩展</p>
<ul>
<li>搜索 Search：深度优先搜索 Depth first search，广度优先搜索 Breadth first search,A*,etc</li>
<li>动态规划 Dynamic Programming </li>
<li>二分查找 Binary Search </li>
<li>贪心算法 Greedy </li>
<li>数学 Math，集合 Geometry</li>
</ul>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度用Big O notation表示，也就是<code>O()</code>表示。时间复杂度有这么几种：</p>
<p><code>O(1)</code>：表示Constant Complexity 常数复杂度</p>
<p><code>O(log n)</code>：表示Logarithmic Complexity 对数复杂度</p>
<p><code>O(n)</code>：表示Linear Complexity 线性时间复杂度</p>
<p><code>O(n^2)</code>：表示N Square Complexity 平方</p>
<p><code>O(n^3)</code>：表示N Cube Complexity 立方</p>
<p><code>O(2^n)</code>：表示Exponential Growth 指数</p>
<p><code>O(n!)</code>：表示 Factorial 阶乘</p>
<p>查看一个函数的时间复杂度，主要跟N有关，而且会去掉前面的常数，也就是<code>O(2)</code>、<code>O(3)</code>统称为常数复杂度，也就是<code>O(1)</code></p>
<p>例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10000</span></span><br><span class="line">fmt.Println(n)</span><br><span class="line"><span class="keyword">return</span> </span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(1)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10000</span></span><br><span class="line">fmt.Println(n)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello + &quot;</span>,n)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello golang : &quot;</span>,n)</span><br><span class="line"><span class="keyword">return</span> </span><br></pre></td></tr></table></figure>

<p>时间复杂度也是 <code>O(1)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello &quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(n)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello &quot;</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(n^2)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello &quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello &quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然执行的时候，是 <code>O(2n)</code>，但是时间复杂度会去掉前面的常数，也就是 <code>O(n)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i=i*<span class="number">2</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello &quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(log(n))</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fib(n<span class="number">-2</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(k^n)</code></p>
<p>时间复杂度是衡量一段代码效率的重要指标</p>
<p><img src="/../../../../../Library/Application%20Support/typora-user-images/image-20221212180817930.png" alt="image-20221212180817930"></p>
<p>可以看到，不同的时间复杂度，在n增大时，所需要的时间增大服务不一样，其中最快的是 <code>O(1)</code>，但是实际上几乎不会是这种，其次是 <code>O(log(n))</code>。</p>
<p>使用到 <code>O(1)</code>的情况，例如求和</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	s := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		s += i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(n)</code>，但是使用求和公式，可以直接获取结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sumFormula(n int) int &#123;</span><br><span class="line">	return (1 + n) * n / 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <code>O(1)</code></p>
<h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>一些常用的搜索算法，可以通过主定理直接得到时间复杂度</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221211233041574.png" alt="image-20221211233041574"></p>
<p>通过主定理，可以得到：</p>
<ul>
<li>二叉树遍历-前序、中序、后序的时间复杂度都是 <code>O(n)</code>，因为要遍历每一个结点，n代表二叉树中的每一个结点</li>
<li>图的遍历的时间复杂度是 <code>O(n)</code>，n代表图里面的每一个结点</li>
<li>搜索算法，DFS、BFS时间复杂度都是 <code>O(n)</code>，n代表搜索空间里面的结点总数</li>
<li>二分查找法的时间复杂度是 <code>O(log(n))</code></li>
</ul>
<h3 id="不同数据结构检索时的时间复杂度"><a href="#不同数据结构检索时的时间复杂度" class="headerlink" title="不同数据结构检索时的时间复杂度"></a>不同数据结构检索时的时间复杂度</h3><p><img src="/../../../../../Library/Application%20Support/typora-user-images/image-20221212180917113.png" alt="image-20221212180917113"></p>
<h3 id="不同数组排序算法的时间复杂度"><a href="#不同数组排序算法的时间复杂度" class="headerlink" title="不同数组排序算法的时间复杂度"></a>不同数组排序算法的时间复杂度</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212180958673.png" alt="image-20221212180958673"></p>
<p>汇总：<span class="exturl" data-url="aHR0cDovL3d3dy5yZWRidWJibGUuY29tL3Blb3BsZS9pbW1vcnRhbGxvb20vd29ya3MvMjI5Mjk0MDgtb2ZmaWNpYWwtYmlnLW8tY2hlYXQtc2hlZXQtcG9zdGVyP3A9cG9zdGVyJmZpbmlzaD1zZW1pX2dsb3NzJnNpemU9bGFyZ2U=">http://www.redbubble.com/people/immortalloom/works/22929408-official-big-o-cheat-sheet-poster?p=poster&amp;finish=semi_gloss&amp;size=large<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h2><h3 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 array</h3><p>在<code>golang</code>中定义数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">string</span></span><br><span class="line">b := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>数据会在内存中开辟一段连续的空间，<code>占用的字节数 = 元素类型字节 * 元素个数</code>，例如上例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(unsafe.Sizeof(a))		<span class="comment">// 48，string底层由一个指向数据的指针和int类型长度组成，占16个字节</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(b))		<span class="comment">// 16，int类型占8个字节</span></span><br></pre></td></tr></table></figure>

<p>因此，访问第一个元素和访问中间的某一个元素的时间复杂度，是一样的，都是 <code>O(1)</code>。</p>
<p>数组的特点是访问快，但是插入、删除慢</p>
<p>例如要在<code>index=3</code>的位置插入一个元素，需要将后续的<code>E\F\G</code>都往后挪动（前提是数组有空余位置）</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212110147658.png" alt="image-20221212110147658"></p>
<p>此时的时间复杂度取决于位置值，是 <code>O(n)</code></p>
<p>删除操作也是一样的，先将 <code>index=3</code>的值取出来，然后将 <code>EFG</code>的值往前挪动</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212110340885.png" alt="image-20221212110340885"></p>
<p>此时的时间复杂度取决于位置值，也是 <code>O(n)</code></p>
<p>当然，在<code>golang</code>中，数组的长度是无法扩展的，因此通常是在切片中操作。在切片中，如果长度不足，首先会扩容，将老数组中的内容拷贝到新数组中。</p>
<h3 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表 Linked List"></a>链表 Linked List</h3><p>链表通过指针指向下一个结点，这种数据结构可以弥补数组中数据插入和数据删除导致的性能问题。</p>
<p>链表根据指针的不同指向，分多种：</p>
<ul>
<li><p>单链表：指针指向下一个结点的地址，尾结点的指针指向<code>none</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">  value <span class="type">int</span></span><br><span class="line">  next  *LinkedList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212111147012.png" alt="image-20221212111147012"></p>
</li>
<li><p>双链表：一个指针指向下一个结点的地址，另外一个指针指向上一个结点的地址，尾结点的<code>next</code>指向<code>none</code>，头结点的<code>pre</code>指向<code>none</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">  value     <span class="type">int</span></span><br><span class="line">  pre, next *LinkedList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>环形链表：单链表下，尾结点的<code>next</code>指向头结点的地址</p>
</li>
</ul>
<p>代码实现</p>
<p>List定义：</p>
<p>单链表：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List holds the elements, where each element points to the next element</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;					<span class="comment">// list 记录头和尾结点，以及list中元素个数</span></span><br><span class="line">	first *element</span><br><span class="line">	last  *element</span><br><span class="line">	size  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> element <span class="keyword">struct</span> &#123;				<span class="comment">// 结点</span></span><br><span class="line">	value <span class="keyword">interface</span>&#123;&#125;					<span class="comment">// 结点中使用interface包含所有类型元素</span></span><br><span class="line">	next  *element						<span class="comment">// 下一个结点的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双链表：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List holds the elements, where each element points to the next and previous element</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *element</span><br><span class="line">	last  *element</span><br><span class="line">	size  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> element <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	prev  *element</span><br><span class="line">	next  *element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表实现的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> List <span class="keyword">interface</span> &#123;</span><br><span class="line">	Get(index <span class="type">int</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>)</span><br><span class="line">	Remove(index <span class="type">int</span>)</span><br><span class="line">	Add(values ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Contains(values ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span></span><br><span class="line">	Sort(comparator utils.Comparator)</span><br><span class="line">	Swap(index1, index2 <span class="type">int</span>)</span><br><span class="line">	Insert(index <span class="type">int</span>, values ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Set(index <span class="type">int</span>, value <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	containers.Container</span><br><span class="line">	<span class="comment">// Empty() bool</span></span><br><span class="line">	<span class="comment">// Size() int</span></span><br><span class="line">	<span class="comment">// Clear()</span></span><br><span class="line">	<span class="comment">// Values() []interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>增加结点</p>
<p>在第一个<code>node</code>和第二个<code>node</code>中间插入一个<code>node</code></p>
<ol>
<li>记录前一个<code>node</code>指向的下一个<code>node</code>的指针</li>
<li>将前一个<code>node</code>的指针改成指向新的<code>node</code></li>
<li>将新的<code>node</code>的指针，指向记录的指针</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212112708607.png" alt="image-20221212112708607"></p>
<p>这个操作是常数操作，事件复杂度是 <code>O(1)</code></p>
</li>
<li><p>删除结点</p>
<p>将前<code>node</code>的<code>next</code>指向被删结点的<code>next</code>即可</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212114134808.png" alt="image-20221212114134808"></p>
</li>
</ul>
<p>	</p>
<p>增加、删除的操作都不会导致其他的<code>node</code>迁移，在增删操作频繁的场景下，有很大的优势。</p>
<p>一些操作的时间复杂度：</p>
<ul>
<li><code>prepend</code>:<code>O(1)</code></li>
<li><code>append</code>:<code>O(1)</code></li>
<li><code>lookup</code>:<code>O(n)</code>，查询操作需要逐个遍历，时间复杂度取决于便利的node个数</li>
<li><code>insert</code>:<code>O(1)</code></li>
<li><code>delete</code>:<code>O(1)</code></li>
</ul>
<h3 id="跳表-Skip-List"><a href="#跳表-Skip-List" class="headerlink" title="跳表 Skip List"></a>跳表 Skip List</h3><p>跳表可以解决链表中查询操作慢的问题</p>
<p>针对链表中查询慢的情况，通过升维，或者说以空间换时间的概念，给<code>node</code>添加多个<code>next</code></p>
<p>在跳表中，增加索引的概念，通过多层索引，实现一次性跨越多个元素，增加查找效率</p>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212114840010.png" alt="image-20221212114840010"></p>
<p>第一级索引的个数是 <code>n/2</code>，第二级索引个数是 <code>n/4</code>，以此类推，第k级别索引结点的个数就是 <code>n/(2^k)</code></p>
<p>那么，当最高级的索引有2个结点，索引层级是<code>h</code>,那么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n/(2^n) = 2</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = log2(n) - 1</span><br></pre></td></tr></table></figure>

<p>也就是说，在跳表中查询数据的时间复杂度是 <code>O(log(n))</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212115133160.png" alt="image-20221212115133160"></p>
<p>当跳表在增加、删除结点之后，有些结点的指针可能指向为<code>none</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212115255293.png" alt="image-20221212115255293"></p>
<p>因此，跳表的维护成本相对而言是比较高的。</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>假设原始链表大小为n，每2个结点抽1个，每层索引的结点数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n/2,n/4,...,8,4,2</span><br></pre></td></tr></table></figure>

<p>假设原始链表大小为n，每3个结点抽1个，每层索引的结点数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n/3,n/9,...,9,3,1</span><br></pre></td></tr></table></figure>

<p>空间复杂度是 <code>O(n)</code></p>
<h3 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h3><p>在一维数据结构中，有一些典型题目</p>
<ul>
<li><p>两数之和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS8=">https://leetcode-cn.com/problems/two-sum/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双循环，便利每两个元素，时间复杂度 <code>O(n^2)</code></p>
<p>解法2：使用hash，便利的时候获取是否有<code>target-i位置元素</code>的数字在hash中，时间复杂度 <code>O(n)</code>，更优</p>
</li>
<li><p>盛水最多的容器：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udGFpbmVyLXdpdGgtbW9zdC13YXRlci8=">https://leetcode-cn.com/problems/container-with-most-water/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双循环，便利每两个元素，时间复杂度 <code>O(n^2)</code></p>
<p>解法2：头尾双角标，判断角标数字小的，该角标向中间移动，时间复杂度 <code>O(n)</code>，更优</p>
</li>
<li><p>移动0：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbW92ZS16ZXJvZXMv">https://leetcode-cn.com/problems/move-zeroes/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：再创建一个等长数组，便利数组，将非0的数字拷贝到另一个数组中，时间复杂度 <code>O(1)</code>，但是空间复杂度 <code>O(n)</code></p>
<p>解法2：双角标便利，第一个角标记录非0，第二个角标往后移动，将非0的数字移动到第一个角标上，最后将剩余数字改为0，时间复杂度 <code>O(n)</code>，空间复杂度 <code>O(1)</code></p>
</li>
<li><p>爬楼梯：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzLw==">https://leetcode.com/problems/climbing-stairs/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：找到规律，例如第3阶楼梯方法次数，为第1阶加上第2阶的总和，<code>f(n)=f(n-1)+f(n-2)</code>，类似斐波那契，而且这里不能使用递归，因为递归的时候会有很多重复的计算，因此要使用循环遍历，从1,2，…，一直计算到n，时间复杂度 <code>O(n)</code>。为了代码渐变，可以将结果放在数组里面，角标0为1，角标1为2，以此类推。</p>
<p>解法2：直接推到斐波那契公式，时间复杂度 <code>O(log(n))</code>，这个比较复杂</p>
</li>
<li><p>三数之和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvM3N1bS8=">https://leetcode-cn.com/problems/3sum/<i class="fa fa-external-link-alt"></i></span>(高频老题）</p>
<p>解法1：先排序，然后三角标，第一个角标选择i，从0开始往右直到大于0，第二个角标从i+1开始，第三个角标从最右边开始，相加之后的结果如果大于0，则将第三个角标往左边移动，减小总和；如果相加之后的结果小于0，则将第二个角标往右边移动，增大总和。总共时间复杂度为 <code>O(n^2)</code>。这题需要注意的是要去重，去重的方法可以是在便利过程中，去掉和前一次便利相同的时刻。</p>
</li>
<li><p>反转链表：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC8=">https://leetcode.com/problems/reverse-linked-list/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：迭代，由于指针要指向前一个节点，因此，迭代过程中保存前一个节点，然后迭代当前节点，时间复杂度 <code>O(n)</code>，注意，判断条件为当前节点是否为<code>nil</code>，返回的是前一个节点<code>pre</code></p>
<p>解法2：递归，将当前节点传到递归函数中进行处理，递归函数中一方面，将 <code>node.Next.Next = node</code>， 第二方面，将 <code>node.Next=nil</code>将首个<code>node</code>的<code>next</code>指向<code>nil</code>，第三方面，将最后一个<code>node</code>作为 函数返回值，从最底层递归函数返回到最上层。</p>
</li>
<li><p>两两交换链表中的节点：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc3dhcC1ub2Rlcy1pbi1wYWlycw==">https://leetcode.com/problems/swap-nodes-in-pairs<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：迭代，记录一个虚拟的<code>head</code>，用于返回<code>head.Next</code>，每次用两个<code>node</code>，<code>head.Next</code>和<code>head.Next.Next</code>进行迭代，终止条件是<code>node.Next</code>为<code>nil</code>或者<code>node.Next.Next</code>为<code>nil</code>，迭代过程中是将链表进行转换，时间复杂度 <code>O(n)</code></p>
<p>解法2：递归，两两节点处理，返回的时候，将交换后的head节点返回，用于前一对指定</p>
</li>
<li><p>环形链表：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS8=">https://leetcode.cn/problems/linked-list-cycle/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：遍历链表中所有结点，将数据存储到<code>map</code>中，查看是否有重复的</p>
<p>解法2：快慢指针，一个一次走两个结点，一个一次走一个结点，如果重叠，则表示有环</p>
</li>
<li><p>环形链表II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS1paS8=">https://leetcode.cn/problems/linked-list-cycle-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：与上一个问题一样，记录map的value为结点索引</p>
<p>解法2：与上一个问题一样，但是需要注意的是，快指针从头开始，并且每次走1步，第二次相遇的结点，即是循环开始的结点</p>
</li>
<li><p>K 个一组翻转链表：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLW5vZGVzLWluLWstZ3JvdXAvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/reverse-nodes-in-k-group/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：将链表拆开成已翻转链表和待翻转链表，在判断后续的链表是否能翻转的时候，可以确定下一个head在哪，将链表进行翻转之后，将指针一起往后移动，pre代表开始翻转链表的上一个节点，next代表需要翻转的链表</p>
<p>解法2：递归，将第k+1个节点传递到函数中进行递归，如果这个节点不存在，则返回当前节点，如果存在，则传递到函数中。递归终止条件是不满足k个节点，如果满足，则将这个节点递归，递归返回的是翻转后的head，然后将自己这个链表进行反转，最终返回的是翻转之后的头结点。</p>
</li>
<li><p>删除有序数组中的重复项：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWR1cGxpY2F0ZXMtZnJvbS1zb3J0ZWQtYXJyYXkv">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双指针，一个指针记录不同数字，另外一个指针扫描后续数字，当数字不同，将第一个指针往后移动，并且将第二个指针的数字拷贝到第一个指针的位置</p>
</li>
<li><p>轮转数组：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcm90YXRlLWFycmF5Lw==">https://leetcode-cn.com/problems/rotate-array/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：新开辟一个数组，将原数组拷贝到新的数组中，原数组中(i+k)%len的位置就是新数组的位置</p>
<p>解法2：反转数组，先反转所有元素，再翻转两个区间内<code>[:k%len]</code>和<code>[k%length:]</code>的元素，注意，这里可以将反转的函数提取出来，会简单很多</p>
</li>
<li><p>合并两个有序链表：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWVyZ2UtdHdvLXNvcnRlZC1saXN0cy8=">https://leetcode-cn.com/problems/merge-two-sorted-lists/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：迭代，遍历两个链表，选择小的一个作为next，理解简单，但是写法复杂</p>
<p>解法2：递归，比较将更大的元素和小元素的下一个丢到递归函数中，返回的是最大的，小元素的下一个指向返回的，然后返回这个小的元素</p>
</li>
<li><p>合并两个有序数组：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWVyZ2Utc29ydGVkLWFycmF5Lw==">https://leetcode-cn.com/problems/merge-sorted-array/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：比较，放入到新数组中，这个方法理解简单，但是需要额外的内存</p>
<p>解法2：逆序三指针，一个指针放在数值末尾，另外的两个指针分别是两个数组的数字末尾，两个比较之后将较大的放在第一个指针的位置，指针往前移动，最后，如果有任意一个数字为0，则直接将非0的数组拷贝到前对应数组中</p>
</li>
<li><p>两数之和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS8=">https://leetcode-cn.com/problems/two-sum/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用map记录，然后遍历数组</p>
<p>解法2：暴力枚举</p>
</li>
<li><p>移动零：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbW92ZS16ZXJvZXMv">https://leetcode-cn.com/problems/move-zeroes/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双指针，将非0的数字拷贝到前面，便利结束之后，将剩余的位置全部置0</p>
<p>解法2：双指针，将非0的数字和前面换位置，换了之后，指针向后移动</p>
</li>
<li><p>加一：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGx1cy1vbmUv">https://leetcode-cn.com/problems/plus-one/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：找到最长子串9，然后处理+1</p>
</li>
</ul>
<h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 stack</h3><p>类似于一个容器，先进后出（FIFO），添加、删除皆为 <code>O(1)</code>，查询是 <code>O(n)</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212171916859.png" alt="image-20221212171916859"></p>
<p>基于数组实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List holds the elements in a slice</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	size     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack holds elements in an array-list</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">	list *List</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于单链表实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List holds the elements, where each element points to the next element</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *element</span><br><span class="line">	last  *element</span><br><span class="line">	size  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> element <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	next  *element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack holds elements in a singly-linked-list	</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">	list *List				<span class="comment">// 由 单链表构成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈提供的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stack interface that all stacks implement</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">interface</span> &#123;</span><br><span class="line">	Push(value <span class="keyword">interface</span>&#123;&#125;)									<span class="comment">// 推入一个元素</span></span><br><span class="line">	Pop() (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)			<span class="comment">// 吐出一个元素</span></span><br><span class="line">	Peek() (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)			<span class="comment">// 获取长度</span></span><br><span class="line"></span><br><span class="line">	containers.Container</span><br><span class="line">	<span class="comment">// Empty() bool</span></span><br><span class="line">	<span class="comment">// Size() int</span></span><br><span class="line">	<span class="comment">// Clear()</span></span><br><span class="line">	<span class="comment">// Values() []interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列 queue"></a>队列 queue</h3><p>先进先出，添加、删除皆为 <code>O(1)</code>，查询是 <code>O(n)</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212171745511.png" alt="image-20221212171745511"></p>
<p>基于数组实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List holds the elements in a slice</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	size     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue holds elements in an array-list</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	list *List</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于环实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue holds values in a slice.</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	values  []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	start   <span class="type">int</span></span><br><span class="line">	end     <span class="type">int</span></span><br><span class="line">	full    <span class="type">bool</span></span><br><span class="line">	maxSize <span class="type">int</span></span><br><span class="line">	size    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于单向链表实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List holds the elements, where each element points to the next element</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *element</span><br><span class="line">	last  *element</span><br><span class="line">	size  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> element <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	next  *element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue holds elements in a singly-linked-list</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	list *List</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双端队列-deque：double-end-queue"><a href="#双端队列-deque：double-end-queue" class="headerlink" title="双端队列 deque：double end queue"></a>双端队列 deque：double end queue</h3><p>可以看做是栈和队列的结合，可以从头插入或者删除，也可以从尾部插入或者删除，添加、删除皆为 <code>O(1)</code>，查询是 <code>O(n)</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221212172050483.png" alt="image-20221212172050483"></p>
<p>基于数组实现</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/deque.png" alt="双端队列图"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deque represents a single instance of the deque data structure. A Deque</span></span><br><span class="line"><span class="comment">// instance contains items of the type specified by the type argument.</span></span><br><span class="line"><span class="keyword">type</span> Deque[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">	buf    []T</span><br><span class="line">	head   <span class="type">int</span></span><br><span class="line">	tail   <span class="type">int</span></span><br><span class="line">	count  <span class="type">int</span></span><br><span class="line">	minCap <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支持的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Cap() <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Len() <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> PushBack(elem T)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> PushFront(elem T)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> PopFront() T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> PopBack() T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Front() T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Back() T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> At(i <span class="type">int</span>) T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Set(i <span class="type">int</span>, item T)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Clear()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Rotate(n <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Index(f <span class="function"><span class="keyword">func</span><span class="params">(T)</span></span> <span class="type">bool</span>) <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> RIndex(f <span class="function"><span class="keyword">func</span><span class="params">(T)</span></span> <span class="type">bool</span>) <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Insert(at <span class="type">int</span>, item T)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> Remove(at <span class="type">int</span>) T</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Deque[T])</span></span> SetMinCapacity(minCapacityExp <span class="type">uint</span>)</span><br></pre></td></tr></table></figure>

<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>和所有的队列、stack一致，插入操作是 <code>O(1)</code>，取出操作是 <code>O(log(n))</code>，取出按照元素的优先级取出，底层具体实现的数据结构较为多样和复杂，例如通过列表实现的堆</p>
<p>基于列表实现堆，通过堆实现优先级，基于堆和比较器实现优先级队列，此时插入操作就不是 <code>O(1)</code>，而是 <code>O(nlogn)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue holds elements in an array-list</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	heap       *Heap</span><br><span class="line">	Comparator Comparator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Heap holds elements in an array-list</span></span><br><span class="line"><span class="keyword">type</span> Heap <span class="keyword">struct</span> &#123;</span><br><span class="line">	list       *List</span><br><span class="line">	Comparator Comparator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List holds the elements in a slice</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	elements []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	size     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparator will make type assertion (see IntComparator for example),</span></span><br><span class="line"><span class="comment">// which will panic if a or b are not of the asserted type.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Should return a number:</span></span><br><span class="line"><span class="comment">//    negative , if a &lt; b</span></span><br><span class="line"><span class="comment">//    zero     , if a == b</span></span><br><span class="line"><span class="comment">//    positive , if a &gt; b</span></span><br><span class="line"><span class="keyword">type</span> Comparator <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>队列的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue interface that all queues implement</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">interface</span> &#123;</span><br><span class="line">	Enqueue(value <span class="keyword">interface</span>&#123;&#125;)								<span class="comment">// 入队</span></span><br><span class="line">	Dequeue() (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)		<span class="comment">// 出队</span></span><br><span class="line">	Peek() (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)				<span class="comment">// 获取队列长度</span></span><br><span class="line"></span><br><span class="line">	containers.Container</span><br><span class="line">	<span class="comment">// Empty() bool</span></span><br><span class="line">	<span class="comment">// Size() int</span></span><br><span class="line">	<span class="comment">// Clear()</span></span><br><span class="line">	<span class="comment">// Values() []interface&#123;&#125;</span></span><br><span class="line">	<span class="comment">// String() string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型题目-1"><a href="#典型题目-1" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>有效的括号：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYXJlbnRoZXNlcy9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/valid-parentheses/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力法，不断地将字符串中的 <code>()</code>,<code>&#123;&#125;</code>,<code>[]</code>替换成空字符串，最终看是否是空字符串</p>
<p>解法2：使用栈，将符号压栈，下一个符号是否与栈顶元素对比，栈顶记录一个随机的符号。这个方法时间复杂度 <code>O(n)</code></p>
</li>
<li><p>最小栈：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tc3RhY2sv">https://leetcode.cn/problems/min-stack/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用两个栈，一个栈放正常数据，第二个栈存放最小值</p>
</li>
<li><p>柱状图中最大的矩形：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXJnZXN0LXJlY3RhbmdsZS1pbi1oaXN0b2dyYW0v">https://leetcode.cn/problems/largest-rectangle-in-histogram/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：枚举法，从头开始索引，每次获取左右边界，也就是比他自身矮的，左边边界中间就是面积，每次记录最大面积，时间复杂度是 <code>O(n^3)</code>，会超时</p>
<p>解法2：快速枚举法，也需要利用栈的思想，核心理解逻辑是柱子的左边界，如果比左边柱子高，则左边界就是左边柱子，如果比左边低或者相等，则左边界就是比自己低的</p>
<p>解法3：使用栈，每次压入数据与栈顶数据对比，如果比栈顶数据大，则压入，如果小，则弹出栈顶元素，此时可以确定栈顶元素的右边界，为新元素，左边界为栈中下面的元素。以此计算每一个元素的大小，时间复杂度是<code>O(n)</code></p>
</li>
<li><p>滑动窗口最大值：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtLw==">https://leetcode.cn/problems/sliding-window-maximum/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力求解，嵌套循环，时间复杂度是 <code>O(n*k)</code>，这种方法会超时</p>
<p>解法2：使用单调队列，确保新加入的元素是队列中最小的，将窗口中的数据加入到单调队列中，如果新加进来的数据大于单调队列尾部，则将队列尾部的值丢掉，直到队列单调，如果小于队列尾部，则直接加入到队列尾部。当窗口移动时，需要确定单调队列头部元素是否在窗口中，因此队列中的数据为索引，并且当队列头部数据不在窗口范围内，则去掉头部。</p>
</li>
<li><p>设计循环双端队列：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZXNpZ24tY2lyY3VsYXItZGVxdWUv">https://leetcode.cn/problems/design-circular-deque/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用数组实现，左边为头部，右边为尾部，但是这种做法在插入时，或者删除时，会拷贝所有元素，可能会超时</p>
<p>解法2：使用数组加上双角标实现，一个记录头部，一个记录尾部，形成一个环，此时需要注意，<strong>环的长度是k+1，头指向的是待加入的数字，尾指向的是加入数字的前一位</strong>。Golang中的channel就是这种结构。</p>
<p>解法3：双向链表，时间复杂度都是 <code>O(1)</code>，这个是最快的</p>
</li>
<li><p>接雨水：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmFwcGluZy1yYWluLXdhdGVyLw==">https://leetcode.cn/problems/trapping-rain-water/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：将所有位置的左边高墙和右边高墙求出来，最终计算总的结果，需要注意的是，如何确定这个位置的高墙，要满足两个条件，一个条件是左边位置有高墙，第二个条件是左边位置高墙高于自身，否则左边没有高墙。</p>
<p>解法2：获取每一层能够蓄水的个数，一个一个加起来，得到最终结果，例如第一层能够蓄水的个数，第i个格子能够蓄水，条件是这个格子的左边和右边，都要高于0的墙，也就是两边向中间靠拢，寻找第一个高于0的位置，然后再在这两个位置之间找到小于等于0的个数，加起来就是第1层蓄水的个数，然后顺序找第二层蓄水的个数，依然是从左边找到第一个大于2的数，从右边找到第一个大于2的数，然后找到这两个数之间小于等于1的位置的个数，加起来就是第二层蓄水的个数，以此一直循环到最高的一层。</p>
<p>解法3：使用单调栈，如果放进去的数字比顶上的数字小，则可以直接放进去，否则将顶的数字拿出来，直到顶部的数字不小于新的数字，获取将要放进去的数字和此时顶部数字的最小值，这个最小值和拿出来的数字差就是水池高度。注意，如果栈取空了，则最后一个取出来的数字是最小值。</p>
</li>
</ul>
<h3 id="哈希表和集合以及映射"><a href="#哈希表和集合以及映射" class="headerlink" title="哈希表和集合以及映射"></a>哈希表和集合以及映射</h3><p>Hash Table，也叫散列表，是根据关键码值（Key value）而言，直接进行访问的数据结构。查询、插入、删除的时间复杂度一般是 <code>O(1)</code></p>
<p>通过把关键码值映射到表中一个为止来访问记录，以加快查找的速度</p>
<p>这个映射函数叫做<strong>散列函数</strong>（Hash Function，也叫做哈希函数），存放记录的数组叫做哈希表（或散列表）</p>
<p>例如，<code>lies</code>通过hash函数处理，总数为429，对20取模，则将这个值放到位置值为9上</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213170420074.png" alt="image-20221213170420074"></p>
<p>Hash Collisions 哈希碰撞</p>
<p>对于不同的数据，经过相同的哈希函数处理之后，得到相同的下标，这种情况就是哈希碰撞。</p>
<p>一般的处理方式是放一个链表，但是当碰撞过多，查找效率会从 <code>O(1)</code>退化到 <code>O(n)</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213170522848.png" alt="image-20221213170522848"></p>
<p>Hash表的完整结构</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213170820506.png" alt="image-20221213170820506"></p>
<p>Set，集合：不重复元素的集合，相比哈希表，没有值，只有键。</p>
<p>映射：从查找的资料看，很少单独说映射，可以理解为映射也是hash map的一种，只是相比hash map的线程不安全，映射是线程安全的。（有的资料说是通过锁实现线程安全）</p>
<h3 id="典型题目-2"><a href="#典型题目-2" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>有效的字母异位词：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtYW5hZ3JhbS9kZXNjcmlwdGlvbi8=">https://leetcode-cn.com/problems/valid-anagram/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：字符串排序，然后看排序后的字符串是否相等</p>
<p>解法2：使用hash表</p>
</li>
<li><p>字母异位词分组：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZ3JvdXAtYW5hZ3JhbXMv">https://leetcode-cn.com/problems/group-anagrams/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：先排序，然后放到hash表中</p>
</li>
<li><p>两数只和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHdvLXN1bS9kZXNjcmlwdGlvbi8lRUYlQkMlOEMlRTQlQkIlQTUlRTUlOEYlOEElRTQlQjglODklRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEMlRUYlQkMlOEMlRTUlOUIlOUIlRTYlOTUlQjAlRTQlQjklOEIlRTUlOTIlOEM=">https://leetcode-cn.com/problems/two-sum/description/，以及三数之和，四数之和<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用hash，获取target-A是不是也存在于hash中</p>
</li>
</ul>
<h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树 Tree"></a>树 Tree</h3><p>相比一维的链表或者跳表，是为了解决检索问题，通过升维的思想加快检索。</p>
<p>利用这种升维的思想，一个节点可以同时指向多个节点，这样就形成了树形结构。</p>
<p>注意：树没有环。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213174159016.png" alt="image-20221213174159016"></p>
<h3 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树 Binary Tree"></a>二叉树 Binary Tree</h3><p>在实际开发过程中，用到的最多树形结构就是二叉树，二叉树也就是说每个节点最多只有两个子节点，分别是左子结点和右子节点。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213174748681.png" alt="image-20221213174748681"></p>
<p>二叉树的遍历方式可以分为三种，都是基于递归，当没有子节点时结束递归，根据递归的顺序可以分为这三种：</p>
<p>前序（Pre-order）：根-左-右</p>
<p>中序（In-order）：左-根-右</p>
<p>后序（Post-order）：左-右-根</p>
<h3 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图 Graph"></a>图 Graph</h3><p>图也是一种树形结构，但是相比树而言，图有环形结构</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213174957329.png" alt="image-20221213174957329"></p>
<p>因此，可以这样理解，链表就是特殊化的树，树就是特殊化的图。</p>
<h3 id="二叉搜索树-Binary-Search-Tree"><a href="#二叉搜索树-Binary-Search-Tree" class="headerlink" title="二叉搜索树 Binary Search Tree"></a>二叉搜索树 Binary Search Tree</h3><p>二叉搜索树（Binary Search Tree），也称二叉查找树，有序二叉树（Ordered Binary Tree），排序二叉树（Sorted Binary Tree），是指一颗空树或者具有下列性质的二叉树：</p>
<ul>
<li>左子树上<strong>所有节点</strong>的值，均小于它的根节点的值；</li>
<li>右子树上<strong>所有节点</strong>的值，均大于它的根节点的值；</li>
<li>以此类推；左、右子树也分别为二叉搜索树。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213181228162.png" alt="image-20221213181228162"></p>
<p>使用<strong>中序遍历</strong>时，就是<strong>升序排列</strong>。</p>
<p>查询、插入操作，都是 <code>O(log(n))</code></p>
<h3 id="典型题目-3"><a href="#典型题目-3" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>二叉树的中序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1pbm9yZGVyLXRyYXZlcnNhbC8=">https://leetcode.cn/problems/binary-tree-inorder-traversal/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，按照“左-中-右”的顺序递归</p>
<p>解法2：迭代，使用栈。判断当前节点是否为空，不为空，就压栈，然后处理左边节点，不为空就压栈，直到节点为空，说明左边结束了，然后从栈中取出结点，就是便利的节点，然后处理右边的节点，处理过程与上面一致，判断是否为空，不为空就压栈。</p>
</li>
<li><p>二叉树的前序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wcmVvcmRlci10cmF2ZXJzYWwv">https://leetcode.cn/problems/binary-tree-preorder-traversal/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，这个解法比较简单，按照“中-左-右”的顺序递归</p>
<p>解法2：迭代，使用栈，判断当前节点是否为空，不为空，则放到结果中，然后将右结点压栈，节点往左边移动，直到节点为空。处理完之后，左边处理完毕，只剩下右边节点，开始接触栈，只要栈不为空，从栈中取出数据，然后按照前面的逻辑处理，判断当前节点是否为空，不为空，则当道结果中，然后将右节点压栈。这里一开始直接将root压入栈中，代码会更加漂亮。</p>
</li>
<li><p>N叉树的后序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLWFyeS10cmVlLXBvc3RvcmRlci10cmF2ZXJzYWwv">https://leetcode.cn/problems/n-ary-tree-postorder-traversal/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，按照先子节点，然后本节点的顺序递归</p>
<p>解法2：迭代，使用栈，如果有子节点，则入栈，但是还需要加一个map，用于记录循环的tag</p>
</li>
<li><p>N叉树的前序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLWFyeS10cmVlLXByZW9yZGVyLXRyYXZlcnNhbC8=">https://leetcode.cn/problems/n-ary-tree-preorder-traversal/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归</p>
<p>解法2：迭代，使用栈，如果有子节点，则入栈，便利子节点的时候，先加入到res中，然后再判断该子节点是否有子节点，依然使用map记录便利的tag</p>
</li>
<li><p>N叉树的层序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLWFyeS10cmVlLWxldmVsLW9yZGVyLXRyYXZlcnNhbC8=">https://leetcode.cn/problems/n-ary-tree-level-order-traversal/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：广度优先遍历，写一个BFS算法，入参是数组，出参数数组，过程是将入参的子节点全部都便利出来</p>
</li>
</ul>
<h2 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h2><h3 id="高级树"><a href="#高级树" class="headerlink" title="高级树"></a>高级树</h3><p>二叉树本质是一种链表，通过升维形成树结构。</p>
<p>二叉树有三种遍历方式：前序（<code>Pre-order</code>）、中序（<code>In-order</code>）、后续（<code>Post-order</code>），（可以通过根节点的顺序来理解和记忆）</p>
<p>在二叉树的基础上，满足顺序要求，左子树所有节点均小于根节点；右子树所有节点均大于根节点；其他节点以此类推。则这棵树是一个搜索二叉树，在搜索时效率很高。此时进行中序遍历就是一个升序排列。</p>
<p>但是，当搜索树的结构部平衡，变成一根棍子，此时搜索速度就会从<code>O(log(n))</code>退化到<code>O(n)</code>。那么保证二叉树的平衡性，就很重要了。</p>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>AVL树是一种自平衡二叉树，具有以下特点：</p>
<ul>
<li><p>Balance Factor（平衡因子）：</p>
<p>左子树的高度减去右子树的高度（有时相反）。balance factor &#x3D; {-1,0,1}</p>
</li>
<li><p>通过旋转操作来进行平衡（四种）</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215165518116.png" alt="image-20221215165518116"></p>
<p>为了维持平衡因子，在加入元素时</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215165636052.png" alt="image-20221215165636052" style="zoom:25%;" />

<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215165649621.png" alt="image-20221215165649621" style="zoom:25%;" />

<p>通过四种旋转操作，维持平衡因子。</p>
<ol>
<li>左旋</li>
<li>右旋</li>
<li>左右旋</li>
<li>右左旋</li>
</ol>
<p>右右子树：左旋</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215174927132.png" alt="image-20221215174927132"></p>
<p>左左子树：右旋</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215174943002.png" alt="image-20221215174943002"></p>
<p>左右子树：左右旋</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175041845.png" alt="image-20221215175041845"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175049825.png" alt="image-20221215175049825"></p>
<p>右左子树：右左旋</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175128743.png" alt="image-20221215175128743"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215175154914.png" alt="image-20221215175154914"></p>
<p>总结之后：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/Tree_Rebalancing.gif" alt="Tree_Rebalancing"></p>
<p>带有子树的旋转</p>
<p>增加15	</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203032328.png" alt="image-20221215203032328" style="zoom:25%;" />

<p>加到末尾</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203103195.png" alt="image-20221215203103195" style="zoom:25%;" />

<p>先右旋</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203243856.png" alt="image-20221215203243856" style="zoom:25%;" />

<p>然后左旋</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203223503.png" alt="image-20221215203223503" style="zoom:25%;" />

<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203309163.png" alt="image-20221215203309163" style="zoom:25%;" />

<p>AVL是一个平衡二叉搜索树。（深度差距很小）</p>
<p>每个节点需要存放 <code>balcen factor = &#123;-1,0,1&#125;</code>，因此不足的是需要存储额外信息、且调整次数频繁。</p>
<p>会拥有四种旋转操作。</p>
<p>对于AVL深度差距小的平衡二叉树，衍生出来深度差距不小而二叉树，也就是近似平衡二叉树。</p>
<h3 id="红黑树-Red-Black-Tree"><a href="#红黑树-Red-Black-Tree" class="headerlink" title="红黑树 Red-Black Tree"></a>红黑树 Red-Black Tree</h3><p>红黑树是一种近似平衡的二叉搜索树（Binary Search Tree），它能够确保任何一个结点的左右子树的高度差小于两倍。具体来说，红黑树是满足如下条件的二叉搜索树：</p>
<ul>
<li>每个节点要么是红色，要么是黑色</li>
<li>根节点是黑色</li>
<li>每个叶结点（NIL结点，空结点）是黑色</li>
<li>不能有相邻的两个红色节点</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203746054.png" alt="image-20221215203746054"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221215203806433.png" alt="image-20221215203806433"></p>
<p>关键性质：</p>
<p>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</p>
<p>AVL树和红黑树对比</p>
<ul>
<li>AVL树比红黑树更严格的平衡，因此AVL树的查询效率更高</li>
<li>AVL树比红黑树在插入、删除操作上性能差，这也是由于AVL更严格的平衡性，会有更多的旋转操作</li>
<li>AVL树的结点上需要存储平衡因子或者高度，这些都是整数，而红黑树只需要在节点上用1个bit存储颜色</li>
<li>AVL树会运用在数据库上，会有更好的查询效率，而红黑树运用在一些语言的库中，例如<code>map</code>、映射这些数据结构中</li>
</ul>
<h3 id="布隆过滤器-Bloom-Filter"><a href="#布隆过滤器-Bloom-Filter" class="headerlink" title="布隆过滤器 Bloom Filter"></a>布隆过滤器 Bloom Filter</h3><p>在过滤重复数据的场景中，会经常使用<code>HashTable</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216093933925.png" alt="image-20221216093933925"></p>
<p>但是，在HashTable中会存储数据的<code>key</code>和<code>value</code>，相比而言，存储<code>value</code>的意义不大，并且在大数据量下，Hash冲突也会影响数据性能。因此，在这种场景下，更加适合布隆过滤器。</p>
<p>布隆过滤器由一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。</p>
<p>优点是空间效率和查询时间都远远超过一般的算法。</p>
<p>缺点是有一定的误识别率和删除困难。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216094301929.png" alt="image-20221216094301929"></p>
<p>图中，将x、y、z通过三个hash函数，得到对应的二进制位，添加到布隆过滤器中。判断w的时候，会通过hash函数判断对应二进制位是否都为1</p>
<p>存在误差的情况</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216094513742.png" alt="image-20221216094513742"></p>
<p>例如元素B，布隆过滤器查询到两个位都为1，此时会误判B已存在于布隆过滤器中。</p>
<p>因此，布隆过滤器一般用于缓存中，真正判断一个数据是否已存在，需要更准确的系统，例如数据库。</p>
<p>Golang实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个二进制数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add函数，hash之后，将对应的位置为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find函数</span></span><br><span class="line"><span class="comment">// 能找到说明可能存在</span></span><br></pre></td></tr></table></figure>

<h3 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存 Cache"></a>缓存 Cache</h3><p>缓存是为了加速数据访问，在一些性能有较大差距的情况下会使用到，例如从数据库读取数据在高并发大访问量场景下性能不高，会引入Redis缓存，又例如CPU直接访问硬盘中的数据性能低，会以内存作为缓存，又例如CPU处理数据使用内存性能低，会有L1 Cache，L2 Cache等。</p>
<p>缓存的要素取决于两个：缓存大小和替换策略。</p>
<h4 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h4><p><code>Least Recently Used</code>：最少最近优先</p>
<p>一般缓存会以<code>HashTable+Double ListedList</code>实现</p>
<p>具有 <code>O(1)</code>的查询效率</p>
<p>同时具有 <code>O(1)</code>的修改、更新效率</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221216101833319.png" alt="image-20221216101833319"></p>
<h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><p>LRU：least recently used</p>
<p>LFU：least frequently used</p>
<p>更多替换算法：<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfcmVwbGFjZW1lbnRfcG9saWNpZXM=">https://en.wikipedia.org/wiki/Cache_replacement_policies<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="典型题目-4"><a href="#典型题目-4" class="headerlink" title="典型题目"></a>典型题目</h4><ul>
<li><p>LRU缓存：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9scnUtY2FjaGUvIy8=">https://leetcode.cn/problems/lru-cache/#/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：Hash表+双向链表</p>
</li>
</ul>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>在树的数据结构中，一些算法的核心操作就是利用递归。</p>
<p>递归：通过函数体来进行的循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(factorial(<span class="number">6</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际过程</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213204352351.png" alt="image-20221213204352351"></p>
<p>递归代码的结构：</p>
<ol>
<li>终止条件</li>
<li>业务逻辑</li>
<li>将一些参数传到下一层</li>
<li>清理当前层</li>
</ol>
<p>递归的思维要点：</p>
<ul>
<li>找最近<strong>重复子问题</strong>，拆解成可重复解决的问题，通过递归实现</li>
<li>使用数学归纳法思维</li>
</ul>
<h3 id="典型题目-5"><a href="#典型题目-5" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>爬楼梯：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jbGltYmluZy1zdGFpcnMv">https://leetcode.cn/problems/climbing-stairs/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归的题目，找最近重复性。例如第三级台阶等于第二级台阶的次数+第一级台阶的次数。可以用缓存递归，时间复杂度是 <code>O(n)</code></p>
<p>解法2：使用动态规划</p>
</li>
<li><p>括号生成：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZW5lcmF0ZS1wYXJlbnRoZXNlcy8=">https://leetcode.cn/problems/generate-parentheses/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用递归，递归的方法有两种，主要是根据判断条件不同，第一种方式是 <code>f(n)</code>从 <code>f(n-1)</code>中，获取插入括号的方式，注意需要去重；第二种方式是 <code>f(2n)</code>从 <code>f(2n-1)</code>中可以增加的方式，要么增加一个 <code>(</code>要么增加一个 <code>)</code>，判断增加之后是否合理即可。</p>
</li>
<li><p>反转二叉树：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnZlcnQtYmluYXJ5LXRyZWUvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/invert-binary-tree/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，反转自己的两个子节点，然后将子节点传到下一层</p>
</li>
<li><p>验证二叉搜索树：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUv">https://leetcode.cn/problems/validate-binary-search-tree/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：利用二叉树的中序遍历有序性，先便利，然后检验排序是否正确。排序检验可以使用<code>sort.SliceIsSorted</code>方法</p>
</li>
<li><p>二叉树的最大深度：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">https://leetcode.cn/problems/maximum-depth-of-binary-tree/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：深度优先，递归，将子节点传入下一层，返回最深的子节点+1</p>
</li>
<li><p>二叉树的最小深度：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">https://leetcode.cn/problems/minimum-depth-of-binary-tree/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：广度优先，迭代，迭代的是子节点</p>
</li>
<li><p>二叉树的序列化与反序列化：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZXJpYWxpemUtYW5kLWRlc2VyaWFsaXplLWJpbmFyeS10cmVlLw==">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：深度优先，题目是传入一个结点，先进行序列化，然后再进行反序列化，先通过中序遍历进行排序，反序列化成中序，然后再通过相同的方式进行反序列化，使用递归</p>
<p>解法2：广度优先，使用迭代，先进行前序遍历进行序列化，反序列化的时候需要注意，节点拿出来的时候处理这个节点的子节点</p>
</li>
<li><p>二叉树的最近公共祖先：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUv">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力法，便利两次，记录对应节点的上面所有父节点，然后获取最后一个重叠的父节点</p>
<p>解法2：DFS，使用前序遍历，先便利自身，然后左节点，然后遍历右节点，将父节点作为结果返回，需要注意的是判断条件，当自身满足，则返回自身，否则便利左节点和右节点，如果命中其中之一则返回该节点，否则判断子节点是否命中两个如果命中则返回自身，如果没有，则判断左节点是否为空（为空代表没有命中），不为空则返回左节点，否则返回右节点（这种判断条件会简化代码）</p>
</li>
<li><p>从前序与中序遍历序列构造二叉树：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtaW5vcmRlci10cmF2ZXJzYWwv">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，将数组切开，切割成左节点的数组和右节点的数组，传递到左节点和右节点中</p>
</li>
<li><p>组合：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbnMv">https://leetcode.cn/problems/combinations/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，<code>f(n,k)</code>和 <code>f(n,k-1)</code>的关系，这里需要注意，在便利数组的时候，使用append操作，可能会导致原数组扩容，出现结果异常的情况</p>
</li>
<li><p>全排列：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMv">https://leetcode.cn/problems/permutations/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：递归，<code>f(nums)</code>和 <code>f(nums[1:])</code>的关系，每次往结果中插入一个数字，在任何地方插入</p>
</li>
<li><p>全排列 II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMtaWkv">https://leetcode.cn/problems/permutations-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：在上一题的基础上，增加数组去重</p>
</li>
</ul>
<h2 id="分治-Divide-amp-Conquer"><a href="#分治-Divide-amp-Conquer" class="headerlink" title="分治 Divide &amp; Conquer"></a>分治 Divide &amp; Conquer</h2><p>分治是从递归的思想分化而来，递归是将大问题分解为重复的小的子问题。而分治是将大问题分解为小问题，寻找小问题的重复性，最终将子问题组合，从而解决大问题。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221213211610933.png" alt="image-20221213211610933"></p>
<p>分治代码模板（与递归差不多）：</p>
<ol>
<li>终止条件，也就是子问题没有了</li>
<li>处理当前逻辑</li>
<li>调用函数，下探到下一层</li>
<li>将结果组合起来</li>
<li>清理当前层状态</li>
</ol>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>采用试错的思想，尝试分步的区解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其他的可能的分步解答再来尝试寻找问题的答案。</p>
<p>回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ul>
<li>找到一个可能存在的正确的答案</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案</li>
</ul>
<p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。</p>
<h3 id="典型题目-6"><a href="#典型题目-6" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>Pow(x,n)：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3d4LW4v">https://leetcode.cn/problems/powx-n/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力法，乘以n次，时间复杂度是 <code>O(n)</code></p>
<p>解法2：分治法，将n每次对半拆开，需要注意的是需要n的奇偶性和正负性，时间复杂度是 <code>O(log(n))</code></p>
</li>
<li><p>子集：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzLw==">https://leetcode.cn/problems/subsets/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DFS，一层一层往下，产生子集，最终汇总到一起</p>
<p>解法2：两个循环，一个循环数字，另外一个循环循环已经添加上的元素</p>
<p>解法3：位运算，位数为数组长度</p>
</li>
<li><p>多数元素：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYWpvcml0eS1lbGVtZW50L2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/majority-element/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用HashMap</p>
<p>解法2：先排序，然后取中值</p>
<p>解法3：投票法，先将 <code>[0]</code>登记为答案，票数为1，然后遍历到最后，相同的数，票数+1，不同的数，票数-1，票数为0，则将下一个数登记为答案，票数为1，直到最后，剩下的数就是答案</p>
</li>
<li><p>电话号码的字母组合：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZXR0ZXItY29tYmluYXRpb25zLW9mLWEtcGhvbmUtbnVtYmVyLw==">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：分治法加迭代</p>
<p>解法2：递归，<code>f(&quot;12&quot;)</code>为1代表的字母，和 <code>f(&quot;2&quot;)</code>的组合，需要注意的是，初始化的时候，使用<code>map[uint8][]string</code></p>
</li>
<li><p>N皇后：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uLXF1ZWVucy8=">https://leetcode.cn/problems/n-queens/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力回溯，先放1格，然后判断第二格是否满足，满足的时候继续下，不满足的时候，将前一格踢出去，从前一格的位置往后下</p>
<p>解法2：递归加回溯，一排一排遍历，便利的时候判断从0到n哪一个点满足放皇后，满足的话，继续递归到下一层，最终全部满足则为结果</p>
</li>
</ul>
<h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h2><p>在树或者图结构中，需要遍历所有节点、并且每个节点仅访问一次的情况下，可以使用深度优先或者广度优先处理。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214103122667.png" alt="image-20221214103122667"></p>
<p>DFS实例代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _,ok := visited[node];ok &#123;</span><br><span class="line">		<span class="comment">// already visited </span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	visited[node] = <span class="literal">true</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">// process current node </span></span><br><span class="line">  <span class="comment">// logic </span></span><br><span class="line">  <span class="comment">// 如果是一个多叉树，则需要便利所有的多叉树</span></span><br><span class="line">	dfs(node.Left)</span><br><span class="line">	dfs(node.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历顺序：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214103531661.png" alt="image-20221214103531661"></p>
<p>先从左节点（或者右节点）往下遍历，便利到最底层，最底层没有数据之后，再访问另外一边。</p>
<p>图中的遍历顺序也是一样的</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214105138027.png" alt="image-20221214105138027"></p>
<p>图中使用递归，则需要判断当前节点是否被遍历过</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _,ok := visited[node];ok &#123;</span><br><span class="line">		<span class="comment">// already visited </span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// process </span></span><br><span class="line">	visited[node] = <span class="literal">true</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment">// next level </span></span><br><span class="line">	<span class="keyword">for</span> _,nextNode:= <span class="keyword">range</span> node.Children &#123;</span><br><span class="line">		<span class="keyword">if</span> _,ok := visited[nextNode];!ok &#123;</span><br><span class="line">			dfs(nextNode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归写法，使用栈模拟递归</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *Node)</span></span> []*Node &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">	&#125;</span><br><span class="line">	visited := <span class="built_in">make</span>(<span class="keyword">map</span>[*Node]<span class="type">bool</span>)</span><br><span class="line">	stack := NewStack(*Node)</span><br><span class="line">	stack.Push(root)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> stack.Len != <span class="number">0</span> &#123;</span><br><span class="line">		node = stack.Pop()</span><br><span class="line">		visited[node]=<span class="literal">true</span> </span><br><span class="line"></span><br><span class="line">		process(node)</span><br><span class="line"></span><br><span class="line">		nodes := generate_related_nodes(node)</span><br><span class="line">		stack.push(nodes)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索 BFS"></a>广度优先搜索 BFS</h2><p>广度优先遍历就需要使用队列</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214105946104.png" alt="image-20221214105946104"></p>
<p>广度优先相比深度优先的顺序：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214110048812.png" alt="image-20221214110048812"></p>
<p>使用队列迭代：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(start *Node)</span></span> &#123;</span><br><span class="line">	queue := NewQueue(*Node)</span><br><span class="line">  <span class="comment">// 将start入队</span></span><br><span class="line">	queue.Push(start)</span><br><span class="line"></span><br><span class="line">	visited[start]=<span class="literal">true</span> </span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 从队列中取出，队列，先入先出</span></span><br><span class="line">		node := queue.Pop()</span><br><span class="line"></span><br><span class="line">		process(node)</span><br><span class="line"></span><br><span class="line">		nodes := generate_related_nodes(node)</span><br><span class="line">    <span class="comment">// 将子node放到队列中</span></span><br><span class="line">		queue.Push(nodes)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="典型题目-7"><a href="#典型题目-7" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>二叉树的层序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwvIy9kZXNjcmlwdGlvbg==">https://leetcode.cn/problems/binary-tree-level-order-traversal/#/description<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：BFS</p>
<p>解法2：使用DFS，然后记录层树</p>
<p>解法3：骚操作，直接通过脚标便利，每一层开始是<code>2^(n-1)</code>，结尾是 <code>2^(n-1)-1</code></p>
</li>
<li><p>最小基因变化：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWdlbmV0aWMtbXV0YXRpb24vIy9kZXNjcmlwdGlvbg==">https://leetcode.cn/problems/minimum-genetic-mutation/#/description<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：BFS，但是需要注意，不能往回走</p>
</li>
<li><p>在每个树行中找到最大值：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWxhcmdlc3QtdmFsdWUtaW4tZWFjaC10cmVlLXJvdy8jL2Rlc2NyaXB0aW9u">https://leetcode.cn/problems/find-largest-value-in-each-tree-row/#/description<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：BFS，使用数组记录下一层节点，记录这层节点的最大值，直到没有下一层，需要注意的是放入数组的条件</p>
</li>
<li><p>单词接龙：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLWxhZGRlci9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/word-ladder/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：与上面最小基因变化的代码一样，将start放到数组里面，然后比较数组里面能够变化而成的字母，放到新的数组里面，以此变化，注意，不能往回走，因此需要将所有便利过的单词记录下来</p>
<p>解法2：双向BFS，头和尾两端一起BFS</p>
</li>
<li><p>单词接龙 II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLWxhZGRlci1paS9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/word-ladder-ii/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：这题目相比上一题，需要打印出路径，因此最好是选择使用树形结构记录下产生的树，要使用hashmap去重。将节点与总hashmap中的元素对比查看是否可以作为子节点，如果能够作为子节点，则去掉总HashMap，但是这种解法，一般会超时</p>
<p>解法2：双向BFS</p>
</li>
<li><p>岛屿数量：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtaXNsYW5kcy8=">https://leetcode.cn/problems/number-of-islands/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DFS，删除最边缘的1</p>
<p>解法2：BFS，往上、下、左、右扩散，碰到1，就将1和周边的1全部变成0，一直到全部变成0，次数就是岛屿数量</p>
</li>
<li><p>扫雷游戏：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5lc3dlZXBlci9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/minesweeper/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：DFS，递归，先判断点是不是雷，如果是，修改标记，返回，如果不是，则获取周围个数，如果个数是0，该标记，将八个方向的点递归，如果个数大于0，则标记个数，返回。</p>
</li>
</ul>
<h2 id="贪心算法-Greedy"><a href="#贪心算法-Greedy" class="headerlink" title="贪心算法 Greedy"></a>贪心算法 Greedy</h2><p>贪心算法是一种在每一步选择中都采取在<strong>当前状态下最好或最优（即最有利）的选择</strong>，从而希望导致结果是全局最好或最优的算法。</p>
<p>贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p>
<p>贪心算法可以解决一些最优化问题，如：求图中的最小生成树，求哈夫曼编码等。然后对于工程和生活中的问题，贪心算法一般不能得到所求的答案。</p>
<p>一旦一个问题可以通过贪心算法来解决，那么贪心算法一般是解决这个问题的最好办法。由于贪心算法的高效性以及其所求得的答案比较接近最有结果，贪心算法可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。比如最小生成树。</p>
<p>适用贪心算法的场景：</p>
<ul>
<li>问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。</li>
<li>相比动态规划，每个子问题的解决方案做出选择，不能回退；</li>
</ul>
<h3 id="典型题目-8"><a href="#典型题目-8" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>零钱兑换：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS8=">https://leetcode.cn/problems/coin-change/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：贪心算法，先用最大匹配，再用次大匹配。这是由于硬币是倍数。当硬币不是倍数，则不一定能使用贪心算法</p>
<p>解法2：递归，<code>f（n）=min(f(n-5),f(n-2),f(n-1)) +1</code>，也就是某一个数，等于对应硬币的最小次数，加上这枚硬币。自上而下的递归会超时，需要自下而上。</p>
</li>
<li><p>柠檬水找零：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZW1vbmFkZS1jaGFuZ2UvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/lemonade-change/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：记录5、10、20块面额钱的个数，因为只需要找5、15的面额，分别讨论即可。需要注意，贪心的是如果找15，则尽量先试用10块的面额。</p>
</li>
<li><p>买卖股票的最佳时机II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWlpL2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>重点是想到如何获取最大时机，是比较相邻两天。</p>
<p>解法1：贪心算法，只要后面1天比前面1天高，就前1天买，后1天卖。</p>
<p>解法2：动态规划，DP，其中，dp定义是一个二维数组，一位代表天数，二维代表手上有股票还是没有股票，状态转移方程是：如果今天不持有股票，则手上的钱是要么昨天有股票，将股票卖掉，要么是昨天没有股票，今天也没有，两者取最大值，<code>dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i])</code>；如果今天要持有股票，则手上的钱是昨天不持有股票的情况再买股票，或者昨天有股票的时候，两者取最小值，<code>dp[i][1] = max(dp[i-1][0]-prices[i],dp[i-1][1])</code>。</p>
</li>
<li><p>分发饼干：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3NpZ24tY29va2llcy9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/assign-cookies/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：贪心算法，先排序，优先满足胃口小的孩子，双指针，一个代表孩子，一个代表饼干</p>
</li>
<li><p>模拟行走机器人：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93YWxraW5nLXJvYm90LXNpbXVsYXRpb24vZGVzY3JpcHRpb24v">https://leetcode.cn/problems/walking-robot-simulation/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：模拟走格子即可，需要注意的是要将环境准备好，这里不需要准备二元数组作为格子，而是准备好方向，由于障碍物要一直判断，因此，需要将障碍物加入到map中</p>
</li>
<li><p>跳跃游戏：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUv">https://leetcode.cn/problems/jump-game/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：按照层数递归，贪心算法，能跳到最后一层则为true，不能则回溯，然后步数-1</p>
<p>解法2：两重循环，通过步数，更新能跳到的点，记录为true，，时间复杂度 <code>O(n^2)</code></p>
<p>解法3：贪心算法，从后往前进行贪心，时间复杂度是 <code>O(n)</code></p>
<p>解法4：记录最大的能到的地方，便利这些地方，如果有比最大的更大，则最大能到的地方更新，直接便利完最大的地方，还没有到达终点，则为不可达，便利的时候，如果最大的地点大于或者等于终点，则代表可达</p>
</li>
<li><p>跳跃游戏II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUtaWkv">https://leetcode.cn/problems/jump-game-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：双指针，第一个指针从0开始，第二个指针是最大当前能够走到的步数，从指针1便利到指针2，更新最小步数，最小步数为第一个指针的步数+1，同时获取能够走到的最大下一步。更新完成之后，第一个指针移动到第二个指针的位置，第二个指针移动到最大的位置，继续便利。</p>
</li>
</ul>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找的前提：</p>
<ol>
<li>目标函数单调性（单调递增或者递减）</li>
<li>存在上下界（bounded）</li>
<li>能够通过索引访问（index accessible）（排除单链表）</li>
</ol>
<p>Golang代码模板</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearch</span><span class="params">(array []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	left, right := <span class="number">0</span>, <span class="built_in">len</span>(array)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">		mid := (left + right) / <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> array[mid] == target &#123;</span><br><span class="line">			<span class="keyword">return</span> left</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> array[mid] &gt; target &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>				<span class="comment">// 注意，这里要 -1 ，防止最终找不到</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214135650823.png" alt="image-20221214135650823"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214135808104.png" alt="image-20221214135808104"></p>
<h3 id="典型题目-9"><a href="#典型题目-9" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>x的平方根：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcXJ0eC8=">https://leetcode.cn/problems/sqrtx/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用二分法，这里的二分法需要注意，<code>end</code>为<code>x/2+1</code>，条件是<code>start&lt;=end</code>，返回的是<code>start-1</code></p>
<p>解法2：牛顿迭代法</p>
</li>
<li><p>有效的完全平方根：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wZXJmZWN0LXNxdWFyZS8=">https://leetcode.cn/problems/valid-perfect-square/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用二分法，<code>end</code>为<code>x/2+1</code>，条件是<code>start&lt;=end</code></p>
</li>
<li><p>搜索旋转排序数组：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tcm90YXRlZC1zb3J0ZWQtYXJyYXkv">https://leetcode.cn/problems/search-in-rotated-sorted-array/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：使用二分法和迭代，<code>(nums[start] &lt;= target &amp;&amp; target &lt;= nums[mid]) || (nums[mid] &lt;= target &amp;&amp; target &lt;= nums[end])</code>时，说明<code>target</code>在升序的数组之间，使用二分法查找即可。其他的情况，说明也是一个旋转的数组，将头和尾再进行迭代即可，需要注意的是要判断一下当<code>target</code>不存在于这个区间的情况，</p>
</li>
<li><p>搜索二维矩阵：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtYS0yZC1tYXRyaXgv">https://leetcode.cn/problems/search-a-2d-matrix/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：先试用二分法确定行，这个其实就是将每一行的第一个元素取出来，找到最大的小于<code>target</code>的数，也就是目的行，然后再到这一行中使用二分法，是否能查询到数字</p>
</li>
<li><p>寻找旋转排序数组中的最小值：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLW1pbmltdW0taW4tcm90YXRlZC1zb3J0ZWQtYXJyYXkv">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：先排序</p>
<p>解法2：直接二分查找，关键在于需要确定小的数字在左边部分还是右边部分，时间复杂度是 <code>O(log(n))</code>。不停地寻找左边大于右边的数组，直到查找到<code>[2,1]</code>这样子的，需要注意的是，左角标往<code>mid+1</code>移动，而右角标等于<code>mid</code></p>
</li>
</ul>
<h2 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划 Dynamic Programming"></a>动态规划 Dynamic Programming</h2><p>又叫做<strong>动态递推</strong>，将一个复杂的问题，以递归的方式将它分解为简单的子问题。相比分治，分治中每一个子问题中有一个最优解，然后得到全局最优解，但是动态规划中，不需要保存这些值。动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构），共性是<strong>找到重复子问题</strong>。</p>
<p>差异性是最优子结构、中途可以淘汰次优解。</p>
<p>例如：斐波那契数列</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214143305811.png" alt="image-20221214143305811"></p>
<p>时间复杂度是 <code>O(n^2)</code>，每一个节点，都要将下面的节点计算一次，每一个下面的节点，又要将它下面的节点计算一次。</p>
<p>优化方法是做一个缓存，将已经计算过的数字，缓存起来。将时间复杂度降低到 <code>O(n)</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214143544513.png" alt="image-20221214143544513"></p>
<p>有例如走格子问题：</p>
<p>不同路径：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMv">https://leetcode.cn/problems/unique-paths/<i class="fa fa-external-link-alt"></i></span></p>
<p>不同路径II：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMtaWkv">https://leetcode.cn/problems/unique-paths-ii/<i class="fa fa-external-link-alt"></i></span></p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214145242758.png" alt="image-20221214145242758" style="zoom:25%;" />

<p>从start到end的做法，其实是从A走到end的做法+从B到end的做法，这种分治的思想。</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214145426297.png" alt="image-20221214145426297" style="zoom:25%;" />

<p>还可以使用递推的思想，从结尾的地方，向上递推，每个格子的做法为相邻两个格子走法的和，</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214145854501.png" alt="image-20221214145854501" style="zoom:25%;" />

<p>边界和墙都无法走向该格子，有相邻的右边格子和下边格子才能走到对应格子，最终可以得到地图上每一个格子到end的走法</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221214150158043.png" alt="image-20221214150158043" style="zoom:25%;" />

<p>动态规划关键点：</p>
<ol>
<li><p>最优子结构： <code>opt[n] = best_of(opt[n-1],opt[n-2],...)</code></p>
</li>
<li><p>存储中间状态：<code>opt[i]</code></p>
</li>
<li><p>递推公式（或者叫做状态转移方程或者DP方程）</p>
<p>Fib: <code>opt[n] = opt[n-1] + opt[n-2]</code></p>
<p>二维路径: <code>opt[i,j]=opt[i+1][j]+opt[i][j+1]</code>（且判断 <code>a[i,j]</code>是否空地）</p>
</li>
</ol>
<p>又例如最长公共子序列</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbW1vbi1zdWJzZXF1ZW5jZS8=">https://leetcode.cn/problems/longest-common-subsequence/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力求解，求两个字符串的子序列，然后两个子序列对比是否存在，时间复杂度是 <code>O(2^n)</code></p>
<p>解法2：找到重复性，看最后一个字母是否相同，如果相同，则计算减掉这个字符串之后剩余字符串的最长子序列+1，如果不相同，则随机选择一个字符串去掉一个字符，然后比较。</p>
<h3 id="典型题目-10"><a href="#典型题目-10" class="headerlink" title="典型题目"></a>典型题目</h3><ul>
<li><p>爬楼梯：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jbGltYmluZy1zdGFpcnMvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/climbing-stairs/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：<code>f(n)=f(n-1)+f(n-2)</code></p>
</li>
<li><p>三角形最小路径和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmlhbmdsZS9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/triangle/description/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：n层递归，每一层可以左也可以右，但是需要缓存起来</p>
<p>解法2：DP，找到重复性，定义状态数组，列出DP方程。DP可以从上往下，也可以从下往上，相比而言，从上往下理解起来更加简单。状态转移方程，其实就是对应节点的左上和右上最小的路径，外加自身的长度。<code>problem(i,j) = min(sub(i-1,j),sub(i-1,j-1))+a[i,j]</code>，需要注意的是，最左侧和最右侧的路径计算方法不一样，需要独立处理。</p>
<p>国际版推荐解法：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHJpYW5nbGUvc29sdXRpb25zLzM4NzM1L1B5dGhvbi1lYXN5LXRvLXVuZGVyc3RhbmQtc29sdXRpb25zLSh0b3AtZG93bi1ib3R0b20tdXApLi8=">https://leetcode.com/problems/triangle/solutions/38735/Python-easy-to-understand-solutions-(top-down-bottom-up)./<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>最大子数组和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXN1YmFycmF5Lw==">https://leetcode.cn/problems/maximum-subarray/<i class="fa fa-external-link-alt"></i></span></p>
<p>解法1：暴力法：起点和终点都是正数，时间复杂度