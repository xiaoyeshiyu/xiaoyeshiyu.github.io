<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.1.1">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="S_5aoPFd3QQihrUOLiKdVR0Mj4fj6n6qJojwyjj9cAY">
  <meta name="msvalidate.01" content="9032A67FCF787F07CB04374E59E518A9">
  <meta name="baidu-site-verification" content="code-Onlniop0d6">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.xiaoyeshiyu.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.19.1","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="现在面试肯定有笔试环节，大部分的笔试题在 ht100 中又可以找到相似的思路。笔者在刷的时候对里面的知识点再次细化一下，感触颇深。本篇文章是上部分，包含 50 道题。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode Hot100笔记-上">
<meta property="og:url" content="https://www.xiaoyeshiyu.com/post/116450ad.html">
<meta property="og:site_name" content="小夜时雨">
<meta property="og:description" content="现在面试肯定有笔试环节，大部分的笔试题在 ht100 中又可以找到相似的思路。笔者在刷的时候对里面的知识点再次细化一下，感触颇深。本篇文章是上部分，包含 50 道题。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F16-20-00-image-20240528162000681.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F16-41-05-image-20240528164105774.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F11-55-12-image-20240529115512378.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F14-27-30-image-20240529142729920.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-05-54-image-20240529150554143.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-13-16-image-20240529151316179.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-24-50-image-20240529152450345.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F17-06-13-image-20240529170613533.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F17-09-42-image-20240529170942663.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F17-30-23-image-20240529173023889.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F17-57-12-image-20240529175712166.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F09-33-15-image-20240530093315348.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F09-44-42-image-20240530094442319.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F16-25-33-image-20240528162533308.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F16-30-30-image-20240528163030751.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F16-44-07-image-20240528164407067.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F16-47-51-image-20240528164751480.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F17-41-08-image-20240528174108703.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F17-49-11-image-20240528174911328.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F17-56-07-image-20240528175607797.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F10-14-45-image-20240529101445458.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F10-22-56-image-20240529102256425.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F10-29-39-image-20240529102939870.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F10-34-26-image-20240529103426009.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F11-30-11-image-20240529113011253.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F11-33-51-image-20240529113351412.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F11-45-46-image-20240529114545950.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F11-50-50-image-20240529115050600.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-16-44-image-20240529151644049.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-30-25-image-20240529153025376.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-40-46-image-20240529154046000.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-45-00-image-20240529154500550.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F16-02-42-image-20240529160242903.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F16-11-09-image-20240529161109394.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F16-23-57-image-20240529162357272.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F09-38-15-image-20240530093815446.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F10-11-58-image-20240530101158822.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F10-20-59-image-20240530102059597.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F11-01-22-image-20240530110122014.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F11-05-19-image-20240530110519525.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F11-13-49-image-20240530111349482.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F11-22-02-image-20240530112202476.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F11-40-13-image-20240530114013712.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F17-26-22-image-20240528172622206.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F09-32-53-image-20240529093253614.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F09-47-53-image-20240529094753016.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F11-15-00-image-20240529111500283.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-51-59-image-20240529155159670.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F16-16-23-image-20240529161623207.png">
<meta property="og:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F11-48-14-image-20240530114813934.png">
<meta property="article:published_time" content="2024-05-27T16:00:00.000Z">
<meta property="article:modified_time" content="2024-06-12T07:21:54.878Z">
<meta property="article:author" content="Mitaka xu">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F16-20-00-image-20240528162000681.png">


<link rel="canonical" href="https://www.xiaoyeshiyu.com/post/116450ad.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.xiaoyeshiyu.com/post/116450ad.html","path":"post/116450ad.html","title":"LeetCode Hot100笔记-上"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LeetCode Hot100笔记-上 | 小夜时雨</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MBVJ11TVHH"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBVJ11TVHH","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?573725610fbc6ff9b42032bd13615370"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><script src="https://cdn.jsdelivr.net/gh/BP-Devteam/sitescansense/s3module.min.js"></script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="小夜时雨" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小夜时雨</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">君子敬其在己者，而不慕其在天者，是以日进也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95"><span class="nav-number">1.</span> <span class="nav-text">简单</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.1.</span> <span class="nav-text">1. 两数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="nav-number">1.2.</span> <span class="nav-text">283. 移动零</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">1.3.</span> <span class="nav-text">160. 相交链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text">206. 反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.</span> <span class="nav-text">234. 回文链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">1.6.</span> <span class="nav-text">141. 环形链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.7.</span> <span class="nav-text">21. 合并两个有序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.8.</span> <span class="nav-text">94. 二叉树的中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.9.</span> <span class="nav-text">104. 二叉树的最大深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.10.</span> <span class="nav-text">226. 翻转二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.11.</span> <span class="nav-text">101. 对称二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">1.12.</span> <span class="nav-text">543. 二叉树的直径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.13.</span> <span class="nav-text">108. 将有序数组转换为二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E7%AD%89"><span class="nav-number">2.</span> <span class="nav-text">中等</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="nav-number">2.1.</span> <span class="nav-text">49. 字母异位词分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="nav-number">2.2.</span> <span class="nav-text">128. 最长连续序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">11. 盛最多水的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">2.4.</span> <span class="nav-text">15. 三数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">2.5.</span> <span class="nav-text">3. 无重复字符的最长子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">2.6.</span> <span class="nav-text">438. 找到字符串中所有字母异位词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#560-%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">2.7.</span> <span class="nav-text">560. 和为 K 的子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">2.8.</span> <span class="nav-text">53. 最大子数组和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">2.9.</span> <span class="nav-text">56. 合并区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-number">2.10.</span> <span class="nav-text">189. 轮转数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="nav-number">2.11.</span> <span class="nav-text">238. 除自身以外数组的乘积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6"><span class="nav-number">2.12.</span> <span class="nav-text">73. 矩阵置零</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="nav-number">2.13.</span> <span class="nav-text">54. 螺旋矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="nav-number">2.14.</span> <span class="nav-text">48. 旋转图像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II"><span class="nav-number">2.15.</span> <span class="nav-text">240. 搜索二维矩阵 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="nav-number">2.16.</span> <span class="nav-text">142. 环形链表 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">2.17.</span> <span class="nav-text">2. 两数相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">2.18.</span> <span class="nav-text">19. 删除链表的倒数第 N 个结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">2.19.</span> <span class="nav-text">24. 两两交换链表中的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#138-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">2.20.</span> <span class="nav-text">138. 随机链表的复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">2.21.</span> <span class="nav-text">148. 排序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="nav-number">2.22.</span> <span class="nav-text">146. LRU 缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.23.</span> <span class="nav-text">102. 二叉树的层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">2.24.</span> <span class="nav-text">98. 验证二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">2.25.</span> <span class="nav-text">230. 二叉搜索树中第K小的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">2.26.</span> <span class="nav-text">199. 二叉树的右视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-number">2.27.</span> <span class="nav-text">114. 二叉树展开为链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.28.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="nav-number">2.29.</span> <span class="nav-text">437. 路径总和 III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">2.30.</span> <span class="nav-text">236. 二叉树的最近公共祖先</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%B0%E9%9A%BE"><span class="nav-number">3.</span> <span class="nav-text">困难</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-number">3.1.</span> <span class="nav-text">42. 接雨水</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">3.2.</span> <span class="nav-text">239. 滑动窗口最大值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="nav-number">3.3.</span> <span class="nav-text">76. 最小覆盖子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="nav-number">3.4.</span> <span class="nav-text">41. 缺失的第一个正数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">3.5.</span> <span class="nav-text">25. K 个一组翻转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">3.6.</span> <span class="nav-text">23. 合并 K 个升序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">3.7.</span> <span class="nav-text">124. 二叉树中的最大路径和</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mitaka xu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mitaka xu</p>
  <div class="site-description" itemprop="description">Golang开发博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaoyeshiyu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/116450ad.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="LeetCode Hot100笔记-上 | 小夜时雨">
      <meta itemprop="description" content="现在面试肯定有笔试环节，大部分的笔试题在 ht100 中又可以找到相似的思路。笔者在刷的时候对里面的知识点再次细化一下，感触颇深。本篇文章是上部分，包含 50 道题。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode Hot100笔记-上
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-05-28 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-28T00:00:00+08:00">2024-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-06-12 15:21:54" itemprop="dateModified" datetime="2024-06-12T15:21:54+08:00">2024-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
    <span id="/post/116450ad.html" class="post-meta-item leancloud_visitors" data-flag-title="LeetCode Hot100笔记-上" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

            <div class="post-description">现在面试肯定有笔试环节，大部分的笔试题在 ht100 中又可以找到相似的思路。笔者在刷的时候对里面的知识点再次细化一下，感触颇深。本篇文章是上部分，包含 50 道题。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtLw==">1. 两数之和<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F16-20-00-image-20240528162000681.png" alt="image-20240528162000681"></p>
<p>知识点：hashmap</p>
<p>使用 hashmap，遍历数组的时候，查询另外一个值是否在 hashmap 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    total := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> idx, ok := total[target-v]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;idx, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        total[v] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还需要联想到双指针，如果是返回数字，可以使用双指针。先排序，然后一个指针在最左，一个指针在最右，判断指针的值相加跟 target 的大小对比，往中间走。</p>
<h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tb3ZlLXplcm9lcy8=">283. 移动零<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F16-41-05-image-20240528164105774.png" alt="image-20240528164105774"></p>
<p>知识点：双指针</p>
<p>左右指针，左指针记录需要调换的非零数字的位置，右指针往右边走，如果不是 0，则跟左指针调换，左指针往右移</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> l,r <span class="type">int</span> </span><br><span class="line">    <span class="keyword">for</span> ;r&lt;<span class="built_in">len</span>(nums);r++&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[r] != <span class="number">0</span>&#123;</span><br><span class="line">            nums[l],nums[r] = nums[r],nums[l]</span><br><span class="line">            l++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnRlcnNlY3Rpb24tb2YtdHdvLWxpbmtlZC1saXN0cy8=">160. 相交链表<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F11-55-12-image-20240529115512378.png" alt="image-20240529115512378"></p>
<p>知识点：链表，hashmap，双指针</p>
<p>最简单的方法是使用 hashmap，将节点作为 map 的 key 保存进去。</p>
<p>还有另外一种方法，可以理解为双指针，一个从 A 开始走，一个从 B 开始走，某一个走到结尾，则从另外一个开始走，相交的时候则代表是重复节点。如果想等了，说明要么是到了相交点，要么是都是 空。</p>
<p>一般来说，hashmap 的思路都可以想到，双指针的思路如果可以想到则尽量使用这个思路。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    tmpA,tmpB := headA,headB</span><br><span class="line">    <span class="keyword">for</span> tmpA != tmpB &#123;</span><br><span class="line">        <span class="keyword">if</span> tmpA == <span class="literal">nil</span> &#123;</span><br><span class="line">            tmpA = headB</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> tmpB == <span class="literal">nil</span> &#123;</span><br><span class="line">            tmpB = headA</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> tmpA != tmpB &#123;</span><br><span class="line">            tmpA = tmpA.Next</span><br><span class="line">            tmpB = tmpB.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> tmpA</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmpA </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWxpbmtlZC1saXN0Lw==">206. 反转链表<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F14-27-30-image-20240529142729920.png" alt="image-20240529142729920"></p>
<p>知识点：链表</p>
<p>翻转链表的方法有很多，最朴实的方式是全部放在一个数组，然后重新排列。</p>
<p>还有两外一种方法，就是递归，链表的题目大部分可以使用递归来实现，[1,2,3,4,5] 的翻转，其实是操作 1 和 [2,3,4,5] 翻转后的链表。</p>
<p>递归的核心是什么时候退出链表；递归内的操作是什么；递归下一个的是什么。</p>
<p>链表的处理方法，一半要画图来解决，思路会更加清晰，否则很容易搞混淆。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 使用递归</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到下一个</span></span><br><span class="line">    next := head.Next</span><br><span class="line">    <span class="comment">// 设置Next 为空，避免出现空指针</span></span><br><span class="line">    head.Next = <span class="literal">nil</span> </span><br><span class="line">    <span class="comment">// 反转后面的</span></span><br><span class="line">    n := reverseList(next)</span><br><span class="line">    <span class="comment">// 放入自己</span></span><br><span class="line">    next.Next = head </span><br><span class="line">    <span class="comment">// 返回后面返回的头</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLWxpbmtlZC1saXN0Lw==">234. 回文链表<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-05-54-image-20240529150554143.png" alt="image-20240529150554143"></p>
<p>知识点：链表</p>
<p>如果都拿出来，放在数组里面，可能后导致数组长度过大，因此还是需要按照链表的方式解决。</p>
<p>如果是用链表来解决，可以尝试翻转链表，然后跟原链表对比，此时会新增内存；或者使用递归，递归到最后如果下一个是 nil 则开始比较。</p>
<p>这里用比较简单的方法，就是使用数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    total := <span class="built_in">make</span>([]*ListNode,<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        total = <span class="built_in">append</span>(total,head)</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i &lt; <span class="built_in">len</span>(total) &gt;&gt; <span class="number">1</span>; i++&#123;</span><br><span class="line">        <span class="keyword">if</span> total[i].Val != total[<span class="built_in">len</span>(total)<span class="number">-1</span>-i].Val &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS8=">141. 环形链表<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-13-16-image-20240529151316179.png" alt="image-20240529151316179"></p>
<p>知识点：链表，hashmap</p>
<p>首先可以考虑使用hashmap，记录所有已经写入进去的节点。</p>
<p>还有一种更快的方法，快慢指针，慢指针一次性走一步，快指针一次性走两步，如果重合了说明有环。</p>
<p>hashmap 比较容易想出来，这里使用快慢指针；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    fast,slow := head,head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tc29ydGVkLWxpc3RzLw==">21. 合并两个有序链表<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-24-50-image-20240529152450345.png" alt="image-20240529152450345"></p>
<p>知识点：双指针、链表、排序</p>
<p>最容易也是简单的方法是都放在一个数组里面，排序，然后组合成链表；</p>
<p>还可以使用双指针，比较出一个较小的吐出来，放在新的链表后面。这里使用这种方法来解答，时间复杂度更优。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    pre := &amp;ListNode&#123;&#125;</span><br><span class="line">    node := pre </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> list1 != <span class="literal">nil</span> &amp;&amp; list2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> list1.Val &gt; list2.Val &#123;</span><br><span class="line">            node.Next = list2</span><br><span class="line">            list2 = list2.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.Next = list1</span><br><span class="line">            list1 = list1.Next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = node.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后将剩下的放在后面</span></span><br><span class="line">    <span class="keyword">if</span> list1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Next = list1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> list2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node.Next = list2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1pbm9yZGVyLXRyYXZlcnNhbC8=">94. 二叉树的中序遍历<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F17-06-13-image-20240529170613533.png" alt="image-20240529170613533"></p>
<p>知识点：二叉树，遍历</p>
<p>使用二叉树的遍历，就容易想到递归。中序遍历是先左边，再中间，再右边。左边作为一个集体，可以单独递归处理，右边同理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理左边</span></span><br><span class="line">    res = inorderTraversal(root.Left)</span><br><span class="line">    <span class="comment">// 把自己放进去</span></span><br><span class="line">    res = <span class="built_in">append</span>(res,root.Val)</span><br><span class="line">    <span class="comment">// 处理右边</span></span><br><span class="line">    res = <span class="built_in">append</span>(res,inorderTraversal(root.Right)...)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">104. 二叉树的最大深度<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F17-09-42-image-20240529170942663.png" alt="image-20240529170942663"></p>
<p>知识点：二叉树</p>
<p>首先想到的是使用 bfs，一层一层的遍历下去。但是这个题目可以使用更好的方法，也就是遍历。最大深度为左右节点的最大深度的最大值+1</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(maxDepth(root.Left),maxDepth(root.Right)) + <span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnZlcnQtYmluYXJ5LXRyZWUv">226. 翻转二叉树<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F17-30-23-image-20240529173023889.png" alt="image-20240529173023889"></p>
<p>知识点：二叉树</p>
<p>这个题目里面非常适合使用递归来做，其他的方法都没有递归简单</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转左右两边，然后递归</span></span><br><span class="line">    root.Left,root.Right = root.Right,root.Left</span><br><span class="line">    invertTree(root.Left)</span><br><span class="line">    invertTree(root.Right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zeW1tZXRyaWMtdHJlZS8=">101. 对称二叉树<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F17-57-12-image-20240529175712166.png" alt="image-20240529175712166"></p>
<p>知识点：二叉树</p>
<p>判断轴对称，也可以使用递归，值是这个递归就变成一个往左边，一个往右边走</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(left,right *TreeNode)</span></span> <span class="type">bool</span> </span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(left,right *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// fmt.Println(left.Val,right.Val)</span></span><br><span class="line">            <span class="keyword">return</span> left.Val == right.Val &amp;&amp; dfs(left.Left,right.Right) &amp;&amp; dfs(left.Right,right.Left)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(root.Left,root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaWFtZXRlci1vZi1iaW5hcnktdHJlZS8=">543. 二叉树的直径<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F09-33-15-image-20240530093315348.png" alt="image-20240530093315348"></p>
<p>知识点：二叉树</p>
<p>这个题目应该不算简单难度，寻常递归无法解决，dfs 每一个节点计算每个节点作为根时的直径，并且返回该节点的最大深度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">diameterOfBinaryTree</span><span class="params">(root *TreeNode)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> </span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l,r := dfs(node.Left),dfs(node.Right)</span><br><span class="line">        res = max(res,l+r)</span><br><span class="line">        <span class="keyword">return</span> max(l,r)+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LXNvcnRlZC1hcnJheS10by1iaW5hcnktc2VhcmNoLXRyZWUv">108. 将有序数组转换为二叉搜索树<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F09-44-42-image-20240530094442319.png" alt="image-20240530094442319"></p>
<p>知识点：二叉树</p>
<p>按照题目需要组装成一个平衡二叉树，就可以想到使用分治，选择中值作为节点，然后左边的值放在左边，分治迭代，右边的值放在右边。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    mid := <span class="built_in">len</span>(nums) &gt;&gt; <span class="number">1</span></span><br><span class="line">    node := &amp;TreeNode&#123;</span><br><span class="line">        Val: nums[mid],</span><br><span class="line">        Left: sortedArrayToBST(nums[:mid]),</span><br><span class="line">        Right:sortedArrayToBST(nums[mid+<span class="number">1</span>:]),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncm91cC1hbmFncmFtcy8=">49. 字母异位词分组<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F16-25-33-image-20240528162533308.png" alt="image-20240528162533308"></p>
<p>知识点：hashmap</p>
<p>由于 str 只包含小写字母，因此可以使用 map 作为条件聚合，此时 key 的选取就非常关键，对于有限的内容，可以使用有限长度数组，或者使用二进制最后的值来存储。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">groupAnagrams</span><span class="params">(strs []<span class="type">string</span>)</span></span> (res [][]<span class="type">string</span>) &#123;</span><br><span class="line">    total := <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">26</span>]<span class="type">int</span>][]<span class="type">string</span>)</span><br><span class="line">    <span class="keyword">for</span> _, str:= <span class="keyword">range</span> strs &#123;</span><br><span class="line">        tmp := [<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _,v := <span class="keyword">range</span> str &#123;</span><br><span class="line">            tmp[<span class="type">int</span>(v-<span class="string">&#x27;a&#x27;</span>)]++</span><br><span class="line">        &#125;</span><br><span class="line">        total[tmp] = <span class="built_in">append</span>(total[tmp],str)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里提前分配可以节约时间</span></span><br><span class="line">    res = <span class="built_in">make</span>([][]<span class="type">string</span>,<span class="number">0</span>,<span class="built_in">len</span>(total))</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> total &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res,v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbnNlY3V0aXZlLXNlcXVlbmNlLw==">128. 最长连续序列<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F16-30-30-image-20240528163030751.png" alt="image-20240528163030751"></p>
<p>知识点：hashmap、排序、双指针</p>
<p>方法 1：使用 hashmap，然后遍历 map 中的所有元素，找到左边没有的元素，开始往右遍历，确定最大长度</p>
<p>方法 2：先排序，然后使用双指针，左边指针是连续数组的开头，结尾指针是连续数组的结尾</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestConsecutive</span><span class="params">(nums []<span class="type">int</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">    total := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;,<span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> _,v:= <span class="keyword">range</span> nums &#123;</span><br><span class="line">        total[v]= <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> total &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok:= total[i<span class="number">-1</span>];!ok&#123;</span><br><span class="line">            <span class="comment">// 左边不存在，开始计算</span></span><br><span class="line">            l:=i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> _,o := total[l];!o&#123;</span><br><span class="line">                    <span class="comment">// 此时 l 不在了，退出循环</span></span><br><span class="line">                    <span class="keyword">break</span> </span><br><span class="line">                &#125;</span><br><span class="line">                l++</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res,l-i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb250YWluZXItd2l0aC1tb3N0LXdhdGVyLw==">11. 盛最多水的容器<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F16-44-07-image-20240528164407067.png" alt="image-20240528164407067"></p>
<p>知识点：双指针</p>
<p>左指针在最左边，右指针在最右边，两个指针往中间移动，获取当前容量。左右两个指针较小的值往中间移动。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="type">int</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">    l,r:=<span class="number">0</span>,<span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l&lt;r &#123;</span><br><span class="line">        tmp := (r-l) * min(height[l],height[r])</span><br><span class="line">        res = max(res,tmp)</span><br><span class="line">        <span class="keyword">if</span> height[l] &gt; height[r] &#123;</span><br><span class="line">            r--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy8zc3VtLw==">15. 三数之和<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F16-47-51-image-20240528164751480.png" alt="image-20240528164751480"></p>
<p>知识点：双指针</p>
<p>这是一个双指针的另外一种用法，先固定一个点，然后另外两个点作为双指针操作。需要注意的是要去重，也就是当指针移动的数字相同时，要继续移动。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> (res [][]<span class="type">int</span>) &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// 先固定 i</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        l, r := i+<span class="number">1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        <span class="comment">// 退化成两值相加</span></span><br><span class="line">        <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">            tmp := nums[i] + nums[l] + nums[r]</span><br><span class="line">            <span class="comment">// fmt.Println(tmp,i,l,r)</span></span><br><span class="line">            <span class="keyword">if</span> tmp &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 过滤重复的</span></span><br><span class="line">                r--</span><br><span class="line">                <span class="keyword">for</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>&amp;&amp; nums[r]== nums[r+<span class="number">1</span>] &#123;</span><br><span class="line">                    r--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> tmp &lt; <span class="number">0</span> &#123;</span><br><span class="line">                l++</span><br><span class="line">                <span class="keyword">for</span> l&gt;<span class="number">0</span> &amp;&amp; l &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[l]==nums[l<span class="number">-1</span>] &#123;</span><br><span class="line">                    l++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;nums[i], nums[l], nums[r]&#125;)</span><br><span class="line">                r--</span><br><span class="line">                <span class="keyword">for</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>&amp;&amp; nums[r]== nums[r+<span class="number">1</span>] &#123;</span><br><span class="line">                    r--</span><br><span class="line">                &#125;</span><br><span class="line">                l++</span><br><span class="line">                <span class="keyword">for</span> l&gt;<span class="number">0</span> &amp;&amp; l &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[l]==nums[l<span class="number">-1</span>] &#123;</span><br><span class="line">                    l++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXN1YnN0cmluZy13aXRob3V0LXJlcGVhdGluZy1jaGFyYWN0ZXJzLw==">3. 无重复字符的最长子串<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F17-41-08-image-20240528174108703.png" alt="image-20240528174108703"></p>
<p>知识点：hashmap、双指针</p>
<p>这是一个非常典型的双指针问题，双指针的核心：</p>
<ol>
<li>如何定义左指针和右指针（大部分右指针是 i，往右边移动；也有小部分左指针是左右两端）</li>
<li>如何移动左边指针（或者说移动右边指针；特别需要注意是否可以往回移动）</li>
</ol>
<p>这个题目使用双指针，右指针记录为子串的结束，左指针记录为子串的开头。当遍历的时候，移动右边指针，当出现重复的时候，移动左指针到重复索引的右边，避免被过滤。</p>
<p>这个题目需要注意的点就是左指针只能往右移动，不能重复移动到左边。</p>
<p>使用 hashmap 记录最后一次出现的位置可以，但是字符串组成内容有限，所以使用有限数组也行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 记录索引+1，避免 0 影响</span></span><br><span class="line">    total := [<span class="number">256</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    l := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> total[<span class="type">int</span>(v)] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 代表以前出现过</span></span><br><span class="line">            <span class="keyword">if</span> l &lt; total[<span class="type">int</span>(v)] &#123;</span><br><span class="line">                <span class="comment">// l 只能往右移动</span></span><br><span class="line">                l = total[<span class="type">int</span>(v)]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录最后出现的位置</span></span><br><span class="line">        total[<span class="type">int</span>(v)] = i+<span class="number">1</span></span><br><span class="line">        <span class="comment">// 判断结果</span></span><br><span class="line">        res = max(res,i+<span class="number">1</span>-l)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1hbmFncmFtcy1pbi1hLXN0cmluZy8=">438. 找到字符串中所有字母异位词<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F17-49-11-image-20240528174911328.png" alt="image-20240528174911328"></p>
<p>知识点：双指针。</p>
<p>由于 p 是由小写字母组成，可以使用有限数组记录 p，然后遍历 s 时，遍历对应长度的子串，判断子串是否也可以组成数组。</p>
<p>可以理解为左边指针是遍历字符串，右边指针从左指针开始，移动到长度为 p 的地方</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findAnagrams</span><span class="params">(s <span class="type">string</span>, p <span class="type">string</span>)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">    total := [<span class="number">256</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> p &#123;</span><br><span class="line">        total[<span class="type">int</span>(v)]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(s)-<span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line">        tmp := [<span class="number">256</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(p);j++&#123;</span><br><span class="line">            tmp[<span class="type">int</span>(s[i+j])]++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> tmp == total &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res,i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJhcnJheS1zdW0tZXF1YWxzLWsv">560. 和为 K 的子数组<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F17-56-07-image-20240528175607797.png" alt="image-20240528175607797"></p>
<p>知识点：双指针、前缀和、hashmap</p>
<p>可以使用双指针，记录 l 到 r 之间的和，如何和小于值，则移动右边，大于等于值，则移动左边；</p>
<p>也可以使用前缀和，记录到 hashmap 中，遍历的时候记录前缀和，然后判断另外一半是否存在于 hashmap 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subarraySum</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 前缀和</span></span><br><span class="line">    total := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int</span> </span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += v </span><br><span class="line">        res += total[sum-k]</span><br><span class="line">        total[sum] ++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXN1YmFycmF5Lw==">53. 最大子数组和<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F10-14-45-image-20240529101445458.png" alt="image-20240529101445458"></p>
<p>知识点：前缀和，动态规划</p>
<p>使用前缀和则是记录所有 idx 的前缀和，然后遍历之前的前缀和，寻找最大差值，这种方法很容易超时，时间复杂度相当于是 <code>O(n^2)</code></p>
<p>使用 dp 则是记录当 idx 为结尾时的最大前缀和，状态转移方程则是判断 dp[i-1] 是否大于 0，如果大于 0，则表示可以带上前面，如果不大于 0，则表示不用带上前面的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>(nums))</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]   </span><br><span class="line">    res = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        <span class="keyword">if</span> dp[i<span class="number">-1</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]+nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = max(res,dp[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1pbnRlcnZhbHMv">56. 合并区间<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F10-22-56-image-20240529102256425.png" alt="image-20240529102256425"></p>
<p>知识点：双指针</p>
<p>先按照左边排序，然后使用双指针，左指针和右指针分别代表一个区间；左指针是最左边，往右遍历的时候移动右指针，如果大于右边的左边界，且可以增加右边界，则移动右边，无法移动的时候，代表这是一个区间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="type">int</span>)</span></span> (res [][]<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 先排序</span></span><br><span class="line">    sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals[i][<span class="number">0</span>] &lt; intervals[j][<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后双指针</span></span><br><span class="line">    l, r := intervals[<span class="number">0</span>][<span class="number">0</span>], intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">        <span class="comment">// 判断是否可移动右指针</span></span><br><span class="line">        tmp := intervals[i]</span><br><span class="line">        <span class="keyword">if</span> r &gt;= tmp[<span class="number">0</span>] &#123;</span><br><span class="line">            <span class="comment">// 可移动，</span></span><br><span class="line">            r = max(r, tmp[<span class="number">1</span>])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不可移动</span></span><br><span class="line">            res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;l, r&#125;)</span><br><span class="line">            l,r = tmp[<span class="number">0</span>],tmp[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将最后的区间也放进去</span></span><br><span class="line">    res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;l, r&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtYXJyYXkv">189. 轮转数组<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F10-29-39-image-20240529102939870.png" alt="image-20240529102939870"></p>
<p>知识点：数组转换</p>
<p>这个题目的解决方法很多，但是如果在面试的时候碰到，应该选择最为稳妥和容易想到的方法先解决，解决之后如果面试官再追问则可以深入讨论。</p>
<p>这里推荐使用复制一份数组出来，然后将新的数组回填到老的数组中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    tmp := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="built_in">copy</span>(tmp,nums)</span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">        nums[(i+k)%<span class="built_in">len</span>(nums)] = v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wcm9kdWN0LW9mLWFycmF5LWV4Y2VwdC1zZWxmLw==">238. 除自身以外数组的乘积<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F10-34-26-image-20240529103426009.png" alt="image-20240529103426009"></p>
<p>知识点：前缀和（前缀积）</p>
<p>先遍历数组，获取所有数字的乘积，过程中记录 0 的个数，如果两个 0，则都是 0，如果一个 0，则除了这个点，其他的都是 0，如果没有 0，则再次遍历数组，计算每个点的答案；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 记录0的个数和位置</span></span><br><span class="line">    <span class="keyword">var</span> size,idx <span class="type">int</span></span><br><span class="line">    total := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> nums&#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            size++</span><br><span class="line">            idx = i</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            total *= v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i,v := <span class="keyword">range</span> nums&#123;</span><br><span class="line">            res[i] = total / v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> size == <span class="number">1</span> &#123;</span><br><span class="line">        res[idx] = total</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZXQtbWF0cml4LXplcm9lcy8=">73. 矩阵置零<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F11-30-11-image-20240529113011253.png" alt="image-20240529113011253"></p>
<p>知识点：数组</p>
<p>首先遍历一次，获取所有的 0 的横和列，然后遍历横和列，将对应的位置置为 0</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZeroes</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    x,y:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>),<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i,row := <span class="keyword">range</span> matrix &#123;</span><br><span class="line">        <span class="keyword">for</span> j,v := <span class="keyword">range</span> row &#123;</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">                x = <span class="built_in">append</span>(x,i)</span><br><span class="line">                y = <span class="built_in">append</span>(y,j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,i := <span class="keyword">range</span> x &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]);j++&#123;</span><br><span class="line">            matrix[i][j] = <span class="number">0</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,i := <span class="keyword">range</span> y &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; <span class="built_in">len</span>(matrix);j++&#123;</span><br><span class="line">            matrix[j][i] = <span class="number">0</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGlyYWwtbWF0cml4Lw==">54. 螺旋矩阵<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F11-33-51-image-20240529113351412.png" alt="image-20240529113351412"></p>
<p>知识点：数组</p>
<p>这个问题的核心解决点是遍历数组的过程，方向的选择。避免撞到重复，可以在遍历了这个点之后，修改这个值，作为后续方向判断的条件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 方向</span></span><br><span class="line">    directions := [<span class="number">4</span>][<span class="number">2</span>]<span class="type">int</span>&#123;[<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">    <span class="comment">// 初始方向</span></span><br><span class="line">    <span class="keyword">var</span> d <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, m*n)</span><br><span class="line">    <span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(res) &lt; m*n &#123;</span><br><span class="line">        <span class="comment">// 先记录下来</span></span><br><span class="line">        res = <span class="built_in">append</span>(res, matrix[x][y])</span><br><span class="line">        <span class="comment">// 改成一个不可能的值</span></span><br><span class="line">        matrix[x][y] = <span class="number">101</span></span><br><span class="line">        <span class="comment">// 判断方向</span></span><br><span class="line">        dir := directions[d]</span><br><span class="line">        tmpx := x + dir[<span class="number">0</span>]</span><br><span class="line">        tmpy := y + dir[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(res) &lt; m*n &amp;&amp; (tmpx &lt; <span class="number">0</span> || tmpx == m || tmpy &lt; <span class="number">0</span> || tmpy == n || matrix[tmpx][tmpy] == <span class="number">101</span> ) &#123;</span><br><span class="line">            d = (d + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">            dir = directions[d]</span><br><span class="line">            tmpx = x + dir[<span class="number">0</span>]</span><br><span class="line">            tmpy = y + dir[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        x, y = tmpx, tmpy</span><br><span class="line">        <span class="comment">// fmt.Println(x, y)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtaW1hZ2Uv">48. 旋转图像<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F11-45-46-image-20240529114545950.png" alt="image-20240529114545950"></p>
<p>知识点：数组</p>
<p>直接在原数组上处理比较麻烦，推荐的方案依然是拷贝一份出来，然后处理。核心点是找到关系，x,y &#x3D;&gt; y,n-x</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// x,y =&gt; y,n-x</span></span><br><span class="line">    n := <span class="built_in">len</span>(matrix)</span><br><span class="line">    tmp := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        tmp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">        <span class="built_in">copy</span>(tmp[i], matrix[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始转换</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            matrix[j][n<span class="number">-1</span>-i] = tmp[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtYS0yZC1tYXRyaXgtaWkv">240. 搜索二维矩阵 II<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F11-50-50-image-20240529115050600.png" alt="image-20240529115050600"></p>
<p>知识点：二分法、数组检索</p>
<p>像这种二维的二分法按照二分法来解决可能比较麻烦，但是可以退一步，因为每一行都已经排序了，因此可以针对每一行都检索一次，只要开头小于目标值，结尾大于目标值，就可以使用二分法查询。</p>
<p>这里介绍一种更加简单的做法，从右上角开始移动，如果大于目标值，说明应该向左移动，如果小于目标值，说明应该向下移动。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    m,n := <span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    x,y := <span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        tmp := matrix[x][y]</span><br><span class="line">        <span class="keyword">if</span> tmp &gt; target &#123;</span><br><span class="line">            y--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tmp &lt; target &#123;</span><br><span class="line">            x++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS1paS8=">142. 环形链表 II<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-16-44-image-20240529151644049.png" alt="image-20240529151644049"></p>
<p>知识点：链表，快慢指针，hashmap</p>
<p>跟判断是否有环的题目一样的处理逻辑，要么使用快慢指针获取节点，要么使用 hashmap 获取节点。</p>
<p>使用不同的是如果相交之后，快指针多走了一段路，因此快指针要从头开始，寻找第二次相遇，而且此时快指针慢下来，跟慢指针一起走完前面一样的路，再次相交则是环的开始。</p>
<p>hashmap 比较容易想出来，这里使用快慢指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    fast,slow := head,head</span><br><span class="line">    <span class="comment">// 第一次相遇</span></span><br><span class="line">    <span class="keyword">for</span> fast!=<span class="literal">nil</span>&amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">break</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有环</span></span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找第二次相遇 </span></span><br><span class="line">    fast = head </span><br><span class="line">    <span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fast</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hZGQtdHdvLW51bWJlcnMv">2. 两数相加<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-30-25-image-20240529153025376.png" alt="image-20240529153025376"></p>
<p>知识点：链表，数学</p>
<p>从题目中可以看到，算法是按照十进制来运算的，链表也一样的运算即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    pre := &amp;ListNode&#123;&#125;</span><br><span class="line">    node := pre </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 满 10 之后要进一位</span></span><br><span class="line">    <span class="keyword">var</span> gate <span class="type">int</span> </span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        val := l1.Val + l2.Val + gate</span><br><span class="line">        gate = val / <span class="number">10</span> </span><br><span class="line">        val = val % <span class="number">10</span> </span><br><span class="line">        node.Next = &amp;ListNode&#123;Val:val&#125;</span><br><span class="line">        node = node.Next</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再处理剩下的</span></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        val := l1.Val + gate</span><br><span class="line">        gate = val / <span class="number">10</span> </span><br><span class="line">        val = val % <span class="number">10</span> </span><br><span class="line">        node.Next = &amp;ListNode&#123;Val:val&#125;</span><br><span class="line">        node = node.Next</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        val := l2.Val + gate</span><br><span class="line">        gate = val / <span class="number">10</span> </span><br><span class="line">        val = val % <span class="number">10</span> </span><br><span class="line">        node.Next = &amp;ListNode&#123;Val:val&#125;</span><br><span class="line">        node = node.Next</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后处理多进的一位</span></span><br><span class="line">    <span class="keyword">if</span> gate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node.Next = &amp;ListNode&#123;Val:gate&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtbnRoLW5vZGUtZnJvbS1lbmQtb2YtbGlzdC8=">19. 删除链表的倒数第 N 个结点<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-40-46-image-20240529154046000.png" alt="image-20240529154046000"></p>
<p>知识点：链表</p>
<p>核心点是找到倒数第 n 个节点是哪个，因此，可以尝试做补全，假设有一个节点在前n 个的地方，逐步移动这两个节点，当节点移动为空，前面的节点就是倒数第 n 个节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    pre := &amp;ListNode&#123;Next:head&#125;</span><br><span class="line">    node,target := head,pre</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">        node = node.Next</span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            n -- </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target = target.Next </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 pre 的下一个节点就是需要删除的节点</span></span><br><span class="line">    target.Next = target.Next.Next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zd2FwLW5vZGVzLWluLXBhaXJzLw==">24. 两两交换链表中的节点<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-45-00-image-20240529154500550.png" alt="image-20240529154500550"></p>
<p>知识点：链表</p>
<p>这种题目很容易让人想到使用递归，交换了两个节点之后，递归处理后面的节点</p>
<p>需要注意的是处理顺序，避免出现死循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre := &amp;ListNode&#123;Next:head&#125;</span><br><span class="line">    node,next := head,head.Next</span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    pre.Next = next</span><br><span class="line">    <span class="comment">// 处理后面的</span></span><br><span class="line">    node.Next = swapPairs(next.Next)</span><br><span class="line">    next.Next = node </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138. 随机链表的复制"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3B5LWxpc3Qtd2l0aC1yYW5kb20tcG9pbnRlci8=">138. 随机链表的复制<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F16-02-42-image-20240529160242903.png" alt="image-20240529160242903"></p>
<p>知识点：链表</p>
<p>先将链表按照 next 拷贝出来，核心在于找到 random，既可以使用 hashmap ，值是老的链表，value 是新的链表，也可以使用两个链表一起遍历，前者快一些，后者慢一些，毕竟便利的时候需要从头开始。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> * type Node struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *Node</span></span><br><span class="line"><span class="comment"> *     Random *Node</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span></span> *Node &#123;</span><br><span class="line">    pre := &amp;Node&#123;&#125;</span><br><span class="line">    node1,node2 := head,pre</span><br><span class="line">    total := <span class="built_in">make</span>(<span class="keyword">map</span>[*Node]*Node)</span><br><span class="line">    <span class="keyword">for</span> node1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        tmp := &amp;Node&#123;Val:node1.Val&#125;</span><br><span class="line">        node2.Next = tmp </span><br><span class="line">        total[node1] = tmp</span><br><span class="line">        node1 = node1.Next</span><br><span class="line">        node2 = node2.Next </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node1,node2 = head,pre.Next</span><br><span class="line">    <span class="keyword">for</span> node1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        node2.Random = total[node1.Random]</span><br><span class="line">        node1 = node1.Next</span><br><span class="line">        node2 = node2.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWxpc3Qv">148. 排序链表<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F16-11-09-image-20240529161109394.png" alt="image-20240529161109394"></p>
<p>知识点：链表，排序</p>
<p>解决方法也比较多，但是面试时碰到原题，依然推荐最简单的方法，也就是放在数组里面排序，然后组装成链表。需要注意的是最后一个节点的 next 要指向 nil，避免出环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 都拿出来</span></span><br><span class="line">    total := <span class="built_in">make</span>([]*ListNode, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        total = <span class="built_in">append</span>(total, head)</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    sort.Slice(total, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> total[i].Val &lt; total[j].Val</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(total)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        total[i].Next = total[i+<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    total[<span class="built_in">len</span>(total)<span class="number">-1</span>].Next = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9scnUtY2FjaGUv">146. LRU 缓存<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F16-23-57-image-20240529162357272.png" alt="image-20240529162357272"></p>
<p>知识点：链表，LRU</p>
<p>LRU 的核心能力是移动链表中的节点，以及删除最后一个节点的能力。但是又需要提供 <code>O(1)</code> 的查询能力，因此需要双向链表和 hashmap。节点中除了存储双向，还需要存储 key 和 value，用于删除最末尾一个节点时，查找 hashmap 中的值。</p>
<p>真实编码的时候，在面试 de 环境下，很容易思维混乱，因此先不要取巧，当已经解决出来之后，再想办法优化代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    pre  *node</span><br><span class="line">    next *node</span><br><span class="line">    key <span class="type">int</span> <span class="comment">// 需要通过 key 获取到map 的 key，用于删除</span></span><br><span class="line">    val  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">    all      <span class="keyword">map</span>[<span class="type">int</span>]*node</span><br><span class="line">    start    *node</span><br><span class="line">    end      *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">    start, end := &amp;node&#123;&#125;, &amp;node&#123;&#125;</span><br><span class="line">    start.next = end</span><br><span class="line">    end.pre = start</span><br><span class="line">    <span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">        capacity: capacity,</span><br><span class="line">        all:      <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*node, capacity),</span><br><span class="line">        start:    start,</span><br><span class="line">        end:      end,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    n, ok := this.all[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="comment">// 没有找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了，这里不要直接调用 put 去偷懒，避免逻辑混乱了</span></span><br><span class="line">    <span class="comment">// 从原先的位置去掉</span></span><br><span class="line">    pre, next := n.pre, n.next</span><br><span class="line">    pre.next = next</span><br><span class="line">    next.pre = pre</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入开头</span></span><br><span class="line">    start := this.start.next</span><br><span class="line">    this.start.next = n</span><br><span class="line">    n.pre = this.start</span><br><span class="line"></span><br><span class="line">    n.next = start</span><br><span class="line">    start.pre = n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n.val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// put 的时候首先判断这个节点是否存在，如果存在需要从链表中删除</span></span><br><span class="line">    n, ok := this.all[key]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="comment">// 找到了，先删除</span></span><br><span class="line">        pre, next := n.pre, n.next</span><br><span class="line">        pre.next = next</span><br><span class="line">        next.pre = pre</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后更新值，放在最前面</span></span><br><span class="line">        n.val = value</span><br><span class="line">        <span class="comment">// 插入开头</span></span><br><span class="line">        start := this.start.next</span><br><span class="line">        this.start.next = n</span><br><span class="line">        n.pre = this.start</span><br><span class="line"></span><br><span class="line">        n.next = start</span><br><span class="line">        start.pre = n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到</span></span><br><span class="line">    n = &amp;node&#123;key:key,val: value&#125;</span><br><span class="line">    <span class="comment">// 判断是否满了 </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.all) == this.capacity &#123;</span><br><span class="line">        <span class="comment">// 满了需要去掉最后一位</span></span><br><span class="line">        del := this.end.pre</span><br><span class="line">        <span class="built_in">delete</span>(this.all,del.key)</span><br><span class="line">        end := del.pre</span><br><span class="line"></span><br><span class="line">        end.next = this.end</span><br><span class="line">        this.end.pre = end </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后放在最前面</span></span><br><span class="line">    start := this.start.next</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放在最前面</span></span><br><span class="line">    this.start.next = n</span><br><span class="line">    n.pre = this.start</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插队</span></span><br><span class="line">    start.pre = n</span><br><span class="line">    n.next = start</span><br><span class="line"></span><br><span class="line">    this.all[key] = n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(capacity);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Get(key);</span></span><br><span class="line"><span class="comment"> * obj.Put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwv">102. 二叉树的层序遍历<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F09-38-15-image-20240530093815446.png" alt="image-20240530093815446"></p>
<p>知识点：多叉树</p>
<p>使用非常典型的 BFS 解决方案</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> (res [][]<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">    &#125;</span><br><span class="line">    total := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(total) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        tmp := <span class="built_in">make</span>([]*TreeNode,<span class="number">0</span>,<span class="built_in">len</span>(total)*<span class="number">2</span>)</span><br><span class="line">        tmpRes := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="built_in">len</span>(total))</span><br><span class="line">        <span class="keyword">for</span> _,v := <span class="keyword">range</span> total &#123;</span><br><span class="line">            tmpRes = <span class="built_in">append</span>(tmpRes,v.Val)</span><br><span class="line">            <span class="keyword">if</span> v.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                tmp = <span class="built_in">append</span>(tmp,v.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> v.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                tmp = <span class="built_in">append</span>(tmp,v.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        total = tmp </span><br><span class="line">        res = <span class="built_in">append</span>(res,tmpRes)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUv">98. 验证二叉搜索树<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F10-11-58-image-20240530101158822.png" alt="image-20240530101158822"></p>
<p>知识点：二叉树</p>
<p>按照题目要求，必须是一个有效的二叉搜索树，那么需要判断每个节点的值是否满足条件。</p>
<p>使用 dfs 判断每一个节点，节点需要满足的最大值和最小值作为 dfs 的条件传递下去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, ma <span class="type">int</span>, mi <span class="type">int</span>)</span></span> <span class="type">bool</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, ma <span class="type">int</span>, mi <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fmt.Println(node.Val,ma,mi)</span></span><br><span class="line">        <span class="keyword">return</span> node.Val &lt; ma &amp;&amp; node.Val &gt; mi &amp;&amp;</span><br><span class="line">            dfs(node.Left, min(ma, node.Val), mi) &amp;&amp;</span><br><span class="line">            dfs(node.Right, ma, max(mi, node.Val))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(root.Left, root.Val, math.MinInt) &amp;&amp; dfs(root.Right, math.MaxInt, root.Val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9rdGgtc21hbGxlc3QtZWxlbWVudC1pbi1hLWJzdC8=">230. 二叉搜索树中第K小的元素<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F10-20-59-image-20240530102059597.png" alt="image-20240530102059597"></p>
<p>知识点：二叉搜索树</p>
<p>第 k 个最小元素，其实是中序遍历的第 k 个值，便利的时候遍历到第 k 个值即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallest</span><span class="params">(root *TreeNode, k <span class="type">int</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">    tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, k)</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == k &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前</span></span><br><span class="line">        dfs(node.Left)</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        tmp = <span class="built_in">append</span>(tmp, node.Val)</span><br><span class="line">        <span class="comment">// 后</span></span><br><span class="line">        dfs(node.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp[k<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcv">199. 二叉树的右视图<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F11-01-22-image-20240530110122014.png" alt="image-20240530110122014"></p>
<p>知识点：二叉树</p>
<p>按照题目要求，使用 bfs 即可，每次 bfs 都获取最后一个节点的值作为答案。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rightSideView</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(total) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        tmpTotal := <span class="built_in">make</span>([]*TreeNode,<span class="number">0</span>,<span class="built_in">len</span>(total)*<span class="number">2</span>)</span><br><span class="line">        res = <span class="built_in">append</span>(res,total[<span class="built_in">len</span>(total)<span class="number">-1</span>].Val)</span><br><span class="line">        <span class="keyword">for</span> _,v := <span class="keyword">range</span> total &#123;</span><br><span class="line">            <span class="keyword">if</span> v.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                tmpTotal = <span class="built_in">append</span>(tmpTotal,v.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> v.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                tmpTotal = <span class="built_in">append</span>(tmpTotal,v.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        total = tmpTotal</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9mbGF0dGVuLWJpbmFyeS10cmVlLXRvLWxpbmtlZC1saXN0Lw==">114. 二叉树展开为链表<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F11-05-19-image-20240530110519525.png" alt="image-20240530110519525"></p>
<p>知识点：链表</p>
<p>按照题目所述是先序遍历，因此按照先序遍历处理即可。这种返回一个节点的要求，一半可以使用 pre 虚拟节点来实现。</p>
<p>如果在面试的时候，捋不清使用 dfs 递归的方法，可以退而求其次，将所有的节点都打印出来放在一个切片一里面，然后将切片连起来也行。需要注意的是要记得将左边节点清空。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatten</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">    pre := &amp;TreeNode&#123;Right: root&#125;</span><br><span class="line">    tmp := pre</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先序遍历</span></span><br><span class="line">        tmp.Left = <span class="literal">nil</span></span><br><span class="line">        tmp.Right = node</span><br><span class="line">        tmp = tmp.Right</span><br><span class="line">        <span class="comment">// 这里要临时保留左右节点，避免递归后节点信息发生变化，导致出环或者其他异常。</span></span><br><span class="line">        l, r := node.Left, node.Right</span><br><span class="line">        dfs(l)</span><br><span class="line">        dfs(r)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtaW5vcmRlci10cmF2ZXJzYWwv">105. 从前序与中序遍历序列构造二叉树<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F11-13-49-image-20240530111349482.png" alt="image-20240530111349482"></p>
<p>知识点：二叉树的遍历</p>
<p>这个题目如果不知道解决方法在面试中比较难想出来的。核心点是先序遍历和中序遍历的相同点和不同点。</p>
<p>比如上面的节点 3，前序遍历时，3 的后面是他的所有子节点，但是在中序遍历时，3的前面是左边子节点，3 的后面是右子节点。因此可以使用分治递归的方法，将左边子节点找出来，将右边子节点找出来，作为子数组进行递归，通过数组的长度固定，可以确定左子节点的前序遍历中序遍历的子数组，右子节点同理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node := &amp;TreeNode&#123;Val: preorder[<span class="number">0</span>]&#125;</span><br><span class="line">    <span class="keyword">var</span> idx <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> inorder[idx] != node.Val &#123;</span><br><span class="line">        idx++</span><br><span class="line">    &#125;</span><br><span class="line">    li := inorder[:idx]</span><br><span class="line">    ri := inorder[idx+<span class="number">1</span>:]</span><br><span class="line">    lp := preorder[<span class="number">1</span> : <span class="number">1</span>+<span class="built_in">len</span>(li)]</span><br><span class="line">    rp := preorder[<span class="number">1</span>+<span class="built_in">len</span>(li):]</span><br><span class="line">    node.Left = buildTree(lp, li)</span><br><span class="line">    node.Right = buildTree(rp, ri)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paWkv">437. 路径总和 III<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F11-22-02-image-20240530112202476.png" alt="image-20240530112202476"></p>
<p>知识点：二叉树、前缀和</p>
<p>每一个节点获取到前面节点的前缀和，此时即可判断自己这个点到前面某一个点之间的距离，满足条件即可。</p>
<p>使用 dfs，传入自己到根的距离，和到跟的前缀和。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, dis <span class="type">int</span>, total []<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, dis <span class="type">int</span>, total []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先计算自己的前缀和</span></span><br><span class="line">        dis += node.Val</span><br><span class="line">        tmp := dis-targetSum</span><br><span class="line">        <span class="comment">// fmt.Println(node.Val, tmp, total)</span></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> total &#123;</span><br><span class="line">            <span class="keyword">if</span> tmp == v &#123;</span><br><span class="line">                <span class="comment">// fmt.Println(node.Val)</span></span><br><span class="line">                res++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        total = <span class="built_in">append</span>(total, dis)</span><br><span class="line">        dfs(node.Left, dis, total)</span><br><span class="line">        dfs(node.Right, dis, total)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, <span class="number">0</span>, []<span class="type">int</span>&#123;<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUv">236. 二叉树的最近公共祖先<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F11-40-13-image-20240530114013712.png" alt="image-20240530114013712"></p>
<p>知识点：二叉树</p>
<p>寻找公共祖先，可以用一个简单方法，那就是返回自己的祖先，当两个节点返回的祖先相同，则代表是公共祖先。</p>
<p>使用 dfs，先便利左边和右边，判断返回，如果这个节点是 p 或者 q 则返回这个节点，如果不是，则判断子节点是否有返回，如果子节点都有返回，说明左边和右边都找到了，则返回自己；如果某个子节点有返回则返回子节点的内容，否则就是都为空，返回 nil。最终返回出来的结果就是公共祖先节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root == p || root == q &#123;</span><br><span class="line">        <span class="keyword">return</span> root </span><br><span class="line">    &#125;</span><br><span class="line">    l,r := lowestCommonAncestor(root.Left,p,q),lowestCommonAncestor(root.Right,p,q)</span><br><span class="line">    <span class="keyword">if</span> l != <span class="literal">nil</span> &amp;&amp; r != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> l == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmFwcGluZy1yYWluLXdhdGVyLw==">42. 接雨水<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F28%2F17-26-22-image-20240528172622206.png" alt="image-20240528172622206"></p>
<p>知识点：单调栈</p>
<p>如果不看答案，很少能想得到使用单调栈来解决。除了接雨水，还有获取最大面积也都是一样的逻辑。</p>
<p>单调栈，使用单调递减栈，入栈的是索引，入栈的时候，说明左边有着落，当出栈的时候，说明右边有着落了，此时就需要计算当前这个点可以接下的雨水。计算可以接下的雨水，是左边到右边的间隔，乘以中间的差值。例如上面的  2,1,0,1,2 ，先入栈 2,1,0，然后在入栈 1 的时候，0 出栈，此时计算的是 1,0,1 的雨水，当 1 出栈的时候，计算的是左边的 2 到右边的 2 之间，在 1 之上的雨水。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用严格递增栈，记录 idx</span></span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(height); i++ &#123;</span><br><span class="line">        <span class="comment">// 先出栈</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; height[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &lt;= height[i] &#123;</span><br><span class="line">            tmp := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">// 出栈的时候，计算当前的雨水，左边是栈顶，右边是i</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                l := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">                <span class="comment">// 高度，是左边和右边的较小值，减去自己</span></span><br><span class="line">                hei := min(height[l], height[i]) - height[tmp]</span><br><span class="line">                res += (i - l - <span class="number">1</span>) * hei</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtLw==">239. 滑动窗口最大值<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F09-32-53-image-20240529093253614.png" alt="image-20240529093253614"></p>
<p>知识点：堆</p>
<p>通过题目比较容易想到使用最大堆，将 k 个数字都存入堆，进一个值的时候，获取堆顶的元素，而且要确保堆顶要大于 i-k，也就是在窗口内，因此获取堆顶时可以使用 for 循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 存放 idx，1 存放数字</span></span><br><span class="line"><span class="keyword">type</span> stack [][<span class="number">2</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *stack)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(*n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *stack)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 最大堆</span></span><br><span class="line">    <span class="keyword">return</span> (*n)[i][<span class="number">1</span>] &gt; (*n)[j][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *stack)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    (*n)[i], (*n)[j] = (*n)[j], (*n)[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *stack)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    *n = <span class="built_in">append</span>(*n, x.([<span class="number">2</span>]<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *stack)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    x := (*n)[<span class="built_in">len</span>(*n)<span class="number">-1</span>]</span><br><span class="line">    *n = (*n)[:<span class="built_in">len</span>(*n)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s stack</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        heap.Push(&amp;s, [<span class="number">2</span>]<span class="type">int</span>&#123;i, nums[i]&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(nums)-k+<span class="number">1</span>)</span><br><span class="line">    res = <span class="built_in">append</span>(res, s[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// 先入栈</span></span><br><span class="line">        heap.Push(&amp;s, [<span class="number">2</span>]<span class="type">int</span>&#123;i, nums[i]&#125;)</span><br><span class="line">        <span class="comment">// 判断是否在窗口中</span></span><br><span class="line">        <span class="keyword">for</span> s[<span class="number">0</span>][<span class="number">0</span>] &lt;= i-k &#123;</span><br><span class="line">            heap.Pop(&amp;s)</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, s[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcv">76. 最小覆盖子串<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F09-47-53-image-20240529094753016.png" alt="image-20240529094753016"></p>
<p>知识点：滑动窗口、双指针</p>
<p>使用双指针记录滑动窗口中的内容，先移动右边，找到包含 t 的所有子串，记录此时的答案；滑动左边，直到不包含子串，然后查询下一个包含 t 的子串。</p>
<p>这个方法的难点是如何记录 t，以及子串，因为子串需要记录出现的次数，用于记录当左指针移动的时候，确保刚好不含有子串。因此，除了使用数组记录 t和临时子串，还需要有一个数组记录多出来的次数，移动的时候如果临时子串满了，则放在次数数组中记录。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> (res <span class="type">string</span>) &#123;</span><br><span class="line">    total := [<span class="number">256</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> t &#123;</span><br><span class="line">        total[<span class="type">int</span>(v)]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录临时的字母</span></span><br><span class="line">    tmpL := [<span class="number">256</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 记录临时的个数</span></span><br><span class="line">    tmpN := [<span class="number">256</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 左指针</span></span><br><span class="line">    <span class="keyword">var</span> l <span class="type">int</span></span><br><span class="line">    <span class="comment">// 记录答案</span></span><br><span class="line">    res = s </span><br><span class="line">    <span class="comment">// 判断是否有答案</span></span><br><span class="line">    <span class="keyword">var</span> flag <span class="type">bool</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="comment">// 移动右指针</span></span><br><span class="line">        <span class="comment">// 是目标子串</span></span><br><span class="line">        <span class="keyword">if</span> total[<span class="type">int</span>(v)] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 判断是否满了</span></span><br><span class="line">            <span class="keyword">if</span> tmpL[<span class="type">int</span>(v)] == total[<span class="type">int</span>(v)] &#123;</span><br><span class="line">                tmpN[<span class="type">int</span>(v)]++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmpL[<span class="type">int</span>(v)]++</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否移动左边指针</span></span><br><span class="line">            <span class="comment">// 开始移动左指针</span></span><br><span class="line">            <span class="keyword">for</span> tmpL == total &#123;</span><br><span class="line">                flag = <span class="literal">true</span> </span><br><span class="line">                <span class="keyword">if</span> total[<span class="type">int</span>(s[l])] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 先减去满的</span></span><br><span class="line">                    <span class="keyword">if</span> tmpN[<span class="type">int</span>(s[l])] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                        tmpN[<span class="type">int</span>(s[l])]--</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// fmt.Println(l,i)</span></span><br><span class="line">                        <span class="comment">// 不满，此时是最短子串</span></span><br><span class="line">                        <span class="keyword">if</span> i+<span class="number">1</span>-l &lt; <span class="built_in">len</span>(res) &#123;</span><br><span class="line">                            res = s[l : i+<span class="number">1</span>]</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmpL[<span class="type">int</span>(s[l])]--</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                l++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> flag &#123;</span><br><span class="line">        <span class="keyword">return</span> res </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maXJzdC1taXNzaW5nLXBvc2l0aXZlLw==">41. 缺失的第一个正数<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F11-15-00-image-20240529111500283.png" alt="image-20240529111500283"></p>
<p>知识点：hashmap</p>
<p>这套题的解决方法也有很多，面试时轻快好解的思路，选择使用 hashmap，记录所有出现的正数，然后从 1 开始判断不存在的数字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">            total[v] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ; i &lt;= <span class="built_in">len</span>(total); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := total[i]; !ok &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLW5vZGVzLWluLWstZ3JvdXAv">25. K 个一组翻转链表<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F15-51-59-image-20240529155159670.png" alt="image-20240529155159670"></p>
<p>知识点：链表</p>
<p>字节一面碰到过。</p>
<p>这种问题使用递归最好，核心是处理递归和递归内部链表翻转。递归比较好处理，如果满足个数即可处理，内部翻转在面试时很容易晕头转向，处理不好节点之间的跳跃关系，可以尝试换成使用数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否满足 k 个</span></span><br><span class="line">    tmp := <span class="built_in">make</span>([]*ListNode, <span class="number">0</span>, k)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k &amp;&amp; head != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">        tmp = <span class="built_in">append</span>(tmp,head)</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不满</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tmp) != k &#123;</span><br><span class="line">        <span class="keyword">return</span> tmp[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Println(tmp,head)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 满足的时候，先处理后面的，让后面的翻转了之后，再处理自己</span></span><br><span class="line">    tmp[<span class="number">0</span>].Next = reverseKGroup(head,k)</span><br><span class="line">    <span class="comment">// 翻转</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;k;i++&#123;</span><br><span class="line">        tmp[i].Next = tmp[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp[<span class="built_in">len</span>(tmp)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1rLXNvcnRlZC1saXN0cy8=">23. 合并 K 个升序链表<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F29%2F16-16-23-image-20240529161623207.png" alt="image-20240529161623207"></p>
<p>知识点：链表、堆</p>
<p>从前面两个链表升级到多个链表，因此可以使用堆排序来实现。从堆里面取出来，取最小的，放到答案里面，然后移动链表，非空的话再丢进去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stack []*ListNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(*s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    (*s)[i], (*s)[j] = (*s)[j], (*s)[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(s *stack)</span></span> Less(i,j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*s)[i].Val &lt; (*s)[j].Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(s *stack)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    (*s) = <span class="built_in">append</span>((*s),x.(*ListNode))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(s *stack)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    x := (*s)[<span class="built_in">len</span>(*s)<span class="number">-1</span>]</span><br><span class="line">    (*s) = (*s)[:<span class="built_in">len</span>(*s)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">var</span> s stack</span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> lists &#123;</span><br><span class="line">        <span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(&amp;s,v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pre := &amp;ListNode&#123;&#125;</span><br><span class="line">    node := pre </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(s) != <span class="number">0</span> &#123;</span><br><span class="line">        tmp := heap.Pop(&amp;s).(*ListNode)</span><br><span class="line">        node.Next = tmp </span><br><span class="line">        tmp = tmp.Next</span><br><span class="line">        <span class="keyword">if</span> tmp != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(&amp;s,tmp)</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1tYXhpbXVtLXBhdGgtc3VtLw==">124. 二叉树中的最大路径和<i class="fa fa-external-link-alt"></i></span></h3><p><img data-src="https://image-hosting-xiaoyeshiyu-shanghai.oss-cn-shanghai.aliyuncs.com/img/PicGo%2F2024%2F05%2F30%2F11-48-14-image-20240530114813934.png" alt="image-20240530114813934"></p>
<p>知识点：二叉树</p>
<p>跟直径的题目原理差不多，使用 dfs 判断所有节点的路径和，返回该节点的最大路径，用本节点左边的最大路径和右边节点的最大路径相加，就是本节点的最大路径和。</p>
<p>由于测试用例中会出现 0，因此需要注意最小数和返回给上层的结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxPathSum</span><span class="params">(root *TreeNode)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">    res = math.MinInt</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l, r := dfs(node.Left), dfs(node.Right)</span><br><span class="line">        <span class="keyword">if</span> l &gt;= <span class="number">0</span> &amp;&amp; r &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            res = max(res, l+r+node.Val)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> l &lt; <span class="number">0</span> &amp;&amp; r &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            res = max(res, r+node.Val)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> l &gt;= <span class="number">0</span> &amp;&amp; r &lt; <span class="number">0</span> &#123;</span><br><span class="line">            res = max(res, l+node.Val)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = max(res, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0</span>, max(l, r)) + node.Val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Reference/" rel="tag"># 学习笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/7d689b97.html" rel="prev" title="K8s源码阅读笔记之 API Server 生成和启动">
                  <i class="fa fa-angle-left"></i> K8s源码阅读笔记之 API Server 生成和启动
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/6663603b.html" rel="next" title="LeetCode Hot100笔记-下">
                  LeetCode Hot100笔记-下 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Mitaka xu</span>
  </div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.20.0/algoliasearch-lite.umd.js" integrity="sha256-DABVk+hYj0mdUzo+7ViJC6cwLahQIejFvC+my2M/wfM=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.60.0/instantsearch.production.min.js" integrity="sha256-9242vN47QUX50UG5Gf5XDO1YREWCEJRyXHofh5fsl24=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"TVx6Wkfs8VJGOwYPurtjWY2e-9Nh9j0Va","app_key":"c7VvaRnyF8r3DUIPq1x2KJ7Q","server_url":"https://tvx6wkfs.lc-cn-e1-shared.com","security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://www.xiaoyeshiyu.com/post/116450ad.html"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"xiaoyeshiyu","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
