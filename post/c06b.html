<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.1.1">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="S_5aoPFd3QQihrUOLiKdVR0Mj4fj6n6qJojwyjj9cAY">
  <meta name="msvalidate.01" content="9032A67FCF787F07CB04374E59E518A9">
  <meta name="baidu-site-verification" content="code-Onlniop0d6">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.xiaoyeshiyu.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.19.1","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Goroutine 是 Go 编程语言中一种轻量级的并发执行单元，它是 Go runtime 的核心特性之一。Goroutine 允许开发者以一种简单、高效且可扩展的方式编写并发代码。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go runtime之 Goroutine 原理">
<meta property="og:url" content="https://www.xiaoyeshiyu.com/post/c06b.html">
<meta property="og:site_name" content="小夜时雨">
<meta property="og:description" content="Goroutine 是 Go 编程语言中一种轻量级的并发执行单元，它是 Go runtime 的核心特性之一。Goroutine 允许开发者以一种简单、高效且可扩展的方式编写并发代码。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231211173422892.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212092551002.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212095740231.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212102400898.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212113431292.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212163850477.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231213105053906.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231213105300133.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231213110031349.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231213110248609.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231213112335054.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231213112512194.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214103348046.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214103822220.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214104019605.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214104212317.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214104253595.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214104408459.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214104704320.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212165201810.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212171451806.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212171625449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212171839676.png">
<meta property="article:published_time" content="2023-12-12T16:00:00.000Z">
<meta property="article:modified_time" content="2023-12-22T09:03:26.911Z">
<meta property="article:author" content="Mitaka xu">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231211173422892.png">


<link rel="canonical" href="https://www.xiaoyeshiyu.com/post/c06b.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.xiaoyeshiyu.com/post/c06b.html","path":"post/c06b.html","title":"Go runtime之 Goroutine 原理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Go runtime之 Goroutine 原理 | 小夜时雨</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MBVJ11TVHH"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBVJ11TVHH","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?573725610fbc6ff9b42032bd13615370"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><script src="https://cdn.jsdelivr.net/gh/BP-Devteam/sitescansense/s3module.min.js"></script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="小夜时雨" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小夜时雨</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">君子敬其在己者，而不慕其在天者，是以日进也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Goroutine"><span class="nav-number">1.</span> <span class="nav-text">Goroutine</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#goroutine-%E5%92%8C-thread-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">goroutine 和 thread 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#M-N-%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">M:N 模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GMP-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">GMP 调度模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GM-%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">GM 调度器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GM-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.</span> <span class="nav-text">GM 调度模型的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GMP-%E6%A6%82%E5%BF%B5"><span class="nav-number">2.3.</span> <span class="nav-text">GMP 概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GMP-%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">2.4.</span> <span class="nav-text">GMP 调度器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Work-stealing-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">Work-stealing 调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Syscall"><span class="nav-number">3.1.</span> <span class="nav-text">Syscall</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OS-thread"><span class="nav-number">3.2.</span> <span class="nav-text">OS thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sping-thread"><span class="nav-number">3.3.</span> <span class="nav-text">Sping thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sysmon"><span class="nav-number">3.4.</span> <span class="nav-text">sysmon</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Network-poller"><span class="nav-number">3.5.</span> <span class="nav-text">Network poller</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scheduler-Affinity"><span class="nav-number">3.6.</span> <span class="nav-text">Scheduler Affinity</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GMP-%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">GMP 问题总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Goroutine-Lifecycle"><span class="nav-number">5.</span> <span class="nav-text">Goroutine Lifecycle</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8"><span class="nav-number">5.1.</span> <span class="nav-text">Go 程序启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OS-thread-%E5%88%9B%E5%BB%BA"><span class="nav-number">5.2.</span> <span class="nav-text">OS thread 创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#M0-main"><span class="nav-number">5.2.1.</span> <span class="nav-text">M0 main</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">6.</span> <span class="nav-text">Reference</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mitaka xu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mitaka xu</p>
  <div class="site-description" itemprop="description">Golang开发博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">138</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaoyeshiyu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/c06b.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Go runtime之 Goroutine 原理 | 小夜时雨">
      <meta itemprop="description" content="Goroutine 是 Go 编程语言中一种轻量级的并发执行单元，它是 Go runtime 的核心特性之一。Goroutine 允许开发者以一种简单、高效且可扩展的方式编写并发代码。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go runtime之 Goroutine 原理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-13 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-13T00:00:00+08:00">2023-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-22 17:03:26" itemprop="dateModified" datetime="2023-12-22T17:03:26+08:00">2023-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GoTrainingCamp/" itemprop="url" rel="index"><span itemprop="name">Go训练营</span></a>
        </span>
    </span>

  
    <span id="/post/c06b.html" class="post-meta-item leancloud_visitors" data-flag-title="Go runtime之 Goroutine 原理" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

            <div class="post-description">Goroutine 是 Go 编程语言中一种轻量级的并发执行单元，它是 Go runtime 的核心特性之一。Goroutine 允许开发者以一种简单、高效且可扩展的方式编写并发代码。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231211173422892.png" alt="image-20231211173422892"></p>
<blockquote>
<p>Goroutine 是一个与其他 goroutines 并行运行在同一地址空间的 Go 函数或方法。一个运行的程序由一个或更多个 goroutine 组成。它与线程、写成、进程等不同。它是一个 goroutine。</p>
<p>​                                                         – Rob Pike</p>
</blockquote>
<p>Goroutine 在同一个用户地址空间里并行独立执行 <code>functions</code>，<code>channels</code> 则用于  <code>goroutines</code> 间的通信和同步访问控制。</p>
<p>可执行程序可以分成两个层：用户代码和运行时。</p>
<p>运行时提供接口函数供用户代码调用，用来管理 <code>goroutines</code>，<code>channels</code> 和其他一些内置抽象结构。</p>
<p>用户代码对操作系统 <code>API</code>的任何调用都会被运行时层截取，以方便调度和垃圾回收。</p>
<h2 id="goroutine-和-thread-的区别"><a href="#goroutine-和-thread-的区别" class="headerlink" title="goroutine 和 thread 的区别"></a>goroutine 和 thread 的区别</h2><p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212092551002.png" alt="image-20231212092551002"></p>
<p>例如在一个进程的虚拟地址空间内，从低位 <code>0x00000000</code> 到高位 <code>0x7fffffff</code>，堆地址从低地址位到高地址位使用，栈从高地址位到地址位。</p>
<p>在进程内开启多个线程，是从栈上进行分配。</p>
<ul>
<li>内存占用：创建一个 <code>goroutine</code> 的栈内存消耗为 <code>2KB</code>（Linux AMD64 GO v1.4后），运行过程中，如果栈空间不够用，会自动进行扩容。</li>
</ul>
<p>创建一个 <code>thread</code> 为了尽量避免极端情况下操作系统线程栈的溢出，默认会为其分配一个较大的栈内存（ 1-8 MB 栈内存，线程标准 POSIX Thread），而且还需要一个被称为 <code>guard page</code> 的区域用于和其他 <code>thread</code> 的栈空间进行隔离（当进程中有内存溢出，使用 <code>guard page</code> 内存时，可也就是当有应用态使用这部分内存，则可能会被操作系统干掉。避免溢出时操作的是其他线程上的内存。）。而栈内存空间一旦创建和初始化完成之后，其大小就不能再有变化，这决定了在某些特殊场景下系统线程栈还是有溢出的风险。而且线程创建过多，也会导致栈内存耗尽。</p>
<ul>
<li>创建、销毁：线程创建和销毁都会有巨大的消耗，是内核级的交互（<code>trap</code>）</li>
</ul>
<p>POSIX 线程（定义了创建和操作线程的一套 API）通常是在已有的进程模型中增加的逻辑扩展，所以线程控制和进程控制很相似。而进入内核调度所消耗的性能代价比较高，开销较大。<code>goroutine</code> 是用户态线程，是由 <code>go runtime</code> 管理，创建和销毁的消耗非常小。</p>
<ul>
<li>调度切换：抛开陷入内核，线程切换会消耗 1000-1500 纳秒（上下文保存成本高，较多寄存器，公平性，复杂时间计算统计），一个纳秒平均可以执行 12-18 条指令。</li>
</ul>
<p>所以由于线程切换，执行指令的条数会减少 12000-18000。<code>goroutine</code> 的切换约为 <code>200ns</code>（用户态、3个寄存器），相当于 2400-3600 条指令。因此 <code>goroutines</code> 切换成本比 <code>threads</code> 要小得多。</p>
<ul>
<li>复杂性：线程的创建和退出复杂，多个 <code>thread</code> 间通讯复杂（<code>share memory</code>）</li>
</ul>
<p>不能大量创建线程（参考早期 <code>httpd</code>），成本高，使用网络多路复用，存在大量 <code>callback</code>（参考 <code>twemproxy</code>，<code>nginx</code>的代码）。对于应用服务线程门槛高，例如需要做第三方库隔离，需要考虑引用线程池等。</p>
<h2 id="M-N-模型"><a href="#M-N-模型" class="headerlink" title="M:N 模型"></a>M:N 模型</h2><p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212095740231.png" alt="image-20231212095740231"></p>
<p>Go 创建 M 个线程（ CPU 执行调度的单元，内核的 <code>task_struct</code>），之后创建的 N 个 <code>goroutine</code> 都会依附在这 M 个线程上执行，即 <code>M:N</code> 模型。</p>
<p>它们能够同时运行，与线程类似，但相比之下非常轻量。因此，程序运行时，<code>goroutines</code> 的个数应该是远大于线程的个数的（<code>pthread</code> 是内核线程，在计算机领域，POSIX 线程（通常称为 <code>pthreads</code>）是一种独立于编程语言的执行模型，也是一种并行执行模型。它允许程序控制多个在时间上重叠的不同工作流。）</p>
<p>同一个时刻，一个线程只能跑一个 <code>goroutine</code>。当 <code>goroutine</code>发生阻塞（<code>chan</code>阻塞、<code>mutex</code>、<code>syscall</code>等等）时，<code>Go</code> 会把当前的 <code>goroutine</code> 调度走，让其他 <code>goroutine</code> 来继续执行，而不是让线程阻塞休眠，尽可能多的分发任务出去，让 <code>CPU</code> 忙。</p>
<h1 id="GMP-调度模型"><a href="#GMP-调度模型" class="headerlink" title="GMP 调度模型"></a>GMP 调度模型</h1><ul>
<li><p>G ：<code>goroutine</code> 的缩写，每次 <code>go func()</code> 都代表一个G，无限制。</p>
<p>使用 <code>struct runtime.g</code>，包含了当前 <code>goroutine</code>的状态、堆栈、上下文。</p>
</li>
<li><p>M：工作线程（<code>OS thread</code>）也被称为 <code>Machine</code>，使用 <code>struct runtime.m</code>，所有 M 是有线程栈的</p>
<p>如果不对该线程栈提供内存的话，系统会给该线程栈提供内存（不同操作系统提供的线程栈大小不同）。当指定了线程栈，则 <code>M.stack</code> -&gt; <code>G.stack</code>（M 的栈，指向 G 的栈），M 的 PC 寄存器指向 G 提供的函数，然后去执行。（执行的时候，内存指向 G 的栈，切换到G的寄存器，执行完了之后，再切换回来，也就是 <code>g0</code>。）</p>
</li>
<li><p>P：在 <code>golang</code> 早期（go1.2 之前）没有 P 的概念。只有 <code>GM</code> 模型。</p>
</li>
</ul>
<p><code>go/src/runtime/runtime2.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Stack parameters.</span></span><br><span class="line">	<span class="comment">// stack describes the actual stack memory: [stack.lo, stack.hi).</span></span><br><span class="line">	<span class="comment">// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span></span><br><span class="line">	<span class="comment">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span></span><br><span class="line">	<span class="comment">// stackguard1 is the stack pointer compared in the C stack growth prologue.</span></span><br><span class="line">	<span class="comment">// It is stack.lo+StackGuard on g0 and gsignal stacks.</span></span><br><span class="line">	<span class="comment">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</span></span><br><span class="line">	stack       stack   <span class="comment">// offset known to runtime/cgo</span></span><br><span class="line">	stackguard0 <span class="type">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line">	stackguard1 <span class="type">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line"></span><br><span class="line">	_panic    *_panic <span class="comment">// innermost panic - offset known to liblink</span></span><br><span class="line">	_defer    *_defer <span class="comment">// innermost defer</span></span><br><span class="line">	m         *m      <span class="comment">// current m; offset known to arm liblink</span></span><br><span class="line">	sched     gobuf</span><br><span class="line">	syscallsp <span class="type">uintptr</span> <span class="comment">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span></span><br><span class="line">	syscallpc <span class="type">uintptr</span> <span class="comment">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span></span><br><span class="line">	stktopsp  <span class="type">uintptr</span> <span class="comment">// expected sp at top of stack, to check in traceback</span></span><br><span class="line">	<span class="comment">// param is a generic pointer parameter field used to pass</span></span><br><span class="line">	<span class="comment">// values in particular contexts where other storage for the</span></span><br><span class="line">	<span class="comment">// parameter would be difficult to find. It is currently used</span></span><br><span class="line">	<span class="comment">// in three ways:</span></span><br><span class="line">	<span class="comment">// 1. When a channel operation wakes up a blocked goroutine, it sets param to</span></span><br><span class="line">	<span class="comment">//    point to the sudog of the completed blocking operation.</span></span><br><span class="line">	<span class="comment">// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed</span></span><br><span class="line">	<span class="comment">//    the GC cycle. It is unsafe to do so in any other way, because the goroutine&#x27;s</span></span><br><span class="line">	<span class="comment">//    stack may have moved in the meantime.</span></span><br><span class="line">	<span class="comment">// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a</span></span><br><span class="line">	<span class="comment">//    closure in the runtime is forbidden.</span></span><br><span class="line">	param        unsafe.Pointer</span><br><span class="line">	atomicstatus <span class="type">uint32</span></span><br><span class="line">	stackLock    <span class="type">uint32</span> <span class="comment">// sigprof/scang lock; <span class="doctag">TODO:</span> fold in to atomicstatus</span></span><br><span class="line">	goid         <span class="type">int64</span></span><br><span class="line">	schedlink    guintptr</span><br><span class="line">	waitsince    <span class="type">int64</span>      <span class="comment">// approx time when the g become blocked</span></span><br><span class="line">	waitreason   waitReason <span class="comment">// if status==Gwaiting</span></span><br><span class="line"></span><br><span class="line">	preempt       <span class="type">bool</span> <span class="comment">// preemption signal, duplicates stackguard0 = stackpreempt</span></span><br><span class="line">	preemptStop   <span class="type">bool</span> <span class="comment">// transition to _Gpreempted on preemption; otherwise, just deschedule</span></span><br><span class="line">	preemptShrink <span class="type">bool</span> <span class="comment">// shrink stack at synchronous safe point</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// asyncSafePoint is set if g is stopped at an asynchronous</span></span><br><span class="line">	<span class="comment">// safe point. This means there are frames on the stack</span></span><br><span class="line">	<span class="comment">// without precise pointer information.</span></span><br><span class="line">	asyncSafePoint <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	paniconfault <span class="type">bool</span> <span class="comment">// panic (instead of crash) on unexpected fault address</span></span><br><span class="line">	gcscandone   <span class="type">bool</span> <span class="comment">// g has scanned stack; protected by _Gscan bit in status</span></span><br><span class="line">	throwsplit   <span class="type">bool</span> <span class="comment">// must not split stack</span></span><br><span class="line">	<span class="comment">// activeStackChans indicates that there are unlocked channels</span></span><br><span class="line">	<span class="comment">// pointing into this goroutine&#x27;s stack. If true, stack</span></span><br><span class="line">	<span class="comment">// copying needs to acquire channel locks to protect these</span></span><br><span class="line">	<span class="comment">// areas of the stack.</span></span><br><span class="line">	activeStackChans <span class="type">bool</span></span><br><span class="line">	<span class="comment">// parkingOnChan indicates that the goroutine is about to</span></span><br><span class="line">	<span class="comment">// park on a chansend or chanrecv. Used to signal an unsafe point</span></span><br><span class="line">	<span class="comment">// for stack shrinking. It&#x27;s a boolean value, but is updated atomically.</span></span><br><span class="line">	parkingOnChan <span class="type">uint8</span></span><br><span class="line"></span><br><span class="line">	raceignore     <span class="type">int8</span>     <span class="comment">// ignore race detection events</span></span><br><span class="line">	sysblocktraced <span class="type">bool</span>     <span class="comment">// StartTrace has emitted EvGoInSyscall about this goroutine</span></span><br><span class="line">	tracking       <span class="type">bool</span>     <span class="comment">// whether we&#x27;re tracking this G for sched latency statistics</span></span><br><span class="line">	trackingSeq    <span class="type">uint8</span>    <span class="comment">// used to decide whether to track this G</span></span><br><span class="line">	runnableStamp  <span class="type">int64</span>    <span class="comment">// timestamp of when the G last became runnable, only used when tracking</span></span><br><span class="line">	runnableTime   <span class="type">int64</span>    <span class="comment">// the amount of time spent runnable, cleared when running, only used when tracking</span></span><br><span class="line">	sysexitticks   <span class="type">int64</span>    <span class="comment">// cputicks when syscall has returned (for tracing)</span></span><br><span class="line">	traceseq       <span class="type">uint64</span>   <span class="comment">// trace event sequencer</span></span><br><span class="line">	tracelastp     puintptr <span class="comment">// last P emitted an event for this goroutine</span></span><br><span class="line">	lockedm        muintptr</span><br><span class="line">	sig            <span class="type">uint32</span></span><br><span class="line">	writebuf       []<span class="type">byte</span></span><br><span class="line">	sigcode0       <span class="type">uintptr</span></span><br><span class="line">	sigcode1       <span class="type">uintptr</span></span><br><span class="line">	sigpc          <span class="type">uintptr</span></span><br><span class="line">	gopc           <span class="type">uintptr</span>         <span class="comment">// pc of go statement that created this goroutine</span></span><br><span class="line">	ancestors      *[]ancestorInfo <span class="comment">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)</span></span><br><span class="line">	startpc        <span class="type">uintptr</span>         <span class="comment">// pc of goroutine function</span></span><br><span class="line">	racectx        <span class="type">uintptr</span></span><br><span class="line">	waiting        *sudog         <span class="comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span></span><br><span class="line">	cgoCtxt        []<span class="type">uintptr</span>      <span class="comment">// cgo traceback context</span></span><br><span class="line">	labels         unsafe.Pointer <span class="comment">// profiler labels</span></span><br><span class="line">	timer          *timer         <span class="comment">// cached timer for time.Sleep</span></span><br><span class="line">	selectDone     <span class="type">uint32</span>         <span class="comment">// are we participating in a select and did someone win the race?</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-G GC state</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// gcAssistBytes is this G&#x27;s GC assist credit in terms of</span></span><br><span class="line">	<span class="comment">// bytes allocated. If this is positive, then the G has credit</span></span><br><span class="line">	<span class="comment">// to allocate gcAssistBytes bytes without assisting. If this</span></span><br><span class="line">	<span class="comment">// is negative, then the G must correct this by performing</span></span><br><span class="line">	<span class="comment">// scan work. We track this in bytes to make it fast to update</span></span><br><span class="line">	<span class="comment">// and check for debt in the malloc hot path. The assist ratio</span></span><br><span class="line">	<span class="comment">// determines how this corresponds to scan work debt.</span></span><br><span class="line">	gcAssistBytes <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">	g0      *g     <span class="comment">// goroutine with scheduling stack g0在 M 中</span></span><br><span class="line">	morebuf gobuf  <span class="comment">// gobuf arg to morestack</span></span><br><span class="line">	divmod  <span class="type">uint32</span> <span class="comment">// div/mod denominator for arm - known to liblink</span></span><br><span class="line">	_       <span class="type">uint32</span> <span class="comment">// align next field to 8 bytes</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fields not known to debuggers.</span></span><br><span class="line">	procid        <span class="type">uint64</span>            <span class="comment">// for debuggers, but offset not hard-coded</span></span><br><span class="line">	gsignal       *g                <span class="comment">// signal-handling g</span></span><br><span class="line">	goSigStack    gsignalStack      <span class="comment">// Go-allocated signal handling stack</span></span><br><span class="line">	sigmask       sigset            <span class="comment">// storage for saved signal mask</span></span><br><span class="line">	tls           [tlsSlots]<span class="type">uintptr</span> <span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">	mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	curg          *g       <span class="comment">// current running goroutine</span></span><br><span class="line">	caughtsig     guintptr <span class="comment">// goroutine running during fatal signal</span></span><br><span class="line">	p             puintptr <span class="comment">// attached p for executing go code (nil if not executing go code)</span></span><br><span class="line">	nextp         puintptr</span><br><span class="line">	oldp          puintptr <span class="comment">// the p that was attached before executing a syscall</span></span><br><span class="line">	id            <span class="type">int64</span></span><br><span class="line">	mallocing     <span class="type">int32</span></span><br><span class="line">	throwing      <span class="type">int32</span></span><br><span class="line">	preemptoff    <span class="type">string</span> <span class="comment">// if != &quot;&quot;, keep curg running on this m</span></span><br><span class="line">	locks         <span class="type">int32</span></span><br><span class="line">	dying         <span class="type">int32</span></span><br><span class="line">	profilehz     <span class="type">int32</span></span><br><span class="line">	spinning      <span class="type">bool</span> <span class="comment">// m is out of work and is actively looking for work</span></span><br><span class="line">	blocked       <span class="type">bool</span> <span class="comment">// m is blocked on a note</span></span><br><span class="line">	newSigstack   <span class="type">bool</span> <span class="comment">// minit on C thread called sigaltstack</span></span><br><span class="line">	printlock     <span class="type">int8</span></span><br><span class="line">	incgo         <span class="type">bool</span>   <span class="comment">// m is executing a cgo call</span></span><br><span class="line">	freeWait      atomic.Uint32 <span class="comment">// Whether it is safe to free g0 and delete m (one of freeMRef, freeMStack, freeMWait)</span></span><br><span class="line">	fastrand      <span class="type">uint64</span></span><br><span class="line">	needextram    <span class="type">bool</span></span><br><span class="line">	traceback     <span class="type">uint8</span></span><br><span class="line">	ncgocall      <span class="type">uint64</span>      <span class="comment">// number of cgo calls in total</span></span><br><span class="line">	ncgo          <span class="type">int32</span>       <span class="comment">// number of cgo calls currently in progress</span></span><br><span class="line">	cgoCallersUse <span class="type">uint32</span>      <span class="comment">// if non-zero, cgoCallers in use temporarily</span></span><br><span class="line">	cgoCallers    *cgoCallers <span class="comment">// cgo traceback if crashing in cgo call</span></span><br><span class="line">	park          note</span><br><span class="line">	alllink       *m <span class="comment">// on allm</span></span><br><span class="line">	schedlink     muintptr</span><br><span class="line">	lockedg       guintptr</span><br><span class="line">	createstack   [<span class="number">32</span>]<span class="type">uintptr</span> <span class="comment">// stack that created this thread.</span></span><br><span class="line">	lockedExt     <span class="type">uint32</span>      <span class="comment">// tracking for external LockOSThread</span></span><br><span class="line">	lockedInt     <span class="type">uint32</span>      <span class="comment">// tracking for internal lockOSThread</span></span><br><span class="line">	nextwaitm     muintptr    <span class="comment">// next m waiting for lock</span></span><br><span class="line">	waitunlockf   <span class="function"><span class="keyword">func</span><span class="params">(*g, unsafe.Pointer)</span></span> <span class="type">bool</span></span><br><span class="line">	waitlock      unsafe.Pointer</span><br><span class="line">	waittraceev   <span class="type">byte</span></span><br><span class="line">	waittraceskip <span class="type">int</span></span><br><span class="line">	startingtrace <span class="type">bool</span></span><br><span class="line">	syscalltick   <span class="type">uint32</span></span><br><span class="line">	freelink      *m <span class="comment">// on sched.freem</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// these are here because they are too large to be on the stack</span></span><br><span class="line">	<span class="comment">// of low-level NOSPLIT functions.</span></span><br><span class="line">	libcall   libcall</span><br><span class="line">	libcallpc <span class="type">uintptr</span> <span class="comment">// for cpu profiler</span></span><br><span class="line">	libcallsp <span class="type">uintptr</span></span><br><span class="line">	libcallg  guintptr</span><br><span class="line">	syscall   libcall <span class="comment">// stores syscall parameters on windows</span></span><br><span class="line"></span><br><span class="line">	vdsoSP <span class="type">uintptr</span> <span class="comment">// SP for traceback while in VDSO call (0 if not in call)</span></span><br><span class="line">	vdsoPC <span class="type">uintptr</span> <span class="comment">// PC for traceback while in VDSO call</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// preemptGen counts the number of completed preemption</span></span><br><span class="line">	<span class="comment">// signals. This is used to detect when a preemption is</span></span><br><span class="line">	<span class="comment">// requested, but fails. Accessed atomically.</span></span><br><span class="line">	preemptGen <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether this is a pending preemption signal on this M.</span></span><br><span class="line">	<span class="comment">// Accessed atomically.</span></span><br><span class="line">	signalPending <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">	dlogPerM</span><br><span class="line"></span><br><span class="line">	mOS</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Up to 10 locks held by this m, maintained by the lock ranking code.</span></span><br><span class="line">	locksHeldLen <span class="type">int</span></span><br><span class="line">	locksHeld    [<span class="number">10</span>]heldLockInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">	id          <span class="type">int32</span></span><br><span class="line">	status      <span class="type">uint32</span> <span class="comment">// one of pidle/prunning/...</span></span><br><span class="line">	link        puintptr</span><br><span class="line">	schedtick   <span class="type">uint32</span>     <span class="comment">// incremented on every scheduler call</span></span><br><span class="line">	syscalltick <span class="type">uint32</span>     <span class="comment">// incremented on every system call</span></span><br><span class="line">	sysmontick  sysmontick <span class="comment">// last tick observed by sysmon</span></span><br><span class="line">	m           muintptr   <span class="comment">// back-link to associated m (nil if idle)</span></span><br><span class="line">	mcache      *mcache    <span class="comment">// mcache m 的本地缓存</span></span><br><span class="line">	pcache      pageCache</span><br><span class="line">	raceprocctx <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	deferpool    []*_defer <span class="comment">// pool of available defer structs (see panic.go)</span></span><br><span class="line">	deferpoolbuf [<span class="number">32</span>]*_defer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span></span><br><span class="line">	goidcache    <span class="type">uint64</span></span><br><span class="line">	goidcacheend <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Queue of runnable goroutines. Accessed without lock.</span></span><br><span class="line">	runqhead <span class="type">uint32</span></span><br><span class="line">	runqtail <span class="type">uint32</span></span><br><span class="line">	runq     [<span class="number">256</span>]guintptr   <span class="comment">// P 的本地队列</span></span><br><span class="line">	<span class="comment">// runnext, if non-nil, is a runnable G that was ready&#x27;d by</span></span><br><span class="line">	<span class="comment">// the current G and should be run next instead of what&#x27;s in</span></span><br><span class="line">	<span class="comment">// runq if there&#x27;s time remaining in the running G&#x27;s time</span></span><br><span class="line">	<span class="comment">// slice. It will inherit the time left in the current time</span></span><br><span class="line">	<span class="comment">// slice. If a set of goroutines is locked in a</span></span><br><span class="line">	<span class="comment">// communicate-and-wait pattern, this schedules that set as a</span></span><br><span class="line">	<span class="comment">// unit and eliminates the (potentially large) scheduling</span></span><br><span class="line">	<span class="comment">// latency that otherwise arises from adding the ready&#x27;d</span></span><br><span class="line">	<span class="comment">// goroutines to the end of the run queue.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Note that while other P&#x27;s may atomically CAS this to zero,</span></span><br><span class="line">	<span class="comment">// only the owner P can CAS it to a valid G.</span></span><br><span class="line">	runnext guintptr	<span class="comment">// 下一个可以运行的 G</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Available G&#x27;s (status == Gdead)   全局队列</span></span><br><span class="line">	gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">		gList</span><br><span class="line">		n <span class="type">int32</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sudogcache []*sudog</span><br><span class="line">	sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cache of mspan objects from the heap.</span></span><br><span class="line">	mspancache <span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="comment">// We need an explicit length here because this field is used</span></span><br><span class="line">		<span class="comment">// in allocation codepaths where write barriers are not allowed,</span></span><br><span class="line">		<span class="comment">// and eliminating the write barrier/keeping it eliminated from</span></span><br><span class="line">		<span class="comment">// slice updates is tricky, moreso than just managing the length</span></span><br><span class="line">		<span class="comment">// ourselves.</span></span><br><span class="line">		<span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">		buf [<span class="number">128</span>]*mspan</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tracebuf traceBufPtr</span><br><span class="line"></span><br><span class="line">	<span class="comment">// traceSweep indicates the sweep events should be traced.</span></span><br><span class="line">	<span class="comment">// This is used to defer the sweep start event until a span</span></span><br><span class="line">	<span class="comment">// has actually been swept.</span></span><br><span class="line">	traceSweep <span class="type">bool</span></span><br><span class="line">	<span class="comment">// traceSwept and traceReclaimed track the number of bytes</span></span><br><span class="line">	<span class="comment">// swept and reclaimed by sweeping in the current sweep loop.</span></span><br><span class="line">	traceSwept, traceReclaimed <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	palloc persistentAlloc <span class="comment">// per-P to avoid mutex</span></span><br><span class="line"></span><br><span class="line">	_ <span class="type">uint32</span> <span class="comment">// Alignment for atomic fields below</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The when field of the first entry on the timer heap.</span></span><br><span class="line">	<span class="comment">// This is updated using atomic functions.</span></span><br><span class="line">	<span class="comment">// This is 0 if the timer heap is empty.</span></span><br><span class="line">	timer0When <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The earliest known nextwhen field of a timer with</span></span><br><span class="line">	<span class="comment">// timerModifiedEarlier status. Because the timer may have been</span></span><br><span class="line">	<span class="comment">// modified again, there need not be any timer with this value.</span></span><br><span class="line">	<span class="comment">// This is updated using atomic functions.</span></span><br><span class="line">	<span class="comment">// This is 0 if there are no timerModifiedEarlier timers.</span></span><br><span class="line">	timerModifiedEarliest <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-P GC state</span></span><br><span class="line">	gcAssistTime         <span class="type">int64</span> <span class="comment">// Nanoseconds in assistAlloc</span></span><br><span class="line">	gcFractionalMarkTime <span class="type">int64</span> <span class="comment">// Nanoseconds in fractional mark worker (atomic)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// gcMarkWorkerMode is the mode for the next mark worker to run in.</span></span><br><span class="line">	<span class="comment">// That is, this is used to communicate with the worker goroutine</span></span><br><span class="line">	<span class="comment">// selected for immediate execution by</span></span><br><span class="line">	<span class="comment">// gcController.findRunnableGCWorker. When scheduling other goroutines,</span></span><br><span class="line">	<span class="comment">// this field must be set to gcMarkWorkerNotWorker.</span></span><br><span class="line">	gcMarkWorkerMode gcMarkWorkerMode</span><br><span class="line">	<span class="comment">// gcMarkWorkerStartTime is the nanotime() at which the most recent</span></span><br><span class="line">	<span class="comment">// mark worker started.</span></span><br><span class="line">	gcMarkWorkerStartTime <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// gcw is this P&#x27;s GC work buffer cache. The work buffer is</span></span><br><span class="line">	<span class="comment">// filled by write barriers, drained by mutator assists, and</span></span><br><span class="line">	<span class="comment">// disposed on certain GC state transitions.</span></span><br><span class="line">	gcw gcWork</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wbBuf is this P&#x27;s GC write barrier buffer.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Consider caching this in the running G.</span></span><br><span class="line">	wbBuf wbBuf</span><br><span class="line"></span><br><span class="line">	runSafePointFn <span class="type">uint32</span> <span class="comment">// if 1, run sched.safePointFn at next safe point</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// statsSeq is a counter indicating whether this P is currently</span></span><br><span class="line">	<span class="comment">// writing any stats. Its value is even when not, odd when it is.</span></span><br><span class="line">	statsSeq <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lock for timers. We normally access the timers while running</span></span><br><span class="line">	<span class="comment">// on this P, but the scheduler can also do it from a different P.</span></span><br><span class="line">	timersLock mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Actions to take at some time. This is used to implement the</span></span><br><span class="line">	<span class="comment">// standard library&#x27;s time package.</span></span><br><span class="line">	<span class="comment">// Must hold timersLock to access.</span></span><br><span class="line">	timers []*timer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Number of timers in P&#x27;s heap.</span></span><br><span class="line">	<span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">	numTimers <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Number of timerDeleted timers in P&#x27;s heap.</span></span><br><span class="line">	<span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">	deletedTimers <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Race context used while executing timer functions.</span></span><br><span class="line">	timerRaceCtx <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// scannableStackSizeDelta accumulates the amount of stack space held by</span></span><br><span class="line">	<span class="comment">// live goroutines (i.e. those eligible for stack scanning).</span></span><br><span class="line">	<span class="comment">// Flushed to gcController.scannableStackSize once scannableStackSizeSlack</span></span><br><span class="line">	<span class="comment">// or -scannableStackSizeSlack is reached.</span></span><br><span class="line">	scannableStackSizeDelta <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// preempt is set to indicate that this P should be enter the</span></span><br><span class="line">	<span class="comment">// scheduler ASAP (regardless of what G is running on it).</span></span><br><span class="line">	preempt <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Padding is no longer needed. False sharing is now not a worry because p is large enough</span></span><br><span class="line">	<span class="comment">// that its size class is an integer multiple of the cache line size (for any of our architectures).</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GM-调度器"><a href="#GM-调度器" class="headerlink" title="GM 调度器"></a>GM 调度器</h2><p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212102400898.png" alt="image-20231212102400898"></p>
<p>Go 1.2 前的调度器实现，限制了 Go 并发程序的伸缩性，尤其是对那些有高吞吐或并行计算需求的服务程序。</p>
<p>每个 <code>goroutine</code> 对应于 <code>runtime</code> 中的一个抽象结构：G；而 <code>thread</code> 作为 <code>物理CPU</code> 的存在而被抽象为一个结构：M(<code>machine</code>)。</p>
<p>所有创建的 G 都会在一个全局队列中排队，等待被 M 执行（M从 <code>global queue</code>中拿取任务执行）。此时 <code>global queue</code> 会有一个全局大锁 <code>Sched.Lock</code>，会影响 <code>global queue</code>吞吐。</p>
<p>当 <code>goroutine</code> 调用了一个阻塞的系统调用，运行这个 <code>goroutine</code> 的线程就会被阻塞，这时至少应该再创建、唤醒一个线程来运行别的没有阻塞的 <code>goroutine</code>。线程这里可以创建不止一个，可以按需不断的创建，而活跃的线程（处于非阻塞状态的线程）的最大个数存储在变量 <code>GOMAXPROCS</code> 中。（创建、唤醒一个线程的开销是比较大的。）</p>
<ol>
<li>遇到 <code>syscall</code> 唤醒一个 M，避免有 G 在等；</li>
<li>遇到 <code>chan blocking</code> 切换 G 状态为 <code>waiting</code>，当前 M 去执行其他 G，<code>waiting G chan</code> 完成后，恢复为 <code>runable</code>，等待 M 来重新执行（不一定是之前的M）</li>
</ol>
<h2 id="GM-调度模型的问题"><a href="#GM-调度模型的问题" class="headerlink" title="GM 调度模型的问题"></a>GM 调度模型的问题</h2><ul>
<li><p>单一全局互斥锁（<code>Sched.Lock</code>）和集中状态存储</p>
<p>导致所有 <code>goroutine</code> 相关操作，比如：创建、结束、重新调度等都要上锁</p>
</li>
<li><p><code>Goroutine</code> 传递问题</p>
<p>M 经常在 M 之间传递 <code>可运行</code> 的 <code>goroutine</code>，这导致调度延迟增大以及额外的性能损耗（刚创建的 G 放到了全局队列，而不是本地M执行，不必要的开销和延迟；以及当一个 <code>goroutine</code> 阻塞的时候，需要从 M 放回 <code>global queue</code>，等到 <code>runable</code> 的时候，再从<code>global queue</code>中可能被其他的 M 拿到并执行）</p>
</li>
<li><p><code>Per-M</code> 持有内存缓存（<code>M.mcache</code>)</p>
<p>类似<code>TCMalloc</code>的结构，每个 M 持有 <code>mcache</code> 和 <code>stack alloc</code>，然后只有在 M 运行 Go 代码时才需要使用的内存（每个 <code>mcache</code> 可以高达 <code>2mb</code>），当 M 在处于  <code>syscall</code> 时并不需要。运行 Go 代码和阻塞在 <code>syscall</code> 的 M 的比例高达 <code>1:100</code>，造成了很大的浪费。</p>
<p>同时内存亲缘性也较差，G 当前在 M 运行后对 M 的内存进行了预热，因为现在 G 调度到同一个 M 的概率不高，数据局部性不好。（<code>proc a new proc b</code>）</p>
</li>
<li><p>严重的线程阻塞&#x2F;解锁</p>
<p>在系统调用的情况下，工作线程经常被阻塞和取消阻塞，这增加了很多开销。比如 M 找不到G，此时 M 就会进入频繁阻塞&#x2F;唤醒来进行检查的逻辑，以便及时发现新的 G 来执行</p>
</li>
</ul>
<p>GM 调度模型的问题可以参考这边文章</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVFRqNFQySk80MnVENUlEOWU4OW9hMHNMS2hKWUQwWV9rcXhEdjNJM1hNdy9lZGl0P3BsaT0xI2hlYWRpbmc9aC5tbXE4bG00OHFmY3c=">Scalable Go Scheduler Design Doc<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly94aWUuaW5mb3EuY24vYXJ0aWNsZS9hNjk0ODQwMmJlNjg4ZGJhNTMwMDk0ZTli">[翻译]Scalable Go Scheduler Design Doc[Go 可扩展调度设计文档]<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="GMP-概念"><a href="#GMP-概念" class="headerlink" title="GMP 概念"></a>GMP 概念</h2><ul>
<li><p>P：<code>Processor</code> 是一个抽象的概念，并不是真正的物理 CPU</p>
<p>Dmitry Vyukov 的方案是引入一个结构 P，它代表了 M 所需的上下文环境，也是处理用户级代码逻辑的处理器。</p>
<p>它负责衔接 M 和 G 的调度上下文，将等待执行的 G 与 M 对接。</p>
<p>当 P 有任务时需要创建或者唤醒一个 M 来执行它队列里的任务。所以 <code>P/M</code> 需要进行绑定，构成一个执行单元。</p>
<p>P 决定了并行任务的数量，可通过 <code>runtime.GOMAXPROCS</code> 来设定。在 <code>GO 1.5</code> 之后 <code>GOMAXPROCS</code> 被默认设置可用的核数，而之前默认为1。</p>
</li>
</ul>
<p>Tips：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ViZXItZ28vYXV0b21heHByb2Nz">uber-go&#x2F;automaxprocs<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>Automatically set GOMAXPROCS to match Linux container CPU quota。</p>
<p>自动设置GOMAXPROCS以匹配Linux容器CPU配额。</p>
</blockquote>
<p><code>cache</code>, <code>timer</code>，<code>g</code>,<code>cache/stackallc</code> 从 M 移到了 P，而 G 队列也被分为两类，保留全局 G 队列，同时每个 P 中都会有一个本地的 G 队列。（<code>g0</code>还是放在M里面）</p>
<h2 id="GMP-调度器"><a href="#GMP-调度器" class="headerlink" title="GMP 调度器"></a>GMP 调度器</h2><p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212113431292.png" alt="image-20231212113431292"></p>
<p>引入了 <code>local queue</code>，因为 P 的存在，<code>runtime</code> 并不需要做一个集中式的 <code>goroutine</code> 调度，每一个 M 都会在 <code>P&#39;s local queue</code>、<code>global queue</code> 或者<strong>其他 P 队列中找 G 执行</strong>，减少全局锁对性能的影响。</p>
<p>这也是 <code>GMP</code> <code>Work-stealing</code> 调度算法的核心。</p>
<p>注意 P 的本地 G 队列还是可能面临一个并发访问的场景，为了避免加锁，这里 P 的本地队列是一个 <code>LockFree</code> 的队列，窃取 G 时使用 CAS 原子操作来完成。</p>
<p>关于 <code>LockFree</code> 和 <code>CAS</code> 的知识参见：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzAxMjI4MA==">简化概念下的 lock-free 编程<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="Work-stealing-调度算法"><a href="#Work-stealing-调度算法" class="headerlink" title="Work-stealing 调度算法"></a>Work-stealing 调度算法</h1><p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212163850477.png" alt="image-20231212163850477"></p>
<p>当一个 P 执行完本地所有的 G 之后，并且全局队列为空的时候，会<strong>随机</strong>尝试挑选一个受害者 P，从它的 G 队列中窃取一半的 G。否则会从全局队列中获取（当前个数&#x2F;<code>GOMAXPROCS</code>）个 G。</p>
<p>为了保证公平性，从随机位置上的 P 开始，而且<strong>遍历的顺序也随机化</strong>了（选择一个小于 <code>GOMAXPROCS</code>，且和它互为质数的步长），保证遍历的顺序也随机化了。</p>
<p>找到任务之后，切换调用栈执行任务。再循环不断的获取任务，直到进入休眠。</p>
<p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231213105053906.png" alt="image-20231213105053906"></p>
<p>光窃取是不够的，可能会导致全局对了饥饿。（优先级：<code>1/61</code>概率去全局队列拿；全局队列没有或者是<code>60/61</code>再去本地队列；本地队列没有的话，再去同其他 P <code>steal</code>；其他队列也没有再检查全局队列；全局队列没有，就 <code>poll network</code>，处理网络请求中已经 <code>ready</code>的。）</p>
<p>P 的调度算法中还会每个 N 轮调度之后，就去全局队列拿一个 G。</p>
<p>谁放入的全局队列呢？</p>
<p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231213105300133.png" alt="image-20231213105300133"></p>
<p>新建 G 时，P 的本地 G 队列放不下，已满并达到 256 个的时候会放半数 G 到全局队列去，阻塞的系统调用返回时找不到空闲 P 也会放到全局队列。</p>
<h2 id="Syscall"><a href="#Syscall" class="headerlink" title="Syscall"></a>Syscall</h2><p>Go 有自己封装的 <code>syscall</code>，也就是进入和退出 <code>syscall</code> 的时候执行 <code>entersyscall/exitsyscall</code>，也只有被封装了系统调用才有可能出发重新调度，它将改变 P 的状态为 <code>syscall</code>。</p>
<p>系统监视器（<code>system monitor</code>），称为 <code>sysmon</code>，会定时扫描。在执行系统调用时，如果某个 P 的 G 执行超过一个 <code>sysmon tick</code>，则脱离 M。</p>
<p>调用 <code>syscall</code> 后会解绑 P，然后 M 和 G 进入阻塞，而 P 此时的状态就是 <code>syscall</code>，表明这个 P 的 G 正在 <code>syscall</code> 中，这时的 P 是不能被调度给别的 M 的。</p>
<p>如果在短时间内阻塞的 M 就唤醒了，那么 M 会优先来重新获取这个 P，能够取到就继续绑回去，这样有利于数据的局部性。</p>
<p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231213110031349.png" alt="image-20231213110031349"></p>
<p>在执行 <code>syscall</code> 时，如果某个 P 的 G 执行超过一个 <code>sysmon tick</code>（10ms），就会把他设为 <code>idle</code>，重新调度给需要的 M，强制解绑。上图 P3 与 M 解绑，进入 <code>P sched</code>。M 调用 G 依然执行 <code>syscall</code>。</p>
<p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231213110248609.png" alt="image-20231213110248609"></p>
<p>P1 和 M 脱离后目前在 <code>idle list</code> 中等待被绑定（处于 <code>syscall</code> 状态）。G35 在 <code>syscall</code> 结束之后，会<strong>被自己</strong>放到全局队列，等待被 P 获取。</p>
<p>而 <code>syscall</code> 结束后 M 按照如下规则执行直到满足其中一个条件：</p>
<ul>
<li>尝试获取同一个 P（P1），恢复执行 G（获取同一个 P，应该是考虑情缘性，执行相同的 G。）</li>
<li>尝试获取 <code>idle list</code> 中的其他空闲 P，恢复执行 G</li>
<li>找不到空闲 P，把 G 放回 <code>global queue</code>，M 放回到 <code>idle list</code></li>
</ul>
<h2 id="OS-thread"><a href="#OS-thread" class="headerlink" title="OS thread"></a>OS thread</h2><p>当使用了 <code>syscall</code>，Go 无法限制 <code>Blocked OS threads</code> 的数量。</p>
<blockquote>
<p>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package’s GOMAXPROCS function queries and changes the limit.</p>
<p>GOMAXPROCS 变量限制了可以同时执行用户级 Go 代码的操作系统线程数量。在系统调用中代表 Go 代码被阻塞的线程数量没有限制；这些线程不计入 GOMAXPROCS 限制。本软件包的 GOMAXPROCS 函数可查询并更改限制。</p>
</blockquote>
<p><code>Tips</code>：使用 <code>syscall</code> 写程序要认真考虑 <code>pthread exhaust</code> 问题。<code>syscall</code> 会产生 <code>Blocked OS threads</code>。</p>
<h2 id="Sping-thread"><a href="#Sping-thread" class="headerlink" title="Sping thread"></a>Sping thread</h2><p>线程自旋是相对于线程阻塞而言的，表象就是循环执行一个指定逻辑（调度逻辑，目的是不停地寻找 G）。</p>
<p>这样做的问题显而易见，如果 G 迟迟不来，CPU 会白白浪费在这无意义的计算上。但好处也很明显，降低了 M 的上下文切换成本，提高了性能。（自旋时间从 <code>20us</code> ，然后 <code>1ms</code> 后翻倍，直到 <code>10ms</code>，不断重置）</p>
<p>Go 的设计者倾向于高性能的并发表现，选择了后者。</p>
<p>在两个地方引入自旋：</p>
<ul>
<li>类型 1：M 不带 P 的找 P 挂载（一有 P 释放就结合）</li>
<li>类型2 ：M 带 P 的找 G 运行（一有 <code>runable</code> 的 G 就执行）</li>
</ul>
<p>为了避免过多浪费 CPU 资源，自旋的 M 最多只允许 <code>GOMAXPROCS</code>（<code>Busy P</code>）。同时当有类型1 的自旋 M 存在时，类型 2 的自旋 M 就不阻塞，阻塞会释放 P，一释放 P 就马上被类型 1 的自旋 M 抢走了，没必要。</p>
<p>对于未绑定的 <strong>游离态</strong> 的 M，会进入休眠阻塞态。</p>
<p>在新 G 被创建、M 进入系统调用、M 从空闲被激活者三种状态变化前，调度器会确保至少有一个自旋 M 存在（唤醒或创建一个 M），除非没有空闲的 P。</p>
<ul>
<li>当新 G 创建，如果有可用 P，就意味着新 G 可以被立即执行，即便不再同一个 P 也无妨，所以我们保留一个自旋的 M （这时应该不存在类型 1 的自旋，只有类型 2 的自旋）就可以保证新 G 很快被运行。</li>
<li>当 M 进入系统调用，意味着 M 不知道何时可以醒来，那么 M 对应的 P 中剩下的 G 就得有新的 M 来执行，所以我们保留一个自旋的 M 来执行剩下的 G （这时应该不存在类型 2 的自旋，只有类型 1 的自旋）。</li>
<li>如果 M 从空闲变成活跃，意味着可能一个处于自旋状态的 M 进入工作状态了，这时要检查并确保还有一个自旋 M 存在，以防还有 G 或者还有 P 空着的。</li>
</ul>
<h2 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h2><p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231213112335054.png" alt="image-20231213112335054"></p>
<p><code>sysmon</code> 也叫监控线程，它无需 P 也可以运行，他是一个死循环，每 <code>20us~10ms</code> 循环一次，循环完一次就 <code>sleep</code> 一会，为什么会是一个变动的周期呢，主要是避免空转，如果每次循环都没什么需要做的事，那么 <code>sleep</code> 的时间就会加大。</p>
<ul>
<li>释放闲置超过 5分钟的 <code>span</code> 物理内存；</li>
<li>如果超过 2分钟没有垃圾回收，强制执行；</li>
<li>将长时间未处理的 <code>netpoll</code> 添加到全局队列；</li>
<li>向长时间运行的 G 任务发出抢占调度；</li>
<li>收回因 <code>syscall</code> 长时间阻塞的 P；</li>
</ul>
<p>协作式抢占，当 P 在 M 上执行时间超过 10ms，<code>sysmon</code> 调用 <code>preemptone</code> 将 G 标记为 <code>stackPreempt</code>（代表这个 G 为可被抢占）。因此需要在某个地方触发检测逻辑，Go 当前是在检查栈是否溢出的地方判定（<code>morestack()</code>）,M 会保存当前 G 的上下文，重新进入调度逻辑。</p>
<p>死循环：非抢占式：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9pc3N1ZXMvMTE0NjI=">runtime: golang scheduler is not preemptive - it’s cooperative? #11462<i class="fa fa-external-link-alt"></i></span></p>
<p>信号抢占：<span class="exturl" data-url="aHR0cHM6Ly94aWFvcnVpLmNjL2FyY2hpdmVzLzY1MzU=">golang 基于信号的抢占式调度的设计实现原理<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231213112512194.png" alt="image-20231213112512194"></p>
<p>异步抢占，注册 <code>sigurg</code> 信号，通过 <code>sysmon</code> 检测，对 M 对应的线程发送信号，触发注册的 <code>handler</code>，它往当前 G 的 PC 中（指令的寄存器中）插入一条指令（调用某个方法实现跳出），在处理完 <code>handler</code>，G 恢复后，自己把自己推到了 <code>global queue</code> 中。</p>
<p><code>Tips</code>：发生程序 <code>hang</code> 死情况时，通常可以使用一些工具做诊断：</p>
<ul>
<li><code>go tool pprof</code></li>
<li><code>perf</code>,<code>top</code></li>
</ul>
<h2 id="Network-poller"><a href="#Network-poller" class="headerlink" title="Network poller"></a>Network poller</h2><p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214103348046.png" alt="image-20231214103348046"></p>
<p>Go 所有的 <code>I/O</code> 都是阻塞的。然后通过 <code>goroutine</code> + <code>channel</code> 来处理并发。</p>
<p>因此所有的 <code>IO</code> 逻辑都是直来直去的，不再需要回调，不再需要 <code>future</code>，要的仅仅是 <code>step by step</code>。这对于代码的可读性是很有帮助的。</p>
<p>G 发起网络 <code>I/O</code> 操作也不会导致 M 被阻塞（仅阻塞 G ），从而不会导致大量 M 被创建出来。将异步 <code>I/O</code> 转换为阻塞的 <code>I/O</code> 的部分称为 <code>netpoller</code>。</p>
<p>打开或接受连接都被设置为<strong>非阻塞模式</strong>。如果你试图对其进行 <code>I/O</code> 操作，并且文件描述符数据还没有准备好，它将返回一个错误代码，然后调用 <code>netpoller</code>，等待后续被 <code>runtime network poller</code>将其调度到 <code>global queue</code>。G 会进入 <code>gopark</code> 函数，将当前正在执行的 G 状态保存起来，然后切换到新的堆栈上执行新的 G。</p>
<p>那么 G 什么时候被调度回来呢？</p>
<p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214103822220.png" alt="image-20231214103822220"></p>
<p><code>netowrk poller</code> 触发点：</p>
<ul>
<li><code>sysmon</code></li>
<li><code>schedule()</code>：M 找 G 的调度函数</li>
<li>GC：<code>start the world</code></li>
</ul>
<p>调用 <code>netpoll()</code> 在某一次调度 G 的过程中，处于就绪状态的 <code>fd</code> 对应的 G 就会被调度回来。（也就是从 <code>ready</code> 的网络事件中恢复 G）。</p>
<p>G 的 <code>gopark</code> 状态： G 置为 <code>waiting</code> 状态，等待显示 <code>goready</code> 唤醒，在 <code>poller</code> 中用得较多，还有锁、<code>chan</code> 等。</p>
<h2 id="Scheduler-Affinity"><a href="#Scheduler-Affinity" class="headerlink" title="Scheduler Affinity"></a>Scheduler Affinity</h2><p>GM 调度器时代的，<code>chan</code> 操作导致的切换代价。</p>
<ul>
<li><p><code>coroutine #7</code> 正在等待消息，阻塞在 <code>chan</code>。一旦收到消息，这个 <code>goroutine</code> 就被推到全局队列</p>
<p>  <img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214104019605.png" alt="image-20231214104019605"></p>
</li>
<li><p>然后，<code>chan</code> 推送消息，<code>goroutine #X</code> 将在可用线程上运行，而 <code>goroutine #8</code> 将阻塞在 <code>chan</code></p>
<p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214104212317.png" alt="image-20231214104212317"></p>
</li>
<li><p><code>goroutine #7</code> 现在在可用线程上运行</p>
<p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214104253595.png" alt="image-20231214104253595"></p>
</li>
</ul>
<p>在 <code>chan</code> 来回通信的 <code>goroutine</code> 会导致频繁的 <code>blocks</code>，即频繁地在本地队列中重新排队。</p>
<p>然而，由于本地队列是 <code>FIFO</code> 实现，如果另一个 <code>goroutine</code> 占用线程，<code>unblock goroutine</code> 不能保证尽快运行。</p>
<p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214104408459.png" alt="image-20231214104408459"></p>
<p>同时 Go 情缘性调度的一些限制：</p>
<ul>
<li><p><code>work-stealing</code></p>
<p>当 P 的 <code>local queue</code> 任务不够，同时 <code>global queue</code>、<code>network poller</code> 也会空，这时从其他 P 窃取任务运行，然后任务就运行到了其他县城，情缘性就没有意义。</p>
</li>
<li><p>系统调用。</p>
<p>当 <code>syscall</code>  产生，Go 把当前线程设置为 <code>blocking mode</code>，让一个新的线程接管了这个 P （过一个 <code>sysmon tick</code> 才会交给其他 M，大多数 <code>syscall</code> 都是很快的）</p>
</li>
</ul>
<p><code>goroutine #9</code> 在 <code>chan</code> 被阻塞后恢复。但是，它必须等待 <code>#2</code>、<code>#5</code>和<code>#4</code> 之后才能运行。</p>
<p><code>goroutine #5</code> 将阻塞其线程，从而延迟 <code>goroutine #9</code>，并使其面临被另一个 P 窃取的风险。</p>
<p>针对 <code>communicate-and-wait</code> 模式，进行了情缘性调度的优化。</p>
<p>当前 <code>local queue</code> 使用了 <code>FIFO</code> 实现，<code>unlock</code> 的 G 无法尽快执行，如果队列中前面存在占用线程的其他 G 。</p>
<p><code>Go 1.5</code> 在 P 中引入了 <code>runnext</code> 特殊的一个字段，可以高优先级执行 <code>unblock G</code>。</p>
<p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231214104704320.png" alt="image-20231214104704320"></p>
<p><code>goroutine #9</code> 现在被标记为<code>runnext</code>（下一个可运行的）。这种新的优先级排序允许 <code>goroutine</code> 在再次被阻塞之前快速运行。此时就会被其他的 P 给 <code>steal</code> 过去。</p>
<p>这一变化对运行中的标准库产生了总体上的积极影响，提高了一些包的性能。</p>
<h1 id="GMP-问题总结"><a href="#GMP-问题总结" class="headerlink" title="GMP 问题总结"></a>GMP 问题总结</h1><ul>
<li><p>单一全局互斥锁（<code>Sched.Lock</code>）和集中状态存储</p>
<p>G 被分成全局队列和 P 的本地队列，全局队列依旧是全局锁，但是使用场景明显很少，P 本地队列使用无锁队列，使用原子操作来面对可能的并发场景（其他 P <code>steal</code>）</p>
</li>
<li><p>Goroutine 传递问题</p>
<p>G 创建时，就在 P 的本地队列，可以避免在 G 之间传递（窃取除外），G 对 P 的数据局部性好；当 G 开始执行了，系统调用返回后 M 会尝试获取可用 P，获取到了的话可以避免在 M 之间传递。而且优先获取调用阻塞前的 P，所以 G 对 M 数据局部性好，G 对 P 的数据局部性也好。</p>
</li>
<li><p><code>Per-M</code> 持有内存缓存（<code>M.mcache</code>）</p>
<p>内存 <code>mcache</code> 只存在 P 的结构中，P 最多只有 <code>GOMAXPROCS</code>个，远小于 M 的个数，所以内存没有过多的消耗。</p>
</li>
<li><p>严重的线程阻塞&#x2F;解锁</p>
<blockquote>
<p> 通过引入自旋，保证任何时候都有处于等待状态的自旋 M，避免在等待可用的 P 和 G 时频繁的阻塞和唤醒。</p>
<p>– by Dmitry Vyukov  <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVFRqNFQySk80MnVENUlEOWU4OW9hMHNMS2hKWUQwWV9rcXhEdjNJM1hNdy9lZGl0">Scalable Go Scheduler Design Doc<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
</ul>
<h1 id="Goroutine-Lifecycle"><a href="#Goroutine-Lifecycle" class="headerlink" title="Goroutine Lifecycle"></a>Goroutine Lifecycle</h1><h2 id="Go-程序启动"><a href="#Go-程序启动" class="headerlink" title="Go 程序启动"></a>Go 程序启动</h2><p>整个程序始于一段汇编，而在随后的 <code>runtime.rt0_go</code>（也是汇编程序）中，会执行很多初始化工作。</p>
<p><code>go/src/runtime/asm_amd64.s</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _rt0_amd64 is common startup code for most amd64 systems when using</span></span><br><span class="line"><span class="comment">// internal linking. This is the entry point for the program from the</span></span><br><span class="line"><span class="comment">// kernel for an ordinary -buildmode=exe program. The stack holds the</span></span><br><span class="line"><span class="comment">// number of arguments and the C-style argv.</span></span><br><span class="line">TEXT _rt0_amd64(SB),NOSPLIT,$<span class="number">-8</span></span><br><span class="line">	MOVQ	<span class="number">0</span>(SP), DI	<span class="comment">// argc</span></span><br><span class="line">	LEAQ	<span class="number">8</span>(SP), SI	<span class="comment">// argv</span></span><br><span class="line">	JMP	runtime·rt0_go(SB)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212165201810.png" alt="image-20231212165201810"></p>
<ul>
<li>绑定 <code>m0</code> 和 <code>g0</code>，<code>m0</code> 就是程序的主程序，程序启动必然会拥有一个主线程，这个就是 <code>m0</code>。<code>g0</code> 负责调度，即 <code>schedule()</code> 函数。</li>
<li>创建 P，绑定 <code>m0</code>和<code>p0</code>，首先会创建逻辑 CPU 核数个 P，存储在 <code>sched</code> 的空闲链表（<code>pidle</code>），也就是 P 的初始化</li>
<li>新建任务 <code>g</code> 到 <code>p0</code> 本地队列，<code>m0</code> 的 <code>g0</code> 会创建一个指向 <code>runtime.main()</code> 的 <code>g</code>，并放到 <code>p0</code> 的本地队列。</li>
</ul>
<p><code>runtime.main()</code>：启动 <code>sysmon</code> 线程；启动 <code>GC</code> 协程；执行 <code>init</code>，即代码中的各种 <code>init</code> 函数；执行 <code>main.main</code> 函数。</p>
<h2 id="OS-thread-创建"><a href="#OS-thread-创建" class="headerlink" title="OS thread 创建"></a>OS thread 创建</h2><p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212171451806.png" alt="image-20231212171451806"></p>
<p>准备运行新 <code>goroutine</code> 将唤醒 P 以更好的分发工作。这个 P 将创建或者唤醒一个与之关联的 M 绑定到一个 OS thread。</p>
<p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212171625449.png" alt="image-20231212171625449"></p>
<p><code>go func()</code> 中出发 <code>Wakeup</code> 唤醒机制：</p>
<p>有空闲的 P 而没有在 <code>spining</code>（自旋） 状态的 M 时候，需要去唤醒一个空闲（睡眠）的 M 或者新建一个。</p>
<h3 id="M0-main"><a href="#M0-main" class="headerlink" title="M0 main"></a>M0 main</h3><p>程序启动后，Go 已经将主线程和 M 绑定 （<code>rt0_go</code>）。</p>
<blockquote>
<p> 当 <code>goroutine</code> 创建完后，它是放在当前 P 的 <code>local queue</code> 还是 <code>global queue</code>？</p>
</blockquote>
<p><code>runtime.runqput</code> 这个函数会尝试把 <code>newg</code> 放到本地队列上，如果本地队列满了，它会将本地队列的<strong>前半部分和 <code>newg</code></strong> 迁移到全局队列中。剩下的事情就等待 M 自己去拿任务了。</p>
<p>当线程首次创建时，会执行一个特殊的 G，即 <code>g0</code>，它负责管理和调度 G。<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMTM3NDU5OTQ=">Go：g0，特殊的 Goroutine<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231212171839676.png" alt="image-20231212171839676"></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><span class="exturl" data-url="aHR0cHM6Ly93ZWJjYWNoZS5nb29nbGV1c2VyY29udGVudC5jb20vc2VhcmNoP3E9Y2FjaGU6aHR0cHM6Ly9tZWRpdW0uY29tL2Etam91cm5leS13aXRoLWdvL2dvLWdvcm91dGluZS1vcy10aHJlYWQtYW5kLWNwdS1tYW5hZ2VtZW50LTJmNWE1ZWFmNTE4YSZzdHJpcD0wJnZ3c3JjPTEmcmVmZXJlcj1tZWRpdW0tcGFyc2Vy">Go: Goroutine, OS Thread and CPU Management<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5zaXplb2Z2b2lkLm5ldC9nb3JvdXRpbmUtdW5kZXItdGhlLWhvb2Qv">goroutine背后的系统知识<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yYWt5bGwub3JnL3NjaGVkdWxlci8=">Go’s work-stealing scheduler<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNDg2OTczNzE=">Go的核心 goroutine sysmon<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82ODI5OTM0OA==">深入Golang调度器之GMP模型<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NTA0MjcxL2FydGljbGUvZGV0YWlscy84MTAwMDIxNw==">Golang Goroutine的调度机制<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FCb19aaGFuZy9hcnRpY2xlL2RldGFpbHMvOTAxMDY5MTA=">Go语言调度器之调度main goroutine（14）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82NjA5MDQyMA==">Go语言调度器之盗取goroutine(17)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNzA1Njk0NA==">Go调度详解<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc3Vuc2t5MzAzL3AvMTEwNTg3MjguaHRtbA==">Golang&#x2F;Go goroutine调度器原理&#x2F;实现【原】<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vemt3ZWIvcC83ODE1NjAwLmh0bWw=">Golang源码探索(二) 协程的实现原理<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly95aXpoaS5yZW4vMjAxOS8wNi8wMy9nb3NjaGVkdWxlci8=">golang scheduler<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tb3JzbWFjaGluZS5kay9uZXRwb2xsZXI=">The Go netpoller<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZXJjdG8uY29tL2EvMTE2NDg2Lmh0bWw=">Go: g0, 特殊的goroutine<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kYjBhZWE0ZDYwZWQ=">Go 语言调度（一）: 系统调度<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lZjY1NDQxM2YyYzE=">Go 语言调度（三）: 并发<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNDg2OTczNzE=">Go的核心 goroutine sysmon<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93ZWJjYWNoZS5nb29nbGV1c2VyY29udGVudC5jb20vc2VhcmNoP3E9Y2FjaGU6aHR0cHM6Ly9tZWRpdW0uY29tL2Etam91cm5leS13aXRoLWdvL2dvLWhvdy1kb2VzLWEtZ29yb3V0aW5lLXN0YXJ0LWFuZC1leGl0LTJiMzMwMzg5MDQ1MiZzdHJpcD0wJnZ3c3JjPTEmcmVmZXJlcj1tZWRpdW0tcGFyc2Vy">Go: How Does a Goroutine Start and Exit?<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93ZWJjYWNoZS5nb29nbGV1c2VyY29udGVudC5jb20vc2VhcmNoP3E9Y2FjaGU6aHR0cHM6Ly9tZWRpdW0uY29tL2Etam91cm5leS13aXRoLWdvL2dvLWcwLXNwZWNpYWwtZ29yb3V0aW5lLThjNzc4YzY3MDRkOCZzdHJpcD0wJnZ3c3JjPTEmcmVmZXJlcj1tZWRpdW0tcGFyc2Vy">Go: g0, Special Goroutine<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93ZWJjYWNoZS5nb29nbGV1c2VyY29udGVudC5jb20vc2VhcmNoP3E9Y2FjaGU6aHR0cHM6Ly9tZWRpdW0uY29tL2Etam91cm5leS13aXRoLWdvL2dvLWhvdy1kb2VzLWdvLXJlY3ljbGUtZ29yb3V0aW5lcy1mMDQ3YTc5YWIzNTImc3RyaXA9MCZ2d3NyYz0xJnJlZmVyZXI9bWVkaXVtLXBhcnNlcg==">Go: How Does Go Recycle Goroutines?<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93ZWJjYWNoZS5nb29nbGV1c2VyY29udGVudC5jb20vc2VhcmNoP3E9Y2FjaGU6aHR0cHM6Ly9tZWRpdW0uY29tL2Etam91cm5leS13aXRoLWdvL2dvLXdoYXQtZG9lcy1hLWdvcm91dGluZS1zd2l0Y2gtYWN0dWFsbHktaW52b2x2ZS0zOTRjMjAyZGRkYjcmc3RyaXA9MCZ2d3NyYz0xJnJlZmVyZXI9bWVkaXVtLXBhcnNlcg==">Go: What Does a Goroutine Switch Actually Involve?<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly94aWFvcnVpLmNjL2FyY2hpdmVzLzY1MzU=">golang 基于信号的抢占式调度的设计实现原理<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly94aWFvcnVpLmNjL2FyY2hpdmVzL2NhdGVnb3J5L2dvbGFuZw==">Go runtime 源码分析<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xbHlQSWJtc1liWG5wTmo1N2EyNjFoZ09ZVnBOUmNneWR1clZRSXlaT3pfby9wdWI=">Go 1.2 Runtime Symbol Information<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93ZWJjYWNoZS5nb29nbGV1c2VyY29udGVudC5jb20vc2VhcmNoP3E9Y2FjaGU6aHR0cHM6Ly9tZWRpdW0uY29tL2Etam91cm5leS13aXRoLWdvL2dvLWFzeW5jaHJvbm91cy1wcmVlbXB0aW9uLWI1MTk0MjI3MzcxYyZzdHJpcD0wJnZ3c3JjPTEmcmVmZXJlcj1tZWRpdW0tcGFyc2Vy">Go: Asynchronous Preemption<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93ZWJjYWNoZS5nb29nbGV1c2VyY29udGVudC5jb20vc2VhcmNoP3E9Y2FjaGU6aHR0cHM6Ly9tZWRpdW0uY29tL2Etam91cm5leS13aXRoLWdvL2dvLWdvcm91dGluZS1hbmQtcHJlZW1wdGlvbi1kNmJjMmFhMmY0Yjcmc3RyaXA9MCZ2d3NyYz0xJnJlZmVyZXI9bWVkaXVtLXBhcnNlcg==">Go: Goroutine and Preemption<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2Etam91cm5leS13aXRoLWdvL2dvLWdzaWduYWwtbWFzdGVyLW9mLXNpZ25hbHMtMzI5ZjdmZjM5Mzkx">Go: gsignal, Master of Signals<i class="fa fa-external-link-alt"></i></span></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Reference/" rel="tag"># 学习笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/b09f.html" rel="prev" title="多活">
                  <i class="fa fa-angle-left"></i> 多活
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/ab88.html" rel="next" title="Go runtime之内存分配">
                  Go runtime之内存分配 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Mitaka xu</span>
  </div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"TVx6Wkfs8VJGOwYPurtjWY2e-9Nh9j0Va","app_key":"c7VvaRnyF8r3DUIPq1x2KJ7Q","server_url":"https://tvx6wkfs.lc-cn-e1-shared.com","security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://www.xiaoyeshiyu.com/post/c06b.html"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"xiaoyeshiyu","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
