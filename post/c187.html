<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="S_5aoPFd3QQihrUOLiKdVR0Mj4fj6n6qJojwyjj9cAY">
  <meta name="msvalidate.01" content="9032A67FCF787F07CB04374E59E518A9">
  <meta name="baidu-site-verification" content="code-Onlniop0d6">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.xiaoyeshiyu.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Redis学习笔记之实用篇包含Redis的底层原理以及一些使用场景和解决方案，是基础篇的补充篇。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis学习笔记之实用篇">
<meta property="og:url" content="https://www.xiaoyeshiyu.com/post/c187.html">
<meta property="og:site_name" content="小夜时雨">
<meta property="og:description" content="Redis学习笔记之实用篇包含Redis的底层原理以及一些使用场景和解决方案，是基础篇的补充篇。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221206233251024.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207153120913.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207153255458.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207153551158.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207154759309.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207154933719.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207155218114.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207155303812.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208144829613.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208211113618.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208211958051.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208220452732.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208220525758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208220539425.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208225446907.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208225539936.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208225559504.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208222604830.png">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221208222623463.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230036374.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230228077.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230301494.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230358306.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230526270.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230620807.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209095847218.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209103834488.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209104717967.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209112523056.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20220618182945035.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209115226190.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209115351780.png">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221209123451393.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209143255162.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209144539245.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209144619653.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209145524270.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210201059649.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210201749136.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210201815252.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210203200225.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210203828934.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210204124936.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210204444011.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210204855343.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210210608387.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210211253081.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210211744633.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210214947102.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210221442752.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210223240610.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210223454987.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210223732777.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210224114125.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210224832286.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210224908284.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225515989.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225539093.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225853658.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225730118.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225616051.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225655449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210230629790.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210231512045.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210235351250.png">
<meta property="article:published_time" content="2022-12-05T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-08T01:36:10.301Z">
<meta property="article:author" content="Mitaka xu">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221206233251024.png">


<link rel="canonical" href="https://www.xiaoyeshiyu.com/post/c187.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.xiaoyeshiyu.com/post/c187.html","path":"post/c187.html","title":"Redis学习笔记之实用篇"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis学习笔记之实用篇 | 小夜时雨</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MBVJ11TVHH"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBVJ11TVHH","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?573725610fbc6ff9b42032bd13615370"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="小夜时雨" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小夜时雨</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">君子敬其在己者，而不慕其在天者，是以日进也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A1%A5%E5%85%85"><span class="nav-number">1.</span> <span class="nav-text">基础使用的补充</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#key%E7%9A%84%E5%88%86%E7%BA%A7%E5%AD%98%E5%82%A8"><span class="nav-number">1.1.</span> <span class="nav-text">key的分级存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BigKey"><span class="nav-number">1.2.</span> <span class="nav-text">BigKey</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BigKey%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="nav-number">1.2.1.</span> <span class="nav-text">BigKey的危害</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4BigKey"><span class="nav-number">1.2.2.</span> <span class="nav-text">删除BigKey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%81%B0%E5%BD%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">恰当的数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">集群模式下的批处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96"><span class="nav-number">1.4.</span> <span class="nav-text">配置优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98"><span class="nav-number">1.5.</span> <span class="nav-text">Redis作为缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.6.</span> <span class="nav-text">慢查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE"><span class="nav-number">1.7.</span> <span class="nav-text">内存配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E8%BF%98%E6%98%AF%E9%9B%86%E7%BE%A4"><span class="nav-number">1.8.</span> <span class="nav-text">主从还是集群</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E8%A1%A5%E5%85%85"><span class="nav-number">2.</span> <span class="nav-text">使用场景的补充</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">2.1.</span> <span class="nav-text">缓存更新策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%AF%B9%E6%AF%94%E5%88%A0%E9%99%A4"><span class="nav-number">2.1.1.</span> <span class="nav-text">更新对比删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">2.1.2.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">2.1.3.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">2.1.4.</span> <span class="nav-text">缓存击穿</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5"><span class="nav-number">2.2.</span> <span class="nav-text">全局ID生成策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E2%80%98"><span class="nav-number">2.3.</span> <span class="nav-text">对比分布式锁的实现方式‘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81"><span class="nav-number">2.4.</span> <span class="nav-text">关注推送</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">2.5.</span> <span class="nav-text">多级缓存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS"><span class="nav-number">3.1.</span> <span class="nav-text">动态字符串SDS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SDS%E6%89%A9%E5%AE%B9"><span class="nav-number">3.1.1.</span> <span class="nav-text">SDS扩容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88IntSet"><span class="nav-number">3.2.</span> <span class="nav-text">整数集合IntSet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IntSet%E5%8A%A8%E6%80%81%E5%8D%87%E7%BA%A7"><span class="nav-number">3.2.1.</span> <span class="nav-text">IntSet动态升级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8Dict"><span class="nav-number">3.3.</span> <span class="nav-text">字典Dict</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dict%E6%89%A9%E5%AE%B9"><span class="nav-number">3.3.1.</span> <span class="nav-text">Dict扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dict%E6%94%B6%E7%BC%A9"><span class="nav-number">3.3.2.</span> <span class="nav-text">Dict收缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dict%E7%9A%84rehash"><span class="nav-number">3.3.3.</span> <span class="nav-text">Dict的rehash</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ZipList"><span class="nav-number">3.4.</span> <span class="nav-text">压缩列表ZipList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Encoding%E7%BC%96%E7%A0%81"><span class="nav-number">3.4.1.</span> <span class="nav-text">Encoding编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZipList%E7%9A%84%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.2.</span> <span class="nav-text">ZipList的连锁更新问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8QuickList"><span class="nav-number">3.5.</span> <span class="nav-text">快速列表QuickList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8SkipList"><span class="nav-number">3.6.</span> <span class="nav-text">跳表SkipList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RedisObject"><span class="nav-number">3.7.</span> <span class="nav-text">RedisObject</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.8.</span> <span class="nav-text">五种数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">3.8.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">3.8.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">3.8.3.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zset"><span class="nav-number">3.8.4.</span> <span class="nav-text">Zset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash"><span class="nav-number">3.8.5.</span> <span class="nav-text">Hash</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">Redis网络模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="nav-number">4.1.</span> <span class="nav-text">用户空间和内核空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">五种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EIO"><span class="nav-number">4.2.1.</span> <span class="nav-text">阻塞IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-number">4.2.2.</span> <span class="nav-text">非阻塞IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">4.2.3.</span> <span class="nav-text">IO多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select"><span class="nav-number">4.2.4.</span> <span class="nav-text">IO多路复用-select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-poll"><span class="nav-number">4.2.5.</span> <span class="nav-text">IO多路复用-poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-epoll"><span class="nav-number">4.2.6.</span> <span class="nav-text">IO多路复用-epoll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">4.2.7.</span> <span class="nav-text">IO多路复用-事件通知机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%9C%A8web%E6%9C%8D%E5%8A%A1%E4%B8%8A%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">4.2.8.</span> <span class="nav-text">IO多路复用在web服务上的例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO"><span class="nav-number">4.2.9.</span> <span class="nav-text">信号驱动IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5IO"><span class="nav-number">4.2.10.</span> <span class="nav-text">异步IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%86%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-number">4.2.11.</span> <span class="nav-text">区分同步和异步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-1"><span class="nav-number">4.3.</span> <span class="nav-text">Redis网络模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.</span> <span class="nav-text">Redis通信协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RESP%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.1.</span> <span class="nav-text">RESP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.1.</span> <span class="nav-text">数据类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5"><span class="nav-number">6.</span> <span class="nav-text">Redis内存策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%BF%87%E6%9C%9F"><span class="nav-number">6.1.</span> <span class="nav-text">内存过期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="nav-number">6.1.1.</span> <span class="nav-text">惰性删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%A8%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="nav-number">6.1.2.</span> <span class="nav-text">周期删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">6.2.</span> <span class="nav-text">淘汰策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%EF%BC%9A"><span class="nav-number">7.</span> <span class="nav-text">推荐阅读：</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mitaka xu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mitaka xu</p>
  <div class="site-description" itemprop="description">Golang开发博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaoyeshiyu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/c187.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis学习笔记之实用篇 | 小夜时雨">
      <meta itemprop="description" content="Redis学习笔记之实用篇包含Redis的底层原理以及一些使用场景和解决方案，是基础篇的补充篇。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis学习笔记之实用篇
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-06 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-06T00:00:00+08:00">2022-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-08 09:36:10" itemprop="dateModified" datetime="2023-09-08T09:36:10+08:00">2023-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span id="/post/c187.html" class="post-meta-item leancloud_visitors" data-flag-title="Redis学习笔记之实用篇" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/post/c187.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="post/c187.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

            <div class="post-description">Redis学习笔记之实用篇包含Redis的底层原理以及一些使用场景和解决方案，是基础篇的补充篇。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本篇是Redis<a href="https://www.xiaoyeshiyu.com/2022/06/18/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/">学习笔记基础篇</a>的补充，主要补充了底层原理和一些常见的使用场景。</p>
<h1 id="基础使用的补充"><a href="#基础使用的补充" class="headerlink" title="基础使用的补充"></a>基础使用的补充</h1><h2 id="key的分级存储"><a href="#key的分级存储" class="headerlink" title="key的分级存储"></a><code>key</code>的分级存储</h2><p>Redis在使用的过程中，为了更好的体验Key的意义，一般会使用Key作为分级存储，例如<code>mitaka</code>下有<code>user</code>组和<code>age</code>组，存储数据ID为1、2的时候，将<code>key</code>以冒号的形式隔开</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET mitaka:user:1 xu</span><br><span class="line">127.0.0.1:6379&gt; SET mitaka:user:2 xiaoye</span><br><span class="line">127.0.0.1:6379&gt; SET mitaka:age:1 18</span><br><span class="line">127.0.0.1:6379&gt; SET mitaka:age:2 28</span><br><span class="line">127.0.0.1:6379&gt; KEYS *</span><br><span class="line">1) &quot;mitaka:age:2&quot;</span><br><span class="line">2) &quot;mitaka:user:1&quot;</span><br><span class="line">3) &quot;mitaka:age:1&quot;</span><br><span class="line">4) &quot;mitaka:user:2&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>基本格式：[业务名称]:[数据名]:[id]，这样的话，可读性强，而且避免<code>key</code>冲突，方便管理；例如保存登录用户的信息<code>login:user:10</code></li>
<li>长度不超过44字节，节省内存，key是tring类型，底层编码包含<code>int</code>、<code>embstr</code>和<code>raw</code>三种，<code>embstr</code>在小于<code>44</code>字节使用，采用连续内存空间，占用内存更小</li>
<li>不包含特殊字符</li>
</ul>
<p>下载Redis图形化客户端RDM，官网：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlZGlzSW5zaWdodC9SZWRpc0Rlc2t0b3BNYW5hZ2Vy">https://github.com/RedisInsight/RedisDesktopManager<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZXNwLmFwcC8=">https://resp.app/<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZWRpcy5jb20vcmVkaXMtZW50ZXJwcmlzZS9yZWRpcy1pbnNpZ2h0LyNpbnNpZ2h0LWZvcm0=">https://redis.com/redis-enterprise/redis-insight/#insight-form<i class="fa fa-external-link-alt"></i></span></p>
<p><code>mac os m2</code>版本下载地址：<span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5yZWRpc2luc2lnaHQucmVkaXMuY29tL2xhdGVzdC9SZWRpc0luc2lnaHQtdjItbWFjLWFybTY0LmRtZw==">https://download.redisinsight.redis.com/latest/RedisInsight-v2-mac-arm64.dmg<i class="fa fa-external-link-alt"></i></span></p>
<p>在<code>RDM</code>中可以看到类似目录层级结构</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221206233251024.png" alt="image-20221206233251024" style="zoom:50%;" />

<h2 id="BigKey"><a href="#BigKey" class="headerlink" title="BigKey"></a>BigKey</h2><p><code>BigKey</code>通常以<code>Key</code>的大小和Key中成员的数量来综合判定：</p>
<ul>
<li><code>key</code>本身的数据量过大：例如，一个<code>string</code>类型的<code>key</code>，值为5MB</li>
<li><code>key</code>中的成员过多：例如，一个zset类型的<code>key</code>，成员数量为10000个</li>
<li><code>key</code>中成员的数量过大：例如，一个<code>hash</code>类型的<code>key</code>，成员虽然只有1000个，但是<code>Value</code>总大小为100MB</li>
</ul>
<p>推荐值：</p>
<ul>
<li>单个<code>key</code>的<code>value</code>小于10KB</li>
<li>对于集合类型的key，建议元素数量小于1000</li>
</ul>
<p>获取<code>key</code>占用的内存大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MEMORY USAGE a</span><br><span class="line">(integer) 48							// a占用48字节</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="BigKey的危害"><a href="#BigKey的危害" class="headerlink" title="BigKey的危害"></a><code>BigKey</code>的危害</h3><ul>
<li>网络阻塞：对<code>BigKey</code>请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis或者物理机变慢</li>
<li>数据倾斜：<code>BigKey</code>所在实例的内存使用率会超过其他实例，无法使数据分片的内存资源达到均衡</li>
<li>Redis阻塞：对元素较多的hash、list、zset等做运算时，会有更多的耗时，使主线程被阻塞</li>
<li>CPU压力：对<code>BigKey</code>的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其他应用</li>
</ul>
<p>找到BigKey的方法：</p>
<ul>
<li><p><code>--big-keys</code>参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 --big-keys</span><br><span class="line"></span><br><span class="line">Unrecognized option or bad number of args for: &#x27;--big-keys&#x27;</span><br><span class="line">➜  ~ redis-cli -h 127.0.0.1 -p 6379 --bigkeys</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Scanning the entire keyspace to find biggest keys as well as</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">average sizes per key <span class="built_in">type</span>.  You can use -i 0.1 to <span class="built_in">sleep</span> 0.1 sec</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">per 100 SCAN commands (not usually needed).</span></span><br><span class="line"></span><br><span class="line">[00.00%] Biggest string found so far &#x27;mitaka:age:2&#x27; with 2 bytes</span><br><span class="line">[00.00%] Biggest stream found so far &#x27;stream1&#x27; with 44 entries</span><br><span class="line">[00.00%] Biggest string found so far &#x27;mitaka:user:2&#x27; with 6 bytes</span><br><span class="line"></span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 9 keys in the keyspace!</span><br><span class="line">Total key length in bytes is 62 (avg len 6.89)</span><br><span class="line"></span><br><span class="line">Biggest string found &#x27;mitaka:user:2&#x27; has 6 bytes		//	这个类型占用最大的内存</span><br><span class="line">Biggest stream found &#x27;stream1&#x27; has 44 entries</span><br><span class="line"></span><br><span class="line">0 lists with 0 items (00.00% of keys, avg size 0.00)</span><br><span class="line">0 hashs with 0 fields (00.00% of keys, avg size 0.00)</span><br><span class="line">8 strings with 16 bytes (88.89% of keys, avg size 2.00)</span><br><span class="line">1 streams with 44 entries (11.11% of keys, avg size 44.00)</span><br><span class="line">0 sets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">0 zsets with 0 members (00.00% of keys, avg size 0.00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>SCAN</code>扫描，然后逐个判断</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCAN 0 	// 0 是角标</span><br><span class="line">1) <span class="string">&quot;0&quot;</span>		// 这里是下次扫描的角标，0代表扫描完了</span><br><span class="line">2) 1) <span class="string">&quot;mitaka:age:2&quot;</span></span><br><span class="line">   2) <span class="string">&quot;mitaka:user:1&quot;</span></span><br><span class="line">   3) <span class="string">&quot;c&quot;</span></span><br><span class="line">   4) <span class="string">&quot;b1&quot;</span></span><br><span class="line">   5) <span class="string">&quot;stream1&quot;</span></span><br><span class="line">   6) <span class="string">&quot;mitaka:user:2&quot;</span></span><br><span class="line">   7) <span class="string">&quot;a&quot;</span></span><br><span class="line">   8) <span class="string">&quot;mitaka:age:1&quot;</span></span><br><span class="line">   9) <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第三方工具，<a target="_blank" rel="noopener" href="https://github.com/sripathikrishnan/redis-rdb-tools"><code>Redis-Rdb-Tools</code></a>分析<code>RDB</code>快照文件，全面分析内存使用情况，或者封装<code>SCAN</code>命令和一系列的判断逻辑，或者使用<code>LUA</code>脚本</p>
</li>
<li><p>网络监控，监控进出Redis的网络数据，超出预警值时主动告警</p>
</li>
</ul>
<h3 id="删除BigKey"><a href="#删除BigKey" class="headerlink" title="删除BigKey"></a>删除<code>BigKey</code></h3><p><code>BigKey</code>占用内存较多，删除时也会消耗很长时间，导致Redis主线程阻塞，引发一系列问题。</p>
<ul>
<li><p>Redis 3.0及以下版本：如果是集合类型，则便利<code>BigKey</code>的元素，先逐个删除子元素，最后删除<code>BigKey</code></p>
</li>
<li><p>Redis 4.0以后：提供了异步删除的命令，<code>unlink</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; UNLINK stream1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; KEYS stream*</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="恰当的数据类型"><a href="#恰当的数据类型" class="headerlink" title="恰当的数据类型"></a>恰当的数据类型</h3><p>使用恰当的数据类型将<code>BigKey</code>转换成小<code>key</code>是一种更加推荐解决<code>BigKey</code>的方法</p>
<p>一个有100万个<code>key</code>的<code>hash</code>，是一个<code>BigKey</code></p>
<p>方案1：通过<code>json</code>序列化后存储到<code>string</code>中；这种方式，会占用更大的内存，数据耦合，而且还是一个<code>BigKey</code></p>
<p>方案2：打散存储到<code>string</code>中；这种也会占用更大内存，而且没法做到统一控制</p>
<p>方案3：将大划小，通过<code>id/100</code>作为<code>key</code>，分为1万个<code>hash</code>，每个<code>hash</code>中只有<code>100</code>个键值对。</p>
<h2 id="集群模式下的批处理"><a href="#集群模式下的批处理" class="headerlink" title="集群模式下的批处理"></a>集群模式下的批处理</h2><p>批量执行命令可以使用<code>pipeline</code>，节省<code>client</code>到<code>server</code>之间的网络时间。但是加集群模式下，由于<code>key</code>会进行<code>hash</code>然后取模，可能会放到不同的<code>slot</code>中。而批处理是一个网络连接，如果使用不同的<code>slot</code>，则会使用多个网络连接。</p>
<p>在集群模式下，批处理命令的多个<code>key</code>比如落在一个<code>slot</code>中，否则会执行失败。</p>
<p>解决方案</p>
<ul>
<li><p>串行命令：</p>
<p>实现思路：<code>for</code>循环遍历，依次执行每个命令</p>
<p>这种方案其实不是批处理，还是单次处理</p>
</li>
<li><p>串行<code>slot</code>：</p>
<p>实现思路：客户端计算每个<code>key</code>的<code>slot</code>，然后将一致的<code>slot</code>分为一组，使用<code>pipeline</code>串行处理</p>
<p>这种方案逻辑处理会有些复杂，而且<code>slot</code>越多，耗时越久。</p>
</li>
<li><p>并行<code>slot</code>：</p>
<p>实现思路：在串行<code>slot</code>的基础上，改为并行处理，</p>
<p>这种方案实现更加复杂</p>
</li>
<li><p><code>hash_tag</code></p>
<p>实现思路：将所有<code>key</code>设置相同的<code>hash_tag</code>，则所有<code>key</code>的<code>slot</code>一定相同</p>
<p>这种方案容易出现数据倾斜，但是耗时短，实现简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MSET &#123;a&#125;name xu &#123;a&#125;age 18</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li>
</ul>
<p>相比而言，推荐使用并行<code>slot</code></p>
<h2 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h2><p>持久化配置优化：</p>
<ul>
<li>用来做缓存的Redis实例，尽量不要开启持久化功能</li>
<li>建议关闭RDB，只使用AOF持久化</li>
<li>利用脚本定期在Slave节点做RDB，实现数据备份</li>
<li>设置合理的<code>rewrite</code>阈值，避免频繁<code>bgrewrite</code></li>
<li>配置<code>no-appendfsync-on-rewrite=yes</code>，禁止在<code>rewrite</code>期间做AOF，避免因AOF引起的阻塞</li>
</ul>
<p>部署相关建议：</p>
<ul>
<li>物理机需要预留内存，用于<code>fork</code>和<code>rewrite</code>的线程</li>
<li>单个实例内存不建议太大，例如4GB或者8GB，可以加快<code>fork</code>的速度，减少主从同步、数据迁移压力</li>
<li>不要与CPU密集型应用部署在一起</li>
<li>不要与高硬盘负载应用一起部署，例如数据库、消息队列</li>
</ul>
<h2 id="Redis作为缓存"><a href="#Redis作为缓存" class="headerlink" title="Redis作为缓存"></a>Redis作为缓存</h2><p>场景例如用于存储<code>session</code>，例如用户登录的<code>token</code>，需要认证的接口可通过客户传过来的<code>token</code>即可完成验证，不需要再次使用用户名密码通过查询数据库验证。</p>
<p>相对于存储在本地进程，使用Redis可以实现分布式服务认证。</p>
<p>每次使用token成功认证后，刷新<code>token</code>过期时间，以延长<code>token</code>过期时间。</p>
<p>这里介绍另外一种缓存，记录一些常用的数据。例如某些文件目录下的信息，缓存高频目录的信息，可以减少数据库的压力。</p>
<p>服务端配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Required</span></span><br><span class="line"><span class="comment">##########</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set a memory usage limit to the specified amount of bytes.</span></span><br><span class="line"><span class="comment"># When the memory limit is reached Redis will try to remove keys</span></span><br><span class="line"><span class="comment"># according to the eviction policy selected (see maxmemory-policy).</span></span><br><span class="line">maxmemory 100mb</span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional</span></span><br><span class="line"><span class="comment">##########</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Evict any key using approximated LFU when maxmemory is reached.</span></span><br><span class="line">maxmemory-policy allkeys-lfu</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable active memory defragmentation.</span></span><br><span class="line">activedefrag <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Don&#x27;t save data on the disk because we can afford to lose cached data.</span></span><br><span class="line">save <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用缓存</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr: <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// redis 客户端配置</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	mycache := cache.New(&amp;cache.Options&#123;</span><br><span class="line">		Redis:      rdb,                                <span class="comment">// 缓存配置</span></span><br><span class="line">		LocalCache: cache.NewTinyLFU(<span class="number">100</span>, time.Minute), <span class="comment">// 使用本地缓存，缓存使用lfu算法，本地最大存储100个，保存1分钟</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	obj := <span class="built_in">new</span>(Object)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123; <span class="comment">//存放100个</span></span><br><span class="line">		err := mycache.Once(&amp;cache.Item&#123; <span class="comment">// set之前会get一下，如果key存在，则不存储新的value</span></span><br><span class="line">			Key:   <span class="string">&quot;mykey&quot;</span> + strconv.Itoa(i),</span><br><span class="line">			Value: obj, <span class="comment">// destination</span></span><br><span class="line">			Do: <span class="function"><span class="keyword">func</span><span class="params">(*cache.Item)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123; <span class="comment">// 将Object作为Value存储</span></span><br><span class="line">				<span class="keyword">return</span> &amp;Object&#123;</span><br><span class="line">					Str: <span class="string">&quot;mystring123123&quot;</span>,</span><br><span class="line">					Num: <span class="number">421</span>,</span><br><span class="line">				&#125;, <span class="literal">nil</span></span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p>在Redis中，执行时耗时超过某个阈值的命令，称为慢查询。也就是无论读还是写，超时了就是慢查询。</p>
<p>慢查询的阈值可以通过配置指定：</p>
<ul>
<li><code>slowlog-log-slower-than</code>：慢查询阈值，单位ms，默认10000，也就是10s，建议1000</li>
</ul>
<p>超过阈值的的操作会被记录到慢查询日志中，日志长度有上限</p>
<ul>
<li><code>slowlog-max-len</code>：慢查询日志（本质是一个队列）长度，默认128，建议1000</li>
</ul>
<p>查看慢查询</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLOWLOG get 1				// 获取1个慢查询</span><br><span class="line">1) 1) (<span class="built_in">integer</span>) 3										// 日志编号</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1670426153					// 加入日志是的时间戳</span><br><span class="line">   3) (<span class="built_in">integer</span>) 13415								// 慢查询耗时</span><br><span class="line">   4) 1) <span class="string">&quot;info&quot;</span>											// 慢查询命令</span><br><span class="line">   5) <span class="string">&quot;172.17.0.1:62882&quot;</span>						// 客户端地址</span><br><span class="line">   6) <span class="string">&quot;redisinsight-common-c22f7437&quot;</span>	// 客户端名称</span><br><span class="line">127.0.0.1:6379&gt; SLOWLOG len					// 慢查询当前长度</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; SLOWLOG reset				// 清理慢查询队列</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h2 id="内存配置"><a href="#内存配置" class="headerlink" title="内存配置"></a>内存配置</h2><p>当Redis内存不足时，可能导致<code>key</code>频繁被删除、响应时间变长，QPS不稳定等问题。当内存使用率达到90%以上时就需要警惕，并快速定位到内存占用的原因。</p>
<p>内存占用有这几种</p>
<ul>
<li>数据内存：是Redis主要部分，存储Redis的键值信息，主要问题是<code>BigKey</code>的问题，内存碎片问题</li>
<li>进程内存：Redis主进程本身运行肯定需要内存，例如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略</li>
<li>缓冲区内存：一般包括客户端缓冲区、AOF缓冲区（AOF刷盘前的缓存区域）、复制缓冲区（用于主从复制，如果过小，会导致全量复制）等。客户端缓冲区又包括输入输出缓冲区两种。这部分内存占用波动较大，不当使用<code>BigKey</code>，可能导致内存溢出。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INFO memory				// 查看内存占用信息</span><br><span class="line"># Memory</span><br><span class="line">used_memory:2060856								// 内存占用总量</span><br><span class="line">used_memory_human:1.97M</span><br><span class="line">used_memory_rss:9383936</span><br><span class="line">used_memory_rss_human:8.95M</span><br><span class="line">used_memory_peak:2179296</span><br><span class="line">used_memory_peak_human:2.08M</span><br><span class="line">used_memory_peak_perc:94.57%</span><br><span class="line">used_memory_overhead:925920</span><br><span class="line">used_memory_startup:895680</span><br><span class="line">used_memory_dataset:1134936</span><br><span class="line">used_memory_dataset_perc:97.40%</span><br><span class="line">allocator_allocated:2252760</span><br><span class="line">allocator_active:8912896</span><br><span class="line">allocator_resident:10420224</span><br><span class="line">total_system_memory:8232894464</span><br><span class="line">total_system_memory_human:7.67G</span><br><span class="line">used_memory_lua:31744</span><br><span class="line">used_memory_vm_eval:31744</span><br><span class="line">used_memory_lua_human:31.00K</span><br><span class="line">used_memory_scripts_eval:0</span><br><span class="line">number_of_cached_scripts:0</span><br><span class="line">number_of_functions:0</span><br><span class="line">number_of_libraries:0</span><br><span class="line">used_memory_vm_functions:32768</span><br><span class="line">used_memory_vm_total:64512</span><br><span class="line">used_memory_vm_total_human:63.00K</span><br><span class="line">used_memory_functions:184</span><br><span class="line">used_memory_scripts:184</span><br><span class="line">used_memory_scripts_human:184B</span><br><span class="line">maxmemory:0</span><br><span class="line">maxmemory_human:0B</span><br><span class="line">maxmemory_policy:noeviction</span><br><span class="line">allocator_frag_ratio:3.96</span><br><span class="line">allocator_frag_bytes:6660136</span><br><span class="line">allocator_rss_ratio:1.17</span><br><span class="line">allocator_rss_bytes:1507328</span><br><span class="line">rss_overhead_ratio:0.90</span><br><span class="line">rss_overhead_bytes:-1036288</span><br><span class="line">mem_fragmentation_ratio:4.60</span><br><span class="line">mem_fragmentation_bytes:7342728</span><br><span class="line">mem_not_counted_for_evict:0</span><br><span class="line">mem_replication_backlog:0</span><br><span class="line">mem_total_replication_buffers:0</span><br><span class="line">mem_clients_slaves:0</span><br><span class="line">mem_clients_normal:29496</span><br><span class="line">mem_cluster_links:0</span><br><span class="line">mem_aof_buffer:0</span><br><span class="line">mem_allocator:jemalloc-5.2.1</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br><span class="line">lazyfreed_objects:0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MEMORY DOCTOR				// 内存检查医生</span><br><span class="line">Hi Sam, this instance is empty or is using very little memory, my issues detector can&#x27;t be used in these conditions. Please, leave for your mission on Earth and fill it with some data. The new Sam and I will be back to our programming as soon as I finished rebooting.</span><br><span class="line">127.0.0.1:6379&gt; MEMORY MALLOC-STATS	// 内存分配状态，Redis使用jemalloc分配内存</span><br><span class="line">___ Begin jemalloc statistics ___</span><br><span class="line">Version: &quot;5.2.1-0-g0&quot;</span><br><span class="line">... 省略部分信息</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MEMORY STATS</span><br><span class="line">&#x27; 1) &quot;peak.allocated&quot;						// Redis启动后消耗内存的峰值</span><br><span class="line"> 2) (integer) 2179296</span><br><span class="line"> 3) &quot;total.allocated&quot;						// 分配器分配的总字节数，也就是当前的总内存使用量</span><br><span class="line"> 4) (integer) 2110112</span><br><span class="line"> 5) &quot;startup.allocated&quot;					// 启动时消耗的初始内存量</span><br><span class="line"> 6) (integer) 895680</span><br><span class="line"> 7) &quot;replication.backlog&quot;				// 复制积压缓冲区的大小</span><br><span class="line"> 8) (integer) 0</span><br><span class="line"> 9) &quot;clients.slaves&quot;						// 主从复制中所有从节点的读写缓冲区大小</span><br><span class="line">10) (integer) 0</span><br><span class="line">11) &quot;clients.normal&quot;						// 除从节点外，所有其他客户端的读写缓冲区大小</span><br><span class="line">12) (integer) 29496</span><br><span class="line">13) &quot;cluster.links&quot;</span><br><span class="line">14) (integer) 0	</span><br><span class="line">15) &quot;aof.buffer&quot;								// AOF持久化使用的缓存和AOF重写时产生的缓存</span><br><span class="line">16) (integer) 0</span><br><span class="line">17) &quot;lua.caches&quot;</span><br><span class="line">18) (integer) 0</span><br><span class="line">19) &quot;functions.caches&quot;</span><br><span class="line">20) (integer) 184</span><br><span class="line">21) &quot;db.0&quot;												// 数据库0的信息</span><br><span class="line">22) 1) &quot;overhead.hashtable.main&quot;										// 数据库的hash链表开销内存综合，即元数据内存</span><br><span class="line">    2) (integer) 528</span><br><span class="line">    3) &quot;overhead.hashtable.expires&quot;									// 用于存储key过期时间所消耗的内存</span><br><span class="line">    4) (integer) 32</span><br><span class="line">    5) &quot;overhead.hashtable.slot-to-keys&quot;</span><br><span class="line">    6) (integer) 0</span><br><span class="line">23) &quot;overhead.total&quot;						// 等于 startup.allocated + replication.backlog + clients.slaves + clients.normal + aof.buffer + db.x</span><br><span class="line">24) (integer) 925920</span><br><span class="line">25) &quot;keys.count&quot;								// 当前key总数</span><br><span class="line">26) (integer) 10</span><br><span class="line">27) &quot;keys.bytes-per-key&quot;				// 每个key的平均大小，（total.allocated - startup.allocated）/ keys.count</span><br><span class="line">28) (integer) 121443</span><br><span class="line">29) &quot;dataset.bytes&quot;</span><br><span class="line">30) (integer) 1184192</span><br><span class="line">31) &quot;dataset.percentage&quot;</span><br><span class="line">32) &quot;97.50994873046875&quot;</span><br><span class="line">33) &quot;peak.percentage&quot;</span><br><span class="line">34) &quot;96.825393676757812&quot;</span><br><span class="line">35) &quot;allocator.allocated&quot;</span><br><span class="line">36) (integer) 2919320</span><br><span class="line">37) &quot;allocator.active&quot;</span><br><span class="line">38) (integer) 10223616</span><br><span class="line">39) &quot;allocator.resident&quot;</span><br><span class="line">40) (integer) 11730944</span><br><span class="line">41) &quot;allocator-fragmentation.ratio&quot;</span><br><span class="line">42) &quot;3.50205397605896&quot;</span><br><span class="line">43) &quot;allocator-fragmentation.bytes&quot;</span><br><span class="line">44) (integer) 7304296</span><br><span class="line">45) &quot;allocator-rss.ratio&quot;</span><br><span class="line">46) &quot;1.1474359035491943&quot;</span><br><span class="line">47) &quot;allocator-rss.bytes&quot;</span><br><span class="line">48) (integer) 1507328</span><br><span class="line">49) &quot;rss-overhead.ratio&quot;</span><br><span class="line">50) &quot;0.81145250797271729&quot;</span><br><span class="line">51) &quot;rss-overhead.bytes&quot;</span><br><span class="line">52) (integer) -2211840</span><br><span class="line">53) &quot;fragmentation&quot;</span><br><span class="line">54) &quot;4.5555543899536133&quot;</span><br><span class="line">55) &quot;fragmentation.bytes&quot;</span><br><span class="line">56) (integer) 7429544</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MEMORY help</span><br><span class="line"> 1) MEMORY &lt;subcommand&gt; [&lt;arg&gt; [value] [opt] ...]. Subcommands are:</span><br><span class="line"> 2) DOCTOR</span><br><span class="line"> 3)     Return memory problems reports.</span><br><span class="line"> 4) MALLOC-STATS</span><br><span class="line"> 5)     Return internal statistics report from the memory allocator.</span><br><span class="line"> 6) PURGE</span><br><span class="line"> 7)     Attempt to purge dirty pages for reclamation by the allocator. 尝试清除脏页以供分配器回收。</span><br><span class="line"> 8) STATS</span><br><span class="line"> 9)     Return information about the memory usage of the server. 返回有关服务器内存使用情况的信息。</span><br><span class="line">10) USAGE &lt;key&gt; [SAMPLES &lt;count&gt;] </span><br><span class="line">11)     Return memory in bytes used by &lt;key&gt; and its value. Nested values are	// 查看某个key占用的内存</span><br><span class="line">12)     sampled up to &lt;count&gt; times (default: 5, 0 means sample all).</span><br><span class="line">13) HELP</span><br><span class="line">14)     Prints this help.</span><br></pre></td></tr></table></figure>

<p>查看客户端信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CLIENT LIST</span><br><span class="line">id=67 addr=172.17.0.1:62398 laddr=172.17.0.2:6379 fd=8 name= age=69848 idle=0 flags=N db=0 sub=0 psub=0 ssub=0 multi=-1 qbuf=26 qbuf-free=20448 argv-mem=10 multi-mem=0 rbs=1024 rbp=0 obl=0 oll=0 omem=0 tot-mem=22298 events=r cmd=client|list user=default redir=-1 resp=2</span><br><span class="line">id=11 addr=172.17.0.1:65126 laddr=172.17.0.2:6379 fd=10 name=redisinsight-auto-discovery age=151134 idle=151134 flags=N db=0 sub=0 psub=0 ssub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 multi-mem=0 rbs=1024 rbp=0 obl=0 oll=0 omem=0 tot-mem=1800 events=r cmd=info user=default redir=-1 resp=2</span><br><span class="line">id=66 addr=172.17.0.1:57476 laddr=172.17.0.2:6379 fd=14 name= age=70274 idle=70254 flags=N db=0 sub=0 psub=0 ssub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 multi-mem=0 rbs=1024 rbp=0 obl=0 oll=0 omem=0 tot-mem=1800 events=r cmd=xreadgroup user=default redir=-1 resp=2</span><br><span class="line">id=14 addr=172.17.0.1:62882 laddr=172.17.0.2:6379 fd=11 name=redisinsight-common-c22f7437 age=151095 idle=1 flags=N db=0 sub=0 psub=0 ssub=0 multi=-1 qbuf=0 qbuf-free=20474 argv-mem=0 multi-mem=0 rbs=2048 rbp=1024 obl=0 oll=0 omem=0 tot-mem=23296 events=r cmd=info user=default redir=-1 resp=2</span><br><span class="line">id=72 addr=172.17.0.1:65270 laddr=172.17.0.2:6379 fd=12 name=redisinsight-common-c22f7437 age=12021 idle=12021 flags=P db=0 sub=0 psub=1 ssub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 multi-mem=0 rbs=1024 rbp=0 obl=0 oll=0 omem=0 tot-mem=1824 events=r cmd=psubscribe user=default redir=-1 resp=2</span><br></pre></td></tr></table></figure>

<h2 id="主从还是集群"><a href="#主从还是集群" class="headerlink" title="主从还是集群"></a>主从还是集群</h2><p>主从模式和集群模式，都可以实现Redis高可用方案，但是在两者选择上，还是有些侧重点。</p>
<p>集群虽然具备高可用特性，也可以实现自动故障恢复，但是使用上有一些限制：</p>
<ul>
<li>集群完整性问题：缺少<code>slot</code>之后，是否能够服务，需要通过配置设置</li>
<li>集群宽带问题：集群节点和节点之间需要较大的网络带宽</li>
<li>数据倾斜问题：分配slot不均或者<code>pipeline</code>时会导致数据倾斜</li>
<li>客户端性能问题</li>
<li>命令的集群兼容性问题</li>
<li>lua和事务问题</li>
</ul>
<p>因此，如果主从能够满足业务需求的情况下，尽量不要搭建<code>Redis</code>集群。</p>
<h1 id="使用场景的补充"><a href="#使用场景的补充" class="headerlink" title="使用场景的补充"></a>使用场景的补充</h1><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>为了解决缓存一致性的问题，更新数据库之后，还需要更新缓存。</p>
<h3 id="更新对比删除"><a href="#更新对比删除" class="headerlink" title="更新对比删除"></a>更新对比删除</h3><p>更新数据库之后，是使用更新缓存还是使用删除缓存？</p>
<ul>
<li><p>更新会出现的两种情况</p>
<ol>
<li>先更新数据库，再更新缓存</li>
</ol>
<p>   <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207153120913.png" alt="image-20221207153120913"></p>
<p>   此时，这种不一致，只能等到下次更新缓存的时候才能解决。</p>
<ol start="2">
<li><p>先更新缓存，再更新数据库</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207153255458.png" alt="image-20221207153255458"></p>
<p>通常情况下，更新缓存再更新数据库是要避免的一种手段</p>
</li>
</ol>
<p>相比而言，使用更新缓存，数据不一致的情况比较多。</p>
</li>
<li><p>删除缓存会出现的两种情况</p>
<ol>
<li><p>先删除缓存，再更新数据库</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207153551158.png" alt="image-20221207153551158"></p>
<p>这种情况也有另外一个解决方案，那就是<strong>延迟双删</strong>，在更新请求完成之后，将缓存删除</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207154759309.png" alt="image-20221207154759309"></p>
<p>这种解决思路的关键在于对 N 的时间的判断，如果 N 时间太短，线程 A 第二次删除缓存的时间依旧早于线程 B 把脏数据写回缓存的时间，那么相当于做了无用功。而 N 如果设置得太长，那么在触发双删之前，新请求看到的都是脏数据。</p>
</li>
<li><p>更新数据库后删除缓存</p>
<p>也就是延迟双删的思路中，在更新数据库之后将缓存删除</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207154933719.png" alt="image-20221207154933719"></p>
<p>线程C在T2时间段获取到的数据会不一致，但是其实这个时间是非常短的。</p>
<p>但是还有一种情况可能出现数据不一致的情况</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207155218114.png" alt="image-20221207155218114"></p>
<p>总的来说，这个不一致场景出现条件非常严格，因为并发量很大时，缓存不太可能不存在；如果并发很大，而缓存真的不存在，那么很可能是这时的写场景很多，因为写场景会删除缓存。</p>
</li>
</ol>
</li>
</ul>
<p>对比四种更新策略：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207155303812.png" alt="image-20221207155303812"></p>
<p><strong>从一致性的角度来看，采取更新数据库后删除缓存值，是更为适合的策略。</strong>因为出现不一致的场景的条件更为苛刻，概率相比其他方案更低。</p>
<p>做个简单总结，足以适应绝大部分的互联网开发场景的决策：</p>
<ul>
<li><strong>针对大部分读多写少场景，建议选择更新数据库后删除缓存的策略。</strong></li>
<li><strong>针对读写相当或者写多读少的场景，建议选择更新数据库后更新缓存的策略。</strong></li>
</ul>
<p>为了避免这种不一致性永久存在，使用缓存的时候，我们必须要给缓存设置一个过期时间，例如 1 分钟，这样即使出现了更新 Redis 失败的极端场景，不一致的时间窗口最多也只是 1 分钟。</p>
<p>这是我们最终一致性的兜底方案，万一出现任何情况的不一致问题，最后都能通过缓存失效后重新查询数据库，然后回写到缓存，来做到缓存与数据库的最终一致。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指缓存中没有存储访问的数据，缓存永远不生效，请求穿透缓存，打到数据库上。例如访问一些不存在的用户id。</p>
<p>解决方案：</p>
<ol>
<li>将数据库不存在的数据也缓存下来：缺点是会有额外的内存消耗，而且可能造成短期的不一致；</li>
<li>将用户id的复杂度加大，避免推断</li>
<li>使用布隆过滤器，服务启动之前，将所有的数据加载到布隆过滤器中，进行缓存之前先判断在布隆过滤器中是否已经存在；缺点是实现复杂，存在误判可能</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指当大量缓存数据在同一时间过期，或者Redis单机，大量缓存数据失效，数据库压力瞬间增大，导致影响到其他的服务，引起雪崩效应。</p>
<p>解决方案：</p>
<ol>
<li>给不同的key设置随机的TTL</li>
<li>利用Redis集群的高可用性</li>
<li>给缓存的业务添加降级限流策略</li>
<li>给业务增加多级缓存</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿也叫做热key问题，是指热<code>key</code>（被高并发访问并且缓存重建业务较复杂的key）失效，相同的请求透过缓存，直接打到数据库，大流量导致数据库也无法承担。</p>
<p>解决方案：</p>
<ol>
<li>互斥锁：当发现缓存过期，需要从数据库获取数据时，先获取锁，获取锁之后才访问数据库；如果没有获取锁，则休眠一段时间再次重试在缓存中获取数据，没有的话，再次尝试获取锁；缺点是线程需要等待，性能会收到影响，而且可能有死锁的风险</li>
<li>逻辑过期：将热key过期后的数据也缓存起来，作为老数据，当新数据失效时，返回老数据，通过子进程获取互斥锁，新数据放到缓存中，然后释放锁。其他的进程没有访问到老数据也没有获取到锁时，则直接返回老数据；解决了线程等待的问题，性能好，缺点是不保证一致性，有额外的内存，而且实现复杂</li>
</ol>
<h2 id="全局ID生成策略"><a href="#全局ID生成策略" class="headerlink" title="全局ID生成策略"></a>全局ID生成策略</h2><p>全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，要满足的特性：</p>
<ul>
<li>唯一性</li>
<li>高可用</li>
<li>递增性</li>
<li>安全性</li>
<li>高性能</li>
</ul>
<p>实现方式可以有以下几种</p>
<ul>
<li>UUID：通过时间戳+机器号+随机值生成，可以实现全局唯一，并且自增</li>
<li>Redis自增：通过Redis自增，来替代时间戳，通过Redis自增+机器号+时间日期，可以实现全局以为一，并且自增</li>
<li><code>snowflake</code>算法：雪花算法</li>
<li>数据库自增：类似于UUID，自增主键</li>
</ul>
<p>Redis自增ID策略：</p>
<ul>
<li>每天一个key，方便统计订单量</li>
<li>ID构造是 时间戳 + 计数器</li>
</ul>
<h2 id="对比分布式锁的实现方式‘"><a href="#对比分布式锁的实现方式‘" class="headerlink" title="对比分布式锁的实现方式‘"></a>对比分布式锁的实现方式‘</h2><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>
<p>特点：</p>
<ul>
<li>多进程可见</li>
<li>互斥</li>
<li>高可用</li>
<li>高性能</li>
<li>安全性</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>MySQL</th>
<th>Redis</th>
<th>Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td>互斥</td>
<td>利用MySQL本身的互斥锁机制</td>
<td>利用setnx</td>
<td>利用节点唯一性和有序性实现互斥</td>
</tr>
<tr>
<td>高可用</td>
<td>好</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>高性能</td>
<td>一般</td>
<td>好</td>
<td>一般</td>
</tr>
<tr>
<td>安全性</td>
<td>断开连接，自动释放锁</td>
<td>利用过期时间，到期释放</td>
<td>临时节点，断开连接自动释放</td>
</tr>
</tbody></table>
<h2 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a>关注推送</h2><p>关注推送也叫做<code>Feed</code>流，直译为投喂。为用户持续的提供<strong>沉浸式</strong>的体验，通过无限下拉刷新获取新的消息。例如刷朋友圈、微博、抖音。</p>
<p><code>Feed</code>流常见的两种模式：</p>
<ul>
<li><code>TimeLine</code>：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注，例如朋友圈<ul>
<li>优点：信息全面，不会有缺失；实现相对简单</li>
<li>缺点：信息噪音较多，用户不一定感兴趣；内容获取效率低</li>
</ul>
</li>
<li>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户感兴趣信息来吸引用户，例如微博、抖音<ul>
<li>优点：投喂用户感兴趣信息，用户粘性很高，容易沉迷</li>
<li>缺点：如果算法不精确，可能引起反作用</li>
</ul>
</li>
</ul>
<p>实现方案有三种：</p>
<ul>
<li>拉模式：也叫做读扩散，用户从服务端拉取关注的人发送的信息；<ul>
<li>优点：节省空间，保存发送者的数据即可；</li>
<li>缺点：耗费时间，用户通过时间戳拉取数据，每次都要拉取所有数据，然后排序</li>
</ul>
</li>
<li>推模式：服务器将信息发送扩散给所有的用户；<ul>
<li>优点：快，用户获取自己收件箱中的数据即可</li>
<li>缺点：信息占用空间大，每一个消息以关注人数翻倍</li>
</ul>
</li>
<li>推拉结合：将拉模式和推模式结合，针对活跃关注数少（千万级）的人使用推模式，关注的人比较少的用户使用拉模式。</li>
</ul>
<h2 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h2><p>在超高并发的场景下，传统缓存方案可能在缓存失效的情况，或者中间层服务无法支撑请求的情况，此时可以使用多级缓存，充分利用请求处理的每个环节，分别添加缓存，减轻中间层压力，提升服务性能，并且避免缓存失效后请求打到数据库上。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208144829613.png" alt="image-20221208144829613"></p>
<p>进程缓存，例如上述Redis作为缓存章节中，使用本地缓存。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>Redis底层使用以下几种数据结构，在这几种数据结构之上，表现为五种数据使用形式。</p>
<ul>
<li>动态字符串SDS</li>
<li>IntSet</li>
<li>Dict</li>
<li>ZipList</li>
<li>QuickList</li>
<li>SkipList</li>
<li>RedisObject</li>
</ul>
<h2 id="动态字符串SDS"><a href="#动态字符串SDS" class="headerlink" title="动态字符串SDS"></a>动态字符串SDS</h2><p>Redis中保存的key是字符串，value往往是字符串或者字符串的集合。</p>
<p>Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：</p>
<ul>
<li>获取字符串长度需要通过运算</li>
<li>非二进制安全</li>
<li>不可修改</li>
</ul>
<p>在这个基础上，Redis构建一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET hello 世界</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>创建两个SDS，一个是<code>hello</code>，一个是<code>世界</code>。</p>
<p><code>src/sds.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span> 	 <span class="comment">/* 已保存字符串字节数，不包含约束标识\n */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span> <span class="comment">/* 申请的总字节数，不包含结束标识\n */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span>  <span class="comment">/* 不同的SDS的头类型，用来控制SDS的头大小 */</span></span><br><span class="line">    <span class="type">char</span> buf[];	<span class="comment">/*数据体*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如一个包含字符串<code>name</code>的SDS结构如下：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208211113618.png" alt="image-20221208211113618"></p>
<p>结构体中的字段，是连续的内存空间。</p>
<h3 id="SDS扩容"><a href="#SDS扩容" class="headerlink" title="SDS扩容"></a>SDS扩容</h3><p>SDS之所以叫做动态字符串，是因为具备动态扩容的能力。例如在<code>name</code>后面再追加字符串，这里会申请新内存空间：</p>
<ul>
<li>如果新字符串小于1M，则新空间<strong>扩展后字符串长度</strong>的两倍<code>+1</code>；</li>
<li>如果新字符串大于1M，则新空间<strong>扩展后字符串</strong>长度<code>+1M</code>.称为内存预分配</li>
</ul>
<h2 id="整数集合IntSet"><a href="#整数集合IntSet" class="headerlink" title="整数集合IntSet"></a>整数集合IntSet</h2><p>IntSet是Redis中<code>set</code>集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。</p>
<p><code>src/intset.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;  <span class="comment">/* 编码方式，支持存放16位、32位、64位整数 */</span></span><br><span class="line">    <span class="type">uint32_t</span> length;		<span class="comment">/* 元素个数 */</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];	<span class="comment">/* 整数数组，保存集合数据，长度通过encoding指定，是2字节、4字节、8字节*/</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p><code>encoding</code>包含三种模式，表示存储的整数大小不同：</p>
<p><code>src/intset.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note that these encodings are ordered, so:</span></span><br><span class="line"><span class="comment"> * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))				<span class="comment">// 2字节整数，2^16</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))				<span class="comment">// 4字节整数，2^32</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))				<span class="comment">// 8字节整数，2^64</span></span></span><br></pre></td></tr></table></figure>

<p>为了方便查找，Redis会将IntSet中所有的整数按照升序一次保存在<code>contents</code>数组中，结构如图：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208211958051.png" alt="image-20221208211958051"></p>
<p>数组中，数字5、10、20都在2^16以内，因此<code>encoding</code>使用<code>INTSET_ENC_INT16</code>，长度是3，数组中每个元素占用2个字节。</p>
<h3 id="IntSet动态升级"><a href="#IntSet动态升级" class="headerlink" title="IntSet动态升级"></a>IntSet动态升级</h3><p>此时，IntSet每个元素占据2个字节，如果新插入数据，而且数据需要4个字节，超过<code>int16_t</code>的范围，IntSet会自动升级编码方式到合适的大小。流程如下：</p>
<ol>
<li>升级编码为<code>INTSET_ENC_INT32</code>，每个整数占4个字节，并按照新的编码方式及元素个数扩容数组（是扩容，Header不会更换地址空间）</li>
<li><strong>倒序</strong>以此将数据中的元素拷贝到扩容后的正确为止（正序扩容会覆盖后面的元素）</li>
<li>将待添加的元素放入到数组末尾</li>
<li>将IntSet的<code>encoding</code>属性改为<code>INTSET_ENC_INT32</code>，将<code>length</code>更新</li>
</ol>
<p>源码：</p>
<p><code>src/intset.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Insert an integer in the intset */</span></span><br><span class="line">intset *<span class="title function_">intsetAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value, <span class="type">uint8_t</span> *success)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> valenc = _intsetValueEncoding(value);	<span class="comment">// 获取当前值编码</span></span><br><span class="line">    <span class="type">uint32_t</span> pos;		<span class="comment">// 要插入的位置</span></span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;	<span class="comment">// 判断成功或是失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span></span><br><span class="line"><span class="comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span></span><br><span class="line"><span class="comment">     * because it lies outside the range of existing values. */</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;		<span class="comment">// 判断编码是否超过当前的encoding</span></span><br><span class="line">        <span class="comment">/* This always succeeds, so we don&#x27;t need to curry *success. */</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);			<span class="comment">// </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Abort if the value is already present in the set.</span></span><br><span class="line"><span class="comment">         * This call will populate &quot;pos&quot; with the right position to insert</span></span><br><span class="line"><span class="comment">         * the value when it cannot be found. */</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span></span><br><span class="line"><span class="type">static</span> intset *<span class="title function_">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="type">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="type">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="type">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don&#x27;t overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IntSet可以看作是特殊的整数数组，具备一些特点：</p>
<ol>
<li>Redis会确保IntSet中的元素唯一、有序</li>
<li>具备类型升级机制，可以节省内存空间</li>
<li>底层采用二分查找方式来查询</li>
</ol>
<h2 id="字典Dict"><a href="#字典Dict" class="headerlink" title="字典Dict"></a>字典Dict</h2><p>在Redis这个键值型数据库中，键与值的映射关系正是通过Dict来实现的。</p>
<p>Dict由两部分组成，分别是：哈希表（<code>dict</code>），哈希节点（<code>DictEntry</code>）</p>
<p><code>deps/hiredis/dict.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;								<span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *val;								<span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>		<span class="comment">// 下一个entry的指针</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dict，hash表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictEntry **table;				<span class="comment">// entry数组，数组中保存的指向entry的指针</span></span><br><span class="line">    dictType *type;						<span class="comment">// 哈希表类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;				<span class="comment">// 哈希表大小，总等于 2^n </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;		<span class="comment">// 哈希表大小的掩码，总等于size - 1，用于做hash运算</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;				<span class="comment">// entry 个数</span></span><br><span class="line">    <span class="type">void</span> *privdata;						<span class="comment">// 私有数据， 做特殊hash运算时用</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典迭代器，用于迭代dict  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *ht;												<span class="comment">// 指向hash表的指针</span></span><br><span class="line">    <span class="type">int</span> index;											<span class="comment">// 索引</span></span><br><span class="line">    dictEntry *entry, *nextEntry;		<span class="comment">// 本节点和下一个节点的指针</span></span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>

<p><code>src/dict.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;                  <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;                        <span class="comment">// 值，并且可以存储不同的数据类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>     <span class="comment">/* Next entry in the same hash bucket. */</span> <span class="comment">// 下一个entry的指针</span></span><br><span class="line">    <span class="type">void</span> *metadata[];           <span class="comment">/* An arbitrary number of bytes (starting at a</span></span><br><span class="line"><span class="comment">                                 * pointer-aligned address) of size as returned</span></span><br><span class="line"><span class="comment">                                 * by dictType&#x27;s dictEntryMetadataBytes(). */</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*keyDup)(dict *d, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(dict *d, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*keyCompare)(dict *d, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(dict *d, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*valDestructor)(dict *d, <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*expandAllowed)(<span class="type">size_t</span> moreMem, <span class="type">double</span> usedRatio);</span><br><span class="line">    <span class="comment">/* Allow a dictEntry to carry extra caller-defined metadata.  The</span></span><br><span class="line"><span class="comment">     * extra memory is initialized to 0 when a dictEntry is allocated. */</span></span><br><span class="line">    <span class="type">size_t</span> (*dictEntryMetadataBytes)(dict *d);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dict，hash表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictEntry **table;        <span class="comment">// entry数组，数组中保存的指向entry的指针</span></span><br><span class="line">    dictType *type;           <span class="comment">// 哈希表类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;       <span class="comment">// 哈希表大小，总等于 2^n </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;   <span class="comment">// 哈希表大小的掩码，总等于size - 1，用于做hash运算</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;       <span class="comment">// entry 个数</span></span><br><span class="line">    <span class="type">void</span> *privdata;           <span class="comment">// 私有数据， 做特殊hash运算时用</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;               <span class="comment">// 哈希表类型，内置不同的hash函数</span></span><br><span class="line"></span><br><span class="line">    dictEntry **ht_table[<span class="number">2</span>];      <span class="comment">// entry数组，有两个元素，一个是使用的，另外一个是空的</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ht_used[<span class="number">2</span>];		</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span>  <span class="comment">// rehash进度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep small vars at end for optimal (minimal) struct padding */</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash; <span class="comment">/* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */</span> <span class="comment">// hash是否暂停， &gt;0 代表暂停</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> ht_size_exp[<span class="number">2</span>]; <span class="comment">/* exponent of size. (size = 1&lt;&lt;exp) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典迭代器，用于迭代dict  </span></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="type">long</span> index;</span><br><span class="line">    <span class="type">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>

<p>向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用<code>h&amp;sizemask</code>（其实也就是取模，位运算更快）来计算元素应该存储到数组中的哪个索引位置。</p>
<p><code>dict</code>中的<code>dictEntry</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208220452732.png" alt="image-20221208220452732"></p>
<p>  存储1个数据</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208220525758.png" alt="image-20221208220525758"></p>
<p>如果出现hash冲突，会加入到链表头部，这样可以不需要便利所有链表</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208220539425.png" alt="image-20221208220539425"></p>
<h3 id="Dict扩容"><a href="#Dict扩容" class="headerlink" title="Dict扩容"></a>Dict扩容</h3><p>Dict中的<code>HashTable</code>就是数组结合单向链表的实现，当集合中元素过多，导致哈希冲突过多，链表过长，则会降低查询效率。此时会进行Dict扩容。</p>
<p>Dict在每次新增键值对时都会检查负载因子（<code>LoadFactor = used/size</code>），满足以下两种情况时会触发哈希表扩容：</p>
<ul>
<li>负载因子<code>LoadFactor &gt;= 1</code>，并且服务器没有执行BGSAVE或者BGREWRITEAOF等后台进程</li>
<li>负载因子<code>LoadFactor &gt; 5</code></li>
</ul>
<p><code>src/dict.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="keyword">if</span> (DICTHT_SIZE(d-&gt;ht_size_exp[<span class="number">0</span>]) == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht_used[<span class="number">0</span>] &gt;= DICTHT_SIZE(d-&gt;ht_size_exp[<span class="number">0</span>]) &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht_used[<span class="number">0</span>]/ DICTHT_SIZE(d-&gt;ht_size_exp[<span class="number">0</span>]) &gt; dict_force_resize_ratio) &amp;&amp;</span><br><span class="line">        dictTypeExpandAllowed(d))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht_used[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dict收缩"><a href="#Dict收缩" class="headerlink" title="Dict收缩"></a>Dict收缩</h3><p>Dict除了扩容以外，每次删除元素时，也会对负载因子做检查，当<code>LoadFactor &lt; 0.1</code>时，会做哈希表收缩</p>
<p><code>src/server.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">htNeedsResize</span><span class="params">(dict *dict)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size, used;</span><br><span class="line"></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">            (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>src/dict.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Resize the table to the minimal size that contains all the elements,</span></span><br><span class="line"><span class="comment"> * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    minimal = d-&gt;ht_used[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dict的rehash"><a href="#Dict的rehash" class="headerlink" title="Dict的rehash"></a>Dict的rehash</h3><p>不管是收缩还是扩容，必定会创建新的哈希表，导致哈希表的size和sizemask发生变化，而key的查询语sizemask有关，因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。</p>
<p>过程如下</p>
<ol>
<li><p>计算新hash表的<code>realeSize</code>，取值取决于当前要做的是扩容还是缩容：</p>
<ul>
<li>如果是扩容，则新<code>size</code>为第一个大于等于<code>dict.ht[0].used + 1</code> 的 <code>2^n</code></li>
<li>如果是缩容，则新<code>size</code>为第一个大于等于<code>dict.ht[0].used</code> 的 <code>2^n</code>（不得小于4）</li>
</ul>
</li>
<li><p>按照新的<code>realeSize</code>申请内存空间，创建<code>dictht</code>，并赋值给<code>dict.ht[1]</code></p>
</li>
<li><p>设置<code>dict.rehashidx=0</code>，标识开始rehash</p>
</li>
<li><p>将老hash表中的每一个dictentry都rehash到新的hash表中</p>
<p>这个过程是每次执行新增、查询、修改、删除操作时，都要检查下<code>dict.rehashidx</code>是否大于-1，如果是，则rehash一个entry后，都要将<code>rehashidx++</code>，直到所有的entry都rehash</p>
</li>
<li><p>将<code>dict.ht[1]</code>赋值给<code>dict.ht[0]</code>，给<code>dict.ht[1]</code>初始化为空哈希表，释放原来的<code>dict.ht[0]</code>的内存</p>
</li>
<li><p>将rehashidx赋值为-1，代表rehash结束</p>
</li>
<li><p>在rehash过程中，新增操作，直接写入新hash表中，查询、修改和删除则会在老hash表和新hash表依次查找并执行。这样可以确保数据只减，不增，随着rehash最终为空</p>
</li>
</ol>
<p>rehash前</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208225446907.png" alt="image-20221208225446907"></p>
<p>rehash时</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208225539936.png" alt="image-20221208225539936"></p>
<p>rehash后</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208225559504.png" alt="image-20221208225559504"></p>
<h2 id="压缩列表ZipList"><a href="#压缩列表ZipList" class="headerlink" title="压缩列表ZipList"></a>压缩列表ZipList</h2><p>ZipList是一种特殊的<strong>双端链表</strong>，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入、弹出操作，并且该操作的时间复杂度为O(1)。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208222604830.png" alt="image-20221208222604830"></p>
<p><img src="/../../../../../Library/Application%20Support/typora-user-images/image-20221208222623463.png" alt="image-20221208222623463"></p>
<p>其中entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存，而是直接记录前一个entry的长度</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230036374.png" alt="image-20221208230036374"></p>
<h3 id="Encoding编码"><a href="#Encoding编码" class="headerlink" title="Encoding编码"></a>Encoding编码</h3><p>ZipList中的entry中的<code>encoding</code>编码分为字符串和整数两种：</p>
<ul>
<li><p>字符串：如果<code>encoding</code>以<code>00</code>、<code>01</code>或者<code>10</code>开头，则<code>content</code>是字符串</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230228077.png" alt="image-20221208230228077"></p>
<p>  例如保存字符串<code>ab</code></p>
<p>  <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230301494.png" alt="image-20221208230301494"></p>
<p>  再保存一个bc</p>
<p>  <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230358306.png" alt="image-20221208230358306"></p>
</li>
<li><p>整数：如果<code>encoding</code>以<code>11</code>开头，则<code>content</code>是整数，而且<code>encoding</code>固定值占用1个字节</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230526270.png" alt="image-20221208230526270"></p>
<p>例如，一个ZipList中包含两个整数值：2和5</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230620807.png" alt="image-20221208230620807"></p>
</li>
</ul>
<p>源码</p>
<p><code>src/ziplist.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Each entry in the ziplist is either a string or an integer. */</span>				<span class="comment">// 记录ZipList中的节点信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* When string is used, it is provided with the length (slen). */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *sval;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> slen;</span><br><span class="line">    <span class="comment">/* When integer is used, &#x27;sval&#x27; is NULL, and lval holds the value. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> lval;</span><br><span class="line">&#125; ziplistEntry;</span><br></pre></td></tr></table></figure>

<p><code>src/ziplist.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We use this function to receive information about a ziplist entry.</span></span><br><span class="line"><span class="comment"> * Note that this is not how the data is actually encoded, is just what we</span></span><br><span class="line"><span class="comment"> * get filled by a function in order to operate more easily. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previous entry len*/</span>		<span class="comment">// 记录前一个节点长度的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlen;     <span class="comment">/* Previous entry len. */</span>													<span class="comment">// 前一个节点长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize;        <span class="comment">/* Bytes used to encode this entry type/len.				// 记录当前字节长度的字节数</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes			</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;            <span class="comment">/* Bytes used to represent the actual entry.				// 当前字节长度</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;     <span class="comment">/* prevrawlensize + lensize. */</span>										<span class="comment">// 头信息占用字节长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;      <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on			// 编码，确定数据时数字还是字符串</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;            <span class="comment">/* Pointer to the very start of the entry, that		// ZipList中起始节点指针</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>

<h3 id="ZipList的连锁更新问题"><a href="#ZipList的连锁更新问题" class="headerlink" title="ZipList的连锁更新问题"></a>ZipList的连锁更新问题</h3><p>ZipList的每个entry都包含前一个节点的长度，长度是1或者5个字节</p>
<ul>
<li>如果前一节点的长度小于254个字节，则采用1个字节保存这个长度</li>
<li>如果前一节点的长度大于254个字节，则采用5个字节来保存这个长度值，第一个字节以<code>0xfe</code>，后4个字节才是真实长度数据</li>
</ul>
<p>如果出现，插入某个节点，导致后面节点更改长度，又导致后面节点更改长度，就会出现连续多次空间扩展，也就是<strong>连锁更新</strong>（Cascade Update），新增、删除都可能导致连锁更新的发生。</p>
<p>ZipList特性：</p>
<ol>
<li>压缩列表可以看做一种连续内存空间的双向链表</li>
<li>列表的节点之间不是通过指针连接，而是记录上一个节点和本节点长度来寻址，内存占用较低</li>
<li>如果列表数据过多，导致链表过长，可能影响查询性能</li>
<li>增或删较大数据时，有可能发生连续更新问题</li>
</ol>
<p>因此，在Redis 7.0版本，通过<code>listpack</code>完全取代<code>ZipList</code>，并且为了兼容性，保留了<code>ziplist</code>的相关属性。通过在entry末尾记录本entry长度，解决连锁更新的问题。</p>
<h2 id="快速列表QuickList"><a href="#快速列表QuickList" class="headerlink" title="快速列表QuickList"></a>快速列表QuickList</h2><p>ZipList占据连续内存，当节点过多，申请内存的效率就会很低。为了解决这个问题，引入快速列表QuickList，将多个ZipList通过双向链表连接起来。</p>
<p>QuickList是一个双端链表，链表中的每个节点都是一个ZipList（Redis 7.0中，每个节点是ListPack）。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209095847218.png" alt="image-20221209095847218"></p>
<p>为了避免QuickList中的每个ZipList中entry过多，Redis通过配置限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5) &quot;list-max-ziplist-size&quot;</span><br><span class="line">6) &quot;-2&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果为正，代表ZipList的允许entry个数的最大值</li>
<li>如果为负，代表ZipList的最大内存大小，分5中情况：<ul>
<li>-1：每个ZipList的内存占用不能超过4KB</li>
<li>-2：每个ZipList的内存占用不能超过8KB，默认值</li>
<li>-3：每个ZipList的内存占用不能超过16KB</li>
<li>-4：每个ZipList的内存占用不能超过32KB</li>
<li>-5：每个ZipList的内存占用不能超过64KB</li>
</ul>
</li>
</ul>
<p>除了控制ZipList的大小，还可以控制ZipList做压缩，通过配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">23) &quot;list-compress-depth&quot;</span><br><span class="line">24) &quot;0&quot;</span><br></pre></td></tr></table></figure>

<p>因为链表一般是首位访问较多，所以首位是不压缩的。这个参数就是控制首位不压缩的节点个数：</p>
<ul>
<li>0：特殊值，代表不压缩，默认值，不压缩内存申请效率高，但是超找效率不如压缩</li>
<li>1：代表QuickList首位各有1个节点不压缩，中间节点压缩</li>
<li>2：代表QuickList首位各有2个节点不压缩，中间节点压缩</li>
<li>以此类推</li>
</ul>
<p>QuickList源码</p>
<p><code>src/quicklist.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* quicklistNode is a 32 byte struct describing a listpack for a quicklist.</span></span><br><span class="line"><span class="comment"> * We use bit fields keep the quicklistNode at 32 bytes.</span></span><br><span class="line"><span class="comment"> * count: 16 bits, max 65536 (max lp bytes is 65k, so max count actually &lt; 32k).</span></span><br><span class="line"><span class="comment"> * encoding: 2 bits, RAW=1, LZF=2.</span></span><br><span class="line"><span class="comment"> * container: 2 bits, PLAIN=1 (a single item as char array), PACKED=2 (listpack with multiple items).</span></span><br><span class="line"><span class="comment"> * recompress: 1 bit, bool, true if node is temporary decompressed for usage.</span></span><br><span class="line"><span class="comment"> * attempted_compress: 1 bit, boolean, used for verifying during testing.</span></span><br><span class="line"><span class="comment"> * extra: 10 bits, free for future use; pads out the remainder of 32 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span>			<span class="comment">// QuickList中的节点结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>			<span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>			<span class="comment">// 后一个节点指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *entry;						<span class="comment">// 当前节点指针</span></span><br><span class="line">    <span class="type">size_t</span> sz;             <span class="comment">/* entry size in bytes */</span>	<span class="comment">// 当前节点ZipList的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in listpack */</span>	<span class="comment">// 当前节点ZipList中entry的个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span>						<span class="comment">// 编码方式，1是ZipList，2是LZP压缩模式</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;  <span class="comment">/* PLAIN==1 or PACKED==2 */</span>			<span class="comment">// 数据容器类型，1是PLAIN，2是PACKED</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span>			<span class="comment">// 是否被压缩，1说明被解压了，后续要重新压缩</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span>	<span class="comment">// 测试用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dont_compress : <span class="number">1</span>; <span class="comment">/* prevent compression of entry that will be used later */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">9</span>; <span class="comment">/* more bits to steal for future usage */</span>	<span class="comment">// 预留字段</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;count&#x27; is the number of total entries.</span></span><br><span class="line"><span class="comment"> * &#x27;len&#x27; is the number of quicklist nodes.</span></span><br><span class="line"><span class="comment"> * &#x27;compress&#x27; is: 0 if compression disabled, otherwise it&#x27;s the number</span></span><br><span class="line"><span class="comment"> *                of quicklistNodes to leave uncompressed at ends of quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;fill&#x27; is the user-requested (or default) fill factor.</span></span><br><span class="line"><span class="comment"> * &#x27;bookmarks are an optional feature that is used by realloc this struct,</span></span><br><span class="line"><span class="comment"> *      so that they don&#x27;t consume memory when not used. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span>			<span class="comment">// QuickList 结构体</span></span><br><span class="line">    quicklistNode *head;				<span class="comment">// 头节点指针</span></span><br><span class="line">    quicklistNode *tail;				<span class="comment">// 尾结点指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;        <span class="comment">/* total count of all entries in all listpacks */</span>	<span class="comment">// 所有ZipList中entry数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;          <span class="comment">/* number of quicklistNodes */</span>										<span class="comment">// ZipList的数量</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span> fill : QL_FILL_BITS;       <span class="comment">/* fill factor for individual nodes */</span>	<span class="comment">// ZipList上限，默认值 -2 </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : QL_COMP_BITS; <span class="comment">/* depth of end nodes not to compress;0=off */</span>	<span class="comment">// 首位不压缩的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bookmark_count: QL_BM_BITS;	<span class="comment">// 内存重分配时的书签数量及数组，一般用不到</span></span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>

<p>示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209103834488.png" alt="image-20221209103834488"></p>
<h2 id="跳表SkipList"><a href="#跳表SkipList" class="headerlink" title="跳表SkipList"></a>跳表SkipList</h2><p>在QuickList中，通过首位访问是比较快的，但是如果需要访问中间元素，则需要进行从首或者尾进行遍历，遍历到某个ZipList之后，在ZipList中可以二分查找，但是如果QuickList非常长，这个遍历效率会非常低。</p>
<p>因此，当QuickList中节点过多时，需要引入SkipList。SkipList，跳表，是一个链表，但是与传统链表有几点差异：</p>
<ul>
<li>元素按照升序排列存储</li>
<li>节点可以包含多个指针，指针跨度不同</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209104717967.png" alt="image-20221209104717967"></p>
<p>SkipList中，最大可以允许32级指针。</p>
<p><code>src/server.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span>								<span class="comment">// SkipList中节点信息</span></span><br><span class="line">    sds ele;																	<span class="comment">// 节点存储的值</span></span><br><span class="line">    <span class="type">double</span> score;															<span class="comment">// 节点分数，用于排序、查找</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>						<span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span>										<span class="comment">// 层级信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>				<span class="comment">// 下一个节点指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;										<span class="comment">// 索引跨度</span></span><br><span class="line">    &#125; level[];																<span class="comment">// 保存所有层级的指针信息</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span>										<span class="comment">// SkipList数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>			<span class="comment">// 头节点、尾结点指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;											<span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">int</span> level;																<span class="comment">// 最大索引层级，默认值1 </span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209112523056.png" alt="image-20221209112523056"></p>
<p>SkipList特点：</p>
<ul>
<li>跳跃表是一个双向链表，每个节点包含<code>score</code>和<code>ele</code>值，也就是打分和值</li>
<li>节点按照score值排序，score值一样则按照<code>ele</code>字典排序</li>
<li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li>
<li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li>
<li>增删改查效率与红黑树基本一致，实现却更加简单</li>
</ul>
<h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><p>Redis中任意数据类型的键值都会被封装为一个RedisObject，也叫做Redis对象</p>
<p><code>src/server.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;				<span class="comment">// 对象类，数据类型，从0-4有5种，占4个bit</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;		<span class="comment">// 数据编码，同一个数据类型，也会有不同的数据编码，占4个bit</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or		// 表示该对象最后一次被访问的时间，占用24个bit，便于判断空闲时间太久的key</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span>	</span><br><span class="line">    <span class="type">int</span> refcount;																														<span class="comment">// 对象引用计数器，有对象引用+1，没有对象引用-1，为0代表没有应用引用，则可回收</span></span><br><span class="line">    <span class="type">void</span> *ptr;							<span class="comment">// 指针，指向实际存放数据的空间</span></span><br><span class="line">&#125; robj;											<span class="comment">// 对象头部，占用16个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type 数据类型</span></span><br><span class="line"><span class="comment">/* The actual Redis Object */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span>				<span class="comment">// int embstr raw </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span>					<span class="comment">// QuickList</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span>						<span class="comment">// IntSet，HashTable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span>		<span class="comment">// ListPack，SkipList</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span>					<span class="comment">// ListPack，HashTable</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据编码</span></span><br><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The &#x27;encoding&#x27; field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span>															<span class="comment">// 动态字符串的一种方式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span>															<span class="comment">// long类型的整数的字符串</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span>													<span class="comment">// hash表，也就是字典dict</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* No longer used: old hash encoding. */</span>							<span class="comment">// 已废弃</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span>					<span class="comment">// 双端链表，已废弃</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* No longer used: old list/hash/zset encoding. */</span>		<span class="comment">// Redis 7中已经不使用ZipList</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span>															<span class="comment">// 整数集合</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span>													<span class="comment">// 跳表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span>										<span class="comment">// 动态字符串的一种方式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of listpacks */</span>					<span class="comment">// 快速列表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span>						<span class="comment">// Stream 流</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_LISTPACK 11 <span class="comment">/* Encoded as a listpack */</span>												<span class="comment">// Redis 7中使用ListPack代替ZipList				</span></span></span><br></pre></td></tr></table></figure>

<h2 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h2><p>Redis 6.0的数据类型、编码类型和底层数据结构对应</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20220618182945035.png" alt="image-20220618182945035"></p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>string是Redis中最常见的数据存储类型：</p>
<ul>
<li><p>基本编码方式是RAW，基于SDS实现，存储上限是512MB</p>
<p>RAW编码：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209115226190.png" alt="image-20221209115226190"></p>
</li>
<li><p>如果SDS长度小于44字节，则会采用EMBSTR编码，此时object haed与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</p>
<p>EMBSTR编码：</p>
<p>此时RedisObject占用16个字节，SDS占用44+头部的3个字节+尾部\0的1个字节，一共64字节，内存分配时不会有内存碎片。因此推荐String格式的字符串长度不要超过44个字节。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209115351780.png" alt="image-20221209115351780"></p>
</li>
<li><p>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（正好8字节），不再需要SDS</p>
<p>INT编码：</p>
<p><img src="/../../../../../Library/Application%20Support/typora-user-images/image-20221209123451393.png" alt="image-20221209123451393"></p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> raw aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> emb abc</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> int 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding raw</span><br><span class="line"><span class="string">&quot;raw&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding emb</span><br><span class="line"><span class="string">&quot;embstr&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding int</span><br><span class="line"><span class="string">&quot;int&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis的List类型可以从首、尾操作列表中的元素，满足的数据结构是QuickList，包含LinkedList和ZipList的特点，节点和节点之间通过双向链表访问，内存占用较低，每个节点内包含多个ZipList，存储上限高。</p>
<ul>
<li>3.2版本之前，Redis采用LinkedList和ZipList来实现List，当元素数量小于512个，并且元素大小小于64字节时，采用ZipList编码，否则使用LinkedList编码</li>
<li>3.2版本之后，Redis同意使用QuickList来实现List</li>
</ul>
<p><code>src/t_list.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LPUSH/RPUSH/LPUSHX/RPUSHX 命令，都是调用pushGenericCommand</span></span><br><span class="line"><span class="comment">/* LPUSH &lt;key&gt; &lt;element&gt; [&lt;element&gt; ...] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lpushCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    pushGenericCommand(c,LIST_HEAD,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Implements LPUSH/RPUSH/LPUSHX/RPUSHX. </span></span><br><span class="line"><span class="comment"> * &#x27;xx&#x27;: push if key exists. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushGenericCommand</span><span class="params">(client *c, <span class="type">int</span> where, <span class="type">int</span> xx)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">		<span class="comment">// 尝试找到KEY对应的List</span></span><br><span class="line">    robj *lobj = lookupKeyWrite(c-&gt;db, c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">  	<span class="comment">// 检查类型是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (checkType(c,lobj,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">  	<span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!lobj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xx) &#123;</span><br><span class="line">            addReply(c, shared.czero);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 为空，创建QuickList</span></span><br><span class="line">        lobj = createQuicklistObject();</span><br><span class="line">        quicklistSetOptions(lobj-&gt;ptr, server.list_max_listpack_size,</span><br><span class="line">                            server.list_compress_depth);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],lobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        listTypePush(lobj,c-&gt;argv[j],where);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addReplyLongLong(c, listTypeLength(lobj));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *event = (where == LIST_HEAD) ? <span class="string">&quot;lpush&quot;</span> : <span class="string">&quot;rpush&quot;</span>;</span><br><span class="line">    signalModifiedKey(c,c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>src/object.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">createQuicklistObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	<span class="comment">// 申请内存并初始化QuickList</span></span><br><span class="line">    quicklist *l = quicklistCreate();</span><br><span class="line">  	<span class="comment">// 创建RedisObject，type为 OBJ_LIST，ptr指向QuickList</span></span><br><span class="line">    robj *o = createObject(OBJ_LIST,l);</span><br><span class="line">  	<span class="comment">// 设置编码为QuickList</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_QUICKLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209143255162.png" alt="image-20221209143255162"></p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set是Redis中的单列集合，满足以下特点：</p>
<ul>
<li>不保证有序性</li>
<li>保证元素唯一性（可以判断元素是否存在）</li>
<li>求交集、并集、差集</li>
</ul>
<p>满足这种查询元素高效率的要求的数据结构，是HashTable，也就是Dic，不过Dic是双列集合（可以存键值对）</p>
<ul>
<li><p>为了查询效率和唯一性，Set采用HT编码（Dict）。Dict中的key可以用来存储元素，value统一为null。</p>
</li>
<li><p>当存储的所有数据都是整数，并且元素数量不超过<code>set-max-intset-entries</code>时，Set会采用IntSet编码，以节省内存</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG GET *max-intset*</span><br><span class="line">1) <span class="string">&quot;set-max-intset-entries&quot;</span></span><br><span class="line">2) <span class="string">&quot;512&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>src/t_set.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Factory method to return a set that *can* hold &quot;value&quot;. When the object has</span></span><br><span class="line"><span class="comment"> * an integer-encodable value, an intset will be returned. Otherwise a regular</span></span><br><span class="line"><span class="comment"> * hash table. */</span></span><br><span class="line">robj *<span class="title function_">setTypeCreate</span><span class="params">(sds value)</span> &#123;</span><br><span class="line">  	<span class="comment">// 判断value是否是数值类型 LongLong</span></span><br><span class="line">    <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,<span class="literal">NULL</span>) == C_OK)</span><br><span class="line">      	<span class="comment">// 如果是数值类型，则采用IntSet编码</span></span><br><span class="line">        <span class="keyword">return</span> createIntsetObject();</span><br><span class="line">  	<span class="comment">// 如果不是，则采用默认编码，也就是HT</span></span><br><span class="line">    <span class="keyword">return</span> createSetObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>src/object.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="lin