<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.1.1">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="S_5aoPFd3QQihrUOLiKdVR0Mj4fj6n6qJojwyjj9cAY">
  <meta name="msvalidate.01" content="9032A67FCF787F07CB04374E59E518A9">
  <meta name="baidu-site-verification" content="code-Onlniop0d6">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.xiaoyeshiyu.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.19.1","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Redis学习笔记之实用篇包含Redis的底层原理以及一些使用场景和解决方案，是基础篇的补充篇。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis学习笔记之实用篇">
<meta property="og:url" content="https://www.xiaoyeshiyu.com/post/c187.html">
<meta property="og:site_name" content="小夜时雨">
<meta property="og:description" content="Redis学习笔记之实用篇包含Redis的底层原理以及一些使用场景和解决方案，是基础篇的补充篇。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221206233251024.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207153120913.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207153255458.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207153551158.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207154759309.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207154933719.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207155218114.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207155303812.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208144829613.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208211113618.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208211958051.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208220452732.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208220525758.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208220539425.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208225446907.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208225539936.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208225559504.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208222604830.png">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221208222623463.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230036374.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230228077.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230301494.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230358306.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230526270.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230620807.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209095847218.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209103834488.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209104717967.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209112523056.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20220618182945035.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209115226190.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209115351780.png">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20221209123451393.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209143255162.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209144539245.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209144619653.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209145524270.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210201059649.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210201749136.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210201815252.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210203200225.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210203828934.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210204124936.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210204444011.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210204855343.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210210608387.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210211253081.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210211744633.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210214947102.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210221442752.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210223240610.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210223454987.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210223732777.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210224114125.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210224832286.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210224908284.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225515989.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225539093.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225853658.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225730118.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225616051.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225655449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210230629790.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210231512045.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210235351250.png">
<meta property="article:published_time" content="2022-12-05T16:00:00.000Z">
<meta property="article:modified_time" content="2023-12-26T07:56:22.838Z">
<meta property="article:author" content="Mitaka xu">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221206233251024.png">


<link rel="canonical" href="https://www.xiaoyeshiyu.com/post/c187.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.xiaoyeshiyu.com/post/c187.html","path":"post/c187.html","title":"Redis学习笔记之实用篇"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis学习笔记之实用篇 | 小夜时雨</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MBVJ11TVHH"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBVJ11TVHH","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?573725610fbc6ff9b42032bd13615370"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><style>
        .fireman-p-indent{
            text-indent:2em;
        }
        .fireman-span-indent{
            padding-left:2em;
        }
    </style ><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="小夜时雨" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小夜时雨</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">君子敬其在己者，而不慕其在天者，是以日进也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A1%A5%E5%85%85"><span class="nav-number">1.</span> <span class="nav-text">基础使用的补充</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#key%E7%9A%84%E5%88%86%E7%BA%A7%E5%AD%98%E5%82%A8"><span class="nav-number">1.1.</span> <span class="nav-text">key的分级存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BigKey"><span class="nav-number">1.2.</span> <span class="nav-text">BigKey</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BigKey%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="nav-number">1.2.1.</span> <span class="nav-text">BigKey的危害</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4BigKey"><span class="nav-number">1.2.2.</span> <span class="nav-text">删除BigKey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%81%B0%E5%BD%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">恰当的数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">集群模式下的批处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96"><span class="nav-number">1.4.</span> <span class="nav-text">配置优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98"><span class="nav-number">1.5.</span> <span class="nav-text">Redis作为缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.6.</span> <span class="nav-text">慢查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE"><span class="nav-number">1.7.</span> <span class="nav-text">内存配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E8%BF%98%E6%98%AF%E9%9B%86%E7%BE%A4"><span class="nav-number">1.8.</span> <span class="nav-text">主从还是集群</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E8%A1%A5%E5%85%85"><span class="nav-number">2.</span> <span class="nav-text">使用场景的补充</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">2.1.</span> <span class="nav-text">缓存更新策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%AF%B9%E6%AF%94%E5%88%A0%E9%99%A4"><span class="nav-number">2.1.1.</span> <span class="nav-text">更新对比删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">2.1.2.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">2.1.3.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">2.1.4.</span> <span class="nav-text">缓存击穿</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5"><span class="nav-number">2.2.</span> <span class="nav-text">全局ID生成策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E2%80%98"><span class="nav-number">2.3.</span> <span class="nav-text">对比分布式锁的实现方式‘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81"><span class="nav-number">2.4.</span> <span class="nav-text">关注推送</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">2.5.</span> <span class="nav-text">多级缓存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS"><span class="nav-number">3.1.</span> <span class="nav-text">动态字符串SDS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SDS%E6%89%A9%E5%AE%B9"><span class="nav-number">3.1.1.</span> <span class="nav-text">SDS扩容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88IntSet"><span class="nav-number">3.2.</span> <span class="nav-text">整数集合IntSet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IntSet%E5%8A%A8%E6%80%81%E5%8D%87%E7%BA%A7"><span class="nav-number">3.2.1.</span> <span class="nav-text">IntSet动态升级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8Dict"><span class="nav-number">3.3.</span> <span class="nav-text">字典Dict</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dict%E6%89%A9%E5%AE%B9"><span class="nav-number">3.3.1.</span> <span class="nav-text">Dict扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dict%E6%94%B6%E7%BC%A9"><span class="nav-number">3.3.2.</span> <span class="nav-text">Dict收缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dict%E7%9A%84rehash"><span class="nav-number">3.3.3.</span> <span class="nav-text">Dict的rehash</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ZipList"><span class="nav-number">3.4.</span> <span class="nav-text">压缩列表ZipList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Encoding%E7%BC%96%E7%A0%81"><span class="nav-number">3.4.1.</span> <span class="nav-text">Encoding编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZipList%E7%9A%84%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.2.</span> <span class="nav-text">ZipList的连锁更新问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8QuickList"><span class="nav-number">3.5.</span> <span class="nav-text">快速列表QuickList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8SkipList"><span class="nav-number">3.6.</span> <span class="nav-text">跳表SkipList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RedisObject"><span class="nav-number">3.7.</span> <span class="nav-text">RedisObject</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.8.</span> <span class="nav-text">五种数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">3.8.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">3.8.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">3.8.3.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zset"><span class="nav-number">3.8.4.</span> <span class="nav-text">Zset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash"><span class="nav-number">3.8.5.</span> <span class="nav-text">Hash</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">Redis网络模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="nav-number">4.1.</span> <span class="nav-text">用户空间和内核空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">五种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EIO"><span class="nav-number">4.2.1.</span> <span class="nav-text">阻塞IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-number">4.2.2.</span> <span class="nav-text">非阻塞IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">4.2.3.</span> <span class="nav-text">IO多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select"><span class="nav-number">4.2.4.</span> <span class="nav-text">IO多路复用-select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-poll"><span class="nav-number">4.2.5.</span> <span class="nav-text">IO多路复用-poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-epoll"><span class="nav-number">4.2.6.</span> <span class="nav-text">IO多路复用-epoll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">4.2.7.</span> <span class="nav-text">IO多路复用-事件通知机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%9C%A8web%E6%9C%8D%E5%8A%A1%E4%B8%8A%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">4.2.8.</span> <span class="nav-text">IO多路复用在web服务上的例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO"><span class="nav-number">4.2.9.</span> <span class="nav-text">信号驱动IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5IO"><span class="nav-number">4.2.10.</span> <span class="nav-text">异步IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%86%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-number">4.2.11.</span> <span class="nav-text">区分同步和异步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-1"><span class="nav-number">4.3.</span> <span class="nav-text">Redis网络模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.</span> <span class="nav-text">Redis通信协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RESP%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.1.</span> <span class="nav-text">RESP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.1.</span> <span class="nav-text">数据类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5"><span class="nav-number">6.</span> <span class="nav-text">Redis内存策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%BF%87%E6%9C%9F"><span class="nav-number">6.1.</span> <span class="nav-text">内存过期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="nav-number">6.1.1.</span> <span class="nav-text">惰性删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%A8%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="nav-number">6.1.2.</span> <span class="nav-text">周期删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">6.2.</span> <span class="nav-text">淘汰策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB"><span class="nav-number">7.</span> <span class="nav-text">推荐阅读</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mitaka xu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mitaka xu</p>
  <div class="site-description" itemprop="description">Golang开发博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">135</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaoyeshiyu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/c187.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis学习笔记之实用篇 | 小夜时雨">
      <meta itemprop="description" content="Redis学习笔记之实用篇包含Redis的底层原理以及一些使用场景和解决方案，是基础篇的补充篇。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis学习笔记之实用篇
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-12-06 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-06T00:00:00+08:00">2022-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-26 15:56:22" itemprop="dateModified" datetime="2023-12-26T15:56:22+08:00">2023-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span id="/post/c187.html" class="post-meta-item leancloud_visitors" data-flag-title="Redis学习笔记之实用篇" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

            <div class="post-description">Redis学习笔记之实用篇包含Redis的底层原理以及一些使用场景和解决方案，是基础篇的补充篇。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p class="fireman-p-indent" >本篇是Redis<a href="https://www.xiaoyeshiyu.com/2022/06/18/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/">学习笔记基础篇</a>的补充，主要补充了底层原理和一些常见的使用场景。</p>
<h1 id="基础使用的补充"><a href="#基础使用的补充" class="headerlink" title="基础使用的补充"></a>基础使用的补充</h1><h2 id="key的分级存储"><a href="#key的分级存储" class="headerlink" title="key的分级存储"></a><code>key</code>的分级存储</h2><p class="fireman-p-indent" >Redis在使用的过程中，为了更好的体验Key的意义，一般会使用Key作为分级存储，例如<code>mitaka</code>下有<code>user</code>组和<code>age</code>组，存储数据ID为1、2的时候，将<code>key</code>以冒号的形式隔开</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET mitaka:user:1 xu</span><br><span class="line">127.0.0.1:6379&gt; SET mitaka:user:2 xiaoye</span><br><span class="line">127.0.0.1:6379&gt; SET mitaka:age:1 18</span><br><span class="line">127.0.0.1:6379&gt; SET mitaka:age:2 28</span><br><span class="line">127.0.0.1:6379&gt; KEYS *</span><br><span class="line">1) &quot;mitaka:age:2&quot;</span><br><span class="line">2) &quot;mitaka:user:1&quot;</span><br><span class="line">3) &quot;mitaka:age:1&quot;</span><br><span class="line">4) &quot;mitaka:user:2&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>基本格式：[业务名称]:[数据名]:[id]，这样的话，可读性强，而且避免<code>key</code>冲突，方便管理；例如保存登录用户的信息<code>login:user:10</code></li>
<li>长度不超过44字节，节省内存，key是tring类型，底层编码包含<code>int</code>、<code>embstr</code>和<code>raw</code>三种，<code>embstr</code>在小于<code>44</code>字节使用，采用连续内存空间，占用内存更小</li>
<li>不包含特殊字符</li>
</ul>
<p class="fireman-p-indent" >下载Redis图形化客户端RDM，官网：</p>
<p class="fireman-p-indent" ><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlZGlzSW5zaWdodC9SZWRpc0Rlc2t0b3BNYW5hZ2Vy">https://github.com/RedisInsight/RedisDesktopManager<i class="fa fa-external-link-alt"></i></span></p>
<p class="fireman-p-indent" ><span class="exturl" data-url="aHR0cHM6Ly9yZXNwLmFwcC8=">https://resp.app/<i class="fa fa-external-link-alt"></i></span></p>
<p class="fireman-p-indent" ><span class="exturl" data-url="aHR0cHM6Ly9yZWRpcy5jb20vcmVkaXMtZW50ZXJwcmlzZS9yZWRpcy1pbnNpZ2h0LyNpbnNpZ2h0LWZvcm0=">https://redis.com/redis-enterprise/redis-insight/#insight-form<i class="fa fa-external-link-alt"></i></span></p>
<p class="fireman-p-indent" ><code>mac os m2</code>版本下载地址：<span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5yZWRpc2luc2lnaHQucmVkaXMuY29tL2xhdGVzdC9SZWRpc0luc2lnaHQtdjItbWFjLWFybTY0LmRtZw==">https://download.redisinsight.redis.com/latest/RedisInsight-v2-mac-arm64.dmg<i class="fa fa-external-link-alt"></i></span></p>
<p class="fireman-p-indent" >在<code>RDM</code>中可以看到类似目录层级结构</p>
<img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221206233251024.png" alt="image-20221206233251024" style="zoom:50%;" />

<h2 id="BigKey"><a href="#BigKey" class="headerlink" title="BigKey"></a>BigKey</h2><p class="fireman-p-indent" ><code>BigKey</code>通常以<code>Key</code>的大小和Key中成员的数量来综合判定：</p>
<ul>
<li><code>key</code>本身的数据量过大：例如，一个<code>string</code>类型的<code>key</code>，值为5MB</li>
<li><code>key</code>中的成员过多：例如，一个zset类型的<code>key</code>，成员数量为10000个</li>
<li><code>key</code>中成员的数量过大：例如，一个<code>hash</code>类型的<code>key</code>，成员虽然只有1000个，但是<code>Value</code>总大小为100MB</li>
</ul>
<p class="fireman-p-indent" >推荐值：</p>
<ul>
<li>单个<code>key</code>的<code>value</code>小于10KB</li>
<li>对于集合类型的key，建议元素数量小于1000</li>
</ul>
<p class="fireman-p-indent" >获取<code>key</code>占用的内存大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MEMORY USAGE a</span><br><span class="line">(integer) 48							// a占用48字节</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="BigKey的危害"><a href="#BigKey的危害" class="headerlink" title="BigKey的危害"></a><code>BigKey</code>的危害</h3><ul>
<li>网络阻塞：对<code>BigKey</code>请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis或者物理机变慢</li>
<li>数据倾斜：<code>BigKey</code>所在实例的内存使用率会超过其他实例，无法使数据分片的内存资源达到均衡</li>
<li>Redis阻塞：对元素较多的hash、list、zset等做运算时，会有更多的耗时，使主线程被阻塞</li>
<li>CPU压力：对<code>BigKey</code>的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其他应用</li>
</ul>
<p class="fireman-p-indent" >找到BigKey的方法：</p>
<ul>
<li><p><code>--big-keys</code>参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 --big-keys</span><br><span class="line"></span><br><span class="line">Unrecognized option or bad number of args for: &#x27;--big-keys&#x27;</span><br><span class="line">➜  ~ redis-cli -h 127.0.0.1 -p 6379 --bigkeys</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Scanning the entire keyspace to find biggest keys as well as</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">average sizes per key <span class="built_in">type</span>.  You can use -i 0.1 to <span class="built_in">sleep</span> 0.1 sec</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">per 100 SCAN commands (not usually needed).</span></span><br><span class="line"></span><br><span class="line">[00.00%] Biggest string found so far &#x27;mitaka:age:2&#x27; with 2 bytes</span><br><span class="line">[00.00%] Biggest stream found so far &#x27;stream1&#x27; with 44 entries</span><br><span class="line">[00.00%] Biggest string found so far &#x27;mitaka:user:2&#x27; with 6 bytes</span><br><span class="line"></span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 9 keys in the keyspace!</span><br><span class="line">Total key length in bytes is 62 (avg len 6.89)</span><br><span class="line"></span><br><span class="line">Biggest string found &#x27;mitaka:user:2&#x27; has 6 bytes		//	这个类型占用最大的内存</span><br><span class="line">Biggest stream found &#x27;stream1&#x27; has 44 entries</span><br><span class="line"></span><br><span class="line">0 lists with 0 items (00.00% of keys, avg size 0.00)</span><br><span class="line">0 hashs with 0 fields (00.00% of keys, avg size 0.00)</span><br><span class="line">8 strings with 16 bytes (88.89% of keys, avg size 2.00)</span><br><span class="line">1 streams with 44 entries (11.11% of keys, avg size 44.00)</span><br><span class="line">0 sets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">0 zsets with 0 members (00.00% of keys, avg size 0.00)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>SCAN</code>扫描，然后逐个判断</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCAN 0 	// 0 是角标</span><br><span class="line">1) <span class="string">&quot;0&quot;</span>		// 这里是下次扫描的角标，0代表扫描完了</span><br><span class="line">2) 1) <span class="string">&quot;mitaka:age:2&quot;</span></span><br><span class="line">   2) <span class="string">&quot;mitaka:user:1&quot;</span></span><br><span class="line">   3) <span class="string">&quot;c&quot;</span></span><br><span class="line">   4) <span class="string">&quot;b1&quot;</span></span><br><span class="line">   5) <span class="string">&quot;stream1&quot;</span></span><br><span class="line">   6) <span class="string">&quot;mitaka:user:2&quot;</span></span><br><span class="line">   7) <span class="string">&quot;a&quot;</span></span><br><span class="line">   8) <span class="string">&quot;mitaka:age:1&quot;</span></span><br><span class="line">   9) <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第三方工具，<a target="_blank" rel="noopener" href="https://github.com/sripathikrishnan/redis-rdb-tools"><code>Redis-Rdb-Tools</code></a>分析<code>RDB</code>快照文件，全面分析内存使用情况，或者封装<code>SCAN</code>命令和一系列的判断逻辑，或者使用<code>LUA</code>脚本</p>
</li>
<li><p>网络监控，监控进出Redis的网络数据，超出预警值时主动告警</p>
</li>
</ul>
<h3 id="删除BigKey"><a href="#删除BigKey" class="headerlink" title="删除BigKey"></a>删除<code>BigKey</code></h3><p class="fireman-p-indent" ><code>BigKey</code>占用内存较多，删除时也会消耗很长时间，导致Redis主线程阻塞，引发一系列问题。</p>
<ul>
<li><p>Redis 3.0及以下版本：如果是集合类型，则便利<code>BigKey</code>的元素，先逐个删除子元素，最后删除<code>BigKey</code></p>
</li>
<li><p>Redis 4.0以后：提供了异步删除的命令，<code>unlink</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; UNLINK stream1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; KEYS stream*</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="恰当的数据类型"><a href="#恰当的数据类型" class="headerlink" title="恰当的数据类型"></a>恰当的数据类型</h3><p class="fireman-p-indent" >使用恰当的数据类型将<code>BigKey</code>转换成小<code>key</code>是一种更加推荐解决<code>BigKey</code>的方法</p>
<p class="fireman-p-indent" >一个有100万个<code>key</code>的<code>hash</code>，是一个<code>BigKey</code></p>
<p class="fireman-p-indent" >方案1：通过<code>json</code>序列化后存储到<code>string</code>中；这种方式，会占用更大的内存，数据耦合，而且还是一个<code>BigKey</code></p>
<p class="fireman-p-indent" >方案2：打散存储到<code>string</code>中；这种也会占用更大内存，而且没法做到统一控制</p>
<p class="fireman-p-indent" >方案3：将大划小，通过<code>id/100</code>作为<code>key</code>，分为1万个<code>hash</code>，每个<code>hash</code>中只有<code>100</code>个键值对。</p>
<h2 id="集群模式下的批处理"><a href="#集群模式下的批处理" class="headerlink" title="集群模式下的批处理"></a>集群模式下的批处理</h2><p class="fireman-p-indent" >批量执行命令可以使用<code>pipeline</code>，节省<code>client</code>到<code>server</code>之间的网络时间。但是加集群模式下，由于<code>key</code>会进行<code>hash</code>然后取模，可能会放到不同的<code>slot</code>中。而批处理是一个网络连接，如果使用不同的<code>slot</code>，则会使用多个网络连接。</p>
<p class="fireman-p-indent" >在集群模式下，批处理命令的多个<code>key</code>比如落在一个<code>slot</code>中，否则会执行失败。</p>
<p class="fireman-p-indent" >解决方案</p>
<ul>
<li><p>串行命令：</p>
<p>实现思路：<code>for</code>循环遍历，依次执行每个命令</p>
<p>这种方案其实不是批处理，还是单次处理</p>
</li>
<li><p>串行<code>slot</code>：</p>
<p>实现思路：客户端计算每个<code>key</code>的<code>slot</code>，然后将一致的<code>slot</code>分为一组，使用<code>pipeline</code>串行处理</p>
<p>这种方案逻辑处理会有些复杂，而且<code>slot</code>越多，耗时越久。</p>
</li>
<li><p>并行<code>slot</code>：</p>
<p>实现思路：在串行<code>slot</code>的基础上，改为并行处理，</p>
<p>这种方案实现更加复杂</p>
</li>
<li><p><code>hash_tag</code></p>
<p>实现思路：将所有<code>key</code>设置相同的<code>hash_tag</code>，则所有<code>key</code>的<code>slot</code>一定相同</p>
<p>这种方案容易出现数据倾斜，但是耗时短，实现简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MSET &#123;a&#125;name xu &#123;a&#125;age 18</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li>
</ul>
<p class="fireman-p-indent" >相比而言，推荐使用并行<code>slot</code></p>
<h2 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h2><p class="fireman-p-indent" >持久化配置优化：</p>
<ul>
<li>用来做缓存的Redis实例，尽量不要开启持久化功能</li>
<li>建议关闭RDB，只使用AOF持久化</li>
<li>利用脚本定期在Slave节点做RDB，实现数据备份</li>
<li>设置合理的<code>rewrite</code>阈值，避免频繁<code>bgrewrite</code></li>
<li>配置<code>no-appendfsync-on-rewrite=yes</code>，禁止在<code>rewrite</code>期间做AOF，避免因AOF引起的阻塞</li>
</ul>
<p class="fireman-p-indent" >部署相关建议：</p>
<ul>
<li>物理机需要预留内存，用于<code>fork</code>和<code>rewrite</code>的线程</li>
<li>单个实例内存不建议太大，例如4GB或者8GB，可以加快<code>fork</code>的速度，减少主从同步、数据迁移压力</li>
<li>不要与CPU密集型应用部署在一起</li>
<li>不要与高硬盘负载应用一起部署，例如数据库、消息队列</li>
</ul>
<h2 id="Redis作为缓存"><a href="#Redis作为缓存" class="headerlink" title="Redis作为缓存"></a>Redis作为缓存</h2><p class="fireman-p-indent" >场景例如用于存储<code>session</code>，例如用户登录的<code>token</code>，需要认证的接口可通过客户传过来的<code>token</code>即可完成验证，不需要再次使用用户名密码通过查询数据库验证。</p>
<p class="fireman-p-indent" >相对于存储在本地进程，使用Redis可以实现分布式服务认证。</p>
<p class="fireman-p-indent" >每次使用token成功认证后，刷新<code>token</code>过期时间，以延长<code>token</code>过期时间。</p>
<p class="fireman-p-indent" >这里介绍另外一种缓存，记录一些常用的数据。例如某些文件目录下的信息，缓存高频目录的信息，可以减少数据库的压力。</p>
<p class="fireman-p-indent" >服务端配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Required</span></span><br><span class="line"><span class="comment">##########</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set a memory usage limit to the specified amount of bytes.</span></span><br><span class="line"><span class="comment"># When the memory limit is reached Redis will try to remove keys</span></span><br><span class="line"><span class="comment"># according to the eviction policy selected (see maxmemory-policy).</span></span><br><span class="line">maxmemory 100mb</span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional</span></span><br><span class="line"><span class="comment">##########</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Evict any key using approximated LFU when maxmemory is reached.</span></span><br><span class="line">maxmemory-policy allkeys-lfu</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable active memory defragmentation.</span></span><br><span class="line">activedefrag <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Don&#x27;t save data on the disk because we can afford to lose cached data.</span></span><br><span class="line">save <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >使用缓存</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr: <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// redis 客户端配置</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	mycache := cache.New(&amp;cache.Options&#123;</span><br><span class="line">		Redis:      rdb,                                <span class="comment">// 缓存配置</span></span><br><span class="line">		LocalCache: cache.NewTinyLFU(<span class="number">100</span>, time.Minute), <span class="comment">// 使用本地缓存，缓存使用lfu算法，本地最大存储100个，保存1分钟</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	obj := <span class="built_in">new</span>(Object)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123; <span class="comment">//存放100个</span></span><br><span class="line">		err := mycache.Once(&amp;cache.Item&#123; <span class="comment">// set之前会get一下，如果key存在，则不存储新的value</span></span><br><span class="line">			Key:   <span class="string">&quot;mykey&quot;</span> + strconv.Itoa(i),</span><br><span class="line">			Value: obj, <span class="comment">// destination</span></span><br><span class="line">			Do: <span class="function"><span class="keyword">func</span><span class="params">(*cache.Item)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123; <span class="comment">// 将Object作为Value存储</span></span><br><span class="line">				<span class="keyword">return</span> &amp;Object&#123;</span><br><span class="line">					Str: <span class="string">&quot;mystring123123&quot;</span>,</span><br><span class="line">					Num: <span class="number">421</span>,</span><br><span class="line">				&#125;, <span class="literal">nil</span></span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p class="fireman-p-indent" >在Redis中，执行时耗时超过某个阈值的命令，称为慢查询。也就是无论读还是写，超时了就是慢查询。</p>
<p class="fireman-p-indent" >慢查询的阈值可以通过配置指定：</p>
<ul>
<li><code>slowlog-log-slower-than</code>：慢查询阈值，单位ms，默认10000，也就是10s，建议1000</li>
</ul>
<p class="fireman-p-indent" >超过阈值的的操作会被记录到慢查询日志中，日志长度有上限</p>
<ul>
<li><code>slowlog-max-len</code>：慢查询日志（本质是一个队列）长度，默认128，建议1000</li>
</ul>
<p class="fireman-p-indent" >查看慢查询</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLOWLOG get 1				// 获取1个慢查询</span><br><span class="line">1) 1) (<span class="built_in">integer</span>) 3										// 日志编号</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1670426153					// 加入日志是的时间戳</span><br><span class="line">   3) (<span class="built_in">integer</span>) 13415								// 慢查询耗时</span><br><span class="line">   4) 1) <span class="string">&quot;info&quot;</span>											// 慢查询命令</span><br><span class="line">   5) <span class="string">&quot;172.17.0.1:62882&quot;</span>						// 客户端地址</span><br><span class="line">   6) <span class="string">&quot;redisinsight-common-c22f7437&quot;</span>	// 客户端名称</span><br><span class="line">127.0.0.1:6379&gt; SLOWLOG len					// 慢查询当前长度</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; SLOWLOG reset				// 清理慢查询队列</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h2 id="内存配置"><a href="#内存配置" class="headerlink" title="内存配置"></a>内存配置</h2><p class="fireman-p-indent" >当Redis内存不足时，可能导致<code>key</code>频繁被删除、响应时间变长，QPS不稳定等问题。当内存使用率达到90%以上时就需要警惕，并快速定位到内存占用的原因。</p>
<p class="fireman-p-indent" >内存占用有这几种</p>
<ul>
<li>数据内存：是Redis主要部分，存储Redis的键值信息，主要问题是<code>BigKey</code>的问题，内存碎片问题</li>
<li>进程内存：Redis主进程本身运行肯定需要内存，例如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略</li>
<li>缓冲区内存：一般包括客户端缓冲区、AOF缓冲区（AOF刷盘前的缓存区域）、复制缓冲区（用于主从复制，如果过小，会导致全量复制）等。客户端缓冲区又包括输入输出缓冲区两种。这部分内存占用波动较大，不当使用<code>BigKey</code>，可能导致内存溢出。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INFO memory				// 查看内存占用信息</span><br><span class="line"># Memory</span><br><span class="line">used_memory:2060856								// 内存占用总量</span><br><span class="line">used_memory_human:1.97M</span><br><span class="line">used_memory_rss:9383936</span><br><span class="line">used_memory_rss_human:8.95M</span><br><span class="line">used_memory_peak:2179296</span><br><span class="line">used_memory_peak_human:2.08M</span><br><span class="line">used_memory_peak_perc:94.57%</span><br><span class="line">used_memory_overhead:925920</span><br><span class="line">used_memory_startup:895680</span><br><span class="line">used_memory_dataset:1134936</span><br><span class="line">used_memory_dataset_perc:97.40%</span><br><span class="line">allocator_allocated:2252760</span><br><span class="line">allocator_active:8912896</span><br><span class="line">allocator_resident:10420224</span><br><span class="line">total_system_memory:8232894464</span><br><span class="line">total_system_memory_human:7.67G</span><br><span class="line">used_memory_lua:31744</span><br><span class="line">used_memory_vm_eval:31744</span><br><span class="line">used_memory_lua_human:31.00K</span><br><span class="line">used_memory_scripts_eval:0</span><br><span class="line">number_of_cached_scripts:0</span><br><span class="line">number_of_functions:0</span><br><span class="line">number_of_libraries:0</span><br><span class="line">used_memory_vm_functions:32768</span><br><span class="line">used_memory_vm_total:64512</span><br><span class="line">used_memory_vm_total_human:63.00K</span><br><span class="line">used_memory_functions:184</span><br><span class="line">used_memory_scripts:184</span><br><span class="line">used_memory_scripts_human:184B</span><br><span class="line">maxmemory:0</span><br><span class="line">maxmemory_human:0B</span><br><span class="line">maxmemory_policy:noeviction</span><br><span class="line">allocator_frag_ratio:3.96</span><br><span class="line">allocator_frag_bytes:6660136</span><br><span class="line">allocator_rss_ratio:1.17</span><br><span class="line">allocator_rss_bytes:1507328</span><br><span class="line">rss_overhead_ratio:0.90</span><br><span class="line">rss_overhead_bytes:-1036288</span><br><span class="line">mem_fragmentation_ratio:4.60</span><br><span class="line">mem_fragmentation_bytes:7342728</span><br><span class="line">mem_not_counted_for_evict:0</span><br><span class="line">mem_replication_backlog:0</span><br><span class="line">mem_total_replication_buffers:0</span><br><span class="line">mem_clients_slaves:0</span><br><span class="line">mem_clients_normal:29496</span><br><span class="line">mem_cluster_links:0</span><br><span class="line">mem_aof_buffer:0</span><br><span class="line">mem_allocator:jemalloc-5.2.1</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br><span class="line">lazyfreed_objects:0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MEMORY DOCTOR				// 内存检查医生</span><br><span class="line">Hi Sam, this instance is empty or is using very little memory, my issues detector can&#x27;t be used in these conditions. Please, leave for your mission on Earth and fill it with some data. The new Sam and I will be back to our programming as soon as I finished rebooting.</span><br><span class="line">127.0.0.1:6379&gt; MEMORY MALLOC-STATS	// 内存分配状态，Redis使用jemalloc分配内存</span><br><span class="line">___ Begin jemalloc statistics ___</span><br><span class="line">Version: &quot;5.2.1-0-g0&quot;</span><br><span class="line">... 省略部分信息</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MEMORY STATS</span><br><span class="line">&#x27; 1) &quot;peak.allocated&quot;						// Redis启动后消耗内存的峰值</span><br><span class="line"> 2) (integer) 2179296</span><br><span class="line"> 3) &quot;total.allocated&quot;						// 分配器分配的总字节数，也就是当前的总内存使用量</span><br><span class="line"> 4) (integer) 2110112</span><br><span class="line"> 5) &quot;startup.allocated&quot;					// 启动时消耗的初始内存量</span><br><span class="line"> 6) (integer) 895680</span><br><span class="line"> 7) &quot;replication.backlog&quot;				// 复制积压缓冲区的大小</span><br><span class="line"> 8) (integer) 0</span><br><span class="line"> 9) &quot;clients.slaves&quot;						// 主从复制中所有从节点的读写缓冲区大小</span><br><span class="line">10) (integer) 0</span><br><span class="line">11) &quot;clients.normal&quot;						// 除从节点外，所有其他客户端的读写缓冲区大小</span><br><span class="line">12) (integer) 29496</span><br><span class="line">13) &quot;cluster.links&quot;</span><br><span class="line">14) (integer) 0	</span><br><span class="line">15) &quot;aof.buffer&quot;								// AOF持久化使用的缓存和AOF重写时产生的缓存</span><br><span class="line">16) (integer) 0</span><br><span class="line">17) &quot;lua.caches&quot;</span><br><span class="line">18) (integer) 0</span><br><span class="line">19) &quot;functions.caches&quot;</span><br><span class="line">20) (integer) 184</span><br><span class="line">21) &quot;db.0&quot;												// 数据库0的信息</span><br><span class="line">22) 1) &quot;overhead.hashtable.main&quot;										// 数据库的hash链表开销内存综合，即元数据内存</span><br><span class="line">    2) (integer) 528</span><br><span class="line">    3) &quot;overhead.hashtable.expires&quot;									// 用于存储key过期时间所消耗的内存</span><br><span class="line">    4) (integer) 32</span><br><span class="line">    5) &quot;overhead.hashtable.slot-to-keys&quot;</span><br><span class="line">    6) (integer) 0</span><br><span class="line">23) &quot;overhead.total&quot;						// 等于 startup.allocated + replication.backlog + clients.slaves + clients.normal + aof.buffer + db.x</span><br><span class="line">24) (integer) 925920</span><br><span class="line">25) &quot;keys.count&quot;								// 当前key总数</span><br><span class="line">26) (integer) 10</span><br><span class="line">27) &quot;keys.bytes-per-key&quot;				// 每个key的平均大小，（total.allocated - startup.allocated）/ keys.count</span><br><span class="line">28) (integer) 121443</span><br><span class="line">29) &quot;dataset.bytes&quot;</span><br><span class="line">30) (integer) 1184192</span><br><span class="line">31) &quot;dataset.percentage&quot;</span><br><span class="line">32) &quot;97.50994873046875&quot;</span><br><span class="line">33) &quot;peak.percentage&quot;</span><br><span class="line">34) &quot;96.825393676757812&quot;</span><br><span class="line">35) &quot;allocator.allocated&quot;</span><br><span class="line">36) (integer) 2919320</span><br><span class="line">37) &quot;allocator.active&quot;</span><br><span class="line">38) (integer) 10223616</span><br><span class="line">39) &quot;allocator.resident&quot;</span><br><span class="line">40) (integer) 11730944</span><br><span class="line">41) &quot;allocator-fragmentation.ratio&quot;</span><br><span class="line">42) &quot;3.50205397605896&quot;</span><br><span class="line">43) &quot;allocator-fragmentation.bytes&quot;</span><br><span class="line">44) (integer) 7304296</span><br><span class="line">45) &quot;allocator-rss.ratio&quot;</span><br><span class="line">46) &quot;1.1474359035491943&quot;</span><br><span class="line">47) &quot;allocator-rss.bytes&quot;</span><br><span class="line">48) (integer) 1507328</span><br><span class="line">49) &quot;rss-overhead.ratio&quot;</span><br><span class="line">50) &quot;0.81145250797271729&quot;</span><br><span class="line">51) &quot;rss-overhead.bytes&quot;</span><br><span class="line">52) (integer) -2211840</span><br><span class="line">53) &quot;fragmentation&quot;</span><br><span class="line">54) &quot;4.5555543899536133&quot;</span><br><span class="line">55) &quot;fragmentation.bytes&quot;</span><br><span class="line">56) (integer) 7429544</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MEMORY help</span><br><span class="line"> 1) MEMORY &lt;subcommand&gt; [&lt;arg&gt; [value] [opt] ...]. Subcommands are:</span><br><span class="line"> 2) DOCTOR</span><br><span class="line"> 3)     Return memory problems reports.</span><br><span class="line"> 4) MALLOC-STATS</span><br><span class="line"> 5)     Return internal statistics report from the memory allocator.</span><br><span class="line"> 6) PURGE</span><br><span class="line"> 7)     Attempt to purge dirty pages for reclamation by the allocator. 尝试清除脏页以供分配器回收。</span><br><span class="line"> 8) STATS</span><br><span class="line"> 9)     Return information about the memory usage of the server. 返回有关服务器内存使用情况的信息。</span><br><span class="line">10) USAGE &lt;key&gt; [SAMPLES &lt;count&gt;] </span><br><span class="line">11)     Return memory in bytes used by &lt;key&gt; and its value. Nested values are	// 查看某个key占用的内存</span><br><span class="line">12)     sampled up to &lt;count&gt; times (default: 5, 0 means sample all).</span><br><span class="line">13) HELP</span><br><span class="line">14)     Prints this help.</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >查看客户端信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CLIENT LIST</span><br><span class="line">id=67 addr=172.17.0.1:62398 laddr=172.17.0.2:6379 fd=8 name= age=69848 idle=0 flags=N db=0 sub=0 psub=0 ssub=0 multi=-1 qbuf=26 qbuf-free=20448 argv-mem=10 multi-mem=0 rbs=1024 rbp=0 obl=0 oll=0 omem=0 tot-mem=22298 events=r cmd=client|list user=default redir=-1 resp=2</span><br><span class="line">id=11 addr=172.17.0.1:65126 laddr=172.17.0.2:6379 fd=10 name=redisinsight-auto-discovery age=151134 idle=151134 flags=N db=0 sub=0 psub=0 ssub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 multi-mem=0 rbs=1024 rbp=0 obl=0 oll=0 omem=0 tot-mem=1800 events=r cmd=info user=default redir=-1 resp=2</span><br><span class="line">id=66 addr=172.17.0.1:57476 laddr=172.17.0.2:6379 fd=14 name= age=70274 idle=70254 flags=N db=0 sub=0 psub=0 ssub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 multi-mem=0 rbs=1024 rbp=0 obl=0 oll=0 omem=0 tot-mem=1800 events=r cmd=xreadgroup user=default redir=-1 resp=2</span><br><span class="line">id=14 addr=172.17.0.1:62882 laddr=172.17.0.2:6379 fd=11 name=redisinsight-common-c22f7437 age=151095 idle=1 flags=N db=0 sub=0 psub=0 ssub=0 multi=-1 qbuf=0 qbuf-free=20474 argv-mem=0 multi-mem=0 rbs=2048 rbp=1024 obl=0 oll=0 omem=0 tot-mem=23296 events=r cmd=info user=default redir=-1 resp=2</span><br><span class="line">id=72 addr=172.17.0.1:65270 laddr=172.17.0.2:6379 fd=12 name=redisinsight-common-c22f7437 age=12021 idle=12021 flags=P db=0 sub=0 psub=1 ssub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 multi-mem=0 rbs=1024 rbp=0 obl=0 oll=0 omem=0 tot-mem=1824 events=r cmd=psubscribe user=default redir=-1 resp=2</span><br></pre></td></tr></table></figure>

<h2 id="主从还是集群"><a href="#主从还是集群" class="headerlink" title="主从还是集群"></a>主从还是集群</h2><p class="fireman-p-indent" >主从模式和集群模式，都可以实现Redis高可用方案，但是在两者选择上，还是有些侧重点。</p>
<p class="fireman-p-indent" >集群虽然具备高可用特性，也可以实现自动故障恢复，但是使用上有一些限制：</p>
<ul>
<li>集群完整性问题：缺少<code>slot</code>之后，是否能够服务，需要通过配置设置</li>
<li>集群宽带问题：集群节点和节点之间需要较大的网络带宽</li>
<li>数据倾斜问题：分配slot不均或者<code>pipeline</code>时会导致数据倾斜</li>
<li>客户端性能问题</li>
<li>命令的集群兼容性问题</li>
<li>lua和事务问题</li>
</ul>
<p class="fireman-p-indent" >因此，如果主从能够满足业务需求的情况下，尽量不要搭建<code>Redis</code>集群。</p>
<h1 id="使用场景的补充"><a href="#使用场景的补充" class="headerlink" title="使用场景的补充"></a>使用场景的补充</h1><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p class="fireman-p-indent" >为了解决缓存一致性的问题，更新数据库之后，还需要更新缓存。</p>
<h3 id="更新对比删除"><a href="#更新对比删除" class="headerlink" title="更新对比删除"></a>更新对比删除</h3><p class="fireman-p-indent" >更新数据库之后，是使用更新缓存还是使用删除缓存？</p>
<ul>
<li><p>更新会出现的两种情况</p>
<ol>
<li>先更新数据库，再更新缓存</li>
</ol>
<p class="fireman-p-indent" >   <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207153120913.png" alt="image-20221207153120913"></p>
<p class="fireman-p-indent" >   此时，这种不一致，只能等到下次更新缓存的时候才能解决。</p>
<ol start="2">
<li><p>先更新缓存，再更新数据库</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207153255458.png" alt="image-20221207153255458"></p>
<p>通常情况下，更新缓存再更新数据库是要避免的一种手段</p>
</li>
</ol>
<p class="fireman-p-indent" >相比而言，使用更新缓存，数据不一致的情况比较多。</p>
</li>
<li><p class="fireman-p-indent" >删除缓存会出现的两种情况</p>
<ol>
<li><p>先删除缓存，再更新数据库</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207153551158.png" alt="image-20221207153551158"></p>
<p>这种情况也有另外一个解决方案，那就是<strong>延迟双删</strong>，在更新请求完成之后，将缓存删除</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207154759309.png" alt="image-20221207154759309"></p>
<p>这种解决思路的关键在于对 N 的时间的判断，如果 N 时间太短，线程 A 第二次删除缓存的时间依旧早于线程 B 把脏数据写回缓存的时间，那么相当于做了无用功。而 N 如果设置得太长，那么在触发双删之前，新请求看到的都是脏数据。</p>
</li>
<li><p>更新数据库后删除缓存</p>
<p>也就是延迟双删的思路中，在更新数据库之后将缓存删除</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207154933719.png" alt="image-20221207154933719"></p>
<p>线程C在T2时间段获取到的数据会不一致，但是其实这个时间是非常短的。</p>
<p>但是还有一种情况可能出现数据不一致的情况</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207155218114.png" alt="image-20221207155218114"></p>
<p>总的来说，这个不一致场景出现条件非常严格，因为并发量很大时，缓存不太可能不存在；如果并发很大，而缓存真的不存在，那么很可能是这时的写场景很多，因为写场景会删除缓存。</p>
</li>
</ol>
</li>
</ul>
<p class="fireman-p-indent" >对比四种更新策略：</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221207155303812.png" alt="image-20221207155303812"></p>
<p class="fireman-p-indent" ><strong>从一致性的角度来看，采取更新数据库后删除缓存值，是更为适合的策略。</strong>因为出现不一致的场景的条件更为苛刻，概率相比其他方案更低。</p>
<p class="fireman-p-indent" >做个简单总结，足以适应绝大部分的互联网开发场景的决策：</p>
<ul>
<li><strong>针对大部分读多写少场景，建议选择更新数据库后删除缓存的策略。</strong></li>
<li><strong>针对读写相当或者写多读少的场景，建议选择更新数据库后更新缓存的策略。</strong></li>
</ul>
<p class="fireman-p-indent" >为了避免这种不一致性永久存在，使用缓存的时候，我们必须要给缓存设置一个过期时间，例如 1 分钟，这样即使出现了更新 Redis 失败的极端场景，不一致的时间窗口最多也只是 1 分钟。</p>
<p class="fireman-p-indent" >这是我们最终一致性的兜底方案，万一出现任何情况的不一致问题，最后都能通过缓存失效后重新查询数据库，然后回写到缓存，来做到缓存与数据库的最终一致。</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p class="fireman-p-indent" >缓存穿透是指缓存中没有存储访问的数据，缓存永远不生效，请求穿透缓存，打到数据库上。例如访问一些不存在的用户id。</p>
<p class="fireman-p-indent" >解决方案：</p>
<ol>
<li>将数据库不存在的数据也缓存下来：缺点是会有额外的内存消耗，而且可能造成短期的不一致；</li>
<li>将用户id的复杂度加大，避免推断</li>
<li>使用布隆过滤器，服务启动之前，将所有的数据加载到布隆过滤器中，进行缓存之前先判断在布隆过滤器中是否已经存在；缺点是实现复杂，存在误判可能</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p class="fireman-p-indent" >缓存雪崩是指当大量缓存数据在同一时间过期，或者Redis单机，大量缓存数据失效，数据库压力瞬间增大，导致影响到其他的服务，引起雪崩效应。</p>
<p class="fireman-p-indent" >解决方案：</p>
<ol>
<li>给不同的key设置随机的TTL</li>
<li>利用Redis集群的高可用性</li>
<li>给缓存的业务添加降级限流策略</li>
<li>给业务增加多级缓存</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p class="fireman-p-indent" >缓存击穿也叫做热key问题，是指热<code>key</code>（被高并发访问并且缓存重建业务较复杂的key）失效，相同的请求透过缓存，直接打到数据库，大流量导致数据库也无法承担。</p>
<p class="fireman-p-indent" >解决方案：</p>
<ol>
<li>互斥锁：当发现缓存过期，需要从数据库获取数据时，先获取锁，获取锁之后才访问数据库；如果没有获取锁，则休眠一段时间再次重试在缓存中获取数据，没有的话，再次尝试获取锁；缺点是线程需要等待，性能会收到影响，而且可能有死锁的风险</li>
<li>逻辑过期：将热key过期后的数据也缓存起来，作为老数据，当新数据失效时，返回老数据，通过子进程获取互斥锁，新数据放到缓存中，然后释放锁。其他的进程没有访问到老数据也没有获取到锁时，则直接返回老数据；解决了线程等待的问题，性能好，缺点是不保证一致性，有额外的内存，而且实现复杂</li>
</ol>
<h2 id="全局ID生成策略"><a href="#全局ID生成策略" class="headerlink" title="全局ID生成策略"></a>全局ID生成策略</h2><p class="fireman-p-indent" >全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，要满足的特性：</p>
<ul>
<li>唯一性</li>
<li>高可用</li>
<li>递增性</li>
<li>安全性</li>
<li>高性能</li>
</ul>
<p class="fireman-p-indent" >实现方式可以有以下几种</p>
<ul>
<li>UUID：通过时间戳+机器号+随机值生成，可以实现全局唯一，并且自增</li>
<li>Redis自增：通过Redis自增，来替代时间戳，通过Redis自增+机器号+时间日期，可以实现全局以为一，并且自增</li>
<li><code>snowflake</code>算法：雪花算法</li>
<li>数据库自增：类似于UUID，自增主键</li>
</ul>
<p class="fireman-p-indent" >Redis自增ID策略：</p>
<ul>
<li>每天一个key，方便统计订单量</li>
<li>ID构造是 时间戳 + 计数器</li>
</ul>
<h2 id="对比分布式锁的实现方式‘"><a href="#对比分布式锁的实现方式‘" class="headerlink" title="对比分布式锁的实现方式‘"></a>对比分布式锁的实现方式‘</h2><p class="fireman-p-indent" >分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>
<p class="fireman-p-indent" >特点：</p>
<ul>
<li>多进程可见</li>
<li>互斥</li>
<li>高可用</li>
<li>高性能</li>
<li>安全性</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>MySQL</th>
<th>Redis</th>
<th>Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td>互斥</td>
<td>利用MySQL本身的互斥锁机制</td>
<td>利用setnx</td>
<td>利用节点唯一性和有序性实现互斥</td>
</tr>
<tr>
<td>高可用</td>
<td>好</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>高性能</td>
<td>一般</td>
<td>好</td>
<td>一般</td>
</tr>
<tr>
<td>安全性</td>
<td>断开连接，自动释放锁</td>
<td>利用过期时间，到期释放</td>
<td>临时节点，断开连接自动释放</td>
</tr>
</tbody></table>
<h2 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a>关注推送</h2><p class="fireman-p-indent" >关注推送也叫做<code>Feed</code>流，直译为投喂。为用户持续的提供<strong>沉浸式</strong>的体验，通过无限下拉刷新获取新的消息。例如刷朋友圈、微博、抖音。</p>
<p class="fireman-p-indent" ><code>Feed</code>流常见的两种模式：</p>
<ul>
<li><code>TimeLine</code>：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注，例如朋友圈<ul>
<li>优点：信息全面，不会有缺失；实现相对简单</li>
<li>缺点：信息噪音较多，用户不一定感兴趣；内容获取效率低</li>
</ul>
</li>
<li>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户感兴趣信息来吸引用户，例如微博、抖音<ul>
<li>优点：投喂用户感兴趣信息，用户粘性很高，容易沉迷</li>
<li>缺点：如果算法不精确，可能引起反作用</li>
</ul>
</li>
</ul>
<p class="fireman-p-indent" >实现方案有三种：</p>
<ul>
<li>拉模式：也叫做读扩散，用户从服务端拉取关注的人发送的信息；<ul>
<li>优点：节省空间，保存发送者的数据即可；</li>
<li>缺点：耗费时间，用户通过时间戳拉取数据，每次都要拉取所有数据，然后排序</li>
</ul>
</li>
<li>推模式：服务器将信息发送扩散给所有的用户；<ul>
<li>优点：快，用户获取自己收件箱中的数据即可</li>
<li>缺点：信息占用空间大，每一个消息以关注人数翻倍</li>
</ul>
</li>
<li>推拉结合：将拉模式和推模式结合，针对活跃关注数少（千万级）的人使用推模式，关注的人比较少的用户使用拉模式。</li>
</ul>
<h2 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h2><p class="fireman-p-indent" >在超高并发的场景下，传统缓存方案可能在缓存失效的情况，或者中间层服务无法支撑请求的情况，此时可以使用多级缓存，充分利用请求处理的每个环节，分别添加缓存，减轻中间层压力，提升服务性能，并且避免缓存失效后请求打到数据库上。</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208144829613.png" alt="image-20221208144829613"></p>
<p class="fireman-p-indent" >进程缓存，例如上述Redis作为缓存章节中，使用本地缓存。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p class="fireman-p-indent" >Redis底层使用以下几种数据结构，在这几种数据结构之上，表现为五种数据使用形式。</p>
<ul>
<li>动态字符串SDS</li>
<li>IntSet</li>
<li>Dict</li>
<li>ZipList</li>
<li>QuickList</li>
<li>SkipList</li>
<li>RedisObject</li>
</ul>
<h2 id="动态字符串SDS"><a href="#动态字符串SDS" class="headerlink" title="动态字符串SDS"></a>动态字符串SDS</h2><p class="fireman-p-indent" >Redis中保存的key是字符串，value往往是字符串或者字符串的集合。</p>
<p class="fireman-p-indent" >Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：</p>
<ul>
<li>获取字符串长度需要通过运算</li>
<li>非二进制安全</li>
<li>不可修改</li>
</ul>
<p class="fireman-p-indent" >在这个基础上，Redis构建一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET hello 世界</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >创建两个SDS，一个是<code>hello</code>，一个是<code>世界</code>。</p>
<p class="fireman-p-indent" ><code>src/sds.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span> 	 <span class="comment">/* 已保存字符串字节数，不包含约束标识\n */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span> <span class="comment">/* 申请的总字节数，不包含结束标识\n */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span>  <span class="comment">/* 不同的SDS的头类型，用来控制SDS的头大小 */</span></span><br><span class="line">    <span class="type">char</span> buf[];	<span class="comment">/*数据体*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >例如一个包含字符串<code>name</code>的SDS结构如下：</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208211113618.png" alt="image-20221208211113618"></p>
<p class="fireman-p-indent" >结构体中的字段，是连续的内存空间。</p>
<h3 id="SDS扩容"><a href="#SDS扩容" class="headerlink" title="SDS扩容"></a>SDS扩容</h3><p class="fireman-p-indent" >SDS之所以叫做动态字符串，是因为具备动态扩容的能力。例如在<code>name</code>后面再追加字符串，这里会申请新内存空间：</p>
<ul>
<li>如果新字符串小于1M，则新空间<strong>扩展后字符串长度</strong>的两倍<code>+1</code>；</li>
<li>如果新字符串大于1M，则新空间<strong>扩展后字符串</strong>长度<code>+1M</code>.称为内存预分配</li>
</ul>
<h2 id="整数集合IntSet"><a href="#整数集合IntSet" class="headerlink" title="整数集合IntSet"></a>整数集合IntSet</h2><p class="fireman-p-indent" >IntSet是Redis中<code>set</code>集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。</p>
<p class="fireman-p-indent" ><code>src/intset.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;  <span class="comment">/* 编码方式，支持存放16位、32位、64位整数 */</span></span><br><span class="line">    <span class="type">uint32_t</span> length;		<span class="comment">/* 元素个数 */</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];	<span class="comment">/* 整数数组，保存集合数据，长度通过encoding指定，是2字节、4字节、8字节*/</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><code>encoding</code>包含三种模式，表示存储的整数大小不同：</p>
<p class="fireman-p-indent" ><code>src/intset.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note that these encodings are ordered, so:</span></span><br><span class="line"><span class="comment"> * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))				<span class="comment">// 2字节整数，2^16</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))				<span class="comment">// 4字节整数，2^32</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))				<span class="comment">// 8字节整数，2^64</span></span></span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >为了方便查找，Redis会将IntSet中所有的整数按照升序一次保存在<code>contents</code>数组中，结构如图：</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208211958051.png" alt="image-20221208211958051"></p>
<p class="fireman-p-indent" >数组中，数字5、10、20都在2^16以内，因此<code>encoding</code>使用<code>INTSET_ENC_INT16</code>，长度是3，数组中每个元素占用2个字节。</p>
<h3 id="IntSet动态升级"><a href="#IntSet动态升级" class="headerlink" title="IntSet动态升级"></a>IntSet动态升级</h3><p class="fireman-p-indent" >此时，IntSet每个元素占据2个字节，如果新插入数据，而且数据需要4个字节，超过<code>int16_t</code>的范围，IntSet会自动升级编码方式到合适的大小。流程如下：</p>
<ol>
<li>升级编码为<code>INTSET_ENC_INT32</code>，每个整数占4个字节，并按照新的编码方式及元素个数扩容数组（是扩容，Header不会更换地址空间）</li>
<li><strong>倒序</strong>以此将数据中的元素拷贝到扩容后的正确为止（正序扩容会覆盖后面的元素）</li>
<li>将待添加的元素放入到数组末尾</li>
<li>将IntSet的<code>encoding</code>属性改为<code>INTSET_ENC_INT32</code>，将<code>length</code>更新</li>
</ol>
<p class="fireman-p-indent" >源码：</p>
<p class="fireman-p-indent" ><code>src/intset.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Insert an integer in the intset */</span></span><br><span class="line">intset *<span class="title function_">intsetAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value, <span class="type">uint8_t</span> *success)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> valenc = _intsetValueEncoding(value);	<span class="comment">// 获取当前值编码</span></span><br><span class="line">    <span class="type">uint32_t</span> pos;		<span class="comment">// 要插入的位置</span></span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;	<span class="comment">// 判断成功或是失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span></span><br><span class="line"><span class="comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span></span><br><span class="line"><span class="comment">     * because it lies outside the range of existing values. */</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;		<span class="comment">// 判断编码是否超过当前的encoding</span></span><br><span class="line">        <span class="comment">/* This always succeeds, so we don&#x27;t need to curry *success. */</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);			<span class="comment">// </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Abort if the value is already present in the set.</span></span><br><span class="line"><span class="comment">         * This call will populate &quot;pos&quot; with the right position to insert</span></span><br><span class="line"><span class="comment">         * the value when it cannot be found. */</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span></span><br><span class="line"><span class="type">static</span> intset *<span class="title function_">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="type">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="type">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="type">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don&#x27;t overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >IntSet可以看作是特殊的整数数组，具备一些特点：</p>
<ol>
<li>Redis会确保IntSet中的元素唯一、有序</li>
<li>具备类型升级机制，可以节省内存空间</li>
<li>底层采用二分查找方式来查询</li>
</ol>
<h2 id="字典Dict"><a href="#字典Dict" class="headerlink" title="字典Dict"></a>字典Dict</h2><p class="fireman-p-indent" >在Redis这个键值型数据库中，键与值的映射关系正是通过Dict来实现的。</p>
<p class="fireman-p-indent" >Dict由两部分组成，分别是：哈希表（<code>dict</code>），哈希节点（<code>DictEntry</code>）</p>
<p class="fireman-p-indent" ><code>deps/hiredis/dict.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;								<span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *val;								<span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>		<span class="comment">// 下一个entry的指针</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dict，hash表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictEntry **table;				<span class="comment">// entry数组，数组中保存的指向entry的指针</span></span><br><span class="line">    dictType *type;						<span class="comment">// 哈希表类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;				<span class="comment">// 哈希表大小，总等于 2^n </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;		<span class="comment">// 哈希表大小的掩码，总等于size - 1，用于做hash运算</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;				<span class="comment">// entry 个数</span></span><br><span class="line">    <span class="type">void</span> *privdata;						<span class="comment">// 私有数据， 做特殊hash运算时用</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典迭代器，用于迭代dict  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *ht;												<span class="comment">// 指向hash表的指针</span></span><br><span class="line">    <span class="type">int</span> index;											<span class="comment">// 索引</span></span><br><span class="line">    dictEntry *entry, *nextEntry;		<span class="comment">// 本节点和下一个节点的指针</span></span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><code>src/dict.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;                  <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;                        <span class="comment">// 值，并且可以存储不同的数据类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>     <span class="comment">/* Next entry in the same hash bucket. */</span> <span class="comment">// 下一个entry的指针</span></span><br><span class="line">    <span class="type">void</span> *metadata[];           <span class="comment">/* An arbitrary number of bytes (starting at a</span></span><br><span class="line"><span class="comment">                                 * pointer-aligned address) of size as returned</span></span><br><span class="line"><span class="comment">                                 * by dictType&#x27;s dictEntryMetadataBytes(). */</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*keyDup)(dict *d, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(dict *d, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*keyCompare)(dict *d, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(dict *d, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*valDestructor)(dict *d, <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*expandAllowed)(<span class="type">size_t</span> moreMem, <span class="type">double</span> usedRatio);</span><br><span class="line">    <span class="comment">/* Allow a dictEntry to carry extra caller-defined metadata.  The</span></span><br><span class="line"><span class="comment">     * extra memory is initialized to 0 when a dictEntry is allocated. */</span></span><br><span class="line">    <span class="type">size_t</span> (*dictEntryMetadataBytes)(dict *d);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dict，hash表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictEntry **table;        <span class="comment">// entry数组，数组中保存的指向entry的指针</span></span><br><span class="line">    dictType *type;           <span class="comment">// 哈希表类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;       <span class="comment">// 哈希表大小，总等于 2^n </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;   <span class="comment">// 哈希表大小的掩码，总等于size - 1，用于做hash运算</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;       <span class="comment">// entry 个数</span></span><br><span class="line">    <span class="type">void</span> *privdata;           <span class="comment">// 私有数据， 做特殊hash运算时用</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;               <span class="comment">// 哈希表类型，内置不同的hash函数</span></span><br><span class="line"></span><br><span class="line">    dictEntry **ht_table[<span class="number">2</span>];      <span class="comment">// entry数组，有两个元素，一个是使用的，另外一个是空的</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ht_used[<span class="number">2</span>];		</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span>  <span class="comment">// rehash进度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep small vars at end for optimal (minimal) struct padding */</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash; <span class="comment">/* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */</span> <span class="comment">// hash是否暂停， &gt;0 代表暂停</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> ht_size_exp[<span class="number">2</span>]; <span class="comment">/* exponent of size. (size = 1&lt;&lt;exp) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典迭代器，用于迭代dict  </span></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="type">long</span> index;</span><br><span class="line">    <span class="type">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用<code>h&amp;sizemask</code>（其实也就是取模，位运算更快）来计算元素应该存储到数组中的哪个索引位置。</p>
<p class="fireman-p-indent" ><code>dict</code>中的<code>dictEntry</code></p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208220452732.png" alt="image-20221208220452732"></p>
<p class="fireman-p-indent" >  存储1个数据</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208220525758.png" alt="image-20221208220525758"></p>
<p class="fireman-p-indent" >如果出现hash冲突，会加入到链表头部，这样可以不需要便利所有链表</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208220539425.png" alt="image-20221208220539425"></p>
<h3 id="Dict扩容"><a href="#Dict扩容" class="headerlink" title="Dict扩容"></a>Dict扩容</h3><p class="fireman-p-indent" >Dict中的<code>HashTable</code>就是数组结合单向链表的实现，当集合中元素过多，导致哈希冲突过多，链表过长，则会降低查询效率。此时会进行Dict扩容。</p>
<p class="fireman-p-indent" >Dict在每次新增键值对时都会检查负载因子（<code>LoadFactor = used/size</code>），满足以下两种情况时会触发哈希表扩容：</p>
<ul>
<li>负载因子<code>LoadFactor &gt;= 1</code>，并且服务器没有执行BGSAVE或者BGREWRITEAOF等后台进程</li>
<li>负载因子<code>LoadFactor &gt; 5</code></li>
</ul>
<p class="fireman-p-indent" ><code>src/dict.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="keyword">if</span> (DICTHT_SIZE(d-&gt;ht_size_exp[<span class="number">0</span>]) == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht_used[<span class="number">0</span>] &gt;= DICTHT_SIZE(d-&gt;ht_size_exp[<span class="number">0</span>]) &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht_used[<span class="number">0</span>]/ DICTHT_SIZE(d-&gt;ht_size_exp[<span class="number">0</span>]) &gt; dict_force_resize_ratio) &amp;&amp;</span><br><span class="line">        dictTypeExpandAllowed(d))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht_used[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dict收缩"><a href="#Dict收缩" class="headerlink" title="Dict收缩"></a>Dict收缩</h3><p class="fireman-p-indent" >Dict除了扩容以外，每次删除元素时，也会对负载因子做检查，当<code>LoadFactor &lt; 0.1</code>时，会做哈希表收缩</p>
<p class="fireman-p-indent" ><code>src/server.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">htNeedsResize</span><span class="params">(dict *dict)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size, used;</span><br><span class="line"></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">            (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><code>src/dict.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Resize the table to the minimal size that contains all the elements,</span></span><br><span class="line"><span class="comment"> * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    minimal = d-&gt;ht_used[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dict的rehash"><a href="#Dict的rehash" class="headerlink" title="Dict的rehash"></a>Dict的rehash</h3><p class="fireman-p-indent" >不管是收缩还是扩容，必定会创建新的哈希表，导致哈希表的size和sizemask发生变化，而key的查询语sizemask有关，因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。</p>
<p class="fireman-p-indent" >过程如下</p>
<ol>
<li><p>计算新hash表的<code>realeSize</code>，取值取决于当前要做的是扩容还是缩容：</p>
<ul>
<li>如果是扩容，则新<code>size</code>为第一个大于等于<code>dict.ht[0].used + 1</code> 的 <code>2^n</code></li>
<li>如果是缩容，则新<code>size</code>为第一个大于等于<code>dict.ht[0].used</code> 的 <code>2^n</code>（不得小于4）</li>
</ul>
</li>
<li><p class="fireman-p-indent" >按照新的<code>realeSize</code>申请内存空间，创建<code>dictht</code>，并赋值给<code>dict.ht[1]</code></p>
</li>
<li><p class="fireman-p-indent" >设置<code>dict.rehashidx=0</code>，标识开始rehash</p>
</li>
<li><p class="fireman-p-indent" >将老hash表中的每一个dictentry都rehash到新的hash表中</p>
<p class="fireman-p-indent" >这个过程是每次执行新增、查询、修改、删除操作时，都要检查下<code>dict.rehashidx</code>是否大于-1，如果是，则rehash一个entry后，都要将<code>rehashidx++</code>，直到所有的entry都rehash</p>
</li>
<li><p class="fireman-p-indent" >将<code>dict.ht[1]</code>赋值给<code>dict.ht[0]</code>，给<code>dict.ht[1]</code>初始化为空哈希表，释放原来的<code>dict.ht[0]</code>的内存</p>
</li>
<li><p class="fireman-p-indent" >将rehashidx赋值为-1，代表rehash结束</p>
</li>
<li><p class="fireman-p-indent" >在rehash过程中，新增操作，直接写入新hash表中，查询、修改和删除则会在老hash表和新hash表依次查找并执行。这样可以确保数据只减，不增，随着rehash最终为空</p>
</li>
</ol>
<p class="fireman-p-indent" >rehash前</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208225446907.png" alt="image-20221208225446907"></p>
<p class="fireman-p-indent" >rehash时</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208225539936.png" alt="image-20221208225539936"></p>
<p class="fireman-p-indent" >rehash后</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208225559504.png" alt="image-20221208225559504"></p>
<h2 id="压缩列表ZipList"><a href="#压缩列表ZipList" class="headerlink" title="压缩列表ZipList"></a>压缩列表ZipList</h2><p class="fireman-p-indent" >ZipList是一种特殊的<strong>双端链表</strong>，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入、弹出操作，并且该操作的时间复杂度为O(1)。</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208222604830.png" alt="image-20221208222604830"></p>
<p class="fireman-p-indent" ><img src="/../../../../../Library/Application%20Support/typora-user-images/image-20221208222623463.png" alt="image-20221208222623463"></p>
<p class="fireman-p-indent" >其中entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存，而是直接记录前一个entry的长度</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230036374.png" alt="image-20221208230036374"></p>
<h3 id="Encoding编码"><a href="#Encoding编码" class="headerlink" title="Encoding编码"></a>Encoding编码</h3><p class="fireman-p-indent" >ZipList中的entry中的<code>encoding</code>编码分为字符串和整数两种：</p>
<ul>
<li><p>字符串：如果<code>encoding</code>以<code>00</code>、<code>01</code>或者<code>10</code>开头，则<code>content</code>是字符串</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230228077.png" alt="image-20221208230228077"></p>
<p>  例如保存字符串<code>ab</code></p>
<p>  <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230301494.png" alt="image-20221208230301494"></p>
<p>  再保存一个bc</p>
<p>  <img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230358306.png" alt="image-20221208230358306"></p>
</li>
<li><p>整数：如果<code>encoding</code>以<code>11</code>开头，则<code>content</code>是整数，而且<code>encoding</code>固定值占用1个字节</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230526270.png" alt="image-20221208230526270"></p>
<p>例如，一个ZipList中包含两个整数值：2和5</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221208230620807.png" alt="image-20221208230620807"></p>
</li>
</ul>
<p class="fireman-p-indent" >源码</p>
<p class="fireman-p-indent" ><code>src/ziplist.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Each entry in the ziplist is either a string or an integer. */</span>				<span class="comment">// 记录ZipList中的节点信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* When string is used, it is provided with the length (slen). */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *sval;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> slen;</span><br><span class="line">    <span class="comment">/* When integer is used, &#x27;sval&#x27; is NULL, and lval holds the value. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> lval;</span><br><span class="line">&#125; ziplistEntry;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><code>src/ziplist.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We use this function to receive information about a ziplist entry.</span></span><br><span class="line"><span class="comment"> * Note that this is not how the data is actually encoded, is just what we</span></span><br><span class="line"><span class="comment"> * get filled by a function in order to operate more easily. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previous entry len*/</span>		<span class="comment">// 记录前一个节点长度的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlen;     <span class="comment">/* Previous entry len. */</span>													<span class="comment">// 前一个节点长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize;        <span class="comment">/* Bytes used to encode this entry type/len.				// 记录当前字节长度的字节数</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes			</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;            <span class="comment">/* Bytes used to represent the actual entry.				// 当前字节长度</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;     <span class="comment">/* prevrawlensize + lensize. */</span>										<span class="comment">// 头信息占用字节长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;      <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on			// 编码，确定数据时数字还是字符串</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;            <span class="comment">/* Pointer to the very start of the entry, that		// ZipList中起始节点指针</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>

<h3 id="ZipList的连锁更新问题"><a href="#ZipList的连锁更新问题" class="headerlink" title="ZipList的连锁更新问题"></a>ZipList的连锁更新问题</h3><p class="fireman-p-indent" >ZipList的每个entry都包含前一个节点的长度，长度是1或者5个字节</p>
<ul>
<li>如果前一节点的长度小于254个字节，则采用1个字节保存这个长度</li>
<li>如果前一节点的长度大于254个字节，则采用5个字节来保存这个长度值，第一个字节以<code>0xfe</code>，后4个字节才是真实长度数据</li>
</ul>
<p class="fireman-p-indent" >如果出现，插入某个节点，导致后面节点更改长度，又导致后面节点更改长度，就会出现连续多次空间扩展，也就是<strong>连锁更新</strong>（Cascade Update），新增、删除都可能导致连锁更新的发生。</p>
<p class="fireman-p-indent" >ZipList特性：</p>
<ol>
<li>压缩列表可以看做一种连续内存空间的双向链表</li>
<li>列表的节点之间不是通过指针连接，而是记录上一个节点和本节点长度来寻址，内存占用较低</li>
<li>如果列表数据过多，导致链表过长，可能影响查询性能</li>
<li>增或删较大数据时，有可能发生连续更新问题</li>
</ol>
<p class="fireman-p-indent" >因此，在Redis 7.0版本，通过<code>listpack</code>完全取代<code>ZipList</code>，并且为了兼容性，保留了<code>ziplist</code>的相关属性。通过在entry末尾记录本entry长度，解决连锁更新的问题。</p>
<h2 id="快速列表QuickList"><a href="#快速列表QuickList" class="headerlink" title="快速列表QuickList"></a>快速列表QuickList</h2><p class="fireman-p-indent" >ZipList占据连续内存，当节点过多，申请内存的效率就会很低。为了解决这个问题，引入快速列表QuickList，将多个ZipList通过双向链表连接起来。</p>
<p class="fireman-p-indent" >QuickList是一个双端链表，链表中的每个节点都是一个ZipList（Redis 7.0中，每个节点是ListPack）。</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209095847218.png" alt="image-20221209095847218"></p>
<p class="fireman-p-indent" >为了避免QuickList中的每个ZipList中entry过多，Redis通过配置限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5) &quot;list-max-ziplist-size&quot;</span><br><span class="line">6) &quot;-2&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果为正，代表ZipList的允许entry个数的最大值</li>
<li>如果为负，代表ZipList的最大内存大小，分5中情况：<ul>
<li>-1：每个ZipList的内存占用不能超过4KB</li>
<li>-2：每个ZipList的内存占用不能超过8KB，默认值</li>
<li>-3：每个ZipList的内存占用不能超过16KB</li>
<li>-4：每个ZipList的内存占用不能超过32KB</li>
<li>-5：每个ZipList的内存占用不能超过64KB</li>
</ul>
</li>
</ul>
<p class="fireman-p-indent" >除了控制ZipList的大小，还可以控制ZipList做压缩，通过配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">23) &quot;list-compress-depth&quot;</span><br><span class="line">24) &quot;0&quot;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >因为链表一般是首位访问较多，所以首位是不压缩的。这个参数就是控制首位不压缩的节点个数：</p>
<ul>
<li>0：特殊值，代表不压缩，默认值，不压缩内存申请效率高，但是超找效率不如压缩</li>
<li>1：代表QuickList首位各有1个节点不压缩，中间节点压缩</li>
<li>2：代表QuickList首位各有2个节点不压缩，中间节点压缩</li>
<li>以此类推</li>
</ul>
<p class="fireman-p-indent" >QuickList源码</p>
<p class="fireman-p-indent" ><code>src/quicklist.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* quicklistNode is a 32 byte struct describing a listpack for a quicklist.</span></span><br><span class="line"><span class="comment"> * We use bit fields keep the quicklistNode at 32 bytes.</span></span><br><span class="line"><span class="comment"> * count: 16 bits, max 65536 (max lp bytes is 65k, so max count actually &lt; 32k).</span></span><br><span class="line"><span class="comment"> * encoding: 2 bits, RAW=1, LZF=2.</span></span><br><span class="line"><span class="comment"> * container: 2 bits, PLAIN=1 (a single item as char array), PACKED=2 (listpack with multiple items).</span></span><br><span class="line"><span class="comment"> * recompress: 1 bit, bool, true if node is temporary decompressed for usage.</span></span><br><span class="line"><span class="comment"> * attempted_compress: 1 bit, boolean, used for verifying during testing.</span></span><br><span class="line"><span class="comment"> * extra: 10 bits, free for future use; pads out the remainder of 32 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span>			<span class="comment">// QuickList中的节点结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>			<span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>			<span class="comment">// 后一个节点指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *entry;						<span class="comment">// 当前节点指针</span></span><br><span class="line">    <span class="type">size_t</span> sz;             <span class="comment">/* entry size in bytes */</span>	<span class="comment">// 当前节点ZipList的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in listpack */</span>	<span class="comment">// 当前节点ZipList中entry的个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span>						<span class="comment">// 编码方式，1是ZipList，2是LZP压缩模式</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;  <span class="comment">/* PLAIN==1 or PACKED==2 */</span>			<span class="comment">// 数据容器类型，1是PLAIN，2是PACKED</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span>			<span class="comment">// 是否被压缩，1说明被解压了，后续要重新压缩</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span>	<span class="comment">// 测试用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dont_compress : <span class="number">1</span>; <span class="comment">/* prevent compression of entry that will be used later */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">9</span>; <span class="comment">/* more bits to steal for future usage */</span>	<span class="comment">// 预留字段</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;count&#x27; is the number of total entries.</span></span><br><span class="line"><span class="comment"> * &#x27;len&#x27; is the number of quicklist nodes.</span></span><br><span class="line"><span class="comment"> * &#x27;compress&#x27; is: 0 if compression disabled, otherwise it&#x27;s the number</span></span><br><span class="line"><span class="comment"> *                of quicklistNodes to leave uncompressed at ends of quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;fill&#x27; is the user-requested (or default) fill factor.</span></span><br><span class="line"><span class="comment"> * &#x27;bookmarks are an optional feature that is used by realloc this struct,</span></span><br><span class="line"><span class="comment"> *      so that they don&#x27;t consume memory when not used. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span>			<span class="comment">// QuickList 结构体</span></span><br><span class="line">    quicklistNode *head;				<span class="comment">// 头节点指针</span></span><br><span class="line">    quicklistNode *tail;				<span class="comment">// 尾结点指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;        <span class="comment">/* total count of all entries in all listpacks */</span>	<span class="comment">// 所有ZipList中entry数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;          <span class="comment">/* number of quicklistNodes */</span>										<span class="comment">// ZipList的数量</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span> fill : QL_FILL_BITS;       <span class="comment">/* fill factor for individual nodes */</span>	<span class="comment">// ZipList上限，默认值 -2 </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : QL_COMP_BITS; <span class="comment">/* depth of end nodes not to compress;0=off */</span>	<span class="comment">// 首位不压缩的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bookmark_count: QL_BM_BITS;	<span class="comment">// 内存重分配时的书签数量及数组，一般用不到</span></span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >示意图如下：</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209103834488.png" alt="image-20221209103834488"></p>
<h2 id="跳表SkipList"><a href="#跳表SkipList" class="headerlink" title="跳表SkipList"></a>跳表SkipList</h2><p class="fireman-p-indent" >在QuickList中，通过首位访问是比较快的，但是如果需要访问中间元素，则需要进行从首或者尾进行遍历，遍历到某个ZipList之后，在ZipList中可以二分查找，但是如果QuickList非常长，这个遍历效率会非常低。</p>
<p class="fireman-p-indent" >因此，当QuickList中节点过多时，需要引入SkipList。SkipList，跳表，是一个链表，但是与传统链表有几点差异：</p>
<ul>
<li>元素按照升序排列存储</li>
<li>节点可以包含多个指针，指针跨度不同</li>
</ul>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209104717967.png" alt="image-20221209104717967"></p>
<p class="fireman-p-indent" >SkipList中，最大可以允许32级指针。</p>
<p class="fireman-p-indent" ><code>src/server.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span>								<span class="comment">// SkipList中节点信息</span></span><br><span class="line">    sds ele;																	<span class="comment">// 节点存储的值</span></span><br><span class="line">    <span class="type">double</span> score;															<span class="comment">// 节点分数，用于排序、查找</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>						<span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span>										<span class="comment">// 层级信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>				<span class="comment">// 下一个节点指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;										<span class="comment">// 索引跨度</span></span><br><span class="line">    &#125; level[];																<span class="comment">// 保存所有层级的指针信息</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span>										<span class="comment">// SkipList数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>			<span class="comment">// 头节点、尾结点指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;											<span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">int</span> level;																<span class="comment">// 最大索引层级，默认值1 </span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209112523056.png" alt="image-20221209112523056"></p>
<p class="fireman-p-indent" >SkipList特点：</p>
<ul>
<li>跳跃表是一个双向链表，每个节点包含<code>score</code>和<code>ele</code>值，也就是打分和值</li>
<li>节点按照score值排序，score值一样则按照<code>ele</code>字典排序</li>
<li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li>
<li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li>
<li>增删改查效率与红黑树基本一致，实现却更加简单</li>
</ul>
<h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><p class="fireman-p-indent" >Redis中任意数据类型的键值都会被封装为一个RedisObject，也叫做Redis对象</p>
<p class="fireman-p-indent" ><code>src/server.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;				<span class="comment">// 对象类，数据类型，从0-4有5种，占4个bit</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;		<span class="comment">// 数据编码，同一个数据类型，也会有不同的数据编码，占4个bit</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or		// 表示该对象最后一次被访问的时间，占用24个bit，便于判断空闲时间太久的key</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span>	</span><br><span class="line">    <span class="type">int</span> refcount;																														<span class="comment">// 对象引用计数器，有对象引用+1，没有对象引用-1，为0代表没有应用引用，则可回收</span></span><br><span class="line">    <span class="type">void</span> *ptr;							<span class="comment">// 指针，指向实际存放数据的空间</span></span><br><span class="line">&#125; robj;											<span class="comment">// 对象头部，占用16个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type 数据类型</span></span><br><span class="line"><span class="comment">/* The actual Redis Object */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span>				<span class="comment">// int embstr raw </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span>					<span class="comment">// QuickList</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span>						<span class="comment">// IntSet，HashTable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span>		<span class="comment">// ListPack，SkipList</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span>					<span class="comment">// ListPack，HashTable</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据编码</span></span><br><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The &#x27;encoding&#x27; field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span>															<span class="comment">// 动态字符串的一种方式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span>															<span class="comment">// long类型的整数的字符串</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span>													<span class="comment">// hash表，也就是字典dict</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* No longer used: old hash encoding. */</span>							<span class="comment">// 已废弃</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span>					<span class="comment">// 双端链表，已废弃</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* No longer used: old list/hash/zset encoding. */</span>		<span class="comment">// Redis 7中已经不使用ZipList</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span>															<span class="comment">// 整数集合</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span>													<span class="comment">// 跳表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span>										<span class="comment">// 动态字符串的一种方式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of listpacks */</span>					<span class="comment">// 快速列表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span>						<span class="comment">// Stream 流</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_LISTPACK 11 <span class="comment">/* Encoded as a listpack */</span>												<span class="comment">// Redis 7中使用ListPack代替ZipList				</span></span></span><br></pre></td></tr></table></figure>

<h2 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h2><p class="fireman-p-indent" >Redis 6.0的数据类型、编码类型和底层数据结构对应</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20220618182945035.png" alt="image-20220618182945035"></p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p class="fireman-p-indent" >string是Redis中最常见的数据存储类型：</p>
<ul>
<li><p>基本编码方式是RAW，基于SDS实现，存储上限是512MB</p>
<p>RAW编码：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209115226190.png" alt="image-20221209115226190"></p>
</li>
<li><p>如果SDS长度小于44字节，则会采用EMBSTR编码，此时object haed与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</p>
<p>EMBSTR编码：</p>
<p>此时RedisObject占用16个字节，SDS占用44+头部的3个字节+尾部\0的1个字节，一共64字节，内存分配时不会有内存碎片。因此推荐String格式的字符串长度不要超过44个字节。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209115351780.png" alt="image-20221209115351780"></p>
</li>
<li><p>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（正好8字节），不再需要SDS</p>
<p>INT编码：</p>
<p><img src="/../../../../../Library/Application%20Support/typora-user-images/image-20221209123451393.png" alt="image-20221209123451393"></p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> raw aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> emb abc</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> int 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding raw</span><br><span class="line"><span class="string">&quot;raw&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding emb</span><br><span class="line"><span class="string">&quot;embstr&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding int</span><br><span class="line"><span class="string">&quot;int&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p class="fireman-p-indent" >Redis的List类型可以从首、尾操作列表中的元素，满足的数据结构是QuickList，包含LinkedList和ZipList的特点，节点和节点之间通过双向链表访问，内存占用较低，每个节点内包含多个ZipList，存储上限高。</p>
<ul>
<li>3.2版本之前，Redis采用LinkedList和ZipList来实现List，当元素数量小于512个，并且元素大小小于64字节时，采用ZipList编码，否则使用LinkedList编码</li>
<li>3.2版本之后，Redis同意使用QuickList来实现List</li>
</ul>
<p class="fireman-p-indent" ><code>src/t_list.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LPUSH/RPUSH/LPUSHX/RPUSHX 命令，都是调用pushGenericCommand</span></span><br><span class="line"><span class="comment">/* LPUSH &lt;key&gt; &lt;element&gt; [&lt;element&gt; ...] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lpushCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    pushGenericCommand(c,LIST_HEAD,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Implements LPUSH/RPUSH/LPUSHX/RPUSHX. </span></span><br><span class="line"><span class="comment"> * &#x27;xx&#x27;: push if key exists. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushGenericCommand</span><span class="params">(client *c, <span class="type">int</span> where, <span class="type">int</span> xx)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">		<span class="comment">// 尝试找到KEY对应的List</span></span><br><span class="line">    robj *lobj = lookupKeyWrite(c-&gt;db, c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">  	<span class="comment">// 检查类型是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (checkType(c,lobj,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">  	<span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!lobj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xx) &#123;</span><br><span class="line">            addReply(c, shared.czero);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 为空，创建QuickList</span></span><br><span class="line">        lobj = createQuicklistObject();</span><br><span class="line">        quicklistSetOptions(lobj-&gt;ptr, server.list_max_listpack_size,</span><br><span class="line">                            server.list_compress_depth);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],lobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        listTypePush(lobj,c-&gt;argv[j],where);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addReplyLongLong(c, listTypeLength(lobj));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *event = (where == LIST_HEAD) ? <span class="string">&quot;lpush&quot;</span> : <span class="string">&quot;rpush&quot;</span>;</span><br><span class="line">    signalModifiedKey(c,c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><code>src/object.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">createQuicklistObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	<span class="comment">// 申请内存并初始化QuickList</span></span><br><span class="line">    quicklist *l = quicklistCreate();</span><br><span class="line">  	<span class="comment">// 创建RedisObject，type为 OBJ_LIST，ptr指向QuickList</span></span><br><span class="line">    robj *o = createObject(OBJ_LIST,l);</span><br><span class="line">  	<span class="comment">// 设置编码为QuickList</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_QUICKLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209143255162.png" alt="image-20221209143255162"></p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p class="fireman-p-indent" >Set是Redis中的单列集合，满足以下特点：</p>
<ul>
<li>不保证有序性</li>
<li>保证元素唯一性（可以判断元素是否存在）</li>
<li>求交集、并集、差集</li>
</ul>
<p class="fireman-p-indent" >满足这种查询元素高效率的要求的数据结构，是HashTable，也就是Dic，不过Dic是双列集合（可以存键值对）</p>
<ul>
<li><p>为了查询效率和唯一性，Set采用HT编码（Dict）。Dict中的key可以用来存储元素，value统一为null。</p>
</li>
<li><p>当存储的所有数据都是整数，并且元素数量不超过<code>set-max-intset-entries</code>时，Set会采用IntSet编码，以节省内存</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG GET *max-intset*</span><br><span class="line">1) <span class="string">&quot;set-max-intset-entries&quot;</span></span><br><span class="line">2) <span class="string">&quot;512&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p class="fireman-p-indent" ><code>src/t_set.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Factory method to return a set that *can* hold &quot;value&quot;. When the object has</span></span><br><span class="line"><span class="comment"> * an integer-encodable value, an intset will be returned. Otherwise a regular</span></span><br><span class="line"><span class="comment"> * hash table. */</span></span><br><span class="line">robj *<span class="title function_">setTypeCreate</span><span class="params">(sds value)</span> &#123;</span><br><span class="line">  	<span class="comment">// 判断value是否是数值类型 LongLong</span></span><br><span class="line">    <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,<span class="literal">NULL</span>) == C_OK)</span><br><span class="line">      	<span class="comment">// 如果是数值类型，则采用IntSet编码</span></span><br><span class="line">        <span class="keyword">return</span> createIntsetObject();</span><br><span class="line">  	<span class="comment">// 如果不是，则采用默认编码，也就是HT</span></span><br><span class="line">    <span class="keyword">return</span> createSetObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><code>src/object.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建IntSet编码的RedisObject</span></span><br><span class="line">robj *<span class="title function_">createIntsetObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	<span class="comment">// 初始化IntSet，并且申请内存</span></span><br><span class="line">    intset *is = intsetNew();</span><br><span class="line">  	<span class="comment">// 创建RedisObject</span></span><br><span class="line">    robj *o = createObject(OBJ_SET,is);</span><br><span class="line">  	<span class="comment">// 指定编码为OBJ_ENCODING_INTSET</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_INTSET;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建HT编码的RedisObject</span></span><br><span class="line">robj *<span class="title function_">createSetObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	<span class="comment">// 初始化Dict类型，并申请内存</span></span><br><span class="line">    dict *d = dictCreate(&amp;setDictType);</span><br><span class="line">  	<span class="comment">// 创建createObject</span></span><br><span class="line">    robj *o = createObject(OBJ_SET,d);</span><br><span class="line">  	<span class="comment">// 设置编码为OBJ_ENCODING_HT</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><code>src/t_set.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add the specified value into a set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the value was already member of the set, nothing is done and 0 is</span></span><br><span class="line"><span class="comment"> * returned, otherwise the new element is added and 1 is returned. */</span></span><br><span class="line"><span class="comment">// set中增加元素，会判断长度，过长会转变为OBJ_ENCODING_HT</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> llval;</span><br><span class="line">  	<span class="comment">// 已经是HT编码，直接添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 是 IntSet 编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">      	<span class="comment">// 判断数据类型，如果是LongLong</span></span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">/* Convert to regular set when the intset contains</span></span><br><span class="line"><span class="comment">                 * too many entries. */</span></span><br><span class="line">              	<span class="comment">// 当IntSet元素数量超出set_max_intset_entries，则转换成IntSet</span></span><br><span class="line">                <span class="type">size_t</span> max_entries = server.set_max_intset_entries;</span><br><span class="line">                <span class="comment">/* limit to 1G entries due to intset internals. */</span></span><br><span class="line">                <span class="keyword">if</span> (max_entries &gt;= <span class="number">1</span>&lt;&lt;<span class="number">30</span>) max_entries = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; max_entries)</span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Failed to get integer from object, convert to regular set. */</span></span><br><span class="line">          	<span class="comment">// 不是整数，直接转换成 HT</span></span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The set *was* an intset and this value is not integer</span></span><br><span class="line"><span class="comment">             * encodable, so dictAdd should always work. */</span></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >插入整数</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209144539245.png" alt="image-20221209144539245"></p>
<p class="fireman-p-indent" >改为HT</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209144619653.png" alt="image-20221209144619653"></p>
<h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p class="fireman-p-indent" >ZSet也就是SortedSet，其中每一个元素都要指定一个score值和member指：</p>
<ul>
<li>可以根据score值排序</li>
<li>member必须唯一</li>
<li>可以根据member查询分数</li>
</ul>
<p class="fireman-p-indent" >因此，zset底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。zset通过Dict和SkipList结合实现。</p>
<p class="fireman-p-indent" ><code>src/server.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">  	<span class="comment">// Dict 指针</span></span><br><span class="line">    dict *dict;</span><br><span class="line">  	<span class="comment">// SkipList 指针</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><code>src/object.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">createZsetObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line">		<span class="comment">// 创建Dict</span></span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType);</span><br><span class="line">  	<span class="comment">// 创建SkipList</span></span><br><span class="line">    zs-&gt;zsl = zslCreate();</span><br><span class="line">    o = createObject(OBJ_ZSET,zs);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221209145524270.png" alt="image-20221209145524270"></p>
<p class="fireman-p-indent" >当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：</p>
<ol>
<li>元素数量小于<code>zset-max-ziplist-entries</code>（Redis 7的配置是<code>zset-max-listpack-entries</code>），默认是128</li>
<li>每个元素的长度都小于<code>zset-max-ziplist-value</code>（Redis 7的配置是<code>zset-max-listpack-value</code>），默认是64</li>
</ol>
<p class="fireman-p-indent" ><code>src/t_zset.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Sorted set commands</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This generic command implements both ZADD and ZINCRBY. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zaddGenericCommand</span><span class="params">(client *c, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *nanerr = <span class="string">&quot;resulting score is not a number (NaN)&quot;</span>;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="type">double</span> score = <span class="number">0</span>, *scores = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> j, elements, ch = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> scoreidx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* The following vars are used in order to track what the command actually</span></span><br><span class="line"><span class="comment">     * did during the execution, to reply to the client and to trigger the</span></span><br><span class="line"><span class="comment">     * notification of keyspace change. */</span></span><br><span class="line">    <span class="type">int</span> added = <span class="number">0</span>;      <span class="comment">/* Number of new elements added. */</span></span><br><span class="line">    <span class="type">int</span> updated = <span class="number">0</span>;    <span class="comment">/* Number of elements with updated score. */</span></span><br><span class="line">    <span class="type">int</span> processed = <span class="number">0</span>;  <span class="comment">/* Number of elements processed, may remain zero with</span></span><br><span class="line"><span class="comment">                           options like XX. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse options. At the end &#x27;scoreidx&#x27; is set to the argument position</span></span><br><span class="line"><span class="comment">     * of the score of the first score-element pair. */</span></span><br><span class="line">    scoreidx = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(scoreidx &lt; c-&gt;argc) &#123;</span><br><span class="line">        <span class="type">char</span> *opt = c-&gt;argv[scoreidx]-&gt;ptr;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;nx&quot;</span>)) flags |= ZADD_IN_NX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;xx&quot;</span>)) flags |= ZADD_IN_XX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;ch&quot;</span>)) ch = <span class="number">1</span>; <span class="comment">/* Return num of elements added or updated. */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;incr&quot;</span>)) flags |= ZADD_IN_INCR;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;gt&quot;</span>)) flags |= ZADD_IN_GT;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;lt&quot;</span>)) flags |= ZADD_IN_LT;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        scoreidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Turn options into simple to check vars. */</span></span><br><span class="line">    <span class="type">int</span> incr = (flags &amp; ZADD_IN_INCR) != <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nx = (flags &amp; ZADD_IN_NX) != <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> xx = (flags &amp; ZADD_IN_XX) != <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> gt = (flags &amp; ZADD_IN_GT) != <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lt = (flags &amp; ZADD_IN_LT) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* After the options, we expect to have an even number of args, since</span></span><br><span class="line"><span class="comment">     * we expect any number of score-element pairs. */</span></span><br><span class="line">    elements = c-&gt;argc-scoreidx;</span><br><span class="line">    <span class="keyword">if</span> (elements % <span class="number">2</span> || !elements) &#123;</span><br><span class="line">        addReplyErrorObject(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    elements /= <span class="number">2</span>; <span class="comment">/* Now this holds the number of score-element pairs. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for incompatible options. */</span></span><br><span class="line">    <span class="keyword">if</span> (nx &amp;&amp; xx) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">&quot;XX and NX options at the same time are not compatible&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((gt &amp;&amp; nx) || (lt &amp;&amp; nx) || (gt &amp;&amp; lt)) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">&quot;GT, LT, and/or NX options at the same time are not compatible&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Note that XX is compatible with either GT or LT */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (incr &amp;&amp; elements &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">&quot;INCR option supports a single increment-element pair&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start parsing all the scores, we need to emit any syntax error</span></span><br><span class="line"><span class="comment">     * before executing additions to the sorted set, as the command should</span></span><br><span class="line"><span class="comment">     * either execute fully or nothing at all. */</span></span><br><span class="line">    scores = zmalloc(<span class="keyword">sizeof</span>(<span class="type">double</span>)*elements);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDoubleFromObjectOrReply(c,c-&gt;argv[scoreidx+j*<span class="number">2</span>],&amp;scores[j],<span class="literal">NULL</span>)</span><br><span class="line">            != C_OK) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lookup the key and create the sorted set if does not exist. */</span></span><br><span class="line">  	<span class="comment">// zadd 添加元素时，先根据key找到zset，不存在则创建新的key</span></span><br><span class="line">    zobj = lookupKeyWrite(c-&gt;db,key);</span><br><span class="line">    <span class="keyword">if</span> (checkType(c,zobj,OBJ_ZSET)) <span class="keyword">goto</span> cleanup;</span><br><span class="line">  	<span class="comment">// zset不存在时</span></span><br><span class="line">    <span class="keyword">if</span> (zobj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xx) <span class="keyword">goto</span> reply_to_client; <span class="comment">/* No key + XX option: nothing to do. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.zset_max_listpack_entries == <span class="number">0</span> ||</span><br><span class="line">            server.zset_max_listpack_value &lt; sdslen(c-&gt;argv[scoreidx+<span class="number">1</span>]-&gt;ptr))</span><br><span class="line">          	<span class="comment">// zset_max_listpack_entries 为0，则是仅用了ListPack</span></span><br><span class="line">          	<span class="comment">// 或者超过 zset_max_listpack_value ，使用createZsetObject，也就是 HT + SkipList</span></span><br><span class="line">        &#123;</span><br><span class="line">            zobj = createZsetObject();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 反之，则使用ListPack</span></span><br><span class="line">            zobj = createZsetListpackObject();</span><br><span class="line">        &#125;</span><br><span class="line">        dbAdd(c-&gt;db,key,zobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="type">double</span> newscore;</span><br><span class="line">        score = scores[j];</span><br><span class="line">        <span class="type">int</span> retflags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ele = c-&gt;argv[scoreidx+<span class="number">1</span>+j*<span class="number">2</span>]-&gt;ptr;</span><br><span class="line">        <span class="type">int</span> retval = zsetAdd(zobj, score, ele, flags, &amp;retflags, &amp;newscore);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c,nanerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_OUT_ADDED) added++;</span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_OUT_UPDATED) updated++;</span><br><span class="line">        <span class="keyword">if</span> (!(retflags &amp; ZADD_OUT_NOP)) processed++;</span><br><span class="line">        score = newscore;</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += (added+updated);</span><br><span class="line"></span><br><span class="line">reply_to_client:</span><br><span class="line">    <span class="keyword">if</span> (incr) &#123; <span class="comment">/* ZINCRBY or INCR option. */</span></span><br><span class="line">        <span class="keyword">if</span> (processed)</span><br><span class="line">            addReplyDouble(c,score);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addReplyNull(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ZADD. */</span></span><br><span class="line">        addReplyLongLong(c,ch ? added+updated : added);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    zfree(scores);</span><br><span class="line">    <span class="keyword">if</span> (added || updated) &#123;</span><br><span class="line">        signalModifiedKey(c,c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_ZSET,</span><br><span class="line">            incr ? <span class="string">&quot;zincr&quot;</span> : <span class="string">&quot;zadd&quot;</span>, key, c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><code>src/object.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建zset对象</span></span><br><span class="line">robj *<span class="title function_">createZsetObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	<span class="comment">// 申请内存</span></span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line">		<span class="comment">// 创建dict</span></span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType);</span><br><span class="line">  	<span class="comment">// 创建SkipList</span></span><br><span class="line">    zs-&gt;zsl = zslCreate();</span><br><span class="line">    o = createObject(OBJ_ZSET,zs);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ListPack对象</span></span><br><span class="line">robj *<span class="title function_">createZsetListpackObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	<span class="comment">// 申请内存</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *lp = lpNew(<span class="number">0</span>);</span><br><span class="line">  	<span class="comment">// 创建ListPack对象</span></span><br><span class="line">    robj *o = createObject(OBJ_ZSET,lp);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_LISTPACK;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >在给zset中添加元素时，也会进行判断</p>
<p class="fireman-p-indent" ><code>src/t_zset.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a new element or update the score of an existing element in a sorted</span></span><br><span class="line"><span class="comment"> * set, regardless of its encoding.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The set of flags change the command behavior. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The input flags are the following:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ZADD_INCR: Increment the current element score by &#x27;score&#x27; instead of updating</span></span><br><span class="line"><span class="comment"> *            the current element score. If the element does not exist, we</span></span><br><span class="line"><span class="comment"> *            assume 0 as previous score.</span></span><br><span class="line"><span class="comment"> * ZADD_NX:   Perform the operation only if the element does not exist.</span></span><br><span class="line"><span class="comment"> * ZADD_XX:   Perform the operation only if the element already exist.</span></span><br><span class="line"><span class="comment"> * ZADD_GT:   Perform the operation on existing elements only if the new score is </span></span><br><span class="line"><span class="comment"> *            greater than the current score.</span></span><br><span class="line"><span class="comment"> * ZADD_LT:   Perform the operation on existing elements only if the new score is </span></span><br><span class="line"><span class="comment"> *            less than the current score.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When ZADD_INCR is used, the new score of the element is stored in</span></span><br><span class="line"><span class="comment"> * &#x27;*newscore&#x27; if &#x27;newscore&#x27; is not NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The returned flags are the following:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ZADD_NAN:     The resulting score is not a number.</span></span><br><span class="line"><span class="comment"> * ZADD_ADDED:   The element was added (not present before the call).</span></span><br><span class="line"><span class="comment"> * ZADD_UPDATED: The element score was updated.</span></span><br><span class="line"><span class="comment"> * ZADD_NOP:     No operation was performed because of NX or XX.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return value:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns 1 on success, and sets the appropriate flags</span></span><br><span class="line"><span class="comment"> * ADDED or UPDATED to signal what happened during the operation (note that</span></span><br><span class="line"><span class="comment"> * none could be set if we re-added an element using the same score it used</span></span><br><span class="line"><span class="comment"> * to have, or in the case a zero increment is used).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns 0 on error, currently only when the increment</span></span><br><span class="line"><span class="comment"> * produces a NAN condition, or when the &#x27;score&#x27; value is NAN since the</span></span><br><span class="line"><span class="comment"> * start.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The command as a side effect of adding a new element may convert the sorted</span></span><br><span class="line"><span class="comment"> * set internal encoding from listpack to hashtable+skiplist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory management of &#x27;ele&#x27;:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function does not take ownership of the &#x27;ele&#x27; SDS string, but copies</span></span><br><span class="line"><span class="comment"> * it if needed. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">zsetAdd</span><span class="params">(robj *zobj, <span class="type">double</span> score, sds ele, <span class="type">int</span> in_flags, <span class="type">int</span> *out_flags, <span class="type">double</span> *newscore)</span> &#123;</span><br><span class="line">    <span class="comment">/* Turn options into simple to check vars. */</span></span><br><span class="line">    <span class="type">int</span> incr = (in_flags &amp; ZADD_IN_INCR) != <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nx = (in_flags &amp; ZADD_IN_NX) != <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> xx = (in_flags &amp; ZADD_IN_XX) != <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> gt = (in_flags &amp; ZADD_IN_GT) != <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lt = (in_flags &amp; ZADD_IN_LT) != <span class="number">0</span>;</span><br><span class="line">    *out_flags = <span class="number">0</span>; <span class="comment">/* We&#x27;ll return our response flags. */</span></span><br><span class="line">    <span class="type">double</span> curscore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NaN as input is an error regardless of all the other parameters. */</span></span><br><span class="line">    <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">        *out_flags = ZADD_OUT_NAN;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update the sorted set according to its encoding. */</span>	<span class="comment">// 判断编码方式，如果是ListPack</span></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_LISTPACK) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *eptr;</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">// 判断当前元素是否已经存在，已经存在</span></span><br><span class="line">        <span class="keyword">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,&amp;curscore)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* NX? Return, same element already exists. */</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">                *out_flags |= ZADD_OUT_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Prepare the score for the increment if needed. */</span></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                score += curscore;</span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                    *out_flags |= ZADD_OUT_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* GT/LT? Only update if score is greater/less than current. */</span></span><br><span class="line">            <span class="keyword">if</span> ((lt &amp;&amp; score &gt;= curscore) || (gt &amp;&amp; score &lt;= curscore)) &#123;</span><br><span class="line">                *out_flags |= ZADD_OUT_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Remove and re-insert when score changed. */</span></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class="line">                zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">                *out_flags |= ZADD_OUT_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</span><br><span class="line">          	<span class="comment">// 如果元素不存在</span></span><br><span class="line">            <span class="comment">/* check if the element is too large or the list</span></span><br><span class="line"><span class="comment">             * becomes too long *before* executing zzlInsert. */</span></span><br><span class="line">          	<span class="comment">// 判断新增1个元素之后，ziplist长度，如果大于zset_max_listpack_entries，或者值大于zset_max_listpack_value</span></span><br><span class="line">            <span class="keyword">if</span> (zzlLength(zobj-&gt;ptr)+<span class="number">1</span> &gt; server.zset_max_listpack_entries ||</span><br><span class="line">                sdslen(ele) &gt; server.zset_max_listpack_value ||</span><br><span class="line">                !lpSafeToAdd(zobj-&gt;ptr, sdslen(ele)))</span><br><span class="line">            &#123;</span><br><span class="line">              	<span class="comment">// 转换成SkipList</span></span><br><span class="line">                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">                *out_flags |= ZADD_OUT_ADDED;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *out_flags |= ZADD_OUT_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that the above block handling listpack would have either returned or</span></span><br><span class="line"><span class="comment">     * converted the key to skiplist. */</span>		<span class="comment">// 编码方式，如果是SkipList，无需转换</span></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        zskiplistNode *znode;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = dictFind(zs-&gt;dict,ele);</span><br><span class="line">        <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* NX? Return, same element already exists. */</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">                *out_flags |= ZADD_OUT_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curscore = *(<span class="type">double</span>*)dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Prepare the score for the increment if needed. */</span></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                score += curscore;</span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                    *out_flags |= ZADD_OUT_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* GT/LT? Only update if score is greater/less than current. */</span></span><br><span class="line">            <span class="keyword">if</span> ((lt &amp;&amp; score &gt;= curscore) || (gt &amp;&amp; score &lt;= curscore)) &#123;</span><br><span class="line">                *out_flags |= ZADD_OUT_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Remove and re-insert when score changes. */</span></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                znode = zslUpdateScore(zs-&gt;zsl,curscore,ele,score);</span><br><span class="line">                <span class="comment">/* Note that we did not removed the original element from</span></span><br><span class="line"><span class="comment">                 * the hash table representing the sorted set, so we just</span></span><br><span class="line"><span class="comment">                 * update the score. */</span></span><br><span class="line">                dictGetVal(de) = &amp;znode-&gt;score; <span class="comment">/* Update score ptr. */</span></span><br><span class="line">                *out_flags |= ZADD_OUT_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</span><br><span class="line">            ele = sdsdup(ele);</span><br><span class="line">            znode = zslInsert(zs-&gt;zsl,score,ele);</span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK);</span><br><span class="line">            *out_flags |= ZADD_OUT_ADDED;</span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *out_flags |= ZADD_OUT_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown sorted set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Never reached. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >ZipList本身没有排序功能，而且没有键值对的概念，因此需要实现zset，则：</p>
<ul>
<li>将score和element作为紧挨在一起的两个entry，element在前，score在后</li>
<li>score越小，越接近队首，score越大越接近队尾，按照score升序排列</li>
</ul>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210201059649.png" alt="image-20221210201059649"></p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p class="fireman-p-indent" >Hash结构与Redis中的Zset非常像：</p>
<ul>
<li>都是键值对</li>
<li>都需要根据键获取值</li>
<li>键必须唯一</li>
</ul>
<p class="fireman-p-indent" >区别如下：</p>
<ul>
<li>zset的键是<code>member</code>，值是<code>score</code>，hash键和值都是任意值</li>
<li>zset要根据<code>score</code>排序，hash则无需排序</li>
</ul>
<p class="fireman-p-indent" >因此，Hash底层采用的编码与Zset基本一致，只需要把排序有关的SkipList去掉即可。</p>
<ul>
<li>Hash结构默认采用ZipList编码（Redis 7改成ListPack），用以节省内存。ZipList中相邻的两个entry分别保存<code>field</code>和<code>value</code></li>
<li>当数据量较大时，Hash结构会转换为HT编码，也就是Dict，条件有两个：<ol>
<li>ZipList中元素个数超过<code>hash-max-ziplist-entries</code>（默认512），Redis 7为 <code>hash-max-listpack-entries</code></li>
<li>ZipList中任意<code>entry</code>大小长度超过<code>hash-max-ziplist-value</code>（默认64Byte），Redis 7 为 <code>hash-max-listpack-value</code></li>
</ol>
</li>
</ul>
<p class="fireman-p-indent" >ZipList的方式：</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210201749136.png" alt="image-20221210201749136"></p>
<p class="fireman-p-indent" >Hash的方式：</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210201815252.png" alt="image-20221210201815252"></p>
<p class="fireman-p-indent" ><code>src/t_hash.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hsetCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, created = <span class="number">0</span>;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyErrorArity(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 判断hash的key是否存在，不存在则创建一个新的，默认采用ListPack编码</span></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  	<span class="comment">// 判断是否需要将ListPack转为Dict</span></span><br><span class="line">    hashTypeTryConversion(o,c-&gt;argv,<span class="number">2</span>,c-&gt;argc<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; c-&gt;argc; i += <span class="number">2</span>)</span><br><span class="line">      	<span class="comment">// 这里循环遍历命令中的键值，一个一个插入</span></span><br><span class="line">        created += !hashTypeSet(o,c-&gt;argv[i]-&gt;ptr,c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr,HASH_SET_COPY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HMSET (deprecated) and HSET return value is different. */</span></span><br><span class="line">    <span class="type">char</span> *cmdname = c-&gt;argv[<span class="number">0</span>]-&gt;ptr;</span><br><span class="line">    <span class="keyword">if</span> (cmdname[<span class="number">1</span>] == <span class="string">&#x27;s&#x27;</span> || cmdname[<span class="number">1</span>] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">/* HSET */</span></span><br><span class="line">        addReplyLongLong(c, created);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* HMSET */</span></span><br><span class="line">        addReply(c, shared.ok);</span><br><span class="line">    &#125;</span><br><span class="line">    signalModifiedKey(c,c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_HASH,<span class="string">&quot;hset&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    server.dirty += (c-&gt;argc - <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">robj *<span class="title function_">hashTypeLookupWriteOrCreate</span><span class="params">(client *c, robj *key)</span> &#123;	</span><br><span class="line">  	<span class="comment">// 查询key</span></span><br><span class="line">    robj *o = lookupKeyWrite(c-&gt;db,key);</span><br><span class="line">  	<span class="comment">// 判断类型，如果是Hash，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (checkType(c,o,OBJ_HASH)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">// 如果没找到，则创建Hash</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        o = createHashObject();</span><br><span class="line">        dbAdd(c-&gt;db,key,o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the length of a number of objects to see if we need to convert a</span></span><br><span class="line"><span class="comment"> * listpack to a real hash. Note that we only check string encoded objects</span></span><br><span class="line"><span class="comment"> * as their string length can be queried in constant time. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashTypeTryConversion</span><span class="params">(robj *o, robj **argv, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">size_t</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 先判断是不是ListPack</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding != OBJ_ENCODING_LISTPACK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 依次遍历添加进来的元素中的field和value</span></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sdsEncodedObject(argv[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">size_t</span> len = sdslen(argv[i]-&gt;ptr);</span><br><span class="line">      	<span class="comment">// 判断长度 如果大于 hash_max_listpack_value ，则将类型转换成HT</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; server.hash_max_listpack_value) &#123;</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += len;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果 总大小，超过1G，也转为HT</span></span><br><span class="line">    <span class="keyword">if</span> (!lpSafeToAdd(o-&gt;ptr, sum))</span><br><span class="line">        hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a new field, overwrite the old with the new value if it already exists.</span></span><br><span class="line"><span class="comment"> * Return 0 on insert and 1 on update.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * By default, the key and value SDS strings are copied if needed, so the</span></span><br><span class="line"><span class="comment"> * caller retains ownership of the strings passed. However this behavior</span></span><br><span class="line"><span class="comment"> * can be effected by passing appropriate flags (possibly bitwise OR-ed):</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * HASH_SET_TAKE_FIELD -- The SDS field ownership passes to the function.</span></span><br><span class="line"><span class="comment"> * HASH_SET_TAKE_VALUE -- The SDS value ownership passes to the function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When the flags are used the caller does not need to release the passed</span></span><br><span class="line"><span class="comment"> * SDS string(s). It&#x27;s up to the function to use the string to create a new</span></span><br><span class="line"><span class="comment"> * entry or to free the SDS string before returning to the caller.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * HASH_SET_COPY corresponds to no flags passed, and means the default</span></span><br><span class="line"><span class="comment"> * semantics of copying the values if needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_SET_TAKE_FIELD (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_SET_TAKE_VALUE (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_SET_COPY 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashTypeSet</span><span class="params">(robj *o, sds field, sds value, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="type">int</span> update = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the field is too long for listpack, and convert before adding the item.</span></span><br><span class="line"><span class="comment">     * This is needed for HINCRBY* case since in other commands this is handled early by</span></span><br><span class="line"><span class="comment">     * hashTypeTryConversion, so this check will be a NOP. */</span></span><br><span class="line">  	<span class="comment">// 判断编码是ListPack</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_LISTPACK) &#123;</span><br><span class="line">      	<span class="comment">// 判断长度是否大于 hash_max_listpack_value ，或者值大于 hash_max_listpack_value</span></span><br><span class="line">        <span class="keyword">if</span> (sdslen(field) &gt; server.hash_max_listpack_value || sdslen(value) &gt; server.hash_max_listpack_value)</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_LISTPACK) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *zl, *fptr, *vptr;</span><br><span class="line"></span><br><span class="line">        zl = o-&gt;ptr;</span><br><span class="line">        fptr = lpFirst(zl);</span><br><span class="line">        <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fptr = lpFind(zl, fptr, (<span class="type">unsigned</span> <span class="type">char</span>*)field, sdslen(field), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Grab pointer to the value (fptr points to the field) */</span></span><br><span class="line">                vptr = lpNext(zl, fptr);</span><br><span class="line">                serverAssert(vptr != <span class="literal">NULL</span>);</span><br><span class="line">                update = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Replace value */</span></span><br><span class="line">                zl = lpReplace(zl, &amp;vptr, (<span class="type">unsigned</span> <span class="type">char</span>*)value, sdslen(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">            <span class="comment">/* Push new field/value pair onto the tail of the listpack */</span></span><br><span class="line">            zl = lpAppend(zl, (<span class="type">unsigned</span> <span class="type">char</span>*)field, sdslen(field));</span><br><span class="line">            zl = lpAppend(zl, (<span class="type">unsigned</span> <span class="type">char</span>*)value, sdslen(value));</span><br><span class="line">        &#125;</span><br><span class="line">        o-&gt;ptr = zl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the listpack needs to be converted to a hash table */</span></span><br><span class="line">      	<span class="comment">// 插入之后，再次校验长度是否大于hash_max_listpack_entries</span></span><br><span class="line">        <span class="keyword">if</span> (hashTypeLength(o) &gt; server.hash_max_listpack_entries)</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dictEntry *de = dictFind(o-&gt;ptr,field);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            sdsfree(dictGetVal(de));</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123;</span><br><span class="line">                dictGetVal(de) = value;</span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dictGetVal(de) = sdsdup(value);</span><br><span class="line">            &#125;</span><br><span class="line">            update = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sds f,v;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD) &#123;</span><br><span class="line">                f = field;</span><br><span class="line">                field = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = sdsdup(field);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123;</span><br><span class="line">                v = value;</span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = sdsdup(value);</span><br><span class="line">            &#125;</span><br><span class="line">            dictAdd(o-&gt;ptr,f,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free SDS strings we did not referenced elsewhere if the flags</span></span><br><span class="line"><span class="comment">     * want this function to be responsible. */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD &amp;&amp; field) sdsfree(field);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE &amp;&amp; value) sdsfree(value);</span><br><span class="line">    <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><code>src/object.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">createHashObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	<span class="comment">// 创建Hash，申请内存，默认使用ListPack编码的对象</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl = lpNew(<span class="number">0</span>);</span><br><span class="line">  	<span class="comment">// 编码方式是Hash</span></span><br><span class="line">    robj *o = createObject(OBJ_HASH, zl);</span><br><span class="line">  	<span class="comment">// 设置编码是ListPack</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_LISTPACK;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h1><h2 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h2><p class="fireman-p-indent" >服务器大多采用Linux系统，内核也是Linux，应用都是需要通过Linux内核与硬件交互。</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210203200225.png" alt="image-20221210203200225"></p>
<p class="fireman-p-indent" >因此，服务器在运行过程中，内核也需要使用到一定的CPU资源和内存资源。</p>
<p class="fireman-p-indent" >为了避免用户应用导致冲突甚至内核崩溃，用户应用于内核是分离的：</p>
<ul>
<li><p>进程的寻址空间会划分为两部分：内核空间、用户空间</p>
<p>应用或者说内核是无法直接访问物理内存的，而是通过操作虚拟内存空间，映射到物理内存。虚拟内存的地址可以通过一个无符号整形指定，不同位数操作系统的虚拟内存范围不一样，例如32位操作系统最大虚拟内存地址是2^32，也就是4GB。</p>
<p>内核空间和用户空间的划分，是使用高位的1GB划分为内核空间，地位的3GB划分为用户空间。</p>
<p>当进程运行在用户空间时，则称为是用户态；</p>
<p>当进程运行在内核空间时，则称为是内核态。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210203828934.png" alt="image-20221210203828934"></p>
</li>
<li><p>用户空间只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问</p>
</li>
<li><p>内核空间可以执行特权命令（Ring0），调用一切系统资源</p>
</li>
</ul>
<p class="fireman-p-indent" >例如使用IO资源，就会经过内核态到用户态（读取）、用户态到内核态（写入）的切换。inux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p>
<ul>
<li>写数据时，要把用户缓冲区的数据，拷贝到内核缓冲区，然后写入设别</li>
<li>读数据时，要把设备的数据，读取到内核缓冲区，然后拷贝到用户缓冲区</li>
</ul>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210204124936.png" alt="image-20221210204124936"></p>
<p class="fireman-p-indent" >也就是说，应用处理数据的性能，可以从这两个方面进行优化：</p>
<ol>
<li>减少数据从用户态到内核态的切换</li>
<li>减少数据在网络栈中的等待时间</li>
</ol>
<p class="fireman-p-indent" >为了在这两个方面进行优化，操作系统实现五种IO模型。</p>
<h2 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h2><p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210204444011.png" alt="image-20221210204444011"></p>
<p class="fireman-p-indent" >例如读取数据的过程：</p>
<ol>
<li>应用无法直接操作硬件设备，只能通过内核的接口进行调用，因此需要先等待数据就绪</li>
<li>内核缓冲区数据就绪之后，将内核缓冲区的数据读取到用户缓冲区</li>
</ol>
<p class="fireman-p-indent" >针对这种情况，在《UNIX网络编程》一书中，总结归纳了五种IO模型：</p>
<ul>
<li>阻塞IO（Blocking IO）</li>
<li>非阻塞IO（Nonblocking IO）</li>
<li>IO多路复用（IO Multiplexing）</li>
<li>信号驱动IO（Signal Driven IO）</li>
<li>异步IO（Asynchronous IO）</li>
</ul>
<h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p class="fireman-p-indent" >阻塞IO在两个阶段（读取数据时等待内核缓冲区数据就绪；拷贝数据时等待数据拷贝就绪），都必须阻塞等待</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210204855343.png" alt="image-20221210204855343"></p>
<p class="fireman-p-indent" >在等待内核缓冲区数据就绪的过程中，即使内核返回没有数据，阻塞IO也不会报错，而是一直等待数据就位。 </p>
<h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p class="fireman-p-indent" >非阻塞IO的<code>recvfrom</code>操作，会立即返回结果，而不是阻塞用户进程。</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210210608387.png" alt="image-20221210210608387"></p>
<p class="fireman-p-indent" >在内核返回没有数据时，系统调用过程直接返回一个失败的信息，并且再次重试。在等待内核缓冲区数据就绪的过程中，非阻塞IO不会阻塞。</p>
<p class="fireman-p-indent" >一方面，在等待数据的过程中，循环获取内核缓冲区状态，还是会消耗CPU资源，而且数据就绪时，从内核拷贝数据到用户空间的过程，还是处于阻塞状态。因此，非阻塞IO不一定会比阻塞IO要好。</p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p class="fireman-p-indent" >无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用<code>revcfrom</code>来获取数据，差别在于无数据时的处理方案：</p>
<ul>
<li>如果调用<code>revcfrom</code>时，恰好<strong>没有数据</strong>，阻塞IO会使进程阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用</li>
<li>如果调用<code>revcfrom</code>时，恰好<strong>有数据</strong>，则用户进程可以直接进入第二阶段，读取并处理数据</li>
</ul>
<p class="fireman-p-indent" >比如服务端处理客户端Socket请求时，在单线程情况下，只能一次处理每一个Socket，如果正在处理Socket恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有其他客户端Socket都必须等待，性能自然会很差。</p>
<p class="fireman-p-indent" >就像服务员给顾客点餐，分两步：</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210211253081.png" alt="image-20221210211253081"></p>
<ol>
<li>顾客思考要吃什么（等待数据就绪）</li>
<li>顾客想好了，开始点餐（读取数据）</li>
</ol>
<p class="fireman-p-indent" >提升效率的方法：</p>
<ol>
<li>增加更多服务员；也就是使用多线程，使用多颗CPU</li>
<li>不排队，谁想好了吃什么，服务员就给谁点餐；也就是数据就绪之后，用户应用就去读取数据</li>
</ol>
<p class="fireman-p-indent" >使用方案2会更好一点，但是有一个前提，就是用户进程需要知道内核中缓冲数据是否已经就绪。</p>
<p class="fireman-p-indent" >文件描述符（File Descriptor）：简称FD，是一个从0开始递增的无符号整数，用来关联Linux中的一个文件。</p>
<p class="fireman-p-indent" >在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，也包括网络套接字（Socket）</p>
<p class="fireman-p-indent" >IO多路复用：是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210211744633.png" alt="image-20221210211744633"></p>
<p class="fireman-p-indent" >相比阻塞IO和非阻塞IO而言，使用图中的SELECT模式，可以一次性监听多个FD，有一个FD就绪，则立马返回，然后进入阶段二。</p>
<p class="fireman-p-indent" >监听FD的方式、通知的方式又有多种实现，常见的有：</p>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<p class="fireman-p-indent" >差异：</p>
<ul>
<li>select和poll，只会通知用户进程有FD就绪，但不确定具体是哪个FD，需要用户进程遍历FD来确认</li>
<li>epoll则会通知用户进程FD就绪的同事，把已就绪的FD写入用户空间</li>
</ul>
<h3 id="IO多路复用-select"><a href="#IO多路复用-select" class="headerlink" title="IO多路复用-select"></a>IO多路复用-select</h3><p class="fireman-p-indent" >select是Linux中最早的IO多路复用实现方案</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类型别名 __fd_mask，本质是 long int ，占4个字节，32bit</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> __fd_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd_set 记录要监听的fd集合，及其对应状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// fds_bits 是一个long类型数组，长度是 1024/32 = 32</span></span><br><span class="line">  <span class="comment">// 长度32*每一个元素的长度是32bit，等于1024bit，一个bit记录一个FD，也就是一个select最多可以监听1024个FD</span></span><br><span class="line">  <span class="comment">// 一共 1024个bit位，每个bit代表一个fd，0代表未就绪，1代表就绪</span></span><br><span class="line">  __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select 函数，用于监听多个fd的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">( </span></span><br><span class="line"><span class="params">	<span class="type">int</span> nfds, 								<span class="comment">// 要监听的fd_set的最大fd+1</span></span></span><br><span class="line"><span class="params">  <span class="comment">// Linux将IO的事件归为三类，可读、可写、异常，因此，fd状态也分为三类</span></span></span><br><span class="line"><span class="params">  fd_set *readfds, 					<span class="comment">// 要监听读事件的fd集合</span></span></span><br><span class="line"><span class="params">  fd_set *writefds, 				<span class="comment">// 要监听写事件的fd集合</span></span></span><br><span class="line"><span class="params">  fd_set *exceptfds, 				<span class="comment">// 要监听异常事件的fd集合</span></span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> timeval *timeout 	<span class="comment">// 超时时间：null为永不超时；0为不阻塞等待；大于0为等待的时间</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >整个过程如下：</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210214947102.png" alt="image-20221210214947102"></p>
<p class="fireman-p-indent" >其中：</p>
<ul>
<li>需要将<code>fd_set</code>从用户空间拷贝到内核空间</li>
<li>当有任意fd就绪，则内核空间将结果写入<code>fd_set</code>到，而且是便利写入，将没有就绪的<code>fd</code>覆盖掉</li>
<li>再将内核空间的<code>fd_set</code>拷贝到用户空间，并且覆盖原先的<code>fd_set</code></li>
<li>用户空间便利<code>fd_set</code>获取到准备就绪的fd，进行处理</li>
</ul>
<p class="fireman-p-indent" >select模式存在的问题：</p>
<ul>
<li>需要将整个fd_set从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间；这是影响select性能的重要原因</li>
<li>select无法得知具体是哪个fd就绪，需要便利整个fd_set（结构体中记录的bit位）</li>
<li>fd_set监听的fd数量不能超过1024（代码已经固化）</li>
</ul>
<h3 id="IO多路复用-poll"><a href="#IO多路复用-poll" class="headerlink" title="IO多路复用-poll"></a>IO多路复用-poll</h3><p class="fireman-p-indent" >poll模式对select模式做了简单改进，但性能提升不明显，部分关键代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pollfd 中的事件类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLIN		0x0001		<span class="comment">// 可读事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLPRI		0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLOUT		0x0004		<span class="comment">// 可写事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLERR		0x0008		<span class="comment">// 错误事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLHUP		0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLNVAL	0x0020		<span class="comment">// fd未打开</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pollfd结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd;						<span class="comment">// 要监听的fd</span></span><br><span class="line">	<span class="type">short</span> events;			<span class="comment">// 要监听的事件类型：读、写、异常		</span></span><br><span class="line">	<span class="type">short</span> revents;		<span class="comment">// 实际发生的事件类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> pollfd *fds,		<span class="comment">// pollfd数组，可以自定义大小</span></span></span><br><span class="line"><span class="params">  <span class="type">nfds_t</span> nfds,					<span class="comment">// 数组元素个数</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> timeout						<span class="comment">// 超时时间</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >IO流程：</p>
<ol>
<li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li>
<li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li>
<li>内核便利fd，判断是否就绪</li>
<li>数据就绪或超时后，拷贝pollfd数据到用户空间，返回就绪fd数量n</li>
<li>用户进程判断n是否大于0</li>
<li>大于0则便利pollfd数组，找到就绪的fd</li>
</ol>
<p class="fireman-p-indent" >与select对比：</p>
<ul>
<li>select模式中fd_set大小固定1024，而pollfd在内核中采用链表，理论上无上限</li>
<li>监听fd越多，每次便利消耗时间也越久，性能反而会下降</li>
</ul>
<p class="fireman-p-indent" >主要解决了select的fd个数限制问题，但是依然需要便利fd，也需要将fd进行拷贝。</p>
<h3 id="IO多路复用-epoll"><a href="#IO多路复用-epoll" class="headerlink" title="IO多路复用-epoll"></a>IO多路复用-epoll</h3><p class="fireman-p-indent" >源码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpd2Vpd2FuZzE5OTMvZXZlbnRwb2xsL2Jsb2IvbWFzdGVyL2V2ZW50cG9sbC5jcHA=">https://github.com/liweiwang1993/eventpoll/blob/master/eventpoll.cpp<i class="fa fa-external-link-alt"></i></span></p>
<p class="fireman-p-indent" >epoll模式是对select和poll的改进，提供三个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">// 截取部分</span></span><br><span class="line">    <span class="comment">/* List of ready file descriptors */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span>	<span class="comment">// 一个链表，记录就绪的FD</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span>	<span class="comment">// 一颗红黑树，记录要监听的FD</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 会在内核创建eventpoll结构体，返回对应的句柄epfd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 将一个FD添加到epoll的红黑树中，并设置ep_poll_callback</span></span><br><span class="line"><span class="comment">// callback触发时，就把对应的FD加入到rdlist这个就绪列表中</span></span><br><span class="line">epoll_ctl(</span><br><span class="line">	<span class="type">int</span> epfd,										<span class="comment">// epoll实例的句柄</span></span><br><span class="line">  <span class="type">int</span> op,											<span class="comment">// 要执行的操作，包括：增ADD、改MOD、删DEL</span></span><br><span class="line">  <span class="type">int</span> fd,											<span class="comment">// 要监听的FD</span></span><br><span class="line">	<span class="keyword">struct</span> epoll_event *event		<span class="comment">// 要监听的事件类型：读、写、异常等</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 检查rdlist列表是否为空，不为空则返回就绪FD的数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">int</span> epfd,											<span class="comment">// eventpoll实例的句柄</span></span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> epoll_event *events,		<span class="comment">// 空event数组，用于接受就绪的FD</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> maxevents,								<span class="comment">// events数组的最大长度</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> timeout										<span class="comment">// 超时时间；-1永不超时；0不阻塞；大于0位阻塞时间</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210221442752.png" alt="image-20221210221442752"></p>
<p class="fireman-p-indent" >epoll通过在内核空间的红黑树和链表，不需要拷贝fd，而且红黑树也没有fd个数限制，数量很多的时候也不会对红黑树上增、删、查找速度造成很大影响。通过将就绪fd拷贝到<code>events</code>中减少fd拷贝，<code>epoll_wait</code>只处理就绪的fd链表，不需要遍历fd，解决select和poll的问题。</p>
<h3 id="IO多路复用-事件通知机制"><a href="#IO多路复用-事件通知机制" class="headerlink" title="IO多路复用-事件通知机制"></a>IO多路复用-事件通知机制</h3><p class="fireman-p-indent" >当FD有数据可读时，调用<code>epoll_wait</code>就可以得到通知，但是时间通知的模式有两种：</p>
<ul>
<li><code>LevelTriggered</code>：简称LT。当FD有数据可读时，会重复通知多次，直到数据处理完成。是epoll的默认模式。</li>
<li><code>EdgeTriggered</code>：简称ET。当FD有数据可读时，只会被通知一次，不管数据是否处理完成。</li>
</ul>
<p class="fireman-p-indent" >例如：</p>
<ol>
<li>一个客户端Socket对应的FD已经注册到了epoll实例中</li>
<li>客户端Socket发送2KB的数据</li>
<li>服务端调用<code>epoll_wait</code>，得到通知说FD就绪</li>
<li>服务端FD读取到1KB数据</li>
<li>如果是LT，回到步骤3，再次调用<code>epoll_wait</code>，形成循环</li>
<li>如果是ET，另外1KB的数据就无法被读取到</li>
</ol>
<p class="fireman-p-indent" >其实是在epoll过程中，当有fd就绪，链表中的fd拷贝到用户态之后，这些FD会从链表中删除，然后检查通知模式，如果是LT，则会将未处理完的FD添加回链表中，如果是ET，则不会。</p>
<p class="fireman-p-indent" >如果选择ET，出现这种情况时，</p>
<p class="fireman-p-indent" >方案1：可以通过手动调用<code>epoll_ctl</code>检查数据是否读完，没有读完，再手动将数据添加到链表中；</p>
<p class="fireman-p-indent" >方案2：再步骤4时，使用循环读取，数据没有读取完，不返回；（这种方式需要注意，需要使用非阻塞的方式）</p>
<p class="fireman-p-indent" >LT的方式可能出现的问题：</p>
<p class="fireman-p-indent" >1、重复发送会有性能影响</p>
<p class="fireman-p-indent" >2、多个线程处理情况下，可能导致惊群现象</p>
<h3 id="IO多路复用在web服务上的例子"><a href="#IO多路复用在web服务上的例子" class="headerlink" title="IO多路复用在web服务上的例子"></a>IO多路复用在web服务上的例子</h3><p class="fireman-p-indent" >基于epoll模式的web服务的基本流程图：</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210223240610.png" alt="image-20221210223240610"></p>
<h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p class="fireman-p-indent" >信号驱动IO使与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其他业务，无需阻塞等待。</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210223454987.png" alt="image-20221210223454987"></p>
<p class="fireman-p-indent" >这种模式，才是真正的非阻塞模式，因为根本不需要等待内核数据就绪，而是通过回调的形式，内核通知用户进程。</p>
<p class="fireman-p-indent" >这种模式存在的问题：</p>
<ol>
<li>当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理，可能导致信号队列溢出</li>
<li>内核空间与用户空间的频繁信号交互，性能也比较低</li>
</ol>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p class="fireman-p-indent" >异步IO的整个过程都是非阻塞的。通过一个注册一个函数到内核空间，在内核空间中的数据就绪，并且拷贝到用户空间之后，执行这个函数通知用户进程去处理数据。</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210223732777.png" alt="image-20221210223732777"></p>
<p class="fireman-p-indent" >这种模式，可能出现的问题：</p>
<ol>
<li>当数据量很大，占用内存过多时，性能不高，而且可能导致函数调用发生异常，</li>
</ol>
<h3 id="区分同步和异步"><a href="#区分同步和异步" class="headerlink" title="区分同步和异步"></a>区分同步和异步</h3><p class="fireman-p-indent" >IO操作时同步还是异步，关键看数据在内核空间与用户空间的拷贝过程（数据读写的IO操作），也就是阶段二是同步还是异步：</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210224114125.png" alt="image-20221210224114125"></p>
<h2 id="Redis网络模型-1"><a href="#Redis网络模型-1" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h2><p class="fireman-p-indent" >Redis的核心业务部分，也就是命令处理，此时Redis是单线程。但是整个Redis是多线程。</p>
<p class="fireman-p-indent" >在Redis 4.0时，引入多线程异步处理一些耗时较长的任务，例如异步删除命令<code>unlink</code>、<code>bgsave</code>、<code>rewrite</code></p>
<p class="fireman-p-indent" >在Redis 6.0时，核心网络模型中引入多线程，进一步提高对于多个CPU的利用率</p>
<p class="fireman-p-indent" >Redis核心业务使用单线程的原因：</p>
<ul>
<li>Redis是纯内存操作，执行速度非常快，性能瓶颈时网络延迟，而不是执行速度，因此多线程并不会带来巨大的性能提升</li>
<li>多线程会导致过多的上下文切换，带来不必要的开销</li>
<li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li>
</ul>
<p class="fireman-p-indent" >Redis通过IO多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行封装，提供统一的高性能事件库API库AE：</p>
<p class="fireman-p-indent" >以6.2版本为例</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210224832286.png" alt="image-20221210224832286"></p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210224908284.png" alt="image-20221210224908284"></p>
<p class="fireman-p-indent" >实际调用的IO多路复用方式</p>
<p class="fireman-p-indent" ><code>src/ae.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Include the best multiplexing layer supported by this system.</span></span><br><span class="line"><span class="comment"> * The following should be ordered by performances, descending. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_EVPORT									<span class="comment">// 判断是否支持HAVE_EVPORT，如果支持，调用ae_evport.c，下面的代码同理</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ae_evport.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> HAVE_EPOLL								<span class="comment">// 判断是否支持HAVE_EPOLL，如果支持，调用ae_epoll.c，</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ae_epoll.c&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> HAVE_KQUEUE					<span class="comment">// 判断是否支持HAVE_KQUEUE，如果支持，调用ae_kqueue.c，</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ae_kqueue.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span>												<span class="comment">// 如果以上都不支持，就调用ae_select.c</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ae_select.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >Redis网络模型的流程：</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225515989.png" alt="image-20221210225515989"></p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225539093.png" alt="image-20221210225539093"></p>
<p class="fireman-p-indent" >单线程流程：</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225853658.png" alt="image-20221210225853658"></p>
<p class="fireman-p-indent" >Redis 6.0版本引入多线程，目的是为了提高IO读写效率。因此在解析客户端命令、写响应结果时采用了多线程。核心的命令执行、IO多路复用模块，依然是由主线程执行。</p>
<p class="fireman-p-indent" >多线程流程：</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225730118.png" alt="image-20221210225730118"></p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225616051.png" alt="image-20221210225616051"></p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210225655449.png" alt="image-20221210225655449"></p>
<h1 id="Redis通信协议"><a href="#Redis通信协议" class="headerlink" title="Redis通信协议"></a>Redis通信协议</h1><h2 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h2><p class="fireman-p-indent" >Redis是一个CS架构的软件，通信一般分两步（不包括<code>pipeline</code>和PubSub）</p>
<ol>
<li>客户端向服务端发送一条命令</li>
<li>服务端解析并执行命令，返回相应结果给客户端</li>
</ol>
<p class="fireman-p-indent" >因此客户端发送命令的格式、服务端响应结果的格式，必须有一个规范，这个规范就是通信协议。</p>
<p class="fireman-p-indent" >Redis中采用RESP（Redis Serialization Protocl）协议：</p>
<ul>
<li>Redis 1.2版本引入RESP协议</li>
<li>Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2</li>
<li>Redis 6.0版本中，从RESP2升级到RESP3协议，增加了更多数据类型并且支持6.0的新特性–客户端缓存。</li>
</ul>
<p class="fireman-p-indent" >这里以RESP2为例。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p class="fireman-p-indent" >RESP中，通过首字节的字符来区分不同的数据类型，常用的数据类型包括5中：</p>
<ul>
<li><p>单行字符串：首字节是<code>+</code>，后面跟上单行字符串，以CRLF（<code>\r\n</code>），例如返回 <code>OK</code> : <code>+OK\r\n</code></p>
</li>
<li><p>错误（Errors）：首字节是<code>-</code>，与单行字符串格式一样，只是字符串是异常信息，例如：<code>-Error message\r\n</code></p>
</li>
<li><p>数值：首字节是<code>:</code>，后面跟上数字格式的字符串，以CRLF结尾，例如：<code>:10\r\n</code></p>
</li>
<li><p>多行字符串：首字节是<code>$</code>，表示二进制安全的字符串，最大支持512MB：</p>
<ul>
<li>如果大小为0，则代表空字符串：<code>$0\r\n\r\n</code></li>
<li>如果大小为-1，则代表不存在：<code>$-1\r\n</code></li>
</ul>
</li>
<li><p class="fireman-p-indent" >数组：首字节是<code>*</code>，后面跟上数组元素个数，再跟上元素，元素数据类型不限</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210230629790.png" alt="image-20221210230629790"></p>
</li>
</ul>
<h1 id="Redis内存策略"><a href="#Redis内存策略" class="headerlink" title="Redis内存策略"></a>Redis内存策略</h1><p class="fireman-p-indent" >单节点Redis内存大小不易过大，会影响持久化或主从同步性能。</p>
<p class="fireman-p-indent" >可以通过修改配置来设置Redis最大内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG GET *maxmemory*</span><br><span class="line"> 1) &quot;maxmemory&quot;</span><br><span class="line"> 2) &quot;0&quot;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >当内存使用达到上限时，就无法存储更多数据。</p>
<h2 id="内存过期"><a href="#内存过期" class="headerlink" title="内存过期"></a>内存过期</h2><p class="fireman-p-indent" >通过ttl获取数据过期时间，当数据过期时，则删除该数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name mitaka		// 设置key value</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE name 5			// 设置过期时间 5s</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get name					// 立即获取</span><br><span class="line">&quot;mitaka&quot;</span><br><span class="line">127.0.0.1:6379&gt; get name					// 过5s之后再获取</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >可以看到，当key的TTL到期之后，再次访问这个key，返回nil，说明这个key已经不存在了，对应的内存也得到释放，从而起到内存回收的目的。</p>
<p class="fireman-p-indent" >Redis中，所有的key、value都保存在Dict结构中，不过在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-ttl</p>
<p class="fireman-p-indent" ><code>src/server.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Redis database representation. There are multiple databases identified</span></span><br><span class="line"><span class="comment"> * by integers from 0 (the default database) up to the max configured</span></span><br><span class="line"><span class="comment"> * database. The database number is the &#x27;id&#x27; field in the structure. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">		<span class="comment">// 存放所有key及value的地方，也称为keyspace</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span>																		</span><br><span class="line">    <span class="comment">// 存放每一个key及其对应的TTL存活时间，只包含设置了TTL的key</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="type">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="comment">// 记录平均TTL时长</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">    <span class="comment">// expire检查时，在dict中抽样的索引位置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires_cursor; <span class="comment">/* Cursor of the active expire cycle. */</span></span><br><span class="line">    <span class="comment">// 等待碎片整理的key列表</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210231512045.png" alt="image-20221210231512045"></p>
<p class="fireman-p-indent" >Redis通过两个Dict分别记录key-value对，以及key-ttl对，直到一个key是否过期</p>
<p class="fireman-p-indent" >但是TTL到期的不会立即删除，而是<strong>惰性删除</strong>或者<strong>周期删除</strong>。</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p class="fireman-p-indent" >在访问一个key的时候，检查key的存储时间，如果已经过期，才执行删除</p>
<p class="fireman-p-indent" ><code>src/db.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lookup a key for write operations, and as a side effect, if needed, expires</span></span><br><span class="line"><span class="comment"> * the key if its TTL is reached.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the linked value object if the key exists or NULL if the key</span></span><br><span class="line"><span class="comment"> * does not exist in the specified DB. */</span></span><br><span class="line"><span class="comment">// 查找一个key执行写操作</span></span><br><span class="line">robj *<span class="title function_">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">  	<span class="comment">// 检查是否过期</span></span><br><span class="line">    expireIfNeeded(db,key);</span><br><span class="line">    <span class="keyword">return</span> lookupKey(db,key,flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lookup a key for read operations, or return NULL if the key is not found</span></span><br><span class="line"><span class="comment"> * in the specified DB.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As a side effect of calling this function:</span></span><br><span class="line"><span class="comment"> * 1. A key gets expired if it reached it&#x27;s TTL.</span></span><br><span class="line"><span class="comment"> * 2. The key last access time is updated.</span></span><br><span class="line"><span class="comment"> * 3. The global keys hits/misses stats are updated (reported in INFO).</span></span><br><span class="line"><span class="comment"> * 4. If keyspace notifications are enabled, a &quot;keymiss&quot; notification is fired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This API should not be used when we write to the key after obtaining</span></span><br><span class="line"><span class="comment"> * the object linked to the key, but only for read only operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Flags change the behavior of this command:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  LOOKUP_NONE (or zero): no special flags are passed.</span></span><br><span class="line"><span class="comment"> *  LOOKUP_NOTOUCH: don&#x27;t alter the last access time of the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: this function also returns NULL if the key is logically expired</span></span><br><span class="line"><span class="comment"> * but still existing, in case this is a slave, since this API is called only</span></span><br><span class="line"><span class="comment"> * for read operations. Even if the key expiry is master-driven, we can</span></span><br><span class="line"><span class="comment"> * correctly report a key is expired on slaves even if the master is lagging</span></span><br><span class="line"><span class="comment"> * expiring our key via DELs in the replication link. */</span></span><br><span class="line"><span class="comment">// 查找一个key执行读取操作</span></span><br><span class="line">robj *<span class="title function_">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    robj *val;</span><br><span class="line">		<span class="comment">// 检查key是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (expireIfNeeded(db,key) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* If we are in the context of a master, expireIfNeeded() returns 1</span></span><br><span class="line"><span class="comment">         * when the key is no longer valid, so we can return NULL ASAP. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> keymiss;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* However if we are in the context of a slave, expireIfNeeded() will</span></span><br><span class="line"><span class="comment">         * not really try to expire the key, it only returns information</span></span><br><span class="line"><span class="comment">         * about the &quot;logical&quot; status of the key: key expiring is up to the</span></span><br><span class="line"><span class="comment">         * master in order to have a consistent view of master&#x27;s data set.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * However, if the command caller is not the master, and as additional</span></span><br><span class="line"><span class="comment">         * safety measure, the command invoked is a read-only command, we can</span></span><br><span class="line"><span class="comment">         * safely return NULL here, and provide a more consistent behavior</span></span><br><span class="line"><span class="comment">         * to clients accessing expired values in a read-only fashion, that</span></span><br><span class="line"><span class="comment">         * will say the key as non existing.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Notably this covers GETs when slaves are used to scale reads. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.current_client &amp;&amp;</span><br><span class="line">            server.current_client != server.master &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd-&gt;flags &amp; CMD_READONLY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> keymiss;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val = lookupKey(db,key,flags);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> keymiss;</span><br><span class="line">    server.stat_keyspace_hits++;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">keymiss:</span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; LOOKUP_NONOTIFY)) &#123;</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">&quot;keymiss&quot;</span>, key, db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    server.stat_keyspace_misses++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called when we are going to perform some operation</span></span><br><span class="line"><span class="comment"> * in a given key, but such key may be already logically expired even if</span></span><br><span class="line"><span class="comment"> * it still exists in the database. The main way this function is called</span></span><br><span class="line"><span class="comment"> * is via lookupKey*() family of functions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The behavior of the function depends on the replication role of the</span></span><br><span class="line"><span class="comment"> * instance, because slave instances do not expire keys, they wait</span></span><br><span class="line"><span class="comment"> * for DELs from the master for consistency matters. However even</span></span><br><span class="line"><span class="comment"> * slaves will try to have a coherent return value for the function,</span></span><br><span class="line"><span class="comment"> * so that read commands executed in the slave side will be able to</span></span><br><span class="line"><span class="comment"> * behave like if the key is expired even if still present (because the</span></span><br><span class="line"><span class="comment"> * master has yet to propagate the DEL).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In masters as a side effect of finding a key which is expired, such</span></span><br><span class="line"><span class="comment"> * key will be evicted from the database. Also this may trigger the</span></span><br><span class="line"><span class="comment"> * propagation of a DEL/UNLINK command in AOF / replication stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The return value of the function is 0 if the key is still valid,</span></span><br><span class="line"><span class="comment"> * otherwise the function returns 1 if the key is expired. */</span></span><br><span class="line"><span class="comment">// 判断是否过期</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">  	<span class="comment">// key过期，则直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are running in the context of a slave, instead of</span></span><br><span class="line"><span class="comment">     * evicting the expired key from the database, we return ASAP:</span></span><br><span class="line"><span class="comment">     * the slave key expiration is controlled by the master that will</span></span><br><span class="line"><span class="comment">     * send us synthesized DEL operations for expired keys.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Still we try to return the right information to the caller,</span></span><br><span class="line"><span class="comment">     * that is, 0 if we think the key should be still valid, 1 if</span></span><br><span class="line"><span class="comment">     * we think the key is expired at this time. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If clients are paused, we keep the current dataset constant,</span></span><br><span class="line"><span class="comment">     * but return to the client what we believe is the right state. Typically,</span></span><br><span class="line"><span class="comment">     * at the end of the pause we will properly expire the key OR we will</span></span><br><span class="line"><span class="comment">     * have failed over and the new primary will send us the expire. */</span></span><br><span class="line">    <span class="keyword">if</span> (checkClientPauseTimeoutAndReturnIfPaused()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">  	<span class="comment">// 删除过期key</span></span><br><span class="line">    deleteExpiredKeyAndPropagate(db,key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if the key is expired. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="type">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="type">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are in the context of a Lua script, we pretend that time is</span></span><br><span class="line"><span class="comment">     * blocked to when the Lua script started. This way a key can expire</span></span><br><span class="line"><span class="comment">     * only the first time it is accessed and not in the middle of the</span></span><br><span class="line"><span class="comment">     * script execution, making propagation to slaves / AOF consistent.</span></span><br><span class="line"><span class="comment">     * See issue #1525 on Github for more information. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.lua_caller) &#123;</span><br><span class="line">        now = server.lua_time_snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If we are in the middle of a command execution, we still want to use</span></span><br><span class="line"><span class="comment">     * a reference time that does not change: in that case we just use the</span></span><br><span class="line"><span class="comment">     * cached time, that we update before each call in the call() function.</span></span><br><span class="line"><span class="comment">     * This way we avoid that commands such as RPOPLPUSH or similar, that</span></span><br><span class="line"><span class="comment">     * may re-open the same key multiple times, can invalidate an already</span></span><br><span class="line"><span class="comment">     * open object in a next call, if the next call will see the key expired,</span></span><br><span class="line"><span class="comment">     * while the first did not. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.fixed_time_expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        now = server.mstime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* For the other cases, we want to use the most fresh time we have. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        now = mstime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The key expired if the current (virtual or real) time is greater</span></span><br><span class="line"><span class="comment">     * than the expire time of the key. */</span></span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >但是，当一个key已经过期，但是很长时间都没有访问，此时这个key无法被删除。</p>
<h3 id="周期删除"><a href="#周期删除" class="headerlink" title="周期删除"></a>周期删除</h3><p class="fireman-p-indent" >通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。执行周期有两种：</p>
<ul>
<li>Redis设置一个定时任务<code>serverCron()</code>，按照<code>server.hz</code>的频率来执行过期key清理，模式为SLOW</li>
<li>Redis的每个事件循环前会调用<code>beforeSleep()</code>函数，执行过程key清理，模式为FAST</li>
</ul>
<p class="fireman-p-indent" ><code>src/server.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initServer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* Create the timer callback, this is our way to process many background</span></span><br><span class="line"><span class="comment">     * operations incrementally, like clients timeout, eviction of unaccessed</span></span><br><span class="line"><span class="comment">     * expired keys and so forth. */</span></span><br><span class="line">  	<span class="comment">// 创建定时器，关联回调函数serverCron，处理周期取决于server.hz，默认10</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Can&#x27;t create event loop timers.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">serverCron</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="type">long</span> <span class="type">long</span> id, <span class="type">void</span> *clientData)</span> &#123;</span><br><span class="line">    <span class="comment">/* We have just LRU_BITS bits per object for LRU information.</span></span><br><span class="line"><span class="comment">     * So we use an (eventually wrapping) LRU clock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that even if the counter wraps it&#x27;s not a big problem,</span></span><br><span class="line"><span class="comment">     * everything will still work but some object will appear younger</span></span><br><span class="line"><span class="comment">     * to Redis. However for this to happen a given object should never be</span></span><br><span class="line"><span class="comment">     * touched for all the time needed to the counter to wrap, which is</span></span><br><span class="line"><span class="comment">     * not likely.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that you can change the resolution altering the</span></span><br><span class="line"><span class="comment">     * LRU_CLOCK_RESOLUTION define. */</span></span><br><span class="line">  	<span class="comment">// 更新lrulock到当前时间，为后期的LRU和LFU做准备</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lruclock = getLRUClock();	</span><br><span class="line">    atomicSet(server.lruclock,lruclock);		</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Handle background operations on Redis databases. */</span></span><br><span class="line">  	<span class="comment">// 执行database的数据清理，例如过期key处理</span></span><br><span class="line">    databasesCron();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span>/server.hz;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function handles &#x27;background&#x27; operations we are required to do</span></span><br><span class="line"><span class="comment"> * incrementally in Redis databases, such as active key expiring, resizing,</span></span><br><span class="line"><span class="comment"> * rehashing. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">databasesCron</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* Expire keys by random sampling. Not required for slaves</span></span><br><span class="line"><span class="comment">     * as master will synthesize DELs for us. */</span></span><br><span class="line">  	<span class="comment">// 清理过期key</span></span><br><span class="line">    <span class="keyword">if</span> (server.active_expire_enabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iAmMaster()) &#123;</span><br><span class="line">          	<span class="comment">// 使用SLOW模式</span></span><br><span class="line">            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            expireSlaveKeys();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function gets called every time Redis is entering the</span></span><br><span class="line"><span class="comment"> * main loop of the event driven library, that is, before to sleep</span></span><br><span class="line"><span class="comment"> * for ready file descriptors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: This function is (currently) called from two functions:</span></span><br><span class="line"><span class="comment"> * 1. aeMain - The main server loop</span></span><br><span class="line"><span class="comment"> * 2. processEventsWhileBlocked - Process clients during RDB/AOF load</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If it was called from processEventsWhileBlocked we don&#x27;t want</span></span><br><span class="line"><span class="comment"> * to perform all actions (For example, we don&#x27;t want to expire</span></span><br><span class="line"><span class="comment"> * keys), but we do need to perform some actions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The most important is freeClientsInAsyncFreeQueue but we also</span></span><br><span class="line"><span class="comment"> * call some other low-risk functions. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">beforeSleep</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    <span class="comment">/* Run a fast expire cycle (the called function will return</span></span><br><span class="line"><span class="comment">     * ASAP if a fast cycle is not needed). */</span></span><br><span class="line">  	<span class="comment">// 尝试清理部分过期key，清理模式默认为FAST</span></span><br><span class="line">    <span class="keyword">if</span> (server.active_expire_enabled &amp;&amp; server.masterhost == <span class="literal">NULL</span>)</span><br><span class="line">        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" ><code>src/ae.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">      	<span class="comment">// beforeSleep() --&gt; FAST 模式清理</span></span><br><span class="line">      	<span class="comment">// n = aeApiPoll()</span></span><br><span class="line">      	<span class="comment">// 如果 n &gt; 0 ，FD就绪，处理IO事件 </span></span><br><span class="line">      	<span class="comment">// 如果到了执行时间，则调用serverCron() --&gt; SLOW 模式清理</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|</span><br><span class="line">                                   AE_CALL_BEFORE_SLEEP|</span><br><span class="line">                                   AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >SLOW模式规则，相比FAST而言，特点是频率少，耗时长：</p>
<ol>
<li>执行频率受<code>server.hz</code>影响，默认为10，即每秒执行10次，每个执行周期100ms</li>
<li>执行清理耗时不超过一次执行周期的25%</li>
<li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li>
<li>如果没达到时间上限（25ms）并未过期key比例大于10%，再进行一次抽样，否则结束</li>
</ol>
<p class="fireman-p-indent" >FAST模式规则（过期key比例小于10%不执行），相比SLOW而言，特点是频率多，耗时短：</p>
<ol>
<li>执行频率受<code>beforeSleep()</code>调用频率影响，但两次FAST模式间隔不低于2ms</li>
<li>执行清理耗时不超过1ms</li>
<li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li>
<li>如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li>
</ol>
<h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p class="fireman-p-indent" >当Redis内存达到设置的阈值时，Redis主动挑选部分key删除以释放更多内存的流程，就是<strong>内存淘汰</strong>。</p>
<p class="fireman-p-indent" ><code>src/server.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If this function gets called we already read a whole</span></span><br><span class="line"><span class="comment"> * command, arguments are in the client argv/argc fields.</span></span><br><span class="line"><span class="comment"> * processCommand() execute the command or prepare the</span></span><br><span class="line"><span class="comment"> * server for a bulk read from the client.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If C_OK is returned the client is still alive and valid and</span></span><br><span class="line"><span class="comment"> * other operations can be performed by the caller. Otherwise</span></span><br><span class="line"><span class="comment"> * if C_ERR is returned the client was destroyed (i.e. after QUIT). */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">/* Handle the maxmemory directive.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that we do not want to reclaim memory if we are here re-entering</span></span><br><span class="line"><span class="comment">     * the event loop since there is a busy Lua script running in timeout</span></span><br><span class="line"><span class="comment">     * condition, to avoid mixing the propagation of scripts with the</span></span><br><span class="line"><span class="comment">     * propagation of DELs due to eviction. */</span></span><br><span class="line">  	<span class="comment">// 尝试进行内存淘汰 performEvictions，如果失败，则会有 out_of_memory</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;</span><br><span class="line">        <span class="type">int</span> out_of_memory = (performEvictions() == EVICT_FAIL);</span><br><span class="line">      	<span class="comment">// 当 out_of_memory 时，会拒绝命令</span></span><br><span class="line">        <span class="keyword">if</span> (out_of_memory &amp;&amp; reject_cmd_on_oom) &#123;</span><br><span class="line">            rejectCommand(c, shared.oomerr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >也就是说：</p>
<ul>
<li>Redis在执行任何命令之前，都会检查内存是否超过阈值</li>
<li>如果超过，则进行内存淘汰</li>
<li>如果内存淘宝失败，则返回报错</li>
</ul>
<p class="fireman-p-indent" >Redis支持8中不同策略来选择要删除的key，通过修改配置 <code>maxmemory-policy</code>：</p>
<ul>
<li><code>noeviction</code>：不淘汰任何key，但是内存满时不允许写入新数据，默认</li>
<li><code>volatile-ttl</code>：对设置了ttl的key，比较key的剩余ttl值，越小越先被淘汰</li>
<li><code>allkeys-random</code>：对全体key，随机进行淘汰。也就是从<code>db.dict</code>中随机淘汰</li>
<li><code>volatile-random</code>：对设置了ttl的key，随机进行淘汰。也就是从<code>db.expires</code>中随机挑选</li>
<li><code>allkeys-lru</code>：对全体key，基于LRU算法进行淘汰</li>
<li><code>volatile-lru</code>：对设置了TTL的key，基于LRU算法进行淘汰</li>
<li><code>allkeys-lfu</code>：对全体key，基于LFU算法进行淘汰</li>
<li><code>volatile-lfu</code>：对设置了TTL的key，基于LFU算法进行淘汰</li>
</ul>
<p class="fireman-p-indent" ><strong>LRU</strong>（Least Recently Used）：最少最近使用。当前时间减去最后一次访问时间，这个值越大，则淘汰优先级越高</p>
<p class="fireman-p-indent" ><strong>LFU</strong>（Least Frequently Used）：最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高</p>
<p class="fireman-p-indent" >Redis的数据都会被封装为RedisObject结构中</p>
<p class="fireman-p-indent" ><code>src/server.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;		<span class="comment">// 对象类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;	<span class="comment">// 编码方式</span></span><br><span class="line">  	<span class="comment">// LRU：为秒为单位，记录最近一次访问时间，长度24bit</span></span><br><span class="line">  	<span class="comment">// LFU：高16位以分钟为单位记录最近一次访问时间，低8位记录逻辑访问次数</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;				<span class="comment">// 引用计数，计数为0则可以回收</span></span><br><span class="line">    <span class="type">void</span> *ptr;					<span class="comment">// 数据指针，指向真实数据</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >LFU的访问次数叫做<strong>逻辑访问次数</strong>，是因为并不是每次key被访问都计数，而是通过运算：</p>
<ol>
<li>生成0~1之间的随机数R</li>
<li>计算<code>1/（旧次数*lfu_log_factor + 1）</code>，记录为P，<code>lfu_log_factor</code>默认为10</li>
<li>如果R&lt;P，则计数器+1，且最大不超过255（因此，访问频率不会超过255，使用一个较小的数来记录）</li>
<li>访问次数会随时间衰减，距离上一次访问时间间隔<code>lfu_decay_time</code>分钟（默认1），计数器-1（为了防止访问频率很大之后，很长时间没有访问不会被回收的情况）</li>
</ol>
<p class="fireman-p-indent" ><code>src/evict.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check that memory usage is within the current &quot;maxmemory&quot; limit.  If over</span></span><br><span class="line"><span class="comment"> * &quot;maxmemory&quot;, attempt to free memory by evicting data (if it&#x27;s safe to do so).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It&#x27;s possible for Redis to suddenly be significantly over the &quot;maxmemory&quot;</span></span><br><span class="line"><span class="comment"> * setting.  This can happen if there is a large allocation (like a hash table</span></span><br><span class="line"><span class="comment"> * resize) or even if the &quot;maxmemory&quot; setting is manually adjusted.  Because of</span></span><br><span class="line"><span class="comment"> * this, it&#x27;s important to evict for a managed period of time - otherwise Redis</span></span><br><span class="line"><span class="comment"> * would become unresponsive while evicting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The goal of this function is to improve the memory situation - not to</span></span><br><span class="line"><span class="comment"> * immediately resolve it.  In the case that some items have been evicted but</span></span><br><span class="line"><span class="comment"> * the &quot;maxmemory&quot; limit has not been achieved, an aeTimeProc will be started</span></span><br><span class="line"><span class="comment"> * which will continue to evict items until memory limits are achieved or</span></span><br><span class="line"><span class="comment"> * nothing more is evictable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This should be called before execution of commands.  If EVICT_FAIL is</span></span><br><span class="line"><span class="comment"> * returned, commands which will result in increased memory usage should be</span></span><br><span class="line"><span class="comment"> * rejected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *   EVICT_OK       - memory is OK or it&#x27;s not possible to perform evictions now</span></span><br><span class="line"><span class="comment"> *   EVICT_RUNNING  - memory is over the limit, but eviction is still processing</span></span><br><span class="line"><span class="comment"> *   EVICT_FAIL     - memory is over the limit, and there&#x27;s nothing to evict</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">performEvictions</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p class="fireman-p-indent" >整个逻辑流程如下</p>
<p class="fireman-p-indent" ><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/12/image-20221210235351250.png" alt="image-20221210235351250"></p>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p class="fireman-p-indent" ><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVTg3d3JHc3gwRW9wM0NiRjltbFR3UQ==">万字图文讲透数据库缓存一致性问题<i class="fa fa-external-link-alt"></i></span></p>
<p class="fireman-p-indent" ><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RvcnZhbGRzL2xpbnV4">Linux内核源码<i class="fa fa-external-link-alt"></i></span></p>
<p class="fireman-p-indent" ><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZGlzL3JlZGlz">Redis源码<i class="fa fa-external-link-alt"></i></span></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Reference/" rel="tag"># 学习笔记</a>
              <a href="/tags/database/" rel="tag"># 数据库</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/a820.html" rel="prev" title="MySQL学习笔记高可用篇">
                  <i class="fa fa-angle-left"></i> MySQL学习笔记高可用篇
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/dbf7.html" rel="next" title="Golang中的sync.Pool">
                  Golang中的sync.Pool <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Mitaka xu</span>
  </div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"TVx6Wkfs8VJGOwYPurtjWY2e-9Nh9j0Va","app_key":"c7VvaRnyF8r3DUIPq1x2KJ7Q","server_url":"https://tvx6wkfs.lc-cn-e1-shared.com","security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"xiaoyeshiyu","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
