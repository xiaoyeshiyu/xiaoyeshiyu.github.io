<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="S_5aoPFd3QQihrUOLiKdVR0Mj4fj6n6qJojwyjj9cAY">
  <meta name="msvalidate.01" content="9032A67FCF787F07CB04374E59E518A9">
  <meta name="baidu-site-verification" content="code-Onlniop0d6">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.xiaoyeshiyu.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Go语言的sync包是Go标准库中提供的用于同步和并发编程的包。它提供了一些关键的同步原语，用于协调并发操作，以确保数据的正确性和一致性。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go的concurrency之sync">
<meta property="og:url" content="https://www.xiaoyeshiyu.com/post/2f5e.html">
<meta property="og:site_name" content="小夜时雨">
<meta property="og:description" content="Go语言的sync包是Go标准库中提供的用于同步和并发编程的包。它提供了一些关键的同步原语，用于协调并发操作，以确保数据的正确性和一致性。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230905213914872.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907202817211.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907203020266.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907203016068.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907203116581.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230919164340426.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230919164728429.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230919164753278.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230919164815930.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230919164834917.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907210740712.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212340729.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212013181.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212406035.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212238826.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212616874.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212622562.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212754288.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907213716753.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907214605570.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907225501216.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907225817922.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230924223247722.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230924223313202.png">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000039855706">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230924223924892.png">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20230924224214523.png">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20230924224702877.png">
<meta property="og:image" content="https://www.xiaoyeshiyu.com/Library/Application%20Support/typora-user-images/image-20230924225059696.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230924225652184.png">
<meta property="article:published_time" content="2023-09-06T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-24T14:58:42.038Z">
<meta property="article:author" content="Mitaka xu">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230905213914872.png">


<link rel="canonical" href="https://www.xiaoyeshiyu.com/post/2f5e.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://www.xiaoyeshiyu.com/post/2f5e.html","path":"post/2f5e.html","title":"Go的concurrency之sync"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Go的concurrency之sync | 小夜时雨</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MBVJ11TVHH"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBVJ11TVHH","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?573725610fbc6ff9b42032bd13615370"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="小夜时雨" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小夜时雨</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">君子敬其在己者，而不慕其在天者，是以日进也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">1.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%AB%9E%E6%80%81"><span class="nav-number">2.</span> <span class="nav-text">数据竞态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B1"><span class="nav-number">2.1.</span> <span class="nav-text">案例1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B2"><span class="nav-number">2.2.</span> <span class="nav-text">案例2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B3"><span class="nav-number">2.3.</span> <span class="nav-text">案例3</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sync%E5%8C%85"><span class="nav-number">3.</span> <span class="nav-text">sync包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.</span> <span class="nav-text">原子操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#COW"><span class="nav-number">3.2.</span> <span class="nav-text">COW</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">3.3.</span> <span class="nav-text">互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mutex%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.1.</span> <span class="nav-text">Mutex锁的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#errgroup"><span class="nav-number">3.4.</span> <span class="nav-text">errgroup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pool"><span class="nav-number">3.5.</span> <span class="nav-text">Pool</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B8%A9%E5%9D%91%E5%92%8C%E6%8A%80%E5%B7%A7"><span class="nav-number">4.</span> <span class="nav-text">踩坑和技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#sync-XXX"><span class="nav-number">4.1.</span> <span class="nav-text">sync.XXX</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sync-Once"><span class="nav-number">4.2.</span> <span class="nav-text">sync.Once</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">4.3.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E9%94%81"><span class="nav-number">4.4.</span> <span class="nav-text">理解锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">4.5.</span> <span class="nav-text">一些面试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB"><span class="nav-number">5.</span> <span class="nav-text">推荐阅读</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mitaka xu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mitaka xu</p>
  <div class="site-description" itemprop="description">Golang开发博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">108</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaoyeshiyu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/2f5e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Go的concurrency之sync | 小夜时雨">
      <meta itemprop="description" content="Go语言的sync包是Go标准库中提供的用于同步和并发编程的包。它提供了一些关键的同步原语，用于协调并发操作，以确保数据的正确性和一致性。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go的concurrency之sync
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-07 00:00:00" itemprop="dateCreated datePublished" datetime="2023-09-07T00:00:00+08:00">2023-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-24 22:58:42" itemprop="dateModified" datetime="2023-09-24T22:58:42+08:00">2023-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GoTrainingCamp/" itemprop="url" rel="index"><span itemprop="name">Go训练营</span></a>
        </span>
    </span>

  
    <span id="/post/2f5e.html" class="post-meta-item leancloud_visitors" data-flag-title="Go的concurrency之sync" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

            <div class="post-description">Go语言的sync包是Go标准库中提供的用于同步和并发编程的包。它提供了一些关键的同步原语，用于协调并发操作，以确保数据的正确性和一致性。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><blockquote>
<p>Share Memory By Communicating</p>
</blockquote>
<p>传统的线程模型（通常在编写 Java、C++ 和 Python 程序时使用）程序员在线程之间通信需要使用共享内存。通常，共享数据结构由锁保护，线程将争用这些锁来访问数据。在某些情况下，通过使用线程安全的数据结构（如 Python 的 Queue），这会变得更容易。</p>
<p>Go 的并发原语 goroutines 和 channels 为构造并发软件提供了一种优雅而独特的方法。 Go 没有显式地使用锁来协调对共享数据的访问，而是鼓励使用 chan 在 goroutine 之间传递对数据的引用（通常是指针）。这种方法确保在给定的时间只有一个 goroutine 可以访问数据。</p>
<p>通过 channel ，共享内存。</p>
<blockquote>
<p>Do not communicate by sharing memory; instaed, share memory by communicating,</p>
</blockquote>
<h1 id="数据竞态"><a href="#数据竞态" class="headerlink" title="数据竞态"></a>数据竞态</h1><blockquote>
<p>Detecting Race Conditions With Go</p>
</blockquote>
<p>Data race 是两个或多个 goroutine 访问同一个资源（如变量或数据结构），并尝试对该资源进行读写而不考虑其他 goroutine。这种类型的代码可以创建最疯狂和最随机的 bug。通常需要大量的日志记录和运气才能找到这些类型的 bug。</p>
<p>早在2013年6月份的Go 1.1 中，Go 工具引入了一个 race detector。竞态检测器是在构建过程中内置到程序中的代码。然后，一旦程序运行，它就能够检测并报告它发现的任何竞争条件。这个工具非常酷，并且在识别罪魁祸首的代码方面作了令人难以置信的工作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build -race  // 编译时使用-race标志来启用race detector</span><br><span class="line">go test -race   // 单元测试时启用race detector</span><br></pre></td></tr></table></figure>

<h2 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Wait sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> Counter <span class="type">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> routine := <span class="number">1</span>; routine &lt;= <span class="number">2</span>; routine++ &#123;</span><br><span class="line">		Wait.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> Routine(routine)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Wait.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Final Counter: %d\n&quot;</span>, Counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Routine</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">		<span class="comment">//value := Counter</span></span><br><span class="line">		Counter++</span><br><span class="line">		<span class="comment">//Counter = value</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Wait.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如上述代码，在 goroutine 中使用 <code>Counter++ </code>，同时赋值。</p>
<p>通过编译可以看到 <code>Counter++</code> 不是原子的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -N -l -S main.go  // 生成汇编代码 main.o</span><br><span class="line">go build -gcflags -S main.go			// 生成汇编代码 main</span><br><span class="line">go tool objdump main.o 						// 反汇编出代码</span><br></pre></td></tr></table></figure>

<p>go 1.4 <code>go build -gcflags -S main.go</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0022 00034 (code/test1.go:24)	MOVQ	&quot;&quot;.Counter+0(SB),BX</span><br><span class="line">0x0029 00041 (code/test1.go:24)	INCQ	,BX</span><br><span class="line">0x002c 00044 (code/test1.go:24)	MOVQ	BX,&quot;&quot;.Counter+0(SB)</span><br><span class="line">0x0033 00051 (code/test1.go:24)	NOP	,</span><br></pre></td></tr></table></figure>

<p><code>i++</code> 其实是分为三个步骤，先是赋值，然后自增这个赋值，然后把值赋值回去。</p>
<p>三行汇编代码在执行以增加计数器，这三行汇编代码看起来很像原始的 Go 代码。在这三行汇编代码之后可能有一个上下文切换。尽管程序现在正在运行，但从技术上讲，这个 bug 仍然存在。虽然 Go 代码看起来像是在安全地访问资源，而实际上底层的程序集代码根本就不安全。</p>
<p>其实是相当于</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">	value := Counter</span><br><span class="line">	value++</span><br><span class="line">	Counter = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过竞态检测工具，可以看到上面的代码在不同的 goroutine 中有同时读写的行为，检测到代码的争用条件。如果查看 <code>race conditoin</code> 报告下面，可以看到程序的输出：全局计数器变量的值为4。</p>
<p>go 1.4 <code>go build -race &amp;&amp; ./main</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Read by goroutine 6:</span><br><span class="line">  main.Routine()</span><br><span class="line">      /home/xxx/code/main.go:23 +0x49</span><br><span class="line"></span><br><span class="line">Previous write by goroutine 5:</span><br><span class="line">  main.Routine()</span><br><span class="line">      /home/xxx/code/main.go:24 +0x81</span><br><span class="line"></span><br><span class="line">Goroutine 6 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /home/xxx/code/main.go:14 +0x71</span><br><span class="line"></span><br><span class="line">Goroutine 5 (finished) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /home/xxx/code/main.go:14 +0x71</span><br><span class="line">==================</span><br><span class="line">Final Counter: 0</span><br><span class="line">Found 1 data race(s)</span><br></pre></td></tr></table></figure>

<p>如果不好复现，可以让 <code>goroutine</code> 执行久一点，手动增加一点时间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Routine</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">		value := Counter</span><br><span class="line">		time.Sleep(time.Nanosecond)</span><br><span class="line">		Counter++</span><br><span class="line">		Counter = value</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Wait.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常的过程应该是两个 <code>goroutine</code> 有先后顺序</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230905213914872.png" alt="image-20230905213914872"></p>
<p>此时，应该使用 Go 同步语义：<code>Mutex</code></p>
<h2 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h2><p>这里修改 Ben 将<code>id</code>去掉，将 Ben 和 Jerry 的内存布局设置成一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IceCreamMaker <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Hello greets a customer</span></span><br><span class="line">	Hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Ben <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Ben)</span></span> Hello() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Ben says, \&quot;Hello my name is %s\&quot;\n&quot;</span>, b.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Jerry <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j *Jerry)</span></span> Hello() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Jerry says, \&quot;Hello my name is %s\&quot;\n&quot;</span>, j.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ben = &amp;Ben&#123;name: <span class="string">&quot;Ben&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> jerry = &amp;Jerry&#123;<span class="string">&quot;Jerry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> maker IceCreamMaker = ben</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> loop0, loop1 <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">	loop0 = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		maker = ben</span><br><span class="line">		<span class="keyword">go</span> loop1()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	loop1 = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		maker = jerry</span><br><span class="line">		<span class="keyword">go</span> loop0()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> loop0()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		maker.Hello()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在机器字 single machine word（例如 x86_64 的系统上，8字节是最小计算单元）的赋值上，应该是原子赋值，为啥 -race 会乱报。</p>
<p>例如上面的代码，<code>maker</code> 是一个 <code>interface</code>，指针类型占用8个字节，在 <code>loop0</code> 和 <code>loop1</code> 中通过 goroutine 循环调用，在 goroutine 中无法保证调用顺序，因此会有数据竞态。<code>ben</code> 和 <code>jerry</code> 都是指针类型，也是8个字节，</p>
<p>执行之后的效果。</p>
<p>go 1.4 <code>env GOMAXPROCS=2 go run main.go</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ben says, &quot;Hello my name is Ben&quot;</span><br><span class="line">Ben says, &quot;Hello my name is Ben&quot;</span><br><span class="line">Jerry says, &quot;Hello my name is Jerry&quot;</span><br><span class="line">Ben says, &quot;Hello my name is Ben&quot;</span><br><span class="line">Jerry says, &quot;Hello my name is Jerry&quot;</span><br><span class="line">Ben says, &quot;Hello my name is Ben&quot;</span><br><span class="line">Jerry says, &quot;Hello my name is Jerry&quot;</span><br><span class="line">Jerry says, &quot;Hello my name is Jerry&quot;</span><br><span class="line">Jerry says, &quot;Hello my name is Jerry&quot;</span><br></pre></td></tr></table></figure>

<p>但是对于 Golang 来说，interface 是有两部分。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907202817211.png" alt="image-20230907202817211"></p>
<p>Type 指向实现了接口的 <code>struct</code> ，Data 指向了实际的值（也就是一个是类型，一个是值）。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907203020266.png" alt="image-20230907203020266"></p>
<p>Data 作为通过 interface 中任何方法调用的接受方传递。</p>
<p>对于语句 <code>var maker IceCreamMaker = ben</code>，编译器将生成执行以下操作的代码</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907203016068.png" alt="image-20230907203016068"></p>
<p>当 <code>loop1()</code> 执行 <code>maker = jerry</code> 语句时，必须更新接口值的两个字段。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907203116581.png" alt="image-20230907203116581"></p>
<p>很有可能在实际执行的过程中，会出现 Type 和 Data 指向的是不同的字段。</p>
<p><code>Go memory model</code> 提到过：表示下如单个<code>machine word</code>将是原子的，但 <code>interface</code> 内部是两个<code> machine word</code> 的值。另一个 <code>goroutine</code> 可能在更改接口值时观察到它的内容。</p>
<p>在这个例子中， Ben 和 Jerry 内存结构布局是相同的，因此它们在某种意义上是兼容的。如果它们的内存布局不同，会发生什么混乱。（比如。Ben 字段的 id ）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IceCreamMaker <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Hello greets a customer</span></span><br><span class="line">	Hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Ben <span class="keyword">struct</span> &#123;</span><br><span class="line">	id   <span class="type">int</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Ben)</span></span> Hello() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Ben says, \&quot;Hello my name is %s\&quot;\n&quot;</span>, b.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Jerry <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j *Jerry)</span></span> Hello() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Jerry says, \&quot;Hello my name is %s\&quot;\n&quot;</span>, j.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go 1.4 <code>env GOMAXPROCS=2 go run main.go</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Ben says, &quot;Hello my name is Ben&quot;</span><br><span class="line">panic: runtime error: growslice: cap out of range</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">fmt.(*fmt).padString(0xc20804c128, 0x5, 0x7fb1fd752780)</span><br><span class="line">	/usr/local/go/src/fmt/format.go:130 +0x387</span><br><span class="line">fmt.(*fmt).fmt_s(0xc20804c128, 0x5, 0x7fb1fd752780)</span><br><span class="line">	/usr/local/go/src/fmt/format.go:311 +0x68</span><br><span class="line">fmt.(*pp).fmtString(0xc20804c0d0, 0x5, 0x7fb1fd752780, 0x73)</span><br><span class="line">	/usr/local/go/src/fmt/print.go:511 +0xe0</span><br><span class="line">fmt.(*pp).printArg(0xc20804c0d0, 0x49f640, 0xc20805d900, 0x73, 0x0, 0x0)</span><br><span class="line">	/usr/local/go/src/fmt/print.go:787 +0xa82</span><br><span class="line">fmt.(*pp).doPrintf(0xc20804c0d0, 0x4f33f0, 0x20, 0xc208036ef0, 0x1, 0x1)</span><br><span class="line">	/usr/local/go/src/fmt/print.go:1183 +0x21cd</span><br><span class="line">fmt.Fprintf(0x7fb1fd751718, 0xc208056008, 0x4f33f0, 0x20, 0xc208036ef0, 0x1, 0x1, 0xc20805d900, 0x0, 0x0)</span><br><span class="line">	/usr/local/go/src/fmt/print.go:188 +0x7b</span><br><span class="line">fmt.Printf(0x4f33f0, 0x20, 0xc208036ef0, 0x1, 0x1, 0x21, 0x0, 0x0)</span><br><span class="line">	/usr/local/go/src/fmt/print.go:197 +0x9b</span><br><span class="line">main.(*Ben).Hello(0xc20800a200)</span><br><span class="line">	/home/xxx/code/main.go:18 +0xe9</span><br><span class="line">main.main()</span><br><span class="line">	/home/xxx/code/main.go:51 +0x2f8</span><br><span class="line"></span><br><span class="line">goroutine 5721 [runnable]:</span><br><span class="line">main.func·002()</span><br><span class="line">	/home/xxx/code/main.go:43</span><br><span class="line">created by main.func·001</span><br><span class="line">	/home/xxx/code/main.go:40 +0x7d</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p>如果是一个普通的指针、map、slice 可以安全的更新吗？</p>
<p>虽然是一样的8个字节的 machine word ，与 Jerry 是相同大小，兼容的。</p>
<p>但是：</p>
<p>没有安全的 data race(safe data race)。要么是没有 data race ，要么其操作未定义。</p>
<ul>
<li>原子性：操作不可分割，例如 machine word </li>
<li>可见性：指针内部操作，无法确定内部操作是否是原子的。例如上面的 interface ,多个 goroutine 操作的时候，可能不同的 goroutine 操作（或者读取）到的不是同一份数据上的 type 和 data 。</li>
</ul>
<h2 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h2><p>例如下面的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    a []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cfg := &amp;Config&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       i := <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> &#123;</span><br><span class="line">          i++</span><br><span class="line">          cfg.a = []<span class="type">int</span>&#123;i, i + <span class="number">1</span>, i + <span class="number">2</span>, i + <span class="number">3</span>, i + <span class="number">4</span>, i + <span class="number">5</span>&#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">4</span>; n++ &#123;</span><br><span class="line">       wg.Add(<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">100</span>; n++ &#123;</span><br><span class="line">             fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, cfg)</span><br><span class="line">          &#125;</span><br><span class="line">          wg.Done()</span><br><span class="line">       &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cfg</code> 作为包级全局对象，在这个例子中被多个 <code>goroutine</code> 同时访问（一个 <code>goroutine</code> 写入，另外一个 <code>goroutine</code> 读取（打印）），因此这里存在 <code>data race</code>，会看到不连续的内存输出。</p>
<p>go 1.4 <code>env GOMAXPROCS=2 go run main.go</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;[2351 2352 3643 3697 3698 3700]&#125;</span><br><span class="line">&amp;&#123;[2854 2855 4279 4280 4281 4282]&#125;</span><br><span class="line">&amp;&#123;[3357 3358 5588 5690 5696 5702]&#125;</span><br><span class="line">&amp;&#123;[8781 8794 8799 8805 8810 8815]&#125;</span><br><span class="line">&amp;&#123;[9073 9074 9075 9076 9077 9081]&#125;</span><br><span class="line">&amp;&#123;[9243 9244 9245 9246 9247 9248]&#125;</span><br></pre></td></tr></table></figure>

<p>go 1.4 <code>go build -race</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Read by goroutine 6:</span><br><span class="line">  fmt.Printf()</span><br><span class="line">      /usr/local/go/src/fmt/print.go:197 +0xcb</span><br><span class="line">  main.func·002()</span><br><span class="line">      /home/xxx/code/main.go:28 +0x134</span><br><span class="line"></span><br><span class="line">Previous write by goroutine 5:</span><br><span class="line">  [failed to restore the stack]</span><br></pre></td></tr></table></figure>

<p>我们想到使用Go 语义解决。</p>
<ul>
<li>Mutex：互斥锁</li>
<li>RWMutex：读写锁</li>
<li>Atomic：原子操作</li>
</ul>
<h1 id="sync包"><a href="#sync包" class="headerlink" title="sync包"></a>sync包</h1><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>sync.Atomic VS sync.Mutex</p>
<p>例如上述代码，在读多写少的情况下，可以使用读写锁，相比互斥锁效率更高。</p>
<p>但是与更加轻量级的原子操作相比，读写锁的效率不如原子操作。</p>
<p>读写锁：</p>
<p>写入的时候加写锁；读取的时候用读锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	a []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMutex</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> l sync.RWMutex</span><br><span class="line">	cfg := &amp;Config&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			i++</span><br><span class="line">			l.Lock()</span><br><span class="line">			cfg.a = []<span class="type">int</span>&#123;i, i + <span class="number">1</span>, i + <span class="number">2</span>, i + <span class="number">3</span>, i + <span class="number">4</span>, i + <span class="number">5</span>&#125;</span><br><span class="line">			l.Unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">4</span>; n++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">				l.RLock()</span><br><span class="line">				fmt.Sprintf(<span class="string">&quot;%v\n&quot;</span>, cfg)</span><br><span class="line">				l.RUnlock()</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原子操作：</p>
<p>写入的时候使用原子操作存储数据，读取的时候将数据拷贝出来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAtomic</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> v atomic.Value</span><br><span class="line">	v.Store(&amp;Config&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			i++</span><br><span class="line">			cfg := Config&#123;[]<span class="type">int</span>&#123;i, i + <span class="number">1</span>, i + <span class="number">2</span>, i + <span class="number">3</span>, i + <span class="number">4</span>, i + <span class="number">5</span>&#125;&#125;</span><br><span class="line">			v.Store(&amp;cfg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">4</span>; n++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">				cfg := v.Load().(*Config)</span><br><span class="line">				fmt.Sprintf(<span class="string">&quot;%v\n&quot;</span>, cfg)</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Benchmark 测试出结果，Mutex相对更重。</p>
<p><code>go test -bench=.</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: arm64</span><br><span class="line">pkg: gostudy/sync/race</span><br><span class="line">BenchmarkMutex</span><br><span class="line">BenchmarkMutex<span class="number">-10</span>         <span class="number">257473</span>              <span class="number">4842</span> ns/op</span><br><span class="line">BenchmarkAtomic</span><br><span class="line">BenchmarkAtomic<span class="number">-10</span>       <span class="number">1000000</span>              <span class="number">1038</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      gostudy/sync/race       <span class="number">3.730</span>s</span><br></pre></td></tr></table></figure>

<p>因为涉及到更多的 goroutine 之间的上下文切换 pack blocking goroutine，以及唤醒 goroutine。</p>
<p><code>env GOMAXPROCS=4 go test  -trace trace.out -bench .</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230919164340426.png" alt="image-20230919164340426"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230919164728429.png" alt="image-20230919164728429"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230919164753278.png" alt="image-20230919164753278"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230919164815930.png" alt="image-20230919164815930"></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230919164834917.png" alt="image-20230919164834917"></p>
<h2 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h2><p>Copy-On-Write （写时复制）思路在微服务降级或者 local cache 场景中经常使用。写时复制指的是，写入操作时复制全量老数据到一个新的对象中，携带上本次新写的数据，之后利用原子替换（ atomic.Value)，更新调用者的变量。来完成无锁访问共享数据。</p>
<p>例如定期（每10s加载一次最新数据），使用原子操作 <code>store</code> 数据，使用的时候，从 <code>atomic</code> 中读取出来。</p>
<p>但是需要注意，可能会出现读取出来的数据是 <code>v1</code> 的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> config atomic.Value</span><br><span class="line"></span><br><span class="line">    config.Store(loadConfig())</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">for</span> &#123;</span><br><span class="line">          time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">          config.Store(loadConfig())</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          <span class="keyword">for</span> r := <span class="keyword">range</span> requests() &#123;</span><br><span class="line">             c := config.Load()</span><br><span class="line">             _, _ = r, c</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又例如读取配置，实时生效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> m atomic.Value</span><br><span class="line">    m.Store(<span class="built_in">make</span>(Map))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line">    read := <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> (val <span class="type">string</span>) &#123;</span><br><span class="line">       m1 := m.Load().(Map)</span><br><span class="line">       <span class="keyword">return</span> m1[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insert := <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>, value <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">       mu.Lock()</span><br><span class="line">       <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">       m1 := m.Load().(Map)</span><br><span class="line">       m2 := <span class="built_in">make</span>(Map)</span><br><span class="line">       <span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">          m2[k] = v</span><br><span class="line">       &#125;</span><br><span class="line">       m2[key] = val</span><br><span class="line">       m.Store(m2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _, _ = read, insert</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>Mutex</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">for</span> &#123;</span><br><span class="line">          <span class="keyword">select</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> &lt;-done:</span><br><span class="line">             <span class="keyword">return</span></span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">             mu.Lock()</span><br><span class="line">             time.Sleep(<span class="number">100</span> * time.Microsecond)</span><br><span class="line">             mu.Unlock()</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">       time.Sleep(<span class="number">100</span> * time.Microsecond)</span><br><span class="line">       mu.Lock()</span><br><span class="line">       mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个案例基于两个 goroutine ：</p>
<ul>
<li>goroutine 1 持有锁 100ms</li>
<li>goroutine 2 每 100ms 持有一次锁</li>
</ul>
<p>都是100ms 的周期，但是由于 goroutine 1 不断的请求锁，可预期它会频繁的持续锁的状态。</p>
<p>基于 Go 1.8 循环 10次，下面是锁的请求占用分布：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907210740712.png" alt="image-20230907210740712"></p>
<p>Mutex 被 g1 获取了 700 多万次，而 g2 只获取了 10 次。这是非常不公平的。（占用时间长，而且还获得锁的概率高）</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212340729.png" alt="image-20230907212340729"></p>
<p>首先，goroutine1 将获得锁，并休眠 100ms。当 goroutine2 试图获取锁是，它将被添加到锁的队列中- FIFO顺序（先进先出），goroutine 将进入等待状态（Parking）。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212013181.png" alt="image-20230907212013181"></p>
<p>然后，当 goroutine1 完成它的工作时，它将释放锁。此版本将通知队列，唤醒 goroutine2 ，goroutine2 将被通知队列唤醒 goroutine2 。goroutine2 将被标记为可运行的，并且正在等待 Go 调度程序在线程上运行。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212406035.png" alt="image-20230907212406035"></p>
<p>然而，当 goroutine2 等待运行时，goroutine1 将再次请求锁。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212238826.png" alt="image-20230907212238826"></p>
<p>goroutine2 尝试去获取锁，结果发现锁又被人持有了，它自己继续进入到等待模式。</p>
<p>这是由于新请求锁的 goroutine 具有优势（g1）：它正在 CPU 上执行，缩放锁之后，立马竞争，再次获得锁。</p>
<h3 id="Mutex锁的实现"><a href="#Mutex锁的实现" class="headerlink" title="Mutex锁的实现"></a>Mutex锁的实现</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212616874.png" alt="image-20230907212616874"></p>
<ul>
<li>Barging：这种模式时为了提高吞吐量，当锁被释放时，它会唤醒第一个等待者，然后把锁给第一个等待者或者给第一个请求锁的人。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212622562.png" alt="image-20230907212622562"></p>
<ul>
<li>Handsoff：当锁释放时，锁会一直持有直到第一个等待者准备好获取锁。它降低了吞吐量，因为锁被持有，即使另一个 goroutine 准备获取它。降低吞吐，提高公平。</li>
</ul>
<p>一个互斥锁的 handsoff 会完美地平衡两个 goroutine 之间的锁分配，但是会降低性能，因为它会迫使第一个 goroutine 等待锁。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907212754288.png" alt="image-20230907212754288"></p>
<ul>
<li>Spining：自旋，在等待队列为空或者应用程序重度使用锁时效果不错。Parking（ goroutine 进入等待队列 ） 和 Unparking（goroutine 从等待队列中被唤醒） goroutine 有不低的性能成本开销，相比自旋来说要慢得多。</li>
</ul>
<p>Go 1.8使用了 Barging 和 Spining 的结合实现。当试图获取已经被持有的锁时，如果本地队列为空，并且 P 的数量大于1， goroutine 将自旋几次（用一个 P 旋转会阻塞程序）。自旋后，goroutine park。在程序高频使用锁的情况下，它充当了一个快速路径。</p>
<p>Go 1.9 通过增加一个新的饥饿模式来解决先前的公平和开销问题。该模式将会在释放时出发 handsoff。所有等待锁超过 1ms 的goroutine（也被成为有界等待）将被诊断为饥饿。当被标记为饥饿状态时，unlock 方法会 handsoff 把锁直接仍给第一个等待者。</p>
<p>在饥饿模式下，自旋也被停用，因为传入的 goroutine 将没有机会获取为下一个等待者保留的锁。（这样让等待的 goroutine 一定会拿到锁。）</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907213716753.png" alt="image-20230907213716753"></p>
<p>这是由于锁在自旋的过程中，为了保证公平，一段时间没有拿到锁（1ms），会进入<strong>饥饿态</strong>，进而加大获得锁的概率。</p>
<h2 id="errgroup"><a href="#errgroup" class="headerlink" title="errgroup"></a>errgroup</h2><p>把一个复杂的任务，尤其时依赖多个微服务 rpc 需要聚合数据的任务，分解为依赖和并行，依赖的意思为：需要上游 a 的数据才能访问下游 b 的数据进行组合。但是并行的意思为：分解为多个小任务并行执行，最终等全部执行完毕。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907214605570.png" alt="image-20230907214605570"></p>
<p>可以使用<span class="exturl" data-url="aHR0cHM6Ly9wa2cuZ28uZGV2L2dvbGFuZy5vcmcveC9zeW5jL2Vycmdyb3Vw">errgroup<i class="fa fa-external-link-alt"></i></span></p>
<p>核心原理：利用 sync.Waitgroup 管理，并行执行的 goroutine </p>
<p>优势：</p>
<ul>
<li>并行工作流</li>
<li>错误处理 或者 优雅降级</li>
<li>context 传播和取消</li>
<li>利用局部变量 + 闭包</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvLWtyYXRvcy9rcmF0b3MvdHJlZS9tYXN0ZXIvcGtnL3N5bmMvZXJyZ3JvdXA=">示例<i class="fa fa-external-link-alt"></i></span></p>
<p>一些注意事项：</p>
<ul>
<li>处理panic</li>
<li>派生其他的 goroutine </li>
<li>不管有没有报错，都继续执行（避免 context cancel 掉其他的 goroutine ）</li>
<li>使用 context，而且还在作用域之外使用</li>
</ul>
<h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><p>sync.Pool 的场景时用来保存和复用临时对象，以减少内存分配，降低 GC 压力 （Request-Driven 特别合适）。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907225501216.png" alt="image-20230907225501216"></p>
<p>Get 返回 Pool 中的任意一个对象。如果 Pool 为空，则调用 New 函数返回一个新创建的对象。</p>
<p>放进 Pool 中的对象，会在说不准什么时候被回收到。所以如果事先 Put 进去 100个对象，下次 Get 的时候可能 Pool 是空的。这个特性的一个好处就在于不用担心 Pool 会一直增长，因为 Go 已经帮你在 Pool 中做了回收机制。</p>
<p>因此 sync.Pool 里面只能方能被任意回收的对象，例如内存，套接字，文件DF之类的，而不能放连接池，例如连接池放进去，被GC，则会出现内存泄露。</p>
<p>这个清理过程时在每次垃圾回收之前做的。之前每次 GC 时都会清空 pool，而在 1.13 版本中引入 victim cache ，会将 pool 内数据拷贝一份，避免 GC 将其清空，即使没有引用的内容也可以保留最多两轮 GC。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230907225817922.png" alt="image-20230907225817922"></p>
<p>Pool 内部使用环， ring buffer （定长 FIFO）+ 双向链表的方式，头部只能写入，尾部可以并发读取的形式。生成的时候，如果 ring 中存在对象，则直接从尾部读取，如果没有则生成。 写入的时候从头部写入。</p>
<h1 id="踩坑和技巧"><a href="#踩坑和技巧" class="headerlink" title="踩坑和技巧"></a>踩坑和技巧</h1><h2 id="sync-XXX"><a href="#sync-XXX" class="headerlink" title="sync.XXX"></a>sync.XXX</h2><p>不要在参数里面传递sync.XXX</p>
<p>要么是调用者自己决定，例如方法</p>
<p>要么是方法内部使用</p>
<h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><p>一般会用于比较重的资源的初始化</p>
<ul>
<li><p>Double check，在 <code>LoadOrStore()</code> 方法返回对象和 <code>bool</code>，代表返回老的对象还是新的对象，在方法内部，在加锁的时候，需要注意多个 goroutine 可能会产生冲突，因此需要double check</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	mutex sync.RWMutex</span><br><span class="line">	m     <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SafeMap)</span></span> LoadOrStore(key <span class="type">string</span>, newValue <span class="keyword">interface</span>&#123;&#125;) (val <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">	s.mutex.RLock()</span><br><span class="line">	val, ok := s.m[key]</span><br><span class="line">	s.mutex.RUnlock()</span><br><span class="line">	<span class="keyword">if</span> ok &#123; <span class="comment">// 判断OK的时候，就可能有别的 goroutine store新的数据</span></span><br><span class="line">		<span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	s.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.mutex.Unlock()</span><br><span class="line">	s.m[key] = newValue <span class="comment">// 上面的读锁释放后，下面的可能会有多个goroutine store 值</span></span><br><span class="line">	<span class="keyword">return</span> newValue, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 double check</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SafeMap)</span></span> LoadOrStore(key <span class="type">string</span>, newValue <span class="keyword">interface</span>&#123;&#125;) (val <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">	s.mutex.RLock()</span><br><span class="line">	val, ok := s.m[key]</span><br><span class="line">	s.mutex.RUnlock()</span><br><span class="line">	<span class="keyword">if</span> ok &#123; <span class="comment">// 判断OK的时候，就可能有别的 goroutine store新的数据</span></span><br><span class="line">		<span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	s.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.mutex.Unlock()</span><br><span class="line">	<span class="keyword">if</span> val, ok = s.m[key]; ok &#123; <span class="comment">// 使用double check，虽然可以优化成只加一个互斥锁，但是这种方式不影响在可以读到数据的情况下的性能</span></span><br><span class="line">		<span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	s.m[key] = newValue <span class="comment">// 上面的读锁释放后，下面的可能会有多个goroutine store 值</span></span><br><span class="line">	<span class="keyword">return</span> newValue, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是 check and do something</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SafeMap)</span></span> CheckAndDoSomething() &#123;</span><br><span class="line">	s.mutex.Lock()</span><br><span class="line">	<span class="comment">// check and do something</span></span><br><span class="line">	s.mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SafeMap)</span></span> CheckAndDoSomething1() &#123;</span><br><span class="line">	s.mutex.RLock()</span><br><span class="line">	<span class="comment">// first check</span></span><br><span class="line">	s.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line">	s.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.mutex.Unlock()</span><br><span class="line">	<span class="comment">// check and do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LoadAndStore 释放资源</p>
<p>在 Load 资源前面需要注意，如果资源创建之后没有 Store 到 <code>map</code> 中，需要手动回收，不然会给GC压力。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSafeMap_LoadAndStore</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    m := &amp;SafeMap&#123;</span><br><span class="line">       m: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          conn := &amp;connection&#123;&#125;</span><br><span class="line">          nc, _ := m.LoadOrStore(<span class="string">&quot;hello&quot;</span>, conn) <span class="comment">// store 进去的 conn 可以正常使用，但是没有 store 进去的 conn 会被丢弃</span></span><br><span class="line">          _ = nc.(*connection).send()</span><br><span class="line">       &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，需要根据返回的是否使用 <code>map</code> 中的对象，来决定对象是否需要回收</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSafeMap_LoadAndStore</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	m := &amp;SafeMap&#123;</span><br><span class="line">		m: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			conn := &amp;connection&#123;&#125;</span><br><span class="line">			nc, loaded := m.LoadOrStore(<span class="string">&quot;hello&quot;</span>, conn) <span class="comment">// store 进去的 conn 可以正常使用，但是没有 store 进去的 conn 会被丢弃</span></span><br><span class="line">			<span class="keyword">if</span> loaded &#123; <span class="comment">// 判断是否是从 map 中 load 的对象</span></span><br><span class="line">				_ = nc.(*connection).Close()</span><br><span class="line">			&#125;</span><br><span class="line">			_ = nc.(*connection).send()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>减轻重量对象创建时的资源</p>
<p>比如一些链接创建的时候会比较重量，因此在创建对象的时候可以传入一个创建函数，在具体需要使用的时候才创建。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valProvider <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SafeMap)</span></span> LoadOrStore(key <span class="type">string</span>, p valProvider) (val <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    s.mutex.RLock()</span><br><span class="line">    val, ok := s.m[key]</span><br><span class="line">    s.mutex.RUnlock()</span><br><span class="line">    <span class="keyword">if</span> ok &#123; <span class="comment">// 判断OK的时候，就可能有别的 goroutine store新的数据</span></span><br><span class="line">       <span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    s.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.mutex.Unlock()</span><br><span class="line">    <span class="keyword">if</span> val, ok = s.m[key]; ok &#123; <span class="comment">// 使用double check，虽然可以优化成只加一个互斥锁，但是这种方式不影响在可以读到数据的情况下的性能</span></span><br><span class="line">       <span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    newValue := p()     <span class="comment">// 在需要创建的时候才会创建，让对象更加轻量</span></span><br><span class="line">    s.m[key] = newValue <span class="comment">// 上面的读锁释放后，下面的可能会有多个goroutine store 值</span></span><br><span class="line">    <span class="keyword">return</span> newValue, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法也可以优雅的解决前面创建对象时没有 Load 需要手动回收的问题。</p>
</li>
<li><p>Limiter 限流器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    limit   <span class="type">int</span>                               <span class="comment">// 当前处理请求的上限</span></span><br><span class="line">    handler <span class="function"><span class="keyword">func</span><span class="params">(req <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 处理请求逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reject bool 返回值表示究竟有没有执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Limiter)</span></span> Reject(req <span class="keyword">interface</span>&#123;&#125;) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>v1版本，加锁处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    limit   <span class="type">int</span>                               <span class="comment">// 当前处理请求的上限</span></span><br><span class="line">    handler <span class="function"><span class="keyword">func</span><span class="params">(req <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 处理请求逻辑</span></span><br><span class="line"></span><br><span class="line">    mutex sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reject bool 返回值表示究竟有没有执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Limiter)</span></span> Reject(req <span class="keyword">interface</span>&#123;&#125;) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">    l.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> l.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    res := l.handler(req)</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个版本没有意义，只有一个 goroutine 可以处理请求，也一直都不会拒绝其他请求。</p>
<p>下一个版本，将请求从串行改为可并发</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    limit   <span class="type">int</span>                               <span class="comment">// 当前处理请求的上限</span></span><br><span class="line">    handler <span class="function"><span class="keyword">func</span><span class="params">(req <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 处理请求逻辑</span></span><br><span class="line"></span><br><span class="line">    mutex sync.Mutex</span><br><span class="line">    cnt   <span class="type">int</span> <span class="comment">// 当前正在处理的请求数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reject bool 返回值表示究竟有没有执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Limiter)</span></span> Reject(req <span class="keyword">interface</span>&#123;&#125;) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">    l.mutex.Lock()</span><br><span class="line">    <span class="keyword">if</span> l.cnt &lt; l.limit &#123;</span><br><span class="line">       l.cnt++</span><br><span class="line">       l.mutex.Unlock() <span class="comment">// 释放锁，让其他的 goroutine 可以处理</span></span><br><span class="line">       res := l.handler(req)</span><br><span class="line">       l.mutex.Lock() <span class="comment">// 加锁，处理完之后，要减去当前处理的</span></span><br><span class="line">       <span class="keyword">defer</span> l.mutex.Unlock()</span><br><span class="line">       l.cnt--</span><br><span class="line">       <span class="keyword">return</span> res, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    l.mutex.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个版本很繁琐。而且一定要加锁，这里优化一下，使用读写锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    limit   <span class="type">int</span>                               <span class="comment">// 当前处理请求的上限</span></span><br><span class="line">    handler <span class="function"><span class="keyword">func</span><span class="params">(req <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 处理请求逻辑</span></span><br><span class="line"></span><br><span class="line">    mutex sync.RWMutex</span><br><span class="line">    cnt   <span class="type">int</span> <span class="comment">// 当前正在处理的请求数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reject bool 返回值表示究竟有没有执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Limiter)</span></span> Reject(req <span class="keyword">interface</span>&#123;&#125;) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">    l.mutex.RLock()</span><br><span class="line">    <span class="keyword">if</span> l.cnt &gt; l.limit &#123; <span class="comment">// 如果经常命中这个分支，那么性能要好一些</span></span><br><span class="line">       l.mutex.RUnlock()</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    l.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再加写锁</span></span><br><span class="line">    l.mutex.Lock()</span><br><span class="line">    <span class="keyword">if</span> l.cnt &gt; l.limit &#123;</span><br><span class="line">       l.mutex.Unlock()</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l.cnt++</span><br><span class="line">    l.mutex.Unlock() <span class="comment">// 释放锁，让其他的 goroutine 可以处理</span></span><br><span class="line"></span><br><span class="line">    res := l.handler(req)</span><br><span class="line"></span><br><span class="line">    l.mutex.Lock() <span class="comment">// 加锁，处理完之后，要减去当前处理的</span></span><br><span class="line">    <span class="keyword">defer</span> l.mutex.Unlock()</span><br><span class="line">    l.cnt--</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>频繁加锁，代码繁琐，而且性能不好，可以通过 <code>atomic</code> 实现更加轻量的效果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	limit   <span class="type">int64</span>                             <span class="comment">// 当前处理请求的上限</span></span><br><span class="line">	handler <span class="function"><span class="keyword">func</span><span class="params">(req <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 处理请求逻辑</span></span><br><span class="line"></span><br><span class="line">	mutex sync.RWMutex</span><br><span class="line">	cnt   *<span class="type">int64</span> <span class="comment">// 当前正在处理的请求数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reject bool 返回值表示究竟有没有执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Limiter)</span></span> Reject(req <span class="keyword">interface</span>&#123;&#125;) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadInt64(l.cnt) &gt; l.limit &#123; <span class="comment">// 先获取一次</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	atomic.AddInt64(l.cnt, <span class="number">1</span>) <span class="comment">// 没有超过阈值，则+1</span></span><br><span class="line">	<span class="keyword">defer</span> atomic.AddInt64(l.cnt, <span class="number">-1</span>)</span><br><span class="line">	res := l.handler(req)</span><br><span class="line">	<span class="keyword">return</span> res, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改用 <code>atomic</code> 更加简洁，但是，当多个 goroutine 同时通过第一次判断时，第二次就无法准确哦按端请求数量，还需要 double check 一下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    limit   <span class="type">int64</span>                             <span class="comment">// 当前处理请求的上限</span></span><br><span class="line">    handler <span class="function"><span class="keyword">func</span><span class="params">(req <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 处理请求逻辑</span></span><br><span class="line"></span><br><span class="line">    mutex sync.RWMutex</span><br><span class="line">    cnt   *<span class="type">int64</span> <span class="comment">// 当前正在处理的请求数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reject bool 返回值表示究竟有没有执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Limiter)</span></span> Reject(req <span class="keyword">interface</span>&#123;&#125;) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.LoadInt64(l.cnt) &gt; l.limit &#123; <span class="comment">// 先获取一次</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// double check</span></span><br><span class="line">    cnt := atomic.AddInt64(l.cnt, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> atomic.AddInt64(l.cnt, <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> cnt &gt; l.limit &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    res := l.handler(req)</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码还可以更加简洁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	limit   <span class="type">int64</span>                             <span class="comment">// 当前处理请求的上限</span></span><br><span class="line">	handler <span class="function"><span class="keyword">func</span><span class="params">(req <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 处理请求逻辑</span></span><br><span class="line"></span><br><span class="line">	mutex sync.RWMutex</span><br><span class="line">	cnt   *<span class="type">int64</span> <span class="comment">// 当前正在处理的请求数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reject bool 返回值表示究竟有没有执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Limiter)</span></span> Reject(req <span class="keyword">interface</span>&#123;&#125;) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">	cnt := atomic.AddInt64(l.cnt, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> atomic.AddInt64(l.cnt, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cnt &gt; l.limit &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	res := l.handler(req)</span><br><span class="line">	<span class="keyword">return</span> res, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单向幂等修改</p>
<p>比如关闭服务器的时候，方filter拒绝所有的新请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> filter <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 处理请求</span></span><br><span class="line">	handler <span class="function"><span class="keyword">func</span><span class="params">(req <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 0 代表不拒绝，不为0代表拒绝</span></span><br><span class="line">	reject <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *filter)</span></span> Handler(req <span class="keyword">interface</span>&#123;&#125;) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadInt32(&amp;f.reject) &gt; <span class="number">0</span> &#123; <span class="comment">// 每一个请求都检验</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> f.handler(req), <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *filter)</span></span> RejectNewRequest() &#123;</span><br><span class="line">	atomic.StoreInt32(&amp;f.reject, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这个逻辑可以直接使用并发操作，直接修改</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> filter <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 处理请求</span></span><br><span class="line">	handler <span class="function"><span class="keyword">func</span><span class="params">(req <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 0 代表不拒绝，不为0代表拒绝</span></span><br><span class="line">	reject <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *filter)</span></span> Handler(req <span class="keyword">interface</span>&#123;&#125;) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> f.reject &gt; <span class="number">0</span> &#123; <span class="comment">// 每一个请求都检验</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> f.handler(req), <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *filter)</span></span> RejectNewRequest() &#123;</span><br><span class="line">	f.reject = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要接受可见性的短暂延迟，就没啥问题。</p>
</li>
<li><p>锁保护资源</p>
<p>使用锁保护资源的时候，需要将锁和资源结合在一起</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PublicResource 永远不知道用户拿了它会干啥</span></span><br><span class="line"><span class="comment">// 即使调用者不使用 PublicResourceLock 也没有办法</span></span><br><span class="line"><span class="keyword">var</span> PublicResource <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> PublicResourceLock sync.Mutex</span><br></pre></td></tr></table></figure>

<p>推荐写法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> safeResource <span class="keyword">struct</span> &#123;</span><br><span class="line">    resource <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    lock sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *safeResource)</span></span> DoSomething() &#123;</span><br><span class="line">    s.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.lock.Unlock()</span><br><span class="line">    s.resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不用锁，如何实现线程安全。</p>
<p>可以使用使用分割线，第一部分写入，第二部分读取使用。两个部分不会同时使用 goroutine 即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Registry <span class="keyword">struct</span> &#123;</span><br><span class="line">    resources <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Registry)</span></span> Register(name <span class="type">string</span>, resource <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    r.resources[name] = resource</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Registry)</span></span> Get(name <span class="type">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> r.resources[name], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，先注册（不能并发写入），然后使用的时候可以安全并发读取。</p>
</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>在多核CPU上，由于CPU有本地缓存，导致其他CPU要通过读屏障和写屏障获取到最新数据</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230924223247722.png" alt="image-20230924223247722"></p>
<p>这个架构其实与本地存储非常像</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230924223313202.png" alt="image-20230924223313202"></p>
<ol>
<li>如果只是修改本地缓存，别的实例肯定感知不到</li>
<li>如果修改了班底缓存，还写回去了数据库，别的实例也不一定能看到，因为它们自身缓存还没过期</li>
<li>写回去数据库之后，还要通知别的实例让缓存过期，重新加载</li>
</ol>
<h2 id="理解锁"><a href="#理解锁" class="headerlink" title="理解锁"></a>理解锁</h2><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAzOTg1NTY5Nw==">这可能是最容易理解的 Go Mutex 源码剖析<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://segmentfault.com/img/remote/1460000039855706" alt="互相加锁解锁"></p>
<h2 id="一些面试题"><a href="#一些面试题" class="headerlink" title="一些面试题"></a>一些面试题</h2><ul>
<li><p>进程、线程和协程的不同</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230924223924892.png" alt="image-20230924223924892"></p>
</li>
<li><p>为什么引入协程</p>
<p><img src="/../../../../../Library/Application%20Support/typora-user-images/image-20230924224214523.png" alt="image-20230924224214523"></p>
</li>
<li><p>goroutine 泄露的典型场景</p>
<p><img src="/../../../../../Library/Application%20Support/typora-user-images/image-20230924224702877.png" alt="image-20230924224702877"></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VERFlDSlkvYXJ0aWNsZS9kZXRhaWxzLzExNTUzNTIzNw==">跟读者聊 Goroutine 泄露的 N 种方法，真刺激！<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>怎么避免 goroutine 泄露</p>
<p><img src="/../../../../../Library/Application%20Support/typora-user-images/image-20230924225059696.png" alt="image-20230924225059696"></p>
</li>
<li><p>mutex 加锁</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/09/image-20230924225652184.png" alt="image-20230924225652184"></p>
</li>
</ul>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><span class="exturl" data-url="aHR0cHM6Ly9kYXZlLmNoZW5leS5uZXQvMjAxOC8wMS8wNi9pZi1hbGlnbmVkLW1lbW9yeS13cml0ZXMtYXJlLWF0b21pYy13aHktZG8td2UtbmVlZC10aGUtc3luYy1hdG9taWMtcGFja2FnZQ==">If aligned memory writes are atomic, why do we need the sync&#x2F;atomic package?<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Jsb2cuZ29sYW5nLm9yZy9yYWNlLWRldGVjdG9y">Introducing the Go Race Detector<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kYXZlLmNoZW5leS5uZXQvMjAxNC8wNi8yNy9pY2UtY3JlYW0tbWFrZXJzLWFuZC1kYXRhLXJhY2Vz">Ice cream makers and data races<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJkYW5sYWJzLmNvbS9ibG9nLzIwMTQvMDYvaWNlLWNyZWFtLW1ha2Vycy1hbmQtZGF0YS1yYWNlcy1wYXJ0LWlpLmh0bWw=">Ice Cream Makers and Data Races Part II<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2Etam91cm5leS13aXRoLWdvL2dvLWhvdy10by1yZWR1Y2UtbG9jay1jb250ZW50aW9uLXdpdGgtdGhlLWF0b21pYy1wYWNrYWdlLWJhM2IyNjY0YjU0OQ==">Go: How to Reduce Lock Contention with the Atomic Package<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2Etam91cm5leS13aXRoLWdvL2dvLWRpc2NvdmVyeS1vZi10aGUtdHJhY2UtcGFja2FnZS1lNWE4MjE3NDNjM2M=">Go: Discovery of the Trace Package<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2Etam91cm5leS13aXRoLWdvL2dvLW11dGV4LWFuZC1zdGFydmF0aW9uLTNmNGY0ZTc1YWQ1MA==">Go: Mutex and Starvation<i class="fa fa-external-link-alt"></i></span></p>
<p>medium 无法看完整内容推荐使用 <span class="exturl" data-url="aHR0cHM6Ly9jYW5lcmVyZGVuLmNvbS9ibG9nLzIwMjMvdW5sb2NrLW1lZGl1bS8=">https://canererden.com/blog/2023/unlock-medium/<i class="fa fa-external-link-alt"></i></span></p>
<p>PS：好像有方法说用 twitter 也可以突破限制。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Reference/" rel="tag"># 学习笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/6927.html" rel="prev" title="Go的concurrency之goroutine">
                  <i class="fa fa-chevron-left"></i> Go的concurrency之goroutine
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/bda0.html" rel="next" title="casbin">
                  casbin <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mitaka xu</span>
</div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"TVx6Wkfs8VJGOwYPurtjWY2e-9Nh9j0Va","app_key":"c7VvaRnyF8r3DUIPq1x2KJ7Q","server_url":"https://tvx6wkfs.lc-cn-e1-shared.com","security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"xiaoyeshiyu","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
