<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="S_5aoPFd3QQihrUOLiKdVR0Mj4fj6n6qJojwyjj9cAY">
  <meta name="msvalidate.01" content="9032A67FCF787F07CB04374E59E518A9">
  <meta name="baidu-site-verification" content="code-Onlniop0d6">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.xiaoyeshiyu.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.15.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Golang开发博客">
<meta property="og:type" content="website">
<meta property="og:title" content="小夜时雨">
<meta property="og:url" content="https://www.xiaoyeshiyu.com/index.html">
<meta property="og:site_name" content="小夜时雨">
<meta property="og:description" content="Golang开发博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Mitaka xu">
<meta property="article:tag" content="Golang, 微服务，数据库，中间件, 算法">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.xiaoyeshiyu.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>小夜时雨 - 君子敬其在己者，而不慕其在天者，是以日进也。</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MBVJ11TVHH"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-MBVJ11TVHH","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?573725610fbc6ff9b42032bd13615370"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="小夜时雨" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">小夜时雨</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">君子敬其在己者，而不慕其在天者，是以日进也。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mitaka xu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Mitaka xu</p>
  <div class="site-description" itemprop="description">Golang开发博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaoyeshiyu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/ff15.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 小夜时雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/ff15.html" class="post-title-link" itemprop="url">Kubernetes 架构原则和对象设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-01-04 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-04T00:00:00+08:00">2024-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-10 18:23:50" itemprop="dateModified" datetime="2024-01-10T18:23:50+08:00">2024-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">云原生训练营</span></a>
        </span>
    </span>

  
    <span id="/post/ff15.html" class="post-meta-item leancloud_visitors" data-flag-title="Kubernetes 架构原则和对象设计" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h1><p>云原生是云计算时代的产物。</p>
<p>云计算是将计算资源、网络资源、存储资源整合为一个集群的抽象，面向抽象的计算资源运行应用。云平台将应用按照资源需求，自动调度合适的资源运行。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240104172734510.png" alt="image-20240104172734510"></p>
<h2 id="云计算平台的分类"><a href="#云计算平台的分类" class="headerlink" title="云计算平台的分类"></a>云计算平台的分类</h2><p>以 <code>Openstack</code> 为典型的虚拟化平台</p>
<ul>
<li>虚拟机构建和业务代码部署分离</li>
<li>可变的基础架构使后续持续风险变大</li>
</ul>
<p>以谷歌 <code>borg</code> 为典型的基于进程的作业调度平台</p>
<ul>
<li>技术的迭代引发 <code>borg</code> 的换代需求</li>
<li>早期的隔离依靠 <code>chroot jail</code> 实现，一些不合理的设计需要在新产品中改进<ul>
<li>对象之间的强依赖 <code>job</code> 和 <code>task</code> 是强包含关系，不利于重组</li>
<li>所有容器共享 IP，会导致端口冲突，隔离困难等问题</li>
<li>为超级用户添加复杂逻辑导致系统过于复杂</li>
</ul>
</li>
</ul>
<h2 id="Borg"><a href="#Borg" class="headerlink" title="Borg"></a>Borg</h2><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240104173736050.png" alt="image-20240104173736050"></p>
<p><code>Borg</code> 上的任务有两种，一种是持续性服务，例如 <code>Gmail</code>、<code>Google Docs</code>、 <code>Web Search</code>，需要持续性服务，注重可用性和稳定性；另外一种是一些异步任务，定时执行或者持续执行，例如对账。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>特性：</p>
<ul>
<li>物理资源利用率高：相比虚拟化技术</li>
<li>服务器共享，在进程级别做隔离</li>
<li>应用高可用，故障恢复时间短</li>
<li>调度策略灵活</li>
<li>应用接入和使用方便，提供了完备的 <code>Job</code> 描述语言，服务发现，实现状态监控和诊断工具</li>
</ul>
<p>优势：</p>
<ul>
<li>对外隐藏底层资源管理和调度、故障处理等</li>
<li>实现应用的高可靠和高可用</li>
<li>足够弹性，支持应用跑在成千上万的机器上</li>
</ul>
<p>可以看到，<code>Borg</code> 的很多特性和优势，与云平台是一致的，这种思想很值得借鉴。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><code>Workload</code>：</p>
<ul>
<li><code>prod</code>：在线任务，长期运行、对延时敏感、面向终端用户等，比如 <code>Gmail</code>，<code>Google Docs</code>，<code>Web Search</code> 服务等</li>
<li><code>non-prod</code>：离线任务，也称为批处理任务（<code>Batch</code>），比如一些分布式计算服务等。</li>
</ul>
<p><code>Cell</code></p>
<ul>
<li>一个 <code>Cell</code> 上跑一个集群管理系统 <code>Borg</code></li>
<li>通过定义 <code>Cell</code> 可以让 <code>Borg</code> 对服务器资源进行统一抽象，作为用户就无需知道自己的应用跑在哪台机器上，也不用关心资源分配、程序安装、依赖管理、健康检查及故障恢复等。</li>
</ul>
<p><code>Job</code> 和 <code>Task</code></p>
<ul>
<li>用户以 <code>Job</code> 的形式提交应用部署请。一个 <code>Job</code> 包含一个或多个相同的 <code>Task</code>，每个 <code>Taks</code> 运行相同的应用程序，<code>Task</code> 数量就是应用的副本数。</li>
<li>每个 <code>Job</code> 可以定义属性、元信息和优先级，优先级涉及到抢占式调度过程。</li>
</ul>
<p><code>Naming</code></p>
<ul>
<li><code>Borg</code> 的服务发现通过 <code>BNS</code>（<code>Borg Name Service</code>）来实现</li>
<li><code>50.jfoo.ubar.cc.borg.google.com</code> 可表示在一个名为 <code>cc</code> 的 <code>Cell</code> 中由用户 <code>uBar</code> 部署的一个名为 <code>jFoo</code> 的 <code>Job</code> 下的第 <code>50</code> 个 <code>Task</code></li>
</ul>
<p>从这个基本概念就可以看出 <code>Kubernetes</code> 的影子。例如 <code>Cell</code>：集群，<code>Job</code>和<code>Task</code>：<code>Pod</code> 和 <code>container</code>，<code>Naming</code>：<code>namsepace</code>服务发现。</p>
<h3 id="Borg-架构"><a href="#Borg-架构" class="headerlink" title="Borg 架构"></a>Borg 架构</h3><p><img src="/../../../../../../Library/Application%20Support/typora-user-images/image-20240104175905813.png" alt="image-20240104175905813"></p>
<p><code>Borgmaster</code> 主进程：</p>
<ul>
<li>处理客户端 <code>RPC</code> 请求，比如创建 <code>Job</code>，查询 <code>Job</code> 等</li>
<li>维护系统组件和服务的状态，比如服务器、<code>Task</code> 等</li>
<li>负责与 <code>Borglet</code> 通信</li>
</ul>
<p><code>Scheduler</code> 进程：</p>
<ul>
<li>调度策略<ul>
<li><code>Worst Fit</code>：寻找仅够的节点调度；这种方式会将一个节点的资源使用完再使用下一个节点，此时可以将没有调度的节点关机以节省资源</li>
<li><code>Best Fit</code>：寻找最空闲的节点调度；这种方式会使得所有的节点上负载实现均衡</li>
<li><code>Hybrid</code>：混合模式</li>
</ul>
</li>
<li>调度优化<ul>
<li><code>Score caching</code>：当服务器或者任务的状态未发生变更或者变更很少时，直接采用缓存数据，避免重复计算</li>
<li><code>Equivalence classes</code>：调度同一 <code>Job</code> 下多个相同的 <code>Task</code> 只需计算一次</li>
<li><code>Relaxed randomization</code>：引入一些随机性，即每次随机选择一些机器，只要符合需求的服务器数量达到一定值时，就可以停止计算，无需每次对 <code>Cell</code> 中所有服务器进行 <code>feasibility checking</code></li>
</ul>
</li>
</ul>
<p><code>Borglet</code>: 部署在所有服务器上的 <code>Agent</code>，负责接收  <code>Borgmaster</code> 进程的指令。</p>
<h3 id="应用高可用"><a href="#应用高可用" class="headerlink" title="应用高可用"></a>应用高可用</h3><ul>
<li>被抢占的 <code>non-prod</code> 任务放回 <code>pending queueu</code>，等待重新调度</li>
<li>多副本应用跨故障域部署。所谓故障域有大有小，比如相同机器、相同机架或相同电源插座等，一挂全挂。</li>
<li>对于类似服务器或操作系统升级的维护操作，避免大量服务器同时进行</li>
<li>支持幂等性，支持客户端重复操作</li>
<li>当服务器状态变为不可用时，要控制重新调度任务的速率。因为 <code>Brog</code> 无法区分是节点故障还是出现了短暂的网络分区，如果是后者，静静地等待网络恢复更利于保障服务可用性。</li>
<li>当某种 <strong>任务 @ 服务器</strong> 的组合出现故障时，下次重新调度时需避免这种组合再次出现，因为极大可能会再次出现相同故障。</li>
<li>记录详细的内部信息，便于故障排查和分析</li>
<li>保障应用高可用的关键性设计原则：无论何种原因，即使  <code>Brogmaster</code> 或者 <code>Broglet</code> 挂掉、失恋，都不能杀掉正在运行的任务（<code>Task</code>）</li>
</ul>
<h3 id="Borg-系统自身高可用"><a href="#Borg-系统自身高可用" class="headerlink" title="Borg 系统自身高可用"></a>Borg 系统自身高可用</h3><ul>
<li><code>Borgmaster</code> 组件多副本设计（例如 <code>master</code> 有五个实例）</li>
<li>采用一些简单的和底层（<code>low-level</code>）的工具来部署 <code>Borg</code> 系统实例，避免引入过多的外部依赖</li>
<li>每个 <code>Cell</code> 的 <code>Borg</code> 均独立部署，避免不同 <code>Borg</code> 系统相互影响</li>
</ul>
<h3 id="资源利用率"><a href="#资源利用率" class="headerlink" title="资源利用率"></a>资源利用率</h3><ul>
<li><p>通过将在线任务（<code>prod</code>）和离线任务（<code>non-prod</code>，<code>Batch</code>）混合部署，空闲时，离线任务可以充分利用计算资源；繁忙时，在线任务通过抢占式的方式保证优先得到执行，合理地利用资源。</p>
</li>
<li><p><code>98%</code> 的服务器实现了混合部署</p>
</li>
<li><p><code>90%</code> 的服务器中跑了超过 <code>25</code> 个 <code>Task</code> 和 <code>4500</code> 个线程（例如 <code>k8s</code> 中的节点 <code>pod</code> 数量限制也是基于这个推算）</p>
</li>
<li><p>在一个中等规模的 <code>Cell</code> 里，在线任务和离线任务独立部署比混合部署所需的服务器数量多出约 <code>20%-30%</code>。</p>
<p>可以简单算一笔账，<code>Google</code> 的服务器数量在千万级别，按 <code>20%</code> 算也是百分级别，大概能剩下的服务器采购费用就是百亿级别，这还不包括省下的机房等基础设施和电费等费用。</p>
</li>
</ul>
<h3 id="Brog-调度原理"><a href="#Brog-调度原理" class="headerlink" title="Brog 调度原理"></a><code>Brog</code> 调度原理</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240105152940310.png" alt="image-20240105152940310"></p>
<p>应用运行的时候，需要设置资源 <code>limit</code>，这个 <code>limit</code> 通常需要每天观察应用运行状态，在不同的时间节点进行统计。</p>
<p>在 <code>task</code> 启动 <code>300s</code> 后，进行资源回收工作，把保留资源设置为：实际使用资源 + 安全资源，并没过几秒再重新计算一次。</p>
<p>例如上图，给实际使用资源（绿色）预留出一部分 <code>buffer</code>（也就是蓝色），然后将分配的多余的资源（黄色）回收掉。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>安全性隔离：</p>
<ul>
<li>早期采用 <code>Chroot jail</code>，后期版本基于 <code>Namespace</code></li>
</ul>
<p>性能隔离：</p>
<ul>
<li>采用基于 <code>Cgroup</code> 的容器技术实现</li>
<li>在线任务（<code>prod</code>）是延时敏感（<code>latency-sensitive</code>）型的，优先级高，而离线任务（<code>non-prod</code>，<code>Batch</code>）优先级低</li>
<li><code>Borg</code> 通过不同优先级之间的抢占式调度来优先保障在线任务的性能，牺牲离线任务</li>
<li><code>Borg</code> 将资源类型分成两类：<ul>
<li>可压榨的（<code>compressible</code>），<code>CPU</code> 是可压榨资源，资源耗尽不会终止进程；</li>
<li>不可压榨的（<code>non-compressible</code>），内存是不可压榨资源，资源耗尽进程会被终止（<code>OOM</code>）。</li>
</ul>
</li>
</ul>
<h3 id="什么是-Kubernetes-（k8s）"><a href="#什么是-Kubernetes-（k8s）" class="headerlink" title="什么是 Kubernetes （k8s）"></a>什么是 Kubernetes （<code>k8s</code>）</h3><p>Kubernetes 是谷歌开源的容器集群管理系统，是 <code>Google</code> 多年大规模容器管理技术 <code>Borg</code> 的开源版本，主要功能包括：</p>
<ul>
<li>基于容器的应用部署、维护和滚动升级</li>
<li>负载均衡和服务发现</li>
<li>跨机器和跨地区的集群调度</li>
<li>自动伸缩</li>
<li>无状态服务和有状态服务（有状态应用会有额外的运维成本，例如数据库，需要有专门的 <code>DBA</code>）<ul>
<li>无状态服务指的是相同的 <code>pod</code> 之间没有区别，本地不保存任何数据</li>
<li>有状态服务指的是服务自身维护数据或者配置，与其他相同的 <code>pod</code> 的数据不一致</li>
</ul>
</li>
<li>插件机制保证扩展性</li>
</ul>
<p>Kubernetes 早期架构图：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240105154149382.png" alt="image-20240105154149382"></p>
<p>每一个计算节点上运行 <code>kubelet</code>，通过 Docker 本身的 interface 启动一个个容器，容器和容器之间通过 <code>Namespace</code> 和 <code>Cgroup</code> 实现资源隔离和限制。</p>
<h1 id="Kubernetes-架构基础"><a href="#Kubernetes-架构基础" class="headerlink" title="Kubernetes 架构基础"></a>Kubernetes 架构基础</h1><h2 id="系统规范"><a href="#系统规范" class="headerlink" title="系统规范"></a>系统规范</h2><h3 id="命令式（imperative）-vs-声明式（Declarative）"><a href="#命令式（imperative）-vs-声明式（Declarative）" class="headerlink" title="命令式（imperative） vs 声明式（Declarative）"></a>命令式（imperative） vs 声明式（Declarative）</h3><p>命令式系统关注 <strong>如何做</strong></p>
<p>在软件工程领域，命令式系统是写出解决某个问题、完成某个任务或者达到某个目标的明确步骤。此方法明确写出系统应该执行某指令，并且期待系统返回期望结果。例如交互系统。</p>
<p>声明式系统关注 <strong>做什么</strong></p>
<p>在软件工程领域，声明式系统指程序代码描述系统应该做什么而不是怎么做。仅限于描述要达到什么目的，如何达到目的交给系统。</p>
<p>前者例如电视遥控器；后者例如空调遥控器。</p>
<h3 id="声明式（Declaritive）系统规范"><a href="#声明式（Declaritive）系统规范" class="headerlink" title="声明式（Declaritive）系统规范"></a>声明式（Declaritive）系统规范</h3><p>命令式：</p>
<ul>
<li>我要你做什么，怎么做，请严格按照我说的做</li>
</ul>
<p>声明式：</p>
<ul>
<li>我需要你帮我做点事，但是我只告诉你我需要你做什么，不是你应该怎么做。</li>
<li>直接声明：我直接告诉你我需要什么</li>
<li>间接声明：我不直接告诉你我的需求，我会把我的需求放在特定的地方，请在方便的时候拿出来处理</li>
</ul>
<p>幂等性：</p>
<ul>
<li>状态固定，每次我要你做事，请给我返回相同结果</li>
</ul>
<p>面向对象的：</p>
<ul>
<li>把一切抽象成对象</li>
</ul>
<h3 id="Kubernetes：声明式系统"><a href="#Kubernetes：声明式系统" class="headerlink" title="Kubernetes：声明式系统"></a>Kubernetes：声明式系统</h3><p>Kubernetes 的所有管理能力构建在对象抽象的基础上，核心对象包括：</p>
<ul>
<li><code>Node</code>：计算节点的抽象，用来描述计算节点的资源抽象、健康状态等</li>
<li><code>Namespace</code>：资源隔离的基本单位，可以简单理解为文件系统中的目录结构</li>
<li><code>Pod</code>：用来描述应用实例，包括镜像地址、资源需求等。Kubernetes 中最核心的对象，也是打通应用和基础架构的秘密武器（相对  <code>openstack</code> 来说，<code>openstack</code> 无法通过主机获取上层虚拟机运行的服务。而 Kubernetes 可以通过 <code>Node</code> 获取对应节点上的 <code>Pod</code>，也就知道基础架构上的应用情况）</li>
<li><code>Service</code>：服务如何将应用发布成服务，本质上是负载均衡和域名服务的声明</li>
</ul>
<h2 id="Kubernetes-采用与-Borg-类似的架构"><a href="#Kubernetes-采用与-Borg-类似的架构" class="headerlink" title="Kubernetes 采用与 Borg 类似的架构"></a>Kubernetes 采用与 Borg 类似的架构</h2><p><img src="/../../../../../../Library/Application%20Support/typora-user-images/image-20240105160514834.png" alt="image-20240105160514834"></p>
<p><code>kubelet</code> 运行在计算节点上，与 <code>master</code> 通过 <code>API Server</code> 通信，<code>master</code> 同时负责调度 <code>schduler</code> 和控制器 <code>Controllers</code>。</p>
<p><code>kubelet</code>  通过与 <code>API Server</code> 交互，获取 <code>etcd</code> 信息，运行 <code>pod</code> 。</p>
<p><code>scheduler</code>：负责选择最佳 <code>Node</code> 并且调度 <code>pod</code> 到 <code>Node</code> 上。</p>
<p><code>Controllers</code>：负责管理集群的资源以及管理节点状态，例如节点异常，<code>Controllers</code> 将该节点上的资源移除。</p>
<h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240105160551441.png" alt="image-20240105160551441"></p>
<p>左边用户通过 <code>kubectl</code> 命令与 <code>k8s</code> 交互，通过认证和授权，请求发送到 <code>API</code>。<code>API</code> 服务将请求存储到 <code>Distributed Watchable Storage</code>（例如 <code>etcd</code>）。</p>
<p><code>controller manager</code>：通过 <code>API</code> 观察整个集群，监听 <code>kubelet</code> 对象。</p>
<p><code>Scheduler：</code>调度器负责调度没有与 <code>Node</code> 绑定的 <code>Pod</code>，与 <code>API</code> 通信调度 <code>Pod</code> 到 <code>Node</code> 上。</p>
<p><code>kubelet</code>：通过 <code>API</code> 获取本节点上 <code>Pod</code> 调度信息，负责在本 <code>Node</code> 上运行 <code>Pod</code></p>
<p><code>Proxy</code>：应用进程在 <code>Pod</code> 中运行服务，并提供服务，通过 <code>Porxy</code> 实现网络通信和服务发现</p>
<h3 id="Kubernetes-的主节点（Master-Node）"><a href="#Kubernetes-的主节点（Master-Node）" class="headerlink" title="Kubernetes 的主节点（Master Node）"></a>Kubernetes 的主节点（Master Node）</h3><ul>
<li><p><code>API</code> 服务器：<code>API Server</code></p>
<p>这是 Kubernetes 控制面板中唯一带有用户可访问 API 以及用户可交互的组件。API 服务器会暴露一个 <code>RESTful</code> 的 Kubernetes API 并使用 <code>JSON</code> 格式的清单文件（<code>manifest files</code>）。获取请求之后，将请求保存到 <code>etcd</code>。</p>
</li>
<li><p>集群的数据存储：<code>Cluster Data Store</code></p>
<p>Kubernetes 使用 <code>etcd</code>。这是一个强大的、稳定的、高可用的键值存储，被 Kubernetes 用于长久存储所有的 API 对象</p>
</li>
<li><p>控制管理器：<code>Controller Manager</code></p>
<p>被称为 <code>kube-controller manager</code>，他运行着所有处理集群日常任务的控制。包括了节点控制器、副本控制器、端点（<code>endpoint</code>）控制器以及服务账户等。（依靠监控 <code>etcd</code>）</p>
</li>
<li><p>调度器：<code>Scheduler</code></p>
<p>调度器会监控新建的 <code>pods</code>（一组或一个容器）并将其分配给节点。（依靠监控 <code>etcd</code>）</p>
</li>
</ul>
<h3 id="Kubernetes-的工作节点（Worker-Node）"><a href="#Kubernetes-的工作节点（Worker-Node）" class="headerlink" title="Kubernetes 的工作节点（Worker Node）"></a>Kubernetes 的工作节点（Worker Node）</h3><ul>
<li><p><code>Kubelet</code></p>
<p>负责调度到对应节点的 <code>Pod</code> 的生命周期管理，执行任务并将 <code>Pod</code> 状态报告给主节点的渠道，通过容器运行时（拉取镜像、启动和停止容器等）来运行这些容器。它还会定期执行被请求的容器的健康探测程序。</p>
</li>
<li><p><code>Kube-proxy</code></p>
<p>它负责节点的网络，在主机上维护网络规则并执行连接转发。它还负责对正在服务的 <code>pods</code> 进行负载平衡。</p>
</li>
</ul>
<h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><p><code>etcd</code> 是 <code>CoreOS</code> 基于 <code>Raft</code> 开发的分布式 <code>key-value</code> 存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240105163024523.png" alt="image-20240105163024523"></p>
<ul>
<li>基本的 <code>key-value</code> 存储</li>
<li>监听机制：可以实时获取数据变化</li>
<li><code>key</code> 的过期及续约机制，用于监控和服务发现</li>
<li>原子 <code>CAS</code> 的 <code>CAD</code>，用于分布式锁和 <code>leader</code> 选举</li>
</ul>
<h4 id="直接访问-etcd-的数据"><a href="#直接访问-etcd-的数据" class="headerlink" title="直接访问 etcd 的数据"></a>直接访问 <code>etcd</code> 的数据</h4><ul>
<li><p>通过 <code>etcd</code> 进程查看启动参数</p>
</li>
<li><p>进入容器，<code>kubectl exec -it etcd-node201 -n kube-system sh</code></p>
<ul>
<li><p><code>ps -ef | grep etcd</code>：没有 <code>ps</code> 命令，可以通过主机 <code>namespace</code> 查看 <code>cert</code> 信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root       10271   10202  4  2023 ?        1-21:56:11 etcd --name=node201 --cert-file=/etc/kubernetes/pki/etcd/server.crt --key-file=/etc/kubernetes/pki/etcd/server.key --listen-client-urls=https://127.0.0.1:5379,https://192.xxx.:5379 --advertise-client-urls=https://192.xxx.:5379 --listen-peer-urls=https://192.xxx.:5380 --initial-advertise-peer-urls=https://192.xxx.:5380 --initial-cluster=node201=https://192.xxx.:5380 --initial-cluster-token=etcd-xxx --initial-cluster-state=new --client-cert-auth=true --peer-cert-file=/etc/kubernetes/pki/etcd/peer.crt --peer-key-file=/etc/kubernetes/pki/etcd/peer.key --peer-trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt --peer-client-cert-auth=true --data-dir=/var/lib/etcd --trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>进入容器查看数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 设置环境变量，API 版本</span><br><span class="line"># export ETCDCTL_API=3</span><br><span class="line">// 获取以 `/` 开头的数据</span><br><span class="line"># etcdctl --endpoints https://localhost:5379 --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key --cacert /etc/kubernetes/pki/etcd/ca.crt get --keys-only --prefix /</span><br><span class="line">/casbin</span><br><span class="line"></span><br><span class="line">/registry/apiregistration.k8s.io/apiservices/v1.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听对象变化</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 观测前缀是 /registry/services/specs/default/mynginx 的 key 的变化</span><br><span class="line">etcdctl --endpoints https://localhost:5379 --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key --cacert /etc/kubernetes/pki/etcd/ca.crt watch --prefix /registry/services/specs/default/mynginx</span><br><span class="line"></span><br><span class="line">// watch 变化结果示例：</span><br><span class="line">PUT</span><br><span class="line">/registry/services/specs/air/xxx</span><br><span class="line">k8s</span><br><span class="line"></span><br><span class="line">v1Service�</span><br><span class="line">�</span><br><span class="line">xxx-serviceair&quot;*$23d71278-3e5d-416e-bad2-204bfc4f0f302���Z</span><br><span class="line">appair-xxx-serviceb�</span><br><span class="line">0kubectl.kubernetes.io/last-applied-configuration�&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;labels&quot;:&#123;&quot;app&quot;:&quot;air-xxx-service&quot;&#125;,&quot;name&quot;:&quot;xxx-service&quot;,&quot;namespace&quot;:&quot;air&quot;&#125;,&quot;spec&quot;:&#123;&quot;ports&quot;:[&#123;&quot;name&quot;:&quot;air01&quot;,&quot;port&quot;:8081,&quot;protocol&quot;:&quot;TCP&quot;&#125;,&#123;&quot;name&quot;:&quot;air02&quot;,&quot;port&quot;:8082,&quot;protocol&quot;:&quot;TCP&quot;&#125;,&#123;&quot;name&quot;:&quot;dlv&quot;,&quot;port&quot;:8083,&quot;protocol&quot;:&quot;TCP&quot;&#125;],&quot;selector&quot;:&#123;&quot;app&quot;:&quot;air-xxx-service&quot;&#125;,&quot;type&quot;:&quot;NodePort&quot;&#125;&#125;</span><br><span class="line">z�</span><br><span class="line"></span><br><span class="line">air01TCP�?�?(��</span><br><span class="line"></span><br><span class="line">air02TCP�?�?(��</span><br><span class="line"></span><br><span class="line">dlvTCP�?�?(��</span><br><span class="line">appair-xxx-service</span><br><span class="line">                     10.0.210.79NodePort:NoneBRZCluster`h</span><br></pre></td></tr></table></figure>

<p>当修改资源是，<code>etcd</code> 会实时监听变化。</p>
</li>
</ul>
<h3 id="APIServer"><a href="#APIServer" class="headerlink" title="APIServer"></a>APIServer</h3><p>Kube-APIServer 是 Kubernetes 最重要的核心组件之一。<strong>APIServer 是唯一一个与 <code>etcd</code> 通信的组件。</strong></p>
<p><img src="/../../../../../../Library/Application%20Support/typora-user-images/image-20240105171045903.png" alt="image-20240105171045903"></p>
<p>主要提供一下功能：</p>
<ul>
<li>提供集群管理的 <code>REST API</code> 接口，包括：<ul>
<li>认证 <code>Authentication</code></li>
<li>授权 <code>Authorization</code></li>
<li>准入 <code>Admission</code>（<code>Mutating &amp; Valiating</code>）</li>
</ul>
</li>
<li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 <code>APIServer</code> 查询或修改数据，只有 <code>APIServer</code> 才直接操作 <code>etcd</code>）</li>
<li><code>APIServer</code> 提供 <code>etcd</code> 数据缓存以减少集群对 <code>etcd</code> 的访问（大部分读操作会由 <code>APIServer</code> 直接返回，写操作才会到 &#96;etcd）</li>
</ul>
<h4 id="APIServer-展开"><a href="#APIServer-展开" class="headerlink" title="APIServer 展开"></a>APIServer 展开</h4><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240105171505576.png" alt="image-20240105171505576"></p>
<p>APIServer 经历多个版本的变化。目前 <code>v3</code> 版本已经很稳定。</p>
<p>APIServer 的访问过程与 <code>HTTP Router</code> 很像，经过多个中间件。</p>
<ul>
<li><code>AuthN</code>：认证</li>
<li><code>Rate Limit</code>：限流，判断这个请求是否可以处理</li>
<li><code>Auditing</code>：审计日志，记录操作</li>
<li><code>AuthZ</code>：鉴权，通过 <code>RBAC</code> 判断权限是否满足</li>
<li><code>Aggregator</code>：聚合器，当需要给请求加或者修改属性；或者一些不经过 <code>Kubernetes</code> 原生逻辑，而是使用自己的 <code>APIServer</code>。例如 <code>kubectl top node</code> 这些插件。</li>
<li><code>Validation</code>：校验器，语法校验器等</li>
</ul>
<p>最后才到 <code>etcd</code>。</p>
<h3 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller Manager"></a>Controller Manager</h3><ul>
<li><code>Controller Manager</code> 是集群的大脑，是确保整个集群动起来的关键；</li>
<li>作用是确保 <code>Kubernetes</code> 遵循声明式系统规范，确保系统的真实状态（<code>Actual State</code>）于用于定义的期望状态（<code>Desired State</code>）一致；</li>
<li><code>Controller Manager</code> 是多个控制器的组合（例如有 <code>deployment</code> 的控制器），每个 <code>Controller</code> 事实上都是一个 <code>control loop</code>，负责侦听其管控的对象，当对象发生变更时完成配置；（实际上是一个生产者消费者模型，消费的时候如果失败，还需要将任务丢回队列）</li>
<li><code>Controller</code> 配置失败通常会触发自动重试，整个集群会在控制器不断重试的机制下确保最终一致性（<code>Eventual Consistency</code>）</li>
</ul>
<h4 id="控制器的工作流程"><a href="#控制器的工作流程" class="headerlink" title="控制器的工作流程"></a>控制器的工作流程</h4><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240105172435343.png" alt="image-20240105172435343"></p>
<h4 id="Informer-的内部机制"><a href="#Informer-的内部机制" class="headerlink" title="Informer 的内部机制"></a>Informer 的内部机制</h4><p><img src="/../../../../../../Library/Application%20Support/typora-user-images/image-20240105172639833.png" alt="image-20240105172639833"></p>
<p><code>Informer</code>：提供一个 <code>List &amp; Watch</code>机制，获取对象变化，告知 <code>Informer</code>。</p>
<p>配合源码食用效果更佳。</p>
<h4 id="控制器的协同工作原理"><a href="#控制器的协同工作原理" class="headerlink" title="控制器的协同工作原理"></a>控制器的协同工作原理</h4><p>例如三个不同的控制器：</p>
<ul>
<li><code>Deployment Controller</code></li>
<li><code>ReplicaSet Controller</code></li>
<li>调度器（调度器也是一个特殊的控制器）</li>
</ul>
<p>使用描述应用部署的 <code>deployment</code>，在控制平面，会由 <code>Controller manager</code> 通过<code>deployment controller</code>创建副本集 <code>ReplicaSet</code>， 实现副本管理（通过 <code>kubectl descrpbe deployment xxx</code>，获取到 <code>Events</code> 的 <code>From</code>）；</p>
<p><code>Controller</code> 中的 <code>ReplicaSet Controller</code> 通过 <code>APIServer</code> 获取到 <code>ReplicaSet</code> 语义，创建出 <code>ReplicaSet</code>。</p>
<p>调度器通过监听 <code>APIServer</code>的 <code>Pod</code> 信息，选出 <code>Node</code>，调度到对应节点。</p>
<p>计算节点上的 <code>kubelet</code> 监听 <code>API Server</code>，获取 <code>Pod</code> 信息，匹配本机信息，调用运行时，创建出 <code>Pod</code>。</p>
<p>再由网络插件负责网络。如果<code>Pod</code> 需要外部存储，再由 <code>CSI</code> 挂载存储。</p>
<p><img src="/../../../../../../Library/Application%20Support/typora-user-images/image-20240105172739419.png" alt="image-20240105172739419"></p>
<p>修改、删除资源（<code>Pod</code>，<code>ReplicaSet</code>，<code>Deployment</code>）同理。</p>
<p>控制器整个过程，需要监控 <code>API Server</code> 中定义的状态与当前状态是否一致，例如副本数、<code>Pod</code> 个数。</p>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>特殊的 <code>Controller</code> ，工作原理与其他控制器无差别。</p>
<p><code>Scheduler</code> 的特殊职责在于监控当前集群所有未调度的 <code>Pod</code>，并且获取当前集群所有节点的健康状况和资源使用情况，为待调度 <code>Pod</code> 选择最佳计算节点，完成调度。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240105173110075.png" alt="image-20240105173110075"></p>
<p>调度阶段分为：</p>
<ul>
<li><code>Predict</code>：过滤不能满足业务需求的节点，如资源不足、端口冲突等</li>
<li><code>Priority</code>：按既定要素将满足调度需求的节点评分，选择最佳节点</li>
<li><code>Bind</code>：将计算节点与 <code>Pod</code> 绑定，完成调度。</li>
</ul>
<h3 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h3><p>Kubernetes 的初始化系统（<code>init system</code>）</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240105173326543.png" alt="image-20240105173326543"></p>
<ul>
<li>从不同源获取 <code>Pod</code> 清单，并按需求启停 <code>Pod</code> 的核心组件：<ul>
<li><code>Pod</code> 清单可从本地文件目录，给定的 <code>HTTPServer</code> 或 <code>Kube-APIServer</code> 等源头获取；</li>
<li><code>Kubelet</code> 将运行时，网络和存储抽象成了 <code>CRI</code>，<code>CNI</code>，<code>CSI</code></li>
</ul>
</li>
<li>负责汇报当前节点的资源信息和健康状态</li>
<li>负责 <code>Pod</code> 的健康检查和状态汇报</li>
</ul>
<h3 id="Kube-Proxy"><a href="#Kube-Proxy" class="headerlink" title="Kube-Proxy"></a>Kube-Proxy</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240105173356347.png" alt="image-20240105173356347"></p>
<ul>
<li>监控集群中用户发布的服务，并完成负载均衡配置</li>
<li>每个节点的 <code>Kube-Proxy</code> 都会配置相同的负载均衡策略，使得整个集群的服务发现建立在分布式负载均衡器之上，服务调用无需经过额外的网络跳转（<code>Network Hop</code>）</li>
<li>负载均衡配置基于不同插件实现：<ul>
<li><code>userspace</code></li>
<li>操作系统网络协议栈不同的 <code>Hooks</code> 点和插件：<ul>
<li><code>iptables</code></li>
<li><code>ipvs</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="推荐的-Add-ons"><a href="#推荐的-Add-ons" class="headerlink" title="推荐的 Add-ons"></a>推荐的 <code>Add-ons</code></h2><p>一些非核心组件：</p>
<ul>
<li><code>kube-dns</code>：负责为整个集群提供 <code>DNS</code> 服务</li>
<li><code>Ingress Controller</code>：为服务提供外网入口</li>
<li><code>MetricsServer</code>：提供资源监控</li>
<li><code>Dashboard</code>：提供 <code>GUI</code></li>
<li><code>Fluentd-Elasticsearch</code>：提供集群日志采集、存储与查询</li>
</ul>
<h1 id="了解-kubectl"><a href="#了解-kubectl" class="headerlink" title="了解 kubectl"></a>了解 kubectl</h1><h2 id="Kubectl-命令和-kubeconfig"><a href="#Kubectl-命令和-kubeconfig" class="headerlink" title="Kubectl 命令和 kubeconfig"></a>Kubectl 命令和 kubeconfig</h2><ul>
<li><code>kubectl</code> 是一个 <code>Kubernetes</code> 的命令行工具，它允许 <code>Kubernetes</code> 用户以命令行的方式与 <code>Kubernetes</code> 交互，其默认读取配置文件 <code>~/.kube/config</code></li>
<li><code>kubectl</code> 会将接收到的用户请求转化为 <code>REST</code> 调用以 <code>REST client</code> 的形式与 <code>apiserver</code> 通讯</li>
<li><code>apiserver</code> 的地址，用于信息等配置在 <code>kubeconfig</code></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion: v1 clusters:</span></span><br><span class="line"><span class="attr">clusters:</span>  <span class="string">//</span> <span class="string">罗列集群</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span> <span class="string">//</span> <span class="string">一个集群的信息</span></span><br><span class="line">		<span class="attr">certificate-authority-data:</span> <span class="string">REDACTED</span></span><br><span class="line">		<span class="attr">server:</span> <span class="string">https://127.0.0.1:54729</span> </span><br><span class="line">	<span class="attr">name:</span> <span class="string">kind-kind</span>  <span class="string">//</span> <span class="string">名称</span></span><br><span class="line"><span class="attr">contexts:</span> <span class="string">//</span> <span class="string">罗列</span> <span class="string">context</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span> <span class="string">//</span> <span class="string">一个</span> <span class="string">context</span> <span class="string">的信息</span></span><br><span class="line">		<span class="attr">cluster:</span> <span class="string">kind-kind</span> <span class="string">//</span> <span class="string">管理的集群</span></span><br><span class="line">		<span class="attr">user:</span> <span class="string">kind-kind</span>    <span class="string">//</span> <span class="string">用户</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kind-kind</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">kind-kind</span> <span class="string">//</span> <span class="string">当前</span> <span class="string">context</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span> </span><br><span class="line"><span class="attr">users:</span> <span class="string">//</span> <span class="string">用户</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kind-kind</span> <span class="string">//</span> <span class="string">用户名</span></span><br><span class="line">	<span class="attr">user:</span></span><br><span class="line">		<span class="attr">client-certificate-data:</span> <span class="string">REDACTED</span> <span class="string">//</span> <span class="string">这个用户的证书</span></span><br><span class="line">		<span class="attr">client-key-data:</span> <span class="string">REDACTED</span>         <span class="string">//</span> <span class="string">这个用户的key</span></span><br></pre></td></tr></table></figure>

<p>可以通过参数 <code>-v 9</code> 打印操作日志，打印 <code>kubectl</code> 命令背后的逻辑。</p>
<h2 id="kubectl-常用命令"><a href="#kubectl-常用命令" class="headerlink" title="kubectl 常用命令"></a>kubectl 常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po -oyaml // 打印 pod 的详细信息</span><br><span class="line"></span><br><span class="line">kubectl 可查看对象</span><br><span class="line">-oyaml 输出详细信息为 yaml 格式</span><br><span class="line">-owide 以详细列表的格式查看对象</span><br><span class="line">-w watch 对象的后续变化</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe  // 展示资源的详细信息和相关 Event</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240110145417510.png" alt="image-20240110145417510"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec 提供进入运行容器的通道，可以进入容器进行 debug 操作</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240110145439337.png" alt="image-20240110145439337"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kubectl logs 可查看 pod 的标准输入(stdout, stderr)，与 tail 用法类似。</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240110145452235.png" alt="image-20240110145452235"></p>
<h1 id="深入理解-Kubernetes"><a href="#深入理解-Kubernetes" class="headerlink" title="深入理解 Kubernetes"></a>深入理解 Kubernetes</h1><h2 id="Kubernetes-架构"><a href="#Kubernetes-架构" class="headerlink" title="Kubernetes 架构"></a>Kubernetes 架构</h2><h3 id="云计算的传统分类"><a href="#云计算的传统分类" class="headerlink" title="云计算的传统分类"></a>云计算的传统分类</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240110145520928.png" alt="image-20240110145520928"></p>
<ul>
<li>没有云计算的时代，用户需要管理所有的资源和服务，包括硬件资源、操作系统、数据、应用</li>
<li>虚拟化时代，用户不需要管理物理硬件，基于虚拟化提供的操作系统，IaaS （Infrastructure as a Service）基础架构即服务</li>
<li>微服务时代，用户只需要关注应用部署，不需要在意基础架构，PaaS（Platform as a Service）平台即服务</li>
<li>云原生时代，所有应用都由厂商提供，例如 <code>Oracle</code>，用户拥有一个账号，即可使用，SaaS（Software as a Service）软件即服务</li>
</ul>
<h3 id="Kubernetes-生态系统"><a href="#Kubernetes-生态系统" class="headerlink" title="Kubernetes 生态系统"></a>Kubernetes 生态系统</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240110150301860.png" alt="image-20240110150301860"></p>
<h3 id="Kubernetes-设计理念"><a href="#Kubernetes-设计理念" class="headerlink" title="Kubernetes 设计理念"></a>Kubernetes 设计理念</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240110150601992.png" alt="image-20240110150601992"></p>
<p>核心需求：保障高可用。</p>
<h3 id="Kubernetes-Master"><a href="#Kubernetes-Master" class="headerlink" title="Kubernetes Master"></a>Kubernetes Master</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240110150912454.png" alt="image-20240110150912454"></p>
<h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><ul>
<li>核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境，例如 <code>Pod</code></li>
<li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、<code>DNS</code> 解析等）</li>
<li>管理层：系统调度（如基础设施、容器和网络的度量）、自动化（如自动扩展、动态 <code>Provision</code> 等）、策略管理（<code>RBAC</code>、<code>Quota</code>、<code>PSP</code>、<code>NetworkPolicy</code> 等）</li>
<li>接口层：<code>kubectl</code> 命令行工具、客户端 <code>SDK</code> 以及集群联邦</li>
<li>生态系统：在接口层之上的庞大容器集群调度管理调度的生态系统，可以划分为两个范畴：<ul>
<li><code>Kubernetes</code> 外部：日志、监控、配置管理、<code>CI</code>、<code>CD</code>、<code>Workflow</code>、<code>FaaS</code>、<code>OTS</code> 应用、<code>ChatOps</code> 等；</li>
<li><code>Kubernetes</code> 内部：<code>CRI</code>、<code>CNI</code>、<code>CVI</code>、镜像仓库、<code>Cloud Provider</code>、集群自身的配置和管理等</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240110151515695.png" alt="image-20240110151515695"></p>
<p>通过定义不同的 API，由实现 API 的对象来做具体实现。</p>
<p>例如 <code>Contianer Runtime</code> 可以对接 <code>docker</code> 或者 <code>containerd</code>，或者虚拟机。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240110151833188.png" alt="image-20240110151833188"></p>
<p>如果 Kubernetes 提供的 API 不满足需求，还可以通过插件，实现自己的功能。</p>
<h2 id="API-设计原则"><a href="#API-设计原则" class="headerlink" title="API 设计原则"></a>API 设计原则</h2><ul>
<li>所有 API 都是声明式的<ul>
<li>相对于命令式操作，声明式操作对于重复操作的效果是稳定的，这对于容易出现数据丢失或重复的分布式环境来说是很重要的。</li>
<li>声明式操作更容易被用户使用，可以使系统向用户隐藏实现的细节，同时也保留了系统未来持续优化的可能性</li>
<li>此外，声明式的 API 还隐含了所有的 API 对象都是名词性质的，例如 <code>Service</code>、<code>Volume</code> 这些 API 都是名词，这些名词描述了用户所期望得到的一个目标对象。</li>
</ul>
</li>
<li>API 对象是彼此互补而且可组合的<ul>
<li>这实际上孤立 API 对象尽量实现面向对象设计时的要求，即 <strong>高内聚，松耦合</strong> （例如 <code>deployment</code> 和 <code>rs</code>，虽然可以通过 <code>deployment</code> 控制 <code>rs</code>，但是也可以直接控制 <code>rs</code>），对业务相关的概念有一个合适的分解，提高分解出来的对象的可重用性。</li>
</ul>
</li>
<li>高层 API 以操作以图为基础设计<ul>
<li>如何能够设计好 API，跟如何能用面向对象的方法设计好应用系统有相通的地方，高层设计一定是从业务出发，而不是过早的从技术实现出发</li>
<li>因此，针对 Kubernetes 的高层 API 设计，一定是以 Kubernetes 的业务为基础出发，也就是以系统调度管理容器的操作意图为基础设计。</li>
</ul>
</li>
<li>低层 API 根据高层 API 的控制需要设计<ul>
<li>设计实现低层 API 的目的，是为了被高层 API 使用，考虑减少冗余、提供重要性的目的，低层 API 的设计也要以需求为基础，要尽量抵抗受技术实现影响的诱惑</li>
</ul>
</li>
<li>尽量避免简单封装，不要有在外部 API 无法显式知道的内部隐藏的机制<ul>
<li>简单的封装，实际没有提供新的功能，反而增加了对所封装 API 的依赖性</li>
<li>例如 <code>StatefulSet</code> 和 <code>ReplicaSet</code>，本来就是两种 <code>Pod</code> 集合，那么 <code>Kubernetes</code> 就用不同 API 对象来定义他们，而不会只用同一个 <code>ReplicaSet</code>，内部通过特殊的算法再来区分这个 <code>ReplicaSet</code> 是有状态的还是无状态。</li>
</ul>
</li>
<li>API 操作复杂度与对象数量成正比<ul>
<li>API 的操作复杂度不能超过 <code>O(n)</code>，否则系统就不具备水平伸缩性了</li>
</ul>
</li>
<li>API 对象状态不能依赖于网络连接状态<ul>
<li>由于众所周知，在分布式环境下，网络连接断开是经常发生的事情，因此要保证 API 对象状态能应对网络的不稳定，API 对象的状态就不能依赖于网络连接状态。</li>
</ul>
</li>
<li>尽量避免让操作机制依赖于全局状态<ul>
<li>因为在分布式系统中要保证全局状态的同步是非常困难的</li>
</ul>
</li>
</ul>
<h3 id="Kubernetes-通过对象的组合完成业务描述"><a href="#Kubernetes-通过对象的组合完成业务描述" class="headerlink" title="Kubernetes 通过对象的组合完成业务描述"></a>Kubernetes 通过对象的组合完成业务描述</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240110154417029.png" alt="image-20240110154417029"></p>
<p>通过引用依赖、命名规范、标签的形式，将控制器、Pod、Svc、Ingress、Node 组合起来。</p>
<h2 id="架构设计原则"><a href="#架构设计原则" class="headerlink" title="架构设计原则"></a>架构设计原则</h2><ul>
<li>只有 <code>APIServer</code> 可以直接访问 <code>etcd</code> 存储，其他服务必须通过 <code>Kubernetes API</code> 来访问集群状态；</li>
<li>单节点故障不应该影响集群的状态；</li>
<li>在没有新请求的情况下，所有组件应该在故障恢复后继续执行上次最后收到的请求（比如网络分区或服务重启等）；</li>
<li>所有组件都应该在内存中保持所需要的状态，<code>APIServer</code> 将状态写入 <code>etcd</code> 存储，而其他组件则通过 <code>APIServer</code> 更新并监听所有的变化；</li>
<li>优先使用事件监听而不是轮询；（使用长连接，而不是频繁接口调用）</li>
</ul>
<h2 id="引导（Bootstrapping）原则"><a href="#引导（Bootstrapping）原则" class="headerlink" title="引导（Bootstrapping）原则"></a>引导（Bootstrapping）原则</h2><ul>
<li><code>Self-hosting</code> 是目标；（例如 <code>kubelet</code> 由 <code>systemd</code> 托管，其他的服务 <code>etcd</code> 、<code>apiserver</code> 等由 <code>kubelet</code> 管理，通过在 <code>kubelet</code> 监控的目录中新增文件启动对应 <code>pod</code>）</li>
<li>减少依赖，特别是稳态运行的依赖；</li>
<li>通过分层的原则管理依赖；</li>
<li>循环依赖问题的原则：<ul>
<li>同时还接受其他方式的数据输入（比如本地文件等），这样在其他服务不可用时还可以手动配置引导服务；</li>
<li>状态应该是可恢复或可重新发现的；</li>
<li>支持简单的启动临时实例来创建稳态运行所需要的状态，使用分布式锁或文件锁等来协调不同状态的切换（通常称为 <code>pivoting</code> 技术）；</li>
<li>自动重启异常退出的服务，比如副本或者进程管理器等；</li>
</ul>
</li>
</ul>
<h2 id="核心技术概念和-API-对象"><a href="#核心技术概念和-API-对象" class="headerlink" title="核心技术概念和 API 对象"></a>核心技术概念和 API 对象</h2><p>API 对象是 Kubernetes 集群中的管理操作单元。</p>
<p>Kubernetes 集群系统每支持一项新功能，引入一项新技术，一定会新引入对应的 API 对象，支持对该功能的管理操作。</p>
<p>每个 API 对象都有四大类属性：</p>
<ul>
<li><code>TypeMeta</code>：定义这个对象是啥</li>
<li><code>MetaData</code>：定义这个对象的基本属性，例如名称、标签</li>
<li><code>Spec</code>：定义用户对对象的期望值</li>
<li><code>Status</code>：定义对象的状态，由控制器指定</li>
</ul>
<h3 id="TypeMeta"><a href="#TypeMeta" class="headerlink" title="TypeMeta"></a>TypeMeta</h3><p>Kubernetes 对象的最基本定义，它通过引入 <code>GKV</code>（<code>Group</code>，<code>Kind</code>，<code>Version</code>） 模型定义了一个对象的类型。</p>
<ul>
<li><p><code>Group</code></p>
<p>Kubernetes 定义了非常多的对象，如何将这些对象进行归类是一门学问，将对象依据其功能范围归入不同的分组，比如把支撑最基本功能的对象归入 <code>core</code> 组，把与应用部署有关的对象归入 <code>apps</code> 组，会使这些对象的可维护性和可理解性更高。</p>
</li>
<li><p><code>Kind</code></p>
<p>定义一个对象的基本类型，比如 <code>Node</code>、<code>Pod</code>、<code>Deployment</code></p>
</li>
<li><p><code>Version</code></p>
<p>社区每个季度会推出一个 Kubernetes 版本，随着 Kubernetes 版本的演进，对象从创建之初到能够完全生产化就绪的版本是不断变化的。与软件版本类似，通常社区提出一个模型定义以后，随着该对象不断成熟，其版本可能会从 <code>v1alpha1</code> 到 <code>v1alpha2</code>，或者到 <code>v1beta1</code>，最终变成生产就绪版本 <code>v1</code></p>
</li>
</ul>
<h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p><code>Metadata</code> 中有两个最重要的属性：<code>Namespace</code> 和 <code>Name</code>，分别定义了对象的 <code>Namespace</code> 归属及名字，这两个属性唯一定义了某个对象实例。</p>
<ul>
<li><p><code>Label</code></p>
<p>顾名思义就是给对象打标签，一个对象可以有任意对标签，其存在形式是键值对。<code>Label</code> 定义了对象的可识别属性，Kubernetes API 支持以 <code>Label</code> 作为过滤条件查询对象。</p>
</li>
<li><p><code>Annotation</code></p>
<p><code>Annotation</code> 与 <code>Label</code> 一样用键值对来定义，但 <code>Annotation</code> 是作为属性扩展，更多面向于系统管理员和开发人员，因此需要像其他属性一样做合理归类。</p>
</li>
</ul>
<h4 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h4><ul>
<li><code>Label</code> 是识别 Kubernetes 对象的标签，以 <code>key/value</code> 的方式附加到对象上</li>
<li><code>key</code> 最长不能超过 63 字节，<code>value</code> 可以为空，也可以是不超过 253 字节的字符串</li>
<li><code>Label</code> 不提供唯一性，并且实际上经常是很多对象（如 <code>Pods</code>）都使用相同的 <code>label</code> 来标志具体的应用</li>
<li><code>Label</code> 定义好后其他对象可以使用 <code>Label Selector</code> 来选择一组相同 <code>label</code> 的对象</li>
<li><code>Label Selector</code> 支持以下几种方式：<ul>
<li>等式，如 <code>app=nginx</code> 和 <code>evn!=production</code> ;</li>
<li>集合，如 <code>env in (production,qa)</code></li>
<li>多个 <code>label</code>，之间是 <code>AND</code> 关系，如 <code>app=nginx,env=test</code></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/2018-12-09-kubernetes-labels.png" alt="kubernetes-labels"></p>
<h4 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h4><ul>
<li><code>Annotations</code> 是 <code>key/value</code> 形式附加于对象的注解</li>
<li>不同于 <code>Labels</code> 用于标志和选择对象，<code>Annotations</code> 则是用来记录一些附加信息，用来辅助应用部署、安全策略以及调度策略等。</li>
<li>比如 <code>deployment</code> 使用 <code>annotations</code> 来记录 <code>rolling update</code> 的状态</li>
</ul>
<h4 id="Finalizer"><a href="#Finalizer" class="headerlink" title="Finalizer"></a>Finalizer</h4><p><code>Finalizer</code> 本质上是一个资源锁，Kubernetes 在接收某对象的删除请求时，会检查 <code>Finalizer</code> 是否为空，如果不为空则只对其做逻辑删除，即只会更新对象中的 <code>metadata.deletionTimestamp</code> 字段。（也就是将资源锁住，不可删除，一般会用于运维过程或者升级过程）</p>
<h4 id="ResourceVersion"><a href="#ResourceVersion" class="headerlink" title="ResourceVersion"></a>ResourceVersion</h4><p><code>ResourceVersion</code> 可以被看作一种乐观锁，每个对象在任意时刻都有其 <code>ResourceVersion</code>，当 <code>Kubernetes</code> 对象被客户端读取以后，<code>ResourceVersion</code> 信息也被一并读取。此机制确保了分布式系统中任意多线程能够无锁并发访问对象，极大提升了系统的整体效率。</p>
<h3 id="Spec-和-Status"><a href="#Spec-和-Status" class="headerlink" title="Spec 和 Status"></a>Spec 和 Status</h3><ul>
<li><code>Spec</code> 和 <code>Status</code> 才是对象的核心</li>
<li><code>Spec</code> 是用户的期望状态，由创建对象的用户端来定义</li>
<li><code>Status</code> 是对象的实际状态，由对应的控制器收集实际状态并更新</li>
<li>与 <code>TypeMeta</code> 和 <code>Metadata</code> 等通用属性不同，<code>Spec</code> 和 <code>Status</code> 是每个对象独有的</li>
</ul>
<h2 id="常用-Kubernetes-对象及其分组"><a href="#常用-Kubernetes-对象及其分组" class="headerlink" title="常用 Kubernetes 对象及其分组"></a>常用 Kubernetes 对象及其分组</h2><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240110165429135.png" alt="image-20240110165429135"></p>
<h1 id="核心对象概念"><a href="#核心对象概念" class="headerlink" title="核心对象概念"></a>核心对象概念</h1><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><ul>
<li><code>Node</code> 是 <code>Pod</code> 真正运行的主机，可以物理机，也可以是虚拟机</li>
<li>为了管理 <code>Pod</code>，每个 <code>Node</code> 节点上至少要运行 <code>container runtime</code>（比如 <code>Docker</code> 或者 <code>Rkt</code>）、<code>kubelet</code> 和 <code>kube-proxy</code> 服务。</li>
</ul>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p><code>Namespace</code> 是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。</p>
<p>常见的 <code>pods</code>，<code>services</code>，<code>replication controllers</code> 和 <code>deployments</code> 等都是属于某一个 <code>Namespace</code> 的（默认 <code>default</code>），而 <code>Node</code>，<code>persistentVolumes</code> 等则不属于任何 <code>Namespace</code>。</p>
<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><ul>
<li><code>Pod</code> 是一组紧密关联的容器集合，它们共享 <code>PID</code>、<code>IPC</code>、<code>Network</code> 和 <code>UTS namespace</code>，是 <code>Kubernetes</code> 调度的基本单位（一个 <code>Pod</code> 可以放多个容器）；</li>
<li><code>Pod</code> 的设计理念是支持多个容器在一个 <code>Pod</code> 中共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务；</li>
<li>同一个 <code>Pod</code> 中的不同容器可共享资源：<ul>
<li>共享网络 <code>Namespace</code>；</li>
<li>可通过挂载存储卷共享存储；</li>
<li>共享 <code>Security Context</code>；</li>
</ul>
</li>
</ul>
<p>例如 <code>File Puller</code> 容器和 <code>Web Server</code> 容器都在同一个 <code>Pod</code> 中。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240110170853749.png" alt="image-20240110170853749"></p>
<p><code>Pod</code> 的 <code>yaml</code> 定义示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">hello</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">	<span class="attr">containers:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<h3 id="通过-Pod-对象定义支撑应用运行"><a href="#通过-Pod-对象定义支撑应用运行" class="headerlink" title="通过 Pod 对象定义支撑应用运行"></a>通过 Pod 对象定义支撑应用运行</h3><p>将配置传入容器中</p>
<ul>
<li><p>环境变量：</p>
<ul>
<li><p>直接设置值；</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">hello-env</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">	<span class="attr">containers:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">alpine</span> </span><br><span class="line">		<span class="attr">env:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">HELLO</span></span><br><span class="line">			<span class="attr">value:</span> <span class="string">world</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>读取 <code>Pod Spec</code> 的某个属性；</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="attr">env:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAME</span></span><br><span class="line">  	<span class="attr">valueFrom:</span> </span><br><span class="line">  		<span class="attr">fieldRef:</span></span><br><span class="line">  			<span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">  			<span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line"></span><br><span class="line"><span class="string">*</span> <span class="string">从</span> <span class="string">`ConfigMap`</span> <span class="string">读取某个值；</span></span><br><span class="line"></span><br><span class="line">  <span class="string">```yaml</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">VARIABLE1</span></span><br><span class="line">  	<span class="attr">valueFrom:</span> </span><br><span class="line">  		<span class="attr">configMapKeyRef:</span></span><br><span class="line">  			<span class="attr">name:</span> <span class="string">my-env</span> </span><br><span class="line">  			<span class="attr">key:</span> <span class="string">VARIABLE1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从 <code>Secret</code> 读取某个值。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SECRET_USERNAME</span></span><br><span class="line">    	<span class="attr">valueFrom:</span> </span><br><span class="line">    		<span class="attr">secretKeyRef:</span></span><br><span class="line">    			<span class="attr">name:</span> <span class="string">mysecret</span> </span><br><span class="line">    			<span class="attr">key:</span> <span class="string">username</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 存储卷</span></span><br><span class="line"></span><br><span class="line"><span class="string">*</span> <span class="string">通过存储卷可以将外挂存储挂载到</span> <span class="string">`Pod`</span> <span class="string">内部使用</span></span><br><span class="line"><span class="string">*</span> <span class="string">存储卷定义包括两个部分：`Volume`</span> <span class="string">和</span> <span class="string">`VolumeMounts`</span></span><br><span class="line">  <span class="string">*</span> <span class="string">`Volume`：定义</span> <span class="string">`Pod`</span> <span class="string">可以使用的存储卷来源；</span></span><br><span class="line">  <span class="string">*</span> <span class="string">`VolumeMounts`：定义存储卷如何</span> <span class="string">`Mount`</span> <span class="string">到容器内部。</span></span><br><span class="line"></span><br><span class="line"><span class="string">示例：</span></span><br><span class="line"></span><br><span class="line"><span class="string">```yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">hello-volume</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">	<span class="attr">containers:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.15</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">		<span class="attr">volumeMounts:</span> </span><br><span class="line">			<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">				<span class="attr">mountPath:</span> <span class="string">/data</span> </span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">		<span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Pod-网络"><a href="#Pod-网络" class="headerlink" title="Pod 网络"></a>Pod 网络</h3><p><code>Pod</code> 的多个容器是共享网络 <code>Namespace</code> 的，这意味着：</p>
<ul>
<li>同一个 <code>Pod</code> 中的不同容器可以彼此通过 <code>Loopback</code> 地址访问：<ul>
<li>在第一个容器中起了一个服务 <code>http://127.0.0.1</code>；</li>
<li>在第二个容器内，是可以通过 <code>httpGet https://127.0.0.1</code> 访问到该地址的；</li>
</ul>
</li>
<li>这种方法常用于不同容器的相互协作</li>
</ul>
<h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><p>Kubernetes 通过 <code>Cgroups</code> 提供容器资源管理的功能，可以限制每个容器的 <code>CPU</code> 和内存使用，比如对创建的 <code>deployment</code>，可以通过下面的命令限制 <code>nginx</code> 容器最多只用 <code>50%</code> 的 <code>CPU</code> 和 <code>128MB</code> 的内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl set resources deployment nginx-app -c=nginx -- limits=cpu=500m,memory=128Mi</span><br><span class="line">deployment &quot;nginx&quot; resource requirements updated</span><br></pre></td></tr></table></figure>

<p>等同于在每个 <code>Pod</code> 中设置 <code>resources limits</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">labels:</span> </span><br><span class="line">		<span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">	<span class="attr">containers:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">		<span class="attr">resources:</span></span><br><span class="line">			<span class="attr">limits:</span></span><br><span class="line">				<span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span> </span><br><span class="line">				<span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>Kubernetes 作为一个面向应用的集群管理工具，需要确保容器在部署后确实处在正常的运行状态。</p>
<ol>
<li>探针类型：<ol>
<li><code>LivenessProbe</code>：探测应用是否处于健康状态，如果不健康则删除并重新创建容器</li>
<li><code>ReadinessProbe</code>：探测应用是否就绪并且处于正常服务状态，如果不正常则不会接收来自 Kubernetes Service 的流量</li>
<li><code>StartupProbe</code>：探测应用是否启动完成，如果在 <code>failureThreshold * periodSeconds</code> 周期内未就绪，则会将应用进程重启（因此这个探测频次应该比较低）</li>
</ol>
</li>
<li>探活方式：<ol>
<li><code>Exec</code>;</li>
<li><code>TCP socket</code>;</li>
<li><code>HTTP</code></li>
</ol>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">labels:</span> </span><br><span class="line">		<span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">nginx-default</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">	<span class="attr">replicas:</span> <span class="number">3</span> </span><br><span class="line">	<span class="attr">selector:</span></span><br><span class="line">		<span class="attr">matchLabels:</span> </span><br><span class="line">			<span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">	<span class="attr">template:</span> </span><br><span class="line">		<span class="attr">metadata:</span></span><br><span class="line">			<span class="attr">labels:</span> </span><br><span class="line">				<span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">	<span class="attr">spec:</span> </span><br><span class="line">		<span class="attr">containers:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span> </span><br><span class="line">		<span class="attr">imagePullPolicy:</span> <span class="string">Always</span> </span><br><span class="line">		<span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">		<span class="attr">resources:</span> &#123;&#125; </span><br><span class="line">		<span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span> </span><br><span class="line">		<span class="attr">terminationMessagePolicy:</span> <span class="string">File</span> </span><br><span class="line">		<span class="attr">resources:</span></span><br><span class="line">			<span class="attr">limits:</span></span><br><span class="line">				<span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span> </span><br><span class="line">				<span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">		<span class="attr">livenessProbe:</span> </span><br><span class="line">			<span class="attr">httpGet:</span> </span><br><span class="line">				<span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">				<span class="attr">port:</span> <span class="number">80</span> </span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">15</span> </span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line">		<span class="attr">readinessProbe:</span> </span><br><span class="line">			<span class="attr">httpGet:</span></span><br><span class="line">				<span class="attr">path:</span> <span class="string">/ping</span></span><br><span class="line">				<span class="attr">port:</span> <span class="number">80</span> </span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span> </span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h2><ul>
<li><code>ConfigMap</code> 用来将非机密性的数据保存到键值对中；</li>
<li>使用时，<code>Pods</code> 可以将其用作环境变量、命令行参数或者存储卷中的配置文件；</li>
<li><code>ConfigMap</code> 将环境配置信息和容器镜像解耦，便于应用配置的修改。</li>
</ul>
<h2 id="密钥对象（Secret）"><a href="#密钥对象（Secret）" class="headerlink" title="密钥对象（Secret）"></a>密钥对象（Secret）</h2><ul>
<li><code>Secret</code> 是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象；</li>
<li>使用 <code>Secret</code> 的好处是可以避免把敏感信息明文写在配置文件里；</li>
<li>Kubernetes 集群中配置和使用服务不可避免的要用到各种敏感信息实现登录、认证等功能，例如访问 <code>AWS</code> 存储的用户名密码</li>
<li>为了避免将类似的敏感信息明文写在所有需要使用的配置文件中，可以将这些信息存入一个 <code>Secret</code> 对象，儿在配置文件中通过 <code>Secret</code> 对象引用这些敏感信息；</li>
<li>这种方式的好处包括：意图明确、避免重复、减少暴露机会</li>
</ul>
<h2 id="用户（User-Account）-amp-服务账户（Service-Account）"><a href="#用户（User-Account）-amp-服务账户（Service-Account）" class="headerlink" title="用户（User Account）&amp; 服务账户（Service Account）"></a>用户（User Account）&amp; 服务账户（Service Account）</h2><ul>
<li>顾名思义，用户账户为人提供账户标识，而服务账户为计算机进程和 Kubernetes 集群中运行的 <code>Pod</code> 提供账户表示。</li>
<li>用户账户和服务账户的一个区别是作用范围：<ul>
<li>用户账户对应的是人的身份，人的身份与服务的 <code>Namespace</code> 无关，所以用户账户是跨 <code>Namespace</code> 的；</li>
<li>而服务账户对应的是一个运行中程序的身份，于特定 <code>Namespace</code> 是相关的。（例如与 <code>APIServer</code>交互）</li>
</ul>
</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p><code>Service</code> 是应用服务的抽象，通过 <code>labels</code> 为应用提供负载聚合和服务发现。匹配 <code>labels</code> 的 <code>Pod IP</code> 和端口列表组成 <code>endpoints</code>，由 <code>Kube-proxy</code> 负责将服务 IP 负载均衡到这些 <code>endpoints</code> 上。</p>
<p>每个 <code>Service</code> 都会自动分配一个 <code>cluster IP</code> （仅在集群内部可以访问的虚拟地址）和 <code>DNS</code> 名，其他容器可以通过该地址或 <code>DNS</code> 来访问服务，而不需要了解后端容器的运行。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240110173930778.png" alt="image-20240110173930778"></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">	<span class="attr">ports:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8078</span> <span class="comment"># the port that this service should serve on</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">		<span class="comment"># the container on each pod to connect to, can be a name # (e.g. &#x27;www&#x27;) or a number (e.g. 80)</span></span><br><span class="line">		<span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">		<span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">	<span class="attr">selector:</span> </span><br><span class="line">		<span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<h2 id="副本集（Replica-Set）"><a href="#副本集（Replica-Set）" class="headerlink" title="副本集（Replica Set）"></a>副本集（Replica Set）</h2><ul>
<li><code>Pod</code> 知识单个应用实例的抽象，要构建高可用应用，通常需要构建多个同样的副本，提供同一个服务；</li>
<li>Kubernetes 为此抽象出副本集 <code>ReplicaSet</code>，其允许用户定义 <code>Pod</code> 的副本数，每一个 <code>Pod</code> 都会被当作一个无状态的成员进行管理，Kubernetes 保证总是有用户期望的数量的 <code>Pod</code> 正常运行；</li>
<li>当某个副本宕机以后，控制器将会创建一个新的副本；</li>
<li>当因业务负载发生变更儿需要调整扩缩容时，可以方便地调整副本数量</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/2019-02-16-kubernetes-replicaset-spec.png" alt="kubernetes-replicaset-spe"></p>
<h2 id="部署（Deployment）"><a href="#部署（Deployment）" class="headerlink" title="部署（Deployment）"></a>部署（Deployment）</h2><ul>
<li>部署表示用户对 Kubernetes 集群的一次更新操作；</li>
<li>部署是一个比 <code>RS</code> 应用模式更广的 API 对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务；</li>
<li>滚动升级一个服务，实际是创建一个新的 <code>RS</code>，然后逐渐将新 <code>RS</code> 中副本数增加到理想状态，将旧 <code>RS</code> 中的副本数减小到 0 的复合操作；</li>
<li>这样一个符合操作用一个 <code>RS</code> 是不太好描述的，所以应一个更通用的 <code>Deployment</code> 来描述；</li>
<li>以 Kubernetes 的发展方向，未来对所有长期伺服型的业务的管理，都会通过 <code>Deployment</code> 来管理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/2019-02-24-kubernetes-deployment-scale-replicas.png" alt="kubernetes-deployment-scale-replicas"></p>
<p>操作示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl run --image=nginx:alpine nginx-app --port=80 </span><br><span class="line">kubectl get deployment</span><br><span class="line">kubectl describe deployment/rs/pod</span><br><span class="line">kubectl expose deployment nginx-app --port=80 --target-port=80 </span><br><span class="line">kubectl describe svc</span><br><span class="line">kubectl describe ep</span><br></pre></td></tr></table></figure>

<h2 id="有状态服务集（StatefulSet）"><a href="#有状态服务集（StatefulSet）" class="headerlink" title="有状态服务集（StatefulSet）"></a>有状态服务集（StatefulSet）</h2><ul>
<li>对于 <code>StatefulSet</code> 中的 <code>Pod</code>，每个 <code>Pod</code> 挂载自己独立的存储，如果一个 <code>Pod</code> 出现故障，从其他节点启动一个同样名字的 <code>Pod</code>，要挂载上原来 <code>Pod</code> 的存储继续以它的状态提供服务；</li>
<li>适合于 <code>StatefulSet</code> 的业务包括数据库服务 <code>MySQL</code> 和 <code>PostgreSQL</code>，集群化管理服务 <code>ZooKeeper</code>、<code>etcd</code> 等有状态服务；</li>
<li>使用 <code>StatefulSet</code> ，<code>Pod</code> 仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性， <code>StatefulSet</code> 做的知识将确定的 <code>Pod</code> 与确定的存储关联起来保证状态的连续性；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/2019-02-28-kubernetes-statefulset-ordinal.png" alt="kubernetes-statefulset-ordina"></p>
<p>创建和删除都是通过序号来确定顺序。</p>
<h2 id="StatefulSet-与-Deployment-的差异"><a href="#StatefulSet-与-Deployment-的差异" class="headerlink" title="StatefulSet 与 Deployment 的差异"></a>StatefulSet 与 Deployment 的差异</h2><ul>
<li>身份标识<ul>
<li><code>StatefulSet Controller</code> 为每个 <code>Pod</code> 编号，序号从 0 开始</li>
</ul>
</li>
<li>数据存储<ul>
<li><code>StatefulSet</code> 允许用户定义 <code>volumeClaimTemplates</code>，<code>Pod</code> 被创建的同时，Kubernetes 会以 <code>volumeClaimTemplates</code> 中定义的模板创建存储卷，并挂载给 <code>Pod</code>；</li>
</ul>
</li>
<li><code>StatefulSet</code> 的升级策略不同<ul>
<li><code>onDelete</code></li>
<li>滚动升级</li>
<li>分片升级</li>
</ul>
</li>
</ul>
<h2 id="任务（Job）"><a href="#任务（Job）" class="headerlink" title="任务（Job）"></a>任务（Job）</h2><ul>
<li><code>Job</code> 是 <code>Kubernetes</code> 用来控制批处理型任务的 <code>API</code> 对象</li>
<li><code>Job</code> 管理的 <code>Pod</code> 根据用户的设置把任务成功完成后就自动退出</li>
<li>成功完成的标志不同的 <code>spec.completions</code> 策略而不同：<ul>
<li>单 <code>Pod</code> 型任务有一个 <code>Pod</code> 成功就标志完成；</li>
<li>定数成功型任务保证有 N 个任务全部成功；</li>
<li>工作队列型任务根据应用确认的全局成功而标志成功</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/2019-03-05-Job-Topology.png" alt="Job-Topology"></p>
<h2 id="后台支撑服务集（DaemonSet）"><a href="#后台支撑服务集（DaemonSet）" class="headerlink" title="后台支撑服务集（DaemonSet）"></a>后台支撑服务集（DaemonSet）</h2><ul>
<li>长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的 <code>Pod</code>，有些节点上又没有这类 <code>Pod</code> 运行；</li>
<li>而后台支撑型服务的核心关注点在 Kubernetes 集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类 <code>Pod</code> 运行；</li>
<li>节点可能是所有集群节点也可能是通过 <code>nodeSelector</code> 选定的一些特定节点；</li>
<li>典型的后台支撑型服务包括存储、日志和监控等在每个节点上支撑 Kubernetes 集群运行的服务；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/2019-03-01-DaemonSet-Topology.png" alt="DaemonSet-Topology"></p>
<h2 id="存储-PV-和-PVC"><a href="#存储-PV-和-PVC" class="headerlink" title="存储 PV 和 PVC"></a>存储 PV 和 PVC</h2><ul>
<li><code>PersistentVolume</code>（<code>PV</code>）是集群中的一块存储卷，可以由管理员手动设置，或当用户创建 <code>PersistentVolumeClaim</code>（<code>PVC</code>）时，根据 <code>StorageClass</code> 动态设置；</li>
<li><code>PV</code> 和 <code>PVC</code> 与 <code>Pod</code> 生命周期无关。也就是说，当 <code>Pod</code> 中的容器重新启动、<code>Pod</code> 重新调度或者删除时，<code>PV</code> 和 <code>PVC</code> 不会受到影响，<code>Pod</code> 存储于 PV 里的数据得以保留；</li>
<li>对于不同的使用场景，用户通常需要不同属性（例如性能、访问模式等）的 <code>PV</code></li>
</ul>
<h2 id="CustomResourceDefinition"><a href="#CustomResourceDefinition" class="headerlink" title="CustomResourceDefinition"></a>CustomResourceDefinition</h2><ul>
<li><code>CRD</code> 就像数据库的开放式表结构，允许用户自定义 <code>Schema</code>；</li>
<li>有了这种开放式设计，用户可以基于 <code>CRD</code> 定义一切需要的模型，满足不同业务的需求；</li>
<li>社区孤立基于 <code>CRD</code> 的业务抽象，众多主流的扩展应用都是基于 <code>CRD</code> 的构建的，比如 <code>Istio</code>、<code>Knative</code>；</li>
<li>甚至基于 <code>CRD</code> 退出了 <code>Operator Mode</code> 和 <code>Operator SDK</code>，可以以极低的开发成本定义新对象，并构建新对象的控制器。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get customresourcedefinitions.apiextensions.k8s.io</span><br></pre></td></tr></table></figure>

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUva3ViZXJuZXRlcy1qb2ItY3JvbmpvYi8=">详解 Kubernetes Job 和 CronJob 的实现原理<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUva3ViZXJuZXRlcy1yZXBsaWNhc2V0Lw==">详解 Kubernetes ReplicaSet 的实现原理<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUva3ViZXJuZXRlcy1kYWVtb25zZXQv">详解 Kubernetes DaemonSet 的实现原理<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUva3ViZXJuZXRlcy1zdGF0ZWZ1bHNldC8=">详解 Kubernetes StatefulSet 实现原理<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUva3ViZXJuZXRlcy1kZXBsb3ltZW50Lw==">详解 Kubernetes Deployment 的实现原理<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUva3ViZXJuZXRlcy1zZXJ2aWNlLw==">详解 Kubernetes Service 的实现原理<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUva3ViZXJuZXRlcy1wb2Qv">详解 Kubernetes Pod 的实现原理<i class="fa fa-external-link-alt"></i></span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/cdb9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 小夜时雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/cdb9.html" class="post-title-link" itemprop="url">Docker 核心技术</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-29 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-29T00:00:00+08:00">2023-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-04 17:25:27" itemprop="dateModified" datetime="2024-01-04T17:25:27+08:00">2024-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F%E8%AE%AD%E7%BB%83%E8%90%A5/" itemprop="url" rel="index"><span itemprop="name">云原生训练营</span></a>
        </span>
    </span>

  
    <span id="/post/cdb9.html" class="post-meta-item leancloud_visitors" data-flag-title="Docker 核心技术" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><h2 id="传统分层架构-VS-微服务"><a href="#传统分层架构-VS-微服务" class="headerlink" title="传统分层架构 VS 微服务"></a>传统分层架构 VS 微服务</h2><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231229161244176.png" alt="image-20231229161244176"></p>
<p>当业务逻辑简单，需求也比较简单的情况下（例如多年前的it互联网环境），只需要一台或者几台物理服务器即可满足需求，在物理机上部署 UI 服务、业务逻辑服务、存储服务等。</p>
<p>随着业务复杂度和体量增大，架构开始演进到分层架构（分为前端、后端、DBA），将复杂业务拆分成更小颗粒度的、独立的服务（单个部门负责单个服务）。但是多个服务部署到同一台物理服务器上之后，服务之间的隔离性就无法保证，当服务 A 出现异常，可能导致内存占用过多，影响物理机，结果影响其他服务。</p>
<p>服务之间相互隔离，再增加一些高可用、负载均衡的能力，也就逐步演进出微服务架构。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231229162408338.png" alt="image-20231229162408338"></p>
<p>单体架构和微服务架构，在不同的系统上各有优缺点。</p>
<h2 id="微服务改造"><a href="#微服务改造" class="headerlink" title="微服务改造"></a>微服务改造</h2><p>当需要将服务应用（或者一个耦合度高的微服务）改造成一个微服务时，方法和建议：</p>
<ul>
<li>审视并发现可以分离的业务逻辑业务逻辑</li>
<li>寻找天生隔离的代码模块，可以借助于静态代码分析工具</li>
<li>不同并发规模，不同内存需求的模块都可以分离出不同的微服务，此方法可提高资源利用率，节省成本</li>
</ul>
<p>一些常用的可微服务化的组件：</p>
<ul>
<li>用户和账户管理</li>
<li>授权和会话管理</li>
<li>系统配置</li>
<li>通知和通讯服务</li>
<li>照片，多媒体，元数据等</li>
</ul>
<p>分解原则：基于 size（规模）、scope（范围） and capabilities（能力）</p>
<h2 id="微服务间通讯"><a href="#微服务间通讯" class="headerlink" title="微服务间通讯"></a>微服务间通讯</h2><h3 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231229163517004.png" alt="image-20231229163517004"></p>
<ul>
<li>多用于系统内部多组件之间通讯</li>
<li>有大量的重复模块如认证授权</li>
<li>缺少统一规范，如监控，审计等功能</li>
<li>后期维护成本高，服务和服务的依赖关系错综复杂难以管理</li>
</ul>
<h3 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231229163628714.png" alt="image-20231229163628714"></p>
<ul>
<li>基于一个轻量级的 <code>message gateway</code></li>
<li>新 API 通过注册至 <code>Gateway</code> 实现</li>
<li>整合实现 <code>Common function</code></li>
</ul>
<p>一些内部功能和整合进 API 网关，例如认证、授权、统计。</p>
<h1 id="理解-Docker"><a href="#理解-Docker" class="headerlink" title="理解 Docker"></a>理解 Docker</h1><ul>
<li>基于 <code>Linux</code> 内核的 <code>Cgroup</code>（资源管控，用于限制、控制和隔离进程组的系统资源使用），<code>Namespace</code>（隔离进程，隔离网络栈，隔离文件系统挂载点，隔离进程间通信，隔离主机名和域名，隔离用户和用户组标识符），以及 <code>Union FS</code> 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其他的隔离的进程，因此也称其为容器。</li>
<li>最初实现是基于 <code>LXC</code>，从 0.7 以后开始去除 <code>LXC</code>，转而使用自行开发的 <code>Libcontainer</code>，从 1.11 开始，则进一步演进为使用 <code>runC</code> 和 <code>Containerd</code>。</li>
<li><code>Docker</code> 在容器的基础上，进行了进一步的封装，从文件系统、网络互连到进程隔离等等，极大的简化了容器的创建和维护，使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</li>
</ul>
<p>使用 Docker 的理由：</p>
<ul>
<li>更高效地利用系统资源：不需要额外内存使用内核</li>
<li>更快速的启动时间：不需要启动过程中的硬件自检、加载内核等</li>
<li>一致的运行环境：容器提供运行环境</li>
<li>持续交付和部署：更新镜像即可</li>
<li>更轻松地迁移：迁移镜像即可</li>
<li>更轻松地维护和扩展</li>
</ul>
<p>等。</p>
<h2 id="虚拟机和容器运行态的对比"><a href="#虚拟机和容器运行态的对比" class="headerlink" title="虚拟机和容器运行态的对比"></a>虚拟机和容器运行态的对比</h2><p>虚拟机</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231229164755530.png" alt="image-20231229164755530"></p>
<p>在操作系统上，通过 <code>Hypervisor</code> 提供虚拟化能力，各个应用启动对应操作系统，应用在独立的操作系统中运行。</p>
<p>这个调用链比较长，而且有两层操作系统。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231229173153401.png" alt="image-20231229173153401"></p>
<p>在 Docker Engine 上，启动应用。</p>
<p>相比而言，调用链短，而且不需要启动额外的操作系统，节省资源。</p>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231229173351025.png" alt="image-20231229173351025"></p>
<p>一些虚拟机也在做 <code>miniOS</code>，通过瘦身解决启动慢和资源问题，但是依然需要加载额外的操作系统。</p>
<h2 id="Docker-操作"><a href="#Docker-操作" class="headerlink" title="Docker 操作"></a>Docker 操作</h2><p>官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lLw==">https://docs.docker.com/engine/<i class="fa fa-external-link-alt"></i></span></p>
<p>一些常用操作：</p>
<ul>
<li><p>启动</p>
<ul>
<li><p><code>docker run</code> </p>
<p><code>-it</code> 交互<br><code>-d</code> 后台运行<br><code>-p</code> 端口映射<br><code>-v</code> 磁盘挂载</p>
</li>
</ul>
</li>
<li><p>启动已终止容器 </p>
<p><code>docker start</code></p>
</li>
<li><p>停止容器 </p>
<p><code>docker stop</code></p>
</li>
<li><p>查看容器进程 </p>
<p><code>docker ps</code></p>
</li>
<li><p>查看容器细节:<br> <code>docker inspect &lt;containerid&gt;</code></p>
</li>
<li><p>进入容器;<br> <code>Docker attach</code></p>
<ul>
<li><p>通过 <code>nsenter</code></p>
<p><code>PID=$(docker inspect --format &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; &lt;container&gt;)</code></p>
<p><code>$ nsenter --target $PID --mount --uts --ipc --net --pid </code></p>
</li>
</ul>
</li>
<li><p>拷贝文件至容器内:</p>
<p><code>docker cp file1 &lt;containerid&gt;:/file-to-path</code></p>
</li>
</ul>
<h2 id="初识容器"><a href="#初识容器" class="headerlink" title="初识容器"></a>初识容器</h2><ul>
<li><p>创建镜像：<code>cat Dockerfile</code></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENV</span> MY_SERVICE_PORT=<span class="number">80</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> bin/amd64/httpserver /httpserver ENTRYPOINT /httpserver</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将 <code>Dockerfile</code> 打包成镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t xxx/httpserver:$&#123;tag&#125; . </span><br><span class="line">docker push xxx/httpserver:v1.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行容器</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d xxx/httpserver:v1.0</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="容器标准"><a href="#容器标准" class="headerlink" title="容器标准"></a>容器标准</h2><p>在 <code>Docker</code> 发展过程中，由于一些历史性原因，由谷歌牵头定义的一些规范。</p>
<ul>
<li><code>Open Container Initiative</code>（<code>OCI</code>）<ul>
<li>轻量级开放式管理组织（项目）</li>
</ul>
</li>
<li><code>OCI</code> 主要定义两个规范<ul>
<li><code>Runtime Specification</code><ul>
<li>文件系统包如何解压至硬盘，共运行时运行</li>
</ul>
</li>
<li><code>Image Specification</code><ul>
<li>如何通过构建系统打包，生成镜像清单（<code>Manifest</code>）、文件系统序列化文件、镜像配置。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>直白来说，就是镜像如何打包，打包的镜像如何解压如何运行。目的是保障打包、部署过程中的效率。</p>
<h2 id="容器主要特性"><a href="#容器主要特性" class="headerlink" title="容器主要特性"></a>容器主要特性</h2><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2023/12/image-20231229175218442.png" alt="image-20231229175218442" style="zoom:50%;" />

<p>隔离性：通过 <code>namespace</code> 实现</p>
<p>可配额：通过 <code>cgroup</code> 实现</p>
<p>便携性： 通过容器镜像</p>
<p>安全性：通过隔离和配额实现</p>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Linux Namespace 是一种 Linux Kernel 提供的资源隔离方案：</p>
<ul>
<li>系统可以为进程分配不同的 <code>Namespace</code>；</li>
<li>并保证不同的 <code>Namespace</code> 资源独立分配、进程彼此隔离，即不同的 <code>Namespace</code> 下的进程互不干扰。</li>
</ul>
<h3 id="Linux-内核代码中-Namespace-的实现"><a href="#Linux-内核代码中-Namespace-的实现" class="headerlink" title="Linux 内核代码中 Namespace 的实现"></a>Linux 内核代码中 Namespace 的实现</h3><ul>
<li><p>进程数据结构</p>
<p>在<code>Linux</code>内核中提供了多个<code>namespace</code>，其中包括<code>fs (mount)</code>, <code>uts</code>, <code>network</code>, <code>sysvipc</code>, 等。</p>
<p>一个进程可以属于多个<code>namesapce</code>，既然<code>namespace</code>和进程相关，那么在<code>task_struct</code>结构体中就会包含和<code>namespace</code>相关联的变量。</p>
<p>在<code>task_struct</code> 结构中有一个指向<code>namespace</code>结构体的指针<code>nsproxy</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">……..</span><br><span class="line">				<span class="comment">/* namespaces */</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">nsproxy</span>;</span></span><br><span class="line">…….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Namespace</code> 数据结构</p>
<p>再看一下<code>nsproxy</code>是如何定义的，在<code>include/linux/nsproxy.h</code>文件中，这里一共定义了6个各自的命名空间结构体，在该结构体中定义了5个指向各个类型<code>namespace</code>的指针，由于多个进程可以使用同一个<code>namespace</code>，所以<code>nsproxy</code>可以共享使用，<code>count</code>字段是该结构的引用计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A structure to contain pointers to all per-process</span></span><br><span class="line"><span class="comment"> * namespaces - fs (mount), uts, network, sysvipc, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The pid namespace is an exception -- it&#x27;s accessed using</span></span><br><span class="line"><span class="comment"> * task_active_pid_ns.  The pid namespace here is the</span></span><br><span class="line"><span class="comment"> * namespace that children will use.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;count&#x27; is the number of tasks holding a reference.</span></span><br><span class="line"><span class="comment"> * The count for each namespace, then, will be the number</span></span><br><span class="line"><span class="comment"> * of nsproxies pointing to it, not the number of tasks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The nsproxy is shared by tasks which share all namespaces.</span></span><br><span class="line"><span class="comment"> * As soon as a single namespace is cloned or unshared, the</span></span><br><span class="line"><span class="comment"> * nsproxy is copied.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns_for_children</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span>          *<span class="title">net_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_namespace</span> *<span class="title">cgroup_ns</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Linux-对-Namespace-操作方法"><a href="#Linux-对-Namespace-操作方法" class="headerlink" title="Linux 对 Namespace 操作方法"></a>Linux 对 Namespace 操作方法</h3><p>当 Linux 启动时，会通过<code>init</code> 启动 <code>pid</code> 为 1 的进程，并且分配给进程默认的 <code>Namespace</code>。</p>
<p>当要启动其他进程时，可以通过以下几种方法：</p>
<ul>
<li><p><code>clone</code></p>
<p>在创建新进程的系统调用时，可以通过 <code>flags</code> 参数指定需要新建的 <code>Namespace</code> 类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CLONE_NEWCGROUP / CLONE_NEWIPC / CLONE_NEWNET / CLONE_NEWNS </span></span><br><span class="line"><span class="comment">// CLONE_NEWPID / CLONE_NEWUSER / CLONE_NEWUTS  </span></span><br><span class="line"><span class="comment">// 通过 flags 来指定新的 NS</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *arg)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>setns</code></p>
<p>该系统调用可以让调用进程加入某个已经存在的 <code>Namespace</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int <span class="title function_">setns</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> nstype)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>unshare</code></p>
<p>该系统调用可以将调用进程移动到新的 <code>Namespace</code> 下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">unshare</span><span class="params">(<span class="type">int</span> flags)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>Linux</code> 更新后，可能还会新增更多的操作方式。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240102105557872.png" alt="image-20240102105557872"></p>
<p>在 <code>fork</code> 不同的进程后，进程之间可以通过 <code>Namespace</code> 隔离。</p>
<p>例如 <code>PID</code>，在不同的 <code>Namespace</code> 中看到的 <code>PID</code> 是不同的，但是它们是继承关系；网络也不一样，在不同的 <code>Namespace</code> 中，网卡配置没有任何关联。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240102105609178.png" alt="image-20240102105609178"></p>
<p>一个用户进程，拥有不同类型的 <code>namespace</code>。</p>
<h4 id="Pid-namespace"><a href="#Pid-namespace" class="headerlink" title="Pid namespace"></a>Pid namespace</h4><ul>
<li>不同用户的进程就是通过 <code>Pid namespace</code> 隔离开的，且不同 <code>namespace</code> 中可以有相同 <code>Pid</code>。</li>
<li>有了 <code>Pid namespace</code>，每个 <code>namespace</code> 中的 <code>Pid</code> 能够相互隔离。</li>
</ul>
<p>例如在不同的 <code>Namespace</code> 中使用 <code>ps</code> 只获取到本 <code>Namespace</code> 中的进程，方便管理。</p>
<h4 id="net-namespace"><a href="#net-namespace" class="headerlink" title="net namespace"></a>net namespace</h4><ul>
<li>网络隔离是通过 <code>net namespace</code> 实现的，每个 <code>net namespace</code> 有独立的 <code>network devices</code>，<code>IP addresses</code>，<code>IP routing tables</code>，<code>proc/net</code> 目录</li>
<li><code>Docker</code> 默认采用 <code>veth</code> 的方式将 <code>container</code> 中的虚拟网卡同 <code>host</code> 上的一个 <code>docker bridge: docker0</code> 连接在一起</li>
</ul>
<p>不同的 <code>namespace</code> 有不同的网络配置、路由表</p>
<h4 id="ipc-namespace"><a href="#ipc-namespace" class="headerlink" title="ipc namespace"></a>ipc namespace</h4><ul>
<li><code>Container</code> 中进程交互采用 <code>Linux</code> 常见的进程间交互方法（<code>interprocess communication</code> - <code>IPC</code>），包括常见的信号量、消息队列和共享内存</li>
<li><code>Container</code> 的进程间交互实际上还是 <code>hosst</code> 上具有相同 <code>Pid namespace</code> 中的进程间交互，因此需要在 <code>IPC</code> 资源申请时加入 <code>namespace</code> 信息 - 每个 <code>IPC</code> 资源有一个唯一的 32 位 ID。</li>
</ul>
<h4 id="mnt-namespace"><a href="#mnt-namespace" class="headerlink" title="mnt namespace"></a>mnt namespace</h4><ul>
<li><code>mnt namespace</code> 允许不同 <code>namespace</code> 的进程看到的文件结构不同，这样每个 <code>namepace</code> 中的进程所看到的文件目录就被隔离开了。</li>
</ul>
<h4 id="uts-namespace"><a href="#uts-namespace" class="headerlink" title="uts namespace"></a>uts namespace</h4><ul>
<li><code>UTS</code>（<code>UNIX Time-sharing System</code>）<code>namespace</code> 允许每个 <code>container</code> 拥有独立的 <code>hostname</code> 和 <code>domain name</code>，使其在网络上可以被视作一个独立的节点，而非 <code>Host</code> 上的一个进程。</li>
</ul>
<h4 id="user-namespace"><a href="#user-namespace" class="headerlink" title="user namespace"></a>user namespace</h4><ul>
<li>每个 <code>container</code> 可以有不同的 <code>user</code> 和 <code>group id</code>，也就是说可以在 <code>container</code> 内部用 <code>container</code> 内部的用户执行程序而非 <code>Host</code> 上的用户。</li>
</ul>
<h3 id="namespace-常用操作"><a href="#namespace-常用操作" class="headerlink" title="namespace 常用操作"></a>namespace 常用操作</h3><ul>
<li><p>查看当前系统的 <code>namespace</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsns -t &lt;type&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lsns</span></span><br><span class="line">        NS TYPE  NPROCS     PID USER      COMMAND</span><br><span class="line">4026531836 pid      826       1 root      /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">4026531837 user    4343       1 root      /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">4026531838 uts      829       1 root      /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">4026531839 ipc      824       1 root      /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">4026531840 mnt      819       1 root      /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">4026531860 mnt        1     293 root      kdevtmpfs</span><br><span class="line">4026531992 net      835       1 root      /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">4026532751 mnt        1    1520 chrony    /usr/sbin/chronyd</span><br><span class="line">4026532752 mnt        1    1526 root      /usr/sbin/NetworkManager --no-daemon</span><br><span class="line">4026532753 mnt        1   11183 root      /pause</span><br></pre></td></tr></table></figure>

<p>可以看到不同的<code>PID</code>下有不同的类型的<code>namespace</code>。</p>
</li>
<li><p>查看某进程的 <code>namespace</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -la /proc/&lt;PID&gt;/ns/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -la /proc/1/ns/</span></span><br><span class="line">total 0</span><br><span class="line">dr-x--x--x 2 root root 0 Jan  2 00:01 .</span><br><span class="line">dr-xr-xr-x 9 root root 0 Nov 26 20:09 ..</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  2 11:17 cgroup -&gt; cgroup:[4026531835]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  2 11:13 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  2 11:13 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  2 11:13 net -&gt; net:[4026531992]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  2 00:01 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  2 11:17 pid_for_children -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  2 11:17 time -&gt; time:[4026531834]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  2 11:17 time_for_children -&gt; time:[4026531834]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  2 11:13 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan  2 11:13 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入某 <code>namespace</code> 运行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nsenter -t &lt;pid&gt; -n ip addr</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nsenter -t 4176346 -n ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: eth0@if931: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether d6:6b:62:44:63:bb brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.0.0.32/24 brd 10.0.0.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>例如 docker 中没有需要的命令，可以通过获取这个 <code>docker</code> 的进程，然后使用 <code>nsenter</code> 命令，进入到对应 <code>namespace</code> 中操作。</p>
</li>
</ul>
<p>例如创建一个 <code>namespace</code>，并且执行一些操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 在新 network namespace 执行 sleep 指令：</span><br><span class="line"># unshare -fn sleep 60</span><br><span class="line"></span><br><span class="line">// 查看进程信息</span><br><span class="line"># ps -ef | grep &quot;sleep 60&quot;</span><br><span class="line">root     1327579 1146983  0 11:52 pts/3    00:00:00 unshare -fn sleep 60</span><br><span class="line">root     1327580 1327579  0 11:52 pts/3    00:00:00 sleep 60</span><br><span class="line">root     1332215 1329013  0 11:53 pts/4    00:00:00 grep --color=auto sleep 60</span><br><span class="line"></span><br><span class="line">// 查看网络 namespace</span><br><span class="line"># lsns -t net | grep unshare</span><br><span class="line">4026543244 net       2 1327579 root  unshare -fn sleep 60</span><br><span class="line"></span><br><span class="line">// 进入该进程所在 namespace 查看网络配置</span><br><span class="line"># nsenter -t 1332760 -n ip a</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure>

<h2 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h2><ul>
<li><code>Cgroups</code> （<code>Control Groups</code>） 是 Linux 下用于对一个或一组进程进行资源控制和监控的机制；</li>
<li>可以对诸如 CPU 使用时间、内存、磁盘 <code>I/O</code> 等进程所需的资源进行限制；</li>
<li>不同资源的具体管理工作由相应的 <code>Cgroup</code> 子系统（<code>Subsystem</code>）来实现；</li>
<li>针对不同类型的资源限制，只要将限制策略在不同的子系统上进行关联即可；</li>
<li><code>Cgroup</code> 在不同的系统资源管理子系统中以层级树（<code>Hierarchy</code>）的方式来组织管理：每个 <code>Cgroup</code> 都可以包含其他的子 <code>Cgroup</code>，因此子 <code>Cgroup</code> 能使用的资源除了受本 <code>Cgroup</code> 配置的资源参数限制，还受到父 <code>Cgroup</code> 设置的资源限制。</li>
</ul>
<p><code>cgroup</code> 管理，例如删除 <code>cgroup</code> 需要安装包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum install libcgroup-tools // centos</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt install cgroup-tools 		// ubuntu</span></span><br></pre></td></tr></table></figure>

<h3 id="Linux-内核代码中-Cgroup-的实现"><a href="#Linux-内核代码中-Cgroup-的实现" class="headerlink" title="Linux 内核代码中 Cgroup 的实现"></a>Linux 内核代码中 Cgroup 的实现</h3><ul>
<li><p>进程数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUPS </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">css_set_rcu</span> *<span class="title">cgroups</span>;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_list</span>;</span> </span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>css_set</code> 是 <code>cgroup_subsys_state</code> 对象的集合数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> &#123;</span> </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set of subsystem states, one for each subsystem. This array is * immutable after creation apart from the init_css_set during</span></span><br><span class="line"><span class="comment">	 * subsystem registration (at boot time).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">subsys</span>[<span class="title">CGROUP_SUBSYS_COUNT</span>];</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="可配额-x2F-可度量-Control-Groups-cgroups"><a href="#可配额-x2F-可度量-Control-Groups-cgroups" class="headerlink" title="可配额&#x2F;可度量 - Control Groups(cgroups)"></a>可配额&#x2F;可度量 - Control Groups(cgroups)</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240102154000956.png" alt="image-20240102154000956"></p>
</li>
</ul>
<p><code>cgroups</code> 实现了对资源的配额和度量</p>
<ul>
<li><code>blkio</code>：这个子系统设置限制了每个块设备的输入输出控制。例如：磁盘，光盘以及 <code>USB</code> 等等。</li>
<li><code>CPU</code>：这个子系统使用调度程序为 <code>cgroup</code> 任务提供 <code>CPU</code> 的访问。（例如在 <code>Concurrency</code> 过程中，多个进程同时抢占一个 <code>CPU</code>，实际上是将 <code>CPU</code> 分为多个时间片，分配给不同的进程执行。）</li>
<li><code>cpuacct</code>：产生 <code>cgroup</code> 任务的 <code>CPU</code> 资源报告</li>
<li><code>cpuset</code>：如果是多核心的 <code>CPU</code>，这个子系统会为 <code>cgroup</code> 任务分配单独的 <code>CPU</code> 和内存。</li>
<li><code>devices</code>：允许或拒绝 <code>cgroup</code> 任务对设备的访问。</li>
<li><code>freezer</code>：暂停和恢复 <code>cgroup</code> 任务。</li>
<li><code>memory</code>：设置每个 <code>cgroup</code> 的内存限制以及产生内存资源报告。</li>
<li><code>net_cls</code>：标记每个网络包以供 <code>cgroup</code> 方便使用。</li>
<li><code>ns</code>：名称空间子系统。</li>
<li><code>pid</code>：进程标识子系统。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/sys/fs/cgroup</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -ltrah</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  7 root root   0 Nov 26 20:09 ..</span><br><span class="line">dr-xr-xr-x  6 root root   0 Nov 26 20:09 systemd</span><br><span class="line">dr-xr-xr-x  6 root root   0 Nov 26 20:09 pids</span><br><span class="line">lrwxrwxrwx  1 root root  16 Nov 26 20:09 net_prio -&gt; net_cls,net_prio</span><br><span class="line">dr-xr-xr-x  4 root root   0 Nov 26 20:09 net_cls,net_prio</span><br><span class="line">lrwxrwxrwx  1 root root  16 Nov 26 20:09 net_cls -&gt; net_cls,net_prio</span><br><span class="line">dr-xr-xr-x  6 root root   0 Nov 26 20:09 blkio</span><br><span class="line">dr-xr-xr-x  2 root root   0 Nov 26 20:09 rdma</span><br><span class="line">dr-xr-xr-x  2 root root   0 Nov 26 20:09 misc</span><br><span class="line">dr-xr-xr-x  6 root root   0 Nov 26 20:09 memory</span><br><span class="line">dr-xr-xr-x  6 root root   0 Nov 26 20:09 cpu,cpuacct</span><br><span class="line">lrwxrwxrwx  1 root root  11 Nov 26 20:09 cpuacct -&gt; cpu,cpuacct</span><br><span class="line">lrwxrwxrwx  1 root root  11 Nov 26 20:09 cpu -&gt; cpu,cpuacct</span><br><span class="line">dr-xr-xr-x  4 root root   0 Nov 26 20:09 perf_event</span><br><span class="line">dr-xr-xr-x  4 root root   0 Nov 26 20:09 hugetlb</span><br><span class="line">dr-xr-xr-x  4 root root   0 Nov 26 20:09 freezer</span><br><span class="line">dr-xr-xr-x  6 root root   0 Nov 26 20:09 devices</span><br><span class="line">dr-xr-xr-x  4 root root   0 Nov 26 20:09 cpuset</span><br><span class="line">drwxr-xr-x 15 root root 380 Nov 26 20:09 .</span><br></pre></td></tr></table></figure>

<p>在 <code>/sys/fs/cgroup/cpu</code> 目录下创建子目录即可创建一个管理 <code>CPU</code> 的 <code>cgroup</code>，<code>echo &lt;pid&gt; &gt; cgroup.procs</code> 即可将进程添加到 <code>cgropu</code> 进程配置组。</p>
<h3 id="CPU-子系统"><a href="#CPU-子系统" class="headerlink" title="CPU 子系统"></a>CPU 子系统</h3><p><code>CPU</code> 分配给进程的时间片有两种方式，一种是相对值，一种是绝对值。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240102154933393.png" alt="image-20240102154933393"></p>
<p><code>cpu.shares</code>：可让出的能获得 <code>CPU</code> 使用时间的相对值。（例如上图，<code>CGroupA</code> 的 <code>shares</code> 为 <code>512</code>，实际占用 <code>CPU</code> <code>33%</code> 的时间，如果修改成 <code>1024</code>，则占用 <code>50%</code> 的时间）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /sys/fs/cgroup/cpu/cpu.shares</span></span><br><span class="line">1024</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240102155230255.png" alt="image-20240102155230255"></p>
<p><code>cpu.cfs_period_us</code>：<code>fs_period_us</code> 用来配置时间周期长度，单位为 <code>us</code>（微秒）。（默认 <code>100000</code>）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /sys/fs/cgroup/cpu/cpu.cfs_period_us</span></span><br><span class="line">100000</span><br></pre></td></tr></table></figure>

<p><code>cpu.cfs_quota_us</code>：<code>fs_quota_us</code> 用来配置当前 <code>Cgroup</code> 在 <code>cfs_period_us</code> 时间内最多能使用的 <code>CPU</code> 时间数，单位为 <code>us</code> （微秒）。（如果配置 <code>100000</code>，代表可以拿到 1个 <code>CPU</code>）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /sys/fs/cgroup/cpu/cpu.cfs_quota_us</span></span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<p><code>cpu.stat</code>：<code>Cgroup</code> 内的进程使用的 <code>CPU</code> 时间统计。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /sys/fs/cgroup/cpu/cpu.stat</span></span><br><span class="line">nr_periods 0</span><br><span class="line">nr_throttled 0</span><br><span class="line">throttled_time 0</span><br></pre></td></tr></table></figure>

<p><code>nr_periods</code>：经过 <code>cpu.cfs_period_us</code> 的时间周期数量。</p>
<p><code>nr_throttled</code>：在经过的周期内，有多少次因为进程在指定的时间周期内用光了配额时间而受到限制。</p>
<p><code>throttled_time</code>：<code>Cgroup</code> 中的进程被限制使用 <code>CPU</code> 的总用时，单位是 <code>ns</code>（纳秒）。</p>
<p>在 <code>/sys/fs/cgroup/cpu</code> 创建对应目录，即可创建对应名称的 <code>Cgroup</code>，将需要管理的 <code>PID</code> 写入到目录下的 <code>cgroup.procs</code> 目录下即可管理对应进程。</p>
<p>通过 <code>echo 10000 &gt; cpu.cfs_quota_us</code> ，即可让对应进程的 CPU 消耗卡在 <code>10%</code> 以内。</p>
<h4 id="Linux-调度器"><a href="#Linux-调度器" class="headerlink" title="Linux 调度器"></a>Linux 调度器</h4><p>内核默认提供了 5 个调度器，Linux 内核使用 <code>struct sched_class</code> 来对调度器进行抽象：</p>
<ul>
<li><code>Stop</code> 调度器，<code>stop_sched_class</code>：优先级最高的调度类，可以抢占其他所有进程，不能被其他进程抢占；</li>
<li><code>Deadline</code> 调度器，<code>dl_sched_class</code>：使用红黑树，把进程按照绝对截止期限进行排序，选择最小进程进行调度运行；</li>
<li><code>RT</code> 调度器，<code>rt_sched_class</code>：实时调度器，为每个优先级维护一个队列；（公平调度）</li>
<li><code>CFS</code> 调度器，<code>cfs_sched_class</code>：完全公平调度器，采用完全公平调度算法，引入虚拟运行时间概念；</li>
<li><code>IDLE-Task</code> 调度器，<code>idle_sched_class</code>：空闲调度器，每个 <code>CPU</code> 都会有一个 <code>idle</code> 线程，当没有其他进程可以调度时，调度运行 <code>idle</code> 线程。</li>
</ul>
<h4 id="CFS-调度器"><a href="#CFS-调度器" class="headerlink" title="CFS 调度器"></a>CFS 调度器</h4><ul>
<li><code>CFS</code> 是 <code>Completely Fair Scheduler</code> 简称，即完全公平调度器。</li>
<li><code>CFS</code> 实现的主要思想是维护为任务提供处理器时间方面的平衡，这意味着应给进程分配相当数量的处理器。</li>
<li>分给某个任务的时间失去平衡时，应给失去平衡的任务分配时间，让其执行。</li>
<li><code>CFS</code> 通过虚拟运行时间 （<code>vruntime</code>） 来实现平衡，维护提供给某个任务的时间量。<ul>
<li><code>vruntime</code> &#x3D; 实际运行时间 * 1024 &#x2F; 进程权重</li>
</ul>
</li>
<li>进程按照各自不同的速率在物理时钟节拍内前进，优先级高则权重大，其虚拟时钟比真实时钟跑得慢，但获得比较多的运行时间。</li>
</ul>
<h4 id="vruntime-红黑树"><a href="#vruntime-红黑树" class="headerlink" title="vruntime 红黑树"></a><code>vruntime</code> 红黑树</h4><p><code>CFS</code> 调度器没有将进程维护在运行队列中，而是维护了一个以虚拟运行时间为顺序的红黑树。</p>
<p>红黑树的主要特点：</p>
<ol>
<li>自平衡，树上没有一条路径会比其他路径长出两倍。</li>
<li><code>O(logn)</code> 时间复杂度，能够在树上进行快速高效地插入或删除进程。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240102161120245.png" alt="image-20240102161120245"></p>
<h4 id="CFS-进程调度"><a href="#CFS-进程调度" class="headerlink" title="CFS 进程调度"></a>CFS 进程调度</h4><ul>
<li>在时钟周期开始时，调度器调用 <code>_schdule()</code> 函数来开始调度的运行。</li>
<li><code>_schdule()</code> 函数调用 <code>pick_next_task()</code> 让进程调度器从就绪队列中选择一个最合适的进程 <code>next</code>，即红黑树最左边的节点。</li>
<li>通过 <code>context_switch()</code> 切换到新的地址空间，从而保证 <code>next</code> 进程运行。</li>
<li>在时钟周期结束时，调度器调用 <code>entity_tick()</code> 函数来更新进程负载、进程状态以及 <code>vruntime</code>（当前 <code>vruntime</code> + 该时钟周期内运行的时间）。</li>
<li>最后，将该进程的虚拟时间与就绪队列红黑树中最左边的调度实体的虚拟时间做比较，如果小于左边的时间，则不用触发调度，继续调度当前调度实体。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240102162500743.png" alt="image-20240102162500743"></p>
<h3 id="cpuacct-子系统"><a href="#cpuacct-子系统" class="headerlink" title="cpuacct 子系统"></a>cpuacct 子系统</h3><p>用于统计 <code>Cgroup</code> 及其子 <code>Cgroup</code> 下进程的 <code>CPU</code> 的使用情况。</p>
<ul>
<li><p><code>cpuacct.usage</code></p>
<p>包含该 <code>Cgroup</code> 及其子 <code>Cgroup</code> 下进程使用 <code>CPU</code> 的时间，单位是 <code>ns</code>（纳秒）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /sys/fs/cgroup/cpu/cpuacct.usage</span></span><br><span class="line">7873567244444726</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cpuacct.stat</code></p>
<p>包含该 <code>Cgroup</code> 及其子 <code>Cgroup</code> 下进程使用的 <code>CPU</code> 时间，以及用户态和内核态的时间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /sys/fs/cgroup/cpu/cpuacct.stat</span></span><br><span class="line">user 576051691</span><br><span class="line">system 210990765</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Memory-内存子系统"><a href="#Memory-内存子系统" class="headerlink" title="Memory 内存子系统"></a>Memory 内存子系统</h3><p>负责管理 <code>cgroup</code> 中的内存限制。在 <code>/sys/fs/cgroup/memory</code> 目录下创建一个子目录即可创建对应可管理内存的 <code>cgropu</code>，<code>echo &lt;pid&gt; &gt; cgroup.procs</code> 即可将进程添加到 <code>cgropu</code> 进程配置组。</p>
<ul>
<li><p><code>memory.usage_in_bytes</code></p>
<p><code>cgroup</code> 下进程使用的内存，包含 <code>cgroup</code> 及其子 <code>cgroup</code> 下的进程使用的内存</p>
</li>
<li><p><code>memory.max_usage_in_bytes</code></p>
<p><code>cgroup</code> 下进程使用内存的最大值，包含 <code>cgroup</code> 的内存使用量。</p>
</li>
<li><p><code>memory.limit_in_bytes</code></p>
<p>设置 <code>cgroup</code> 下进程最多能使用的内存。如果设置为 <code>-1</code>，表示对该 <code>cgroup</code> 的内存使用不做限制。</p>
<p><code>echo 104960000 &gt; memory.limit_in_bytes</code> 即可配置。</p>
</li>
<li><p><code>memory.soft_limit_in_bytes</code></p>
<p>这个限制并不会阻止进程使用超过配额的内存，只是在系统内存足够时，会优先回收超过限额的内存，使之向限定值靠拢。（例如当使用 <code>swap</code> 分区或者一些页内存超过配额，则可以将这部分内存回收回来，或者转储到硬盘上。）</p>
</li>
<li><p><code>memory.oom_control</code></p>
<p>设置是否在 <code>cgroup</code> 中使用 <code>OOM</code>（<code>Out Of Memory</code>）<code>Killer</code>，默认为使用。当属于该 <code>cgroup</code> 的进程使用的内存超过最大的限定值时，会立刻被 <code>OOM Killer</code> 处理。</p>
</li>
</ul>
<h3 id="Cgroup-driver"><a href="#Cgroup-driver" class="headerlink" title="Cgroup  driver"></a>Cgroup  driver</h3><p>在 <code>systemd</code> 作为 <code>init system</code> 的系统中，默认并存着两套 <code>cgroup driver</code>：</p>
<p><code>systemd</code>：</p>
<ul>
<li>当操作系统使用 <code>systemd</code> 作为 <code>init system</code> 时，初始化进程生成一个根 <code>cgroup</code> 目录结构并作为 <code>cgroup</code> 管理器。</li>
<li><code>systemd</code> 与 <code>cgroup</code> 紧密结合，并且为每个 <code>systemd unit</code> 分配 <code>cgroup</code></li>
</ul>
<p><code>cgroupfs</code>：</p>
<ul>
<li><code>docker</code> 默认用 <code>cgroupfs</code> 作为 <code>cgroup</code> 驱动</li>
</ul>
<p>由于 <code>docker</code> 和 <code>kubelet</code> 默认使用  <code>cgroupfs</code>，而 <code>systemd</code> 拉起的服务由 <code>systemd</code> 驱动管，让 <code>cgroup</code> 管理混乱且容易在资源紧张时引发问题。</p>
<p>因此 <code>kubelet</code> 会默认 <code>--cgroup-driver=systemd</code>，若运行时 <code>cgroup</code> 不一致时，<code>kubelet</code> 会报错。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>Union FS</p>
<ul>
<li>将不同目录挂载到同一个虚拟文件系统上（<code>unite serveral directories into a single virtual filesystem</code>) 的文件系统</li>
<li>支持为每一个成员目录（类似 <code>Git Branch</code>）设定 <code>readonly</code>，<code>readwrite</code> 和 <code>whiteout-able</code> 权限</li>
<li>文件系统分层，对 <code>readonly</code> 权限的 <code>branch</code> 可以逻辑上进行修改（增量地，不影响 <code>readonly</code> 部分的）。</li>
<li>通常 <code>Union FS</code> 有两个用途，一方面可以将多个 <code>disk</code> 挂到同一个目录下，另一个更常用的就是将一个 <code>readonly</code> 的 <code>branch</code> 和一个 <code>writeable</code> 的 <code>branch</code> 联合在一起。</li>
</ul>
<h3 id="容器镜像"><a href="#容器镜像" class="headerlink" title="容器镜像"></a>容器镜像</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240103100712447.png" alt="image-20240103100712447"></p>
<p>例如使用 <code>Dockfile</code>  构建镜像。</p>
<p>通过每一条命令，创建一层镜像，在底层镜像之上，构建上层镜像。</p>
<p>好处是在 <code>devops</code> 时，需要启动一个容器，不需要每个节点上下载全部镜像内容，只下载新增部分或者差异部分即可。</p>
<h3 id="Docker-的文件系统"><a href="#Docker-的文件系统" class="headerlink" title="Docker 的文件系统"></a>Docker 的文件系统</h3><p>典型的 <code>Linux</code> 文件系统组成：</p>
<ul>
<li><p><code>Bootfs</code>（<code>boot file system</code>）</p>
<ul>
<li><code>Bootloader</code> - 引导加载 <code>kernel</code></li>
<li><code>Kernel</code> - 当 <code>kernel</code> 被加载到内存中后 <code>umount bootfs</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240103101538997.png" alt="image-20240103101538997"></p>
</li>
<li><p><code>rootfs</code>（<code>root file system</code>）</p>
<ul>
<li><code>/dev</code>、<code>/proc</code>、<code>/bin</code>、<code>/etc</code> 等标准目录和文件</li>
<li>对于不同的 <code>linux</code> 发行版，<code>bootfs</code> 基本是一致的，但 <code>rootfs</code> 会有差别。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240103101656721.png" alt="image-20240103101656721"></p>
</li>
</ul>
<h3 id="Docker-启动"><a href="#Docker-启动" class="headerlink" title="Docker 启动"></a>Docker 启动</h3><p><code>Linux</code></p>
<ul>
<li>在启动后，首先将 <code>rootfs</code> 设置为 <code>readonly</code>，进行一系列检查，然后将其切换为 <code>readwrite</code> 供用户使用。</li>
</ul>
<p><code>Docker</code></p>
<ul>
<li>初始化时也是将 <code>rootfs</code> 以 <code>readonly</code> 方式加载并检查，然后接下来利用 <code>union mount</code> 的方式，将一个 <code>readwrite</code> 文件系统挂载在 <code>readonly</code> 的 <code>rootfs</code> 之上；</li>
<li>并且允许再次将下层的 <code>FS</code>（<code>file system</code>）设定为 <code>readonly</code> 并且向上叠加</li>
<li>这样一组 <code>readonly</code> 和一个 <code>writeable</code> 的结构构成一个 <code>container</code> 的运行时态，每一个 <code>FS</code> 被称作一个 <code>FS</code> 层。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240103102104646.png" alt="image-20240103102104646"></p>
<h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>由于镜像具有共享特性，所以对容器可写层的操作需要依赖存储驱动提供的写时复制和用时分配机制，以此来支持对容器可写层的修改，进而提高对存储和内存资源的利用率。</p>
<ul>
<li><p>写时复制</p>
<ul>
<li>写时复制，即 <code>Copy-on-Write</code></li>
<li>一个镜像可以被多个容器使用，但是不需要在内存和磁盘上做多个拷贝</li>
<li>在需要对镜像提供的文件进行修改时，该文件会从镜像的文件系统被复制到容器的可写层的文件系统进行修改，而镜像里面的文件不会改变。</li>
<li>不同容器对文件的修改都是相互独立、互不影响。</li>
</ul>
</li>
<li><p>用时分配</p>
<p>按需分配空间，而非提前分配，即当一个文件被创建出来后，才会分配空间。</p>
</li>
</ul>
<h3 id="容器存储驱动"><a href="#容器存储驱动" class="headerlink" title="容器存储驱动"></a>容器存储驱动</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240103102911924.png" alt="image-20240103102911924"></p>
<p>目前容器主流的存储驱动是 <code>OverlayFS</code></p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240103103004115.png" alt="image-20240103103004115"></p>
<h3 id="以-OverlayFS-为例"><a href="#以-OverlayFS-为例" class="headerlink" title="以 OverlayFS 为例"></a>以 OverlayFS 为例</h3><p><code>OverlayFS</code> 也是一种与 <code>AUFS</code> 类似的联合文件系统，同样属于文件级的存储驱动，包含了最初的 <code>Overlay</code> 和更新更稳定的 <code>overlay2</code>.</p>
<p><code>Overlay</code> 只有两层：<code>upper</code> 层和 <code>lower</code> 层，<code>Lower</code> 层代表镜像层，<code>upper</code> 层代表容器可写层。</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240103103156311.png" alt="image-20240103103156311"></p>
<p>例如在 <code>Dockerilfe</code> 中，每一个指令都是从下层往上叠一层，在容器中的文件，要么直接从镜像层获取，要么是从容器层新创建的文件获取。</p>
<h3 id="OverlayFS-使用案例"><a href="#OverlayFS-使用案例" class="headerlink" title="OverlayFS 使用案例"></a>OverlayFS 使用案例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 创建四个目录，用于做准备</span><br><span class="line">//      上层   下层  目标目录 临时工作目录</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> upper lower merged work</span></span><br><span class="line">// 构建下层</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;from lower&quot;</span> &gt; lower/in_lower.txt</span></span><br><span class="line">// 构建上层</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;from upper&quot;</span> &gt; upper/in_upper.txt</span></span><br><span class="line">// 上下层同一个文件，内容不同</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;from lower&quot;</span> &gt; lower/in_both.txt</span></span><br><span class="line">// 上下层同一个文件，内容不同</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;from upper&quot;</span> &gt; upper/in_both.txt</span></span><br><span class="line">// 挂载到 merged 目录</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mount -t overlay overlay -o lowerdir=`<span class="built_in">pwd</span>`/lower,upperdir=`<span class="built_in">pwd</span>`/upper,workdir=`<span class="built_in">pwd</span>`/work `<span class="built_in">pwd</span>`/merged</span></span><br><span class="line">// 查看挂载之后的结果</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> merged/</span></span><br><span class="line">in_lower.txt  in_upper.txt in_both.txt </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> merged/in_both.txt</span></span><br><span class="line">from upper</span><br><span class="line"></span><br><span class="line">// 删除合并之后的 both 文件</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">delete merged/in_both.txt</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> merged/</span></span><br><span class="line">in_lower.txt  in_upper.txt</span><br><span class="line"></span><br><span class="line">// 删除合并之后的下层文件</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">delete merged/in_lower.txt</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l upper/</span></span><br><span class="line">总用量 4</span><br><span class="line">c--------- 1 root root 0, 0 1月   4 12:27 in_both.txt</span><br><span class="line">c--------- 1 root root 0, 0 1月   4 12:28 in_lower.txt</span><br><span class="line">-rw-r--r-- 1 root root   11 1月   4 12:26 in_upper.txt</span><br><span class="line"></span><br><span class="line">// 删除合并之后的上层文件</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">delete merged/in_upper.txt</span></span><br><span class="line"></span><br><span class="line">// merged 里面是空的</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> merged/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l upper/   // 删除合并后的上层文件，其实是删除了上层的文件，上层可写，下层是镜像层。</span></span><br><span class="line">总用量 0</span><br><span class="line">c--------- 1 root root 0, 0 1月   4 12:27 in_both.txt   // 上层可以看到下层的文件</span><br><span class="line">c--------- 1 root root 0, 0 1月   4 12:28 in_lower.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> upper/in_both.txt</span></span><br><span class="line">cat: upper/in_both.txt: 没有那个设备或地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> lower/</span></span><br><span class="line">in_both.txt  in_lower.txt</span><br></pre></td></tr></table></figure>

<p>查看容器详情时，可以直接看到容器的<code>overlayfs</code>信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker inspect 8a77db202e9b</span></span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">		        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/xxx/docker/overlay2/8c88839766cd1d90bebe283a9e2634c8e2fd4f2707375c479287eb5bb7980910-init/diff:/var/lib/xxx/docker/overlay2/53961e498c6657e9372f15861845d3c386642a3cb9ac00f882c49f5d4e01aab5/diff:/var/lib/xxx/docker/overlay2/22b9d9592d3329aeb7427dc015ead91d5830e8d7671182d4106d7fcf4c4ffdaa/diff:/var/lib/xxx/docker/overlay2/687713c2f236e08c11b4893106264e5a2ffe1ff8ff4c578f9941b01673a28df3/diff:/var/lib/xxx/docker/overlay2/52acc6a1047de39d8ddad126bc3f6a10f5d1ca13fec8557115f814e2e65f8a04/diff:/var/lib/xxx/docker/overlay2/f669fa0b144ef5dccce491bdd3ac6257a21463ad704d847dfabcd41437970805/diff:/var/lib/xxx/docker/overlay2/b4bb1ec0613fedf0c8995317a380ef9fbc6a8b7fe503233548ed2d44d3ceebd7/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/xxx/docker/overlay2/8c88839766cd1d90bebe283a9e2634c8e2fd4f2707375c479287eb5bb7980910/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/xxx/docker/overlay2/8c88839766cd1d90bebe283a9e2634c8e2fd4f2707375c479287eb5bb7980910/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/xxx/docker/overlay2/8c88839766cd1d90bebe283a9e2634c8e2fd4f2707375c479287eb5bb7980910/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="OCI-容器标准"><a href="#OCI-容器标准" class="headerlink" title="OCI 容器标准"></a>OCI 容器标准</h2><p><code>Open Container Initiative</code></p>
<ul>
<li><code>OCI</code> 组织于  2015 年创建，是一个致力于定义容器镜像标准和运行时标准的开放式组织</li>
<li><code>OCI</code> 定义了镜像标准（<code>Runtime Specification</code>）、运行时标准（<code>Image Specification</code>）和分发标准（<code>Distribution Specification</code>）<ul>
<li>镜像标准定义应用如何打包</li>
<li>运行时标准定义如何解压应用包并运行</li>
<li>分发标准定义如何分发容器镜像</li>
</ul>
</li>
</ul>
<h2 id="Docker-引擎架构"><a href="#Docker-引擎架构" class="headerlink" title="Docker 引擎架构"></a>Docker 引擎架构</h2><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240103104613595.png" alt="image-20240103104613595"></p>
<p>使用 <code>docker container run</code> 运行一个容器时，是使用 <code>containerd</code> 引擎运行。而 <code>docker</code> 早期本身的架构上，主进程是 <code>docker daemon</code>，其他进程是由主进程 <code>fork</code> 出来的，当 <code>docker</code> 需要更新或者重启，需要重启 <code>docker-daemon</code>，就会导致子进程一并重启。 </p>
<p><code>containerd</code> 引擎，通过 <code>shim</code>进程 <code>fork</code> 出容器子进程 ，当 <code>containerd</code> 主进程重启时，不影响子进程。（<code>shim</code> 的父进程是 <code>systemd</code>，而不是 <code>containerd</code>）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 查看一个容器的进程</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker inspect efd96d555c73 | grep -i pid</span></span><br><span class="line">            &quot;Pid&quot;: 4917,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line"></span><br><span class="line">// 查看这个进程的父进程</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps -ef | grep 4917</span></span><br><span class="line">systemd+  4917  4823  0  2023 ?        00:30:30 mysqld</span><br><span class="line">root      8750  7207  0 11:00 pts/13   00:00:00 grep --color=auto 4917</span><br><span class="line"></span><br><span class="line">// 查看父进程 4823 的信息</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps -ef | grep 4823</span></span><br><span class="line">root      4823     1  0  2023 ?        00:03:47 /usr/bin/containerd-shim-runc-v2 -namespace moby -id efd96d555c73ec357acba410e75c602c40ce82b5ca641e3ce23dedaab0311aa4 -address /run/containerd/containerd.sock</span><br><span class="line">systemd+  4917  4823  0  2023 ?        00:30:30 mysqld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps -p 1</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        01:06:16 systemd</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>4823</code> 进程是 <code>containerd-shim-runc-v2</code>，它的父进程是 <code>PID</code> 为1，也就是 <code>systemd</code>。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>进程在独立的网络 <code>namespace</code> 中，可以有独立的网卡、网络配置等。</p>
<p>在 <code>docker</code> 中，提供多种网络模式：</p>
<ul>
<li><code>Null</code>（–net&#x3D;None）<ul>
<li>把容器放入独立的网络空间但不做任何网络配置；例如 <code>k8s</code> 中</li>
<li>用户需要通过运行 <code>docker network</code> 命令来完成网络配置。</li>
</ul>
</li>
<li><code>Host</code><ul>
<li>使用主机网络名空间，复用主机网络</li>
</ul>
</li>
<li><code>Container</code><ul>
<li>重用其他容器的网络</li>
</ul>
</li>
<li><code>Bridge</code>（<code>--net=bridge</code>）（默认）<ul>
<li>使用 <code>Linux</code> 网桥和 <code>iptables</code> 提供容器互联，<code>Docker</code> 在每台主机上创建一个名叫 <code>docker0</code> 的网桥，通过 <code>veth pair</code> 来连接该主机的每一个 <code>EndPoint</code></li>
</ul>
</li>
</ul>
<p>当扩展到多个机器上，需要主机之间通信，而且需要容器之间相互隔离和有独立的网络，就无法直接使用主机网络。</p>
<p>解决方式有两种：</p>
<ul>
<li><code>Remote</code>（<code>network with remote drivers</code>）<ul>
<li><code>Underlay</code>：<ul>
<li>使用现有底层网络，为每一个容器配置可路由的网络 <code>IP</code></li>
</ul>
</li>
<li><code>Overlay</code>（<code>libnetwork</code>，<code>libkv</code>）：<ul>
<li>通过网络封包实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Null-模式"><a href="#Null-模式" class="headerlink" title="Null 模式"></a>Null 模式</h3><ul>
<li><code>Null</code> 模式是一个空实现；</li>
<li>可以通过 <code>Null</code> 模式启动容器并在宿主机上通过命令为容器配置网络</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 创建 network 的 ns 的临时目录</span><br><span class="line">mkdir -p /var/run/netns</span><br><span class="line">find -L /var/run/netns -type l -delete</span><br><span class="line"></span><br><span class="line">// 开启一个容器，例如nginx，获取到 pid</span><br><span class="line">docker run --network=none -d nginx</span><br><span class="line">docker ps | grep nginx </span><br><span class="line">docker inspect &lt;container_id&gt; | grep -i pid </span><br><span class="line"></span><br><span class="line">// 链接出来，操作更方便</span><br><span class="line">ln -s /proc/$pid/ns/net /var/run/netns/$pid </span><br><span class="line"></span><br><span class="line">// 创建一个 veth ，上面两个口，A 口和 B 口</span><br><span class="line">ip link add A type veth peer name B</span><br><span class="line">// 查看当前 docker0 网桥的状态</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">brctl show</span></span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">docker0		8000.0242838bdad8	no</span><br><span class="line"></span><br><span class="line">// br0上插 A 口，并且打开 A 口</span><br><span class="line">brctl addif docker0 A</span><br><span class="line">ip link set A up</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">brctl show docker0</span></span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">docker0		8000.0242838bdad8	no		A</span><br><span class="line"></span><br><span class="line">// 获取主机上的 docker 网络配置</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip a show docker0</span></span><br><span class="line">4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:83:8b:da:d8 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:83ff:fe8b:dad8/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 设置 B 口，命名、打开、配置 IP</span><br><span class="line">ip link set B netns $pid</span><br><span class="line">ip netns exec $pid ip link set dev B name eth0 </span><br><span class="line">ip netns exec $pid ip link set eth0 up</span><br><span class="line">ip netns exec $pid ip addr add $SETIP/$SETMASK dev eth0</span><br><span class="line">ip netns exec $pid ip route add default via $GATEWAY</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 例如</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip netns <span class="built_in">exec</span> 4854 ip addr add 172.17.0.100/16 dev eth0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip netns <span class="built_in">exec</span> 4854 ip route add default via 172.17.0.1</span></span><br><span class="line">// 此时，主机和docker之间就可以通过 veth 通信</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl 172.17.0.100</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="默认模式-Bridge-和-NAT"><a href="#默认模式-Bridge-和-NAT" class="headerlink" title="默认模式 - Bridge 和 NAT"></a>默认模式 - Bridge 和 NAT</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240103115105833.png" alt="image-20240103115105833"></p>
<p>例如，为主机 <code>eth0</code> 分配IP <code>192.168.0.101</code>；</p>
<p>启动 <code>docker daemon</code>，查看主机 <code>iptables</code>；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POSTROUTING -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span><br></pre></td></tr></table></figure>

<p>在主机启动容器：</p>
<ul>
<li><code>docker run -d --name ssh -p 2333:22 centos-ssh</code></li>
<li><code>Docker</code> 会以标准模式配置网络：<ul>
<li>创建 <code>veth pair</code>；</li>
<li>将 <code>veth pair</code> 的一端连接到 <code>docker0</code> 网桥；</li>
<li><code>veth pair</code> 的另一端设置为容器名空间的 <code>eth0</code>；</li>
<li>为容器名空间的 <code>eth0</code> 分配 <code>ip</code>；</li>
<li>主机上的 <code>iptables</code> 规则：<code>PREROUTING -A DOCKER ! -i docker0 -p tcp -m tcp --dport 2333 -j DNAT --to- destination 172.17.0.2:22</code></li>
</ul>
</li>
</ul>
<h3 id="Underlay"><a href="#Underlay" class="headerlink" title="Underlay"></a>Underlay</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240103170022413.png" alt="image-20240103170022413"></p>
<p>借助主机网卡，通过虚拟网桥实现交换机功能，让容器直接从外部网络中获取网络信息；</p>
<ul>
<li>采用 <code>Linux</code> 网桥设备（<code>sbrctl</code>），通过物理网络连通容器；</li>
<li>创建新的网桥设备 <code>mydr0</code>；</li>
<li>将主机网卡加入网桥；</li>
<li>把主机网卡的地址配置到网桥，并把默认路由规则转移到网桥 <code>mydr0</code>；</li>
<li>启动容器；</li>
<li>创建 <code>veth</code> 对，并且把一个 <code>peer</code> 添加到网桥 <code>mydr0</code>；</li>
<li>配置容器把 <code>veth</code> 的另一个 <code>peer</code> 分配给容器网卡；</li>
</ul>
<h3 id="Docker-Libnetwork-Overlay"><a href="#Docker-Libnetwork-Overlay" class="headerlink" title="Docker Libnetwork Overlay"></a>Docker Libnetwork Overlay</h3><ul>
<li><code>Docker overlay</code> 网络驱动原生支持多主机网络；</li>
<li><code>Libnetwork</code> 是一个内置的基于 <code>VXLAN</code> 的网络驱动；</li>
</ul>
<h4 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h4><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240103170440937.png" alt="image-20240103170440937"></p>
<p>在每一个主机上都有一个设备，例如 <code>VTEP-1</code>，在处理处理容器网络包时，在外层封装一层源地址和源MAC，通过网络进行转发，经过路由到另外一台主机上之后，通过解压缩获取到对端网络信息以及它的目标网络信息。这种方式封装和解封装数据包会影响性能。</p>
<h3 id="Overlay-network-sample-Flannel"><a href="#Overlay-network-sample-Flannel" class="headerlink" title="Overlay network sample - Flannel"></a>Overlay network sample - Flannel</h3><p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240103170836063.png" alt="image-20240103170836063"></p>
<ul>
<li>同一主机内的 <code>Pod</code> 可以使用网桥进行通信；</li>
<li>不同主机上的 <code>Pod</code> 将通过 <code>flanneld</code> 将其流量封装在 <code>UDP</code> 数据包中。</li>
</ul>
<p>需要在每个设备上安装 <code>flannneld</code>，跨主机的包都需要通过 <code>flanneld</code> 封装包。</p>
<p>Flannel Packet Sample</p>
<p><code>flanneld</code> 抓包示例：</p>
<p><img src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2024/01/image-20240103171044864.png" alt="image-20240103171044864"></p>
<p>可以看到，其实是一个 <code>ICMP</code> 协议的包，外层是 <code>IPV4</code>，但是 <code>IPV4</code> 外层还封装了一层 <code>UDP</code>，然后在 <code>UDP</code> 外层再封装 <code>IPV4</code>。</p>
<h2 id="创建-docker-镜像"><a href="#创建-docker-镜像" class="headerlink" title="创建 docker 镜像"></a>创建 docker 镜像</h2><p>定义 <code>dockerfile</code></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># so apt-get doesn&#x27;t complain</span></span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/^exit 101/exit 0/&#x27;</span> /usr/sbin/policy-rc.d</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> \</span></span><br><span class="line"><span class="language-bash">	apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">	apt-get install -y ca-certificates &amp;&amp; \ </span></span><br><span class="line">	apt-get install -y curl &amp;&amp; \</span><br><span class="line">	rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> ./bin/eic eic </span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/eic&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>定义之后 <code>docker build .</code></p>
<h1 id="Dockerfile-的最佳实践"><a href="#Dockerfile-的最佳实践" class="headerlink" title="Dockerfile 的最佳实践"></a>Dockerfile 的最佳实践</h1><p><code>Docker</code> 遵循 <code>12-Factor</code> 的原则管理和构建应用；</p>
<p>核心是进程无状态和无共享。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly8xMmZhY3Rvci5uZXQv">https://12factor.net/<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yODYxMDAzNTc=">https://zhuanlan.zhihu.com/p/286100357<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="构建上下文（Build-Context）"><a href="#构建上下文（Build-Context）" class="headerlink" title="构建上下文（Build Context）"></a>构建上下文（Build Context）</h2><ul>
<li><p>当运行 <code>docker build</code> 命令时，当前工作目录被称为构建上下文；</p>
</li>
<li><p><code>docker build</code> 默认查找当前目录的 <code>Dockerfile</code> 作为构建输入，也可以通过 <code>-f</code> 指定 <code>Dockerfile</code>。</p>
<ul>
<li><code>docker build -f ./Dockerfile</code></li>
</ul>
</li>
<li><p>当 <code>docker build</code> 运行时，首先会把构建上下文传输给 <code>docker daemon</code>，把没用的文件包含在构建上下文时，会导致传输时间长，构建需要的资源多，构建出的镜像大等问题。</p>
<ul>
<li><p>例如可以尝试在一个包含很多目录的目录下，运行下面的命令，会感受到差异</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /xxx/xxx/xxx/Dockerfile</span><br><span class="line">docker build /xxx/xxx/xxx/</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过 <code>.dockerignore</code> 文件从编译上下文排除某些文件</p>
</li>
</ul>
</li>
<li><p>因此需要确保构建上下文清晰，比如创建一个专门的目录放置 <code>Dockerfile</code>，并在目录中运行 <code>docker build</code></p>
</li>
</ul>
<h2 id="镜像构建日志"><a href="#镜像构建日志" class="headerlink" title="镜像构建日志"></a>镜像构建日志</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon 14.57MB</span><br><span class="line">Step 1/4 : FROM ubuntu </span><br><span class="line">---&gt; cf0f3ca922e0</span><br><span class="line">Step 2/4 : ENV MY_SERVICE_PORT=80</span><br><span class="line">---&gt; Using cache</span><br><span class="line">---&gt; a7d824f74410</span><br><span class="line">Step 3/4 : ADD bin/amd64/httpserver /httpserver</span><br><span class="line">---&gt; Using cache</span><br><span class="line">---&gt; 00bb47fce704</span><br><span class="line">Step 4/4 : ENTRYPOINT /httpserver</span><br><span class="line">---&gt; Using cache</span><br><span class="line">---&gt; f77ee3366d08 </span><br><span class="line">Successfully built f77ee3366d08</span><br></pre></td></tr></table></figure>

<h3 id="Build-Cache"><a href="#Build-Cache" class="headerlink" title="Build Cache"></a>Build Cache</h3><p>构建容器镜像时，<code>Docker</code> 依次读取 <code>Dockerfile</code> 中的指令，并按顺序依次执行构建指令。</p>
<p><code>Docker</code> 读取指令后，会先判断缓存中是否有可用的已存镜像，只有已存镜像不存在时才会重新构建。</p>
<ul>
<li>通常 <code>Docker</code> 简单判断 <code>Dockerfile</code> 中的指令与镜像</li>
<li>针对 <code>ADD</code> 和 <code>COPY</code> 指令，<code>Docker</code> 判断该镜像层每一个文件的内容并生成一个 <code>checksum</code>，与现存镜像比较时，<code>Docker</code> 比较的是二者的 <code>checksum</code></li>
<li>其他指令，比如 <code>RUN apt-get -y update</code>，<code>Docker</code> 简单比较与现存镜像中的指令字串是否一致。</li>
<li>当某一层 <code>cache</code> 失效以后，后续所有层级的 <code>cache</code> 均一并失效，后续指令都重新构建镜像。</li>
</ul>
<p>因此，构建时，应该将变动不频繁的指令放在前面，将变动频繁的指令放在后面，尽量使用缓存，降低镜像拉取和存储的消耗的资源。</p>
<h2 id="多段构建（Multi-stage-build）"><a href="#多段构建（Multi-stage-build）" class="headerlink" title="多段构建（Multi-stage build）"></a>多段构建（Multi-stage build）</h2><p>比如在构建比较复杂的应用时，需要有很多的依赖包，而只需要更换最后一个执行文件，此时就可以通过多段构建来将准备环境打包到一个基础镜像。</p>
<p>有效减少镜像层级的方式。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 基础镜像，下载包</span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.16</span>-alpine AS build</span><br><span class="line">// 准备环境</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache git</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get github.com/golang/dep/cmd/dep</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> Gopkg.lock Gopkg.toml /go/src/project/ </span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/project/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dep ensure -vendor-only</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /go/src/project/</span></span><br><span class="line"></span><br><span class="line">// 基础包中，核心内容就是这一个二进制文件</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o /bin/project (只有这个二进制文件是产线需要的，其他都是waste)</span></span><br><span class="line"></span><br><span class="line">// 安装包，将二进制文件拷贝过来即可</span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /bin/project /bin/project </span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/bin/project&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--help&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile-常用指令"><a href="#Dockerfile-常用指令" class="headerlink" title="Dockerfile 常用指令"></a>Dockerfile 常用指令</h2><ul>
<li><p><code>FROM</code>：选择基础镜像，推荐 <code>alpine</code></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LABELS</code>：按标签组织项目</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> multi.label1=<span class="string">&quot;value1&quot;</span> multi.label2=<span class="string">&quot;value2&quot;</span> other=<span class="string">&quot;value3”</span></span></span><br></pre></td></tr></table></figure>

<p>配合 <code>label filter</code> 可过滤镜像查询结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -f label=multi.label1=&quot;value1&quot;</span><br></pre></td></tr></table></figure>

<p>例如 <code>auth</code> 之类也可以通过 <code>LABELS</code></p>
</li>
<li><p><code>RUN</code>：执行命令</p>
<p>最常见的用法是 <code>RUN apt-get update &amp;&amp; apt-get install</code>，这两条命令应该永远用 <code>&amp;&amp;</code> 连接，如果分开执行，<code>RUN apt-get update</code> 构建层被缓存，可能会导致新 <code>package</code> 无法安装。另外，连接起来也可以有效的减少镜像 <code>overlay</code> 层级。</p>
</li>
<li><p><code>CMD</code>：容器镜像中包含应用的运行命令，需要带参数</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>...]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>EXPOSE</code>：发布端口</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure>

<ul>
<li>是镜像创建者和使用者的约定，约定需要暴露哪些端口</li>
<li>在 <code>docker run -P</code> 时（使用 <code>-p</code> 时可以指定端口和映射端口），<code>docker</code> 会自动映射 <code>expose</code> 的端口到主机大端口，大端口会随机选择，如 <code>0.0.0.0:32768-&gt;80/tcp</code></li>
</ul>
</li>
<li><p><code>ENV</code>：设置环境变量</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt;...</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ADD</code>：从源地址（文件，目录或者 <code>URL</code>）复制文件到目标路径</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;src&gt;&quot;</span>,... <span class="string">&quot;&lt;dest&gt;&quot;</span>] (路径中有空格时使用)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>ADD</code> 支持 Go 风格的通配符，如 <code>ADD check* /testdir/</code></li>
<li><code>scr</code> 如果是文件，则必须包含在编译上下文中，<code>ADD</code> 指令无法添加编译上下文之外的文件</li>
<li><code>src</code> 如果是 <code>RUL</code>：<ul>
<li>如果 <code>dest</code> 结尾没有 <code>/</code>，那么 <code>dest</code> 是目标文件名</li>
<li>如果 <code>dest</code> 结尾有 <code>/</code>，那么 <code>dest</code> 是目标目录名</li>
</ul>
</li>
<li><code>src</code> 如果是一个目录，则所有文件都会被复制至 <code>dest</code></li>
<li><code>src</code> 如果是一个本地压缩文件，则在 <code>ADD</code> 的同时完整解压操作</li>
<li>如果 <code>dest</code> 不存在，则 <code>ADD</code> 指令会创建目标目录</li>
<li>应尽量减少通过 <code>ADD URL</code> 添加 <code>remote</code> 文件，建议使用 <code>curl</code> 或者 <code>wget &amp;&amp; untar</code> （主要是这个命令理解困难，而且可控力度少）</li>
</ul>
</li>
<li><p><code>COPY</code>：从源地址（文件，目录）复制文件到目标路径</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;src&gt;&quot;</span>,... <span class="string">&quot;&lt;dest&gt;&quot;</span>] // 路径中有空格时使用</span></span><br></pre></td></tr></table></figure>

<p><code>COPY</code> 的使用与 <code>ADD</code> 类似，但有如下区别：</p>
<ul>
<li><p><code>COPY</code> 只支持本地文件的复制，不支持 <code>URL</code></p>
</li>
<li><p><code>COPY</code> 不解压文件</p>
</li>
<li><p><code>COPY</code> 可以用于多阶段编译场景，可以用前一个临时镜像中拷贝文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /bin/project /bin/project</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>COPY</code> 语义上更加直白，复制本地文件时，优先使用 <code>COPY</code>。</p>
</li>
<li><p><code>ENTRYPOINT</code>：定义可以执行的容器镜像入口命令</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>] // docker run参数追加模式 </span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> <span class="built_in">command</span> param1 param2 // docker run 参数替换模式</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>docker run -entrypoint</code> 可替换 <code>Dockerfile</code> 中定义的 <code>ENTRYPOINT</code></p>
</li>
<li><p><code>ENTRYPOINT</code> 的最佳实践是用 <code>ENTRYPOINT</code> 定义镜像主命令，并通过 <code>CMD</code> 定义主要参数，如下所示</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;s3cmd&quot;</span>] </span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--help&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>VOLUME</code>：将指定目录定义为外挂存储卷，<code>Dockfile</code> 中在该指令之后所有对同一目录的修改都无效</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/data&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>等价于 <code>docker run -v /data</code>，可通过 <code>docker inspect</code> 查看主机的 <code>mount point</code>。</p>
<p>一般用来保护某个目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/volumes/&lt;containerid&gt;/_data</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>USER</code>：切换运行镜像的用户和用户组，因安全性要求，越来越多的场景要求容器应用要以 <code>non-root</code> 身份运行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;<span class="keyword">user</span>&gt;[:&lt;group&gt;]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>WORKDIR</code>：等价于 <code>cd</code>，切换工作目录 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其他非常用指令：</p>
<ul>
<li><code>ARG</code>：构建参数，没有指定则使用默认，可以在构建过程中传递；</li>
<li><code>ONBUILD</code></li>
<li><code>STOPSIGNAL</code></li>
<li><code>HEALTHCHECK</code></li>
<li><code>SHELL</code></li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul>
<li>不要安装无效软件包；会徒增镜像容量</li>
<li>应简化镜像中同时运行的进程数，理想状况下，每个镜像应该只有一个进程；这样易于管理，易于监控状态</li>
<li>当无法避免同一镜像运行多进程时，应选择合理的初始化进程（<code>init process</code>）</li>
<li>最小化层级数<ul>
<li>最新的 <code>docker</code> 只有 <code>RUN</code>、<code>COPY</code>、<code>ADD</code> 创建新层，其他指令创建临时层，不会增加镜像大小。<ul>
<li>比如 <code>EXPOST</code> 指令就不会生成新层</li>
</ul>
</li>
<li>多条 <code>RUN</code> 命令可通过连接符连接成一条指令集以减少层数</li>
<li>通过多段构建减少镜像层数</li>
</ul>
</li>
<li>把多行参数按字母排序，可以减少可能出现的重复参数，并且提高可读性</li>
<li>编写 <code>dockerfile</code> 的时候，应该把变更频率低的编译指令优先构建，以便放在镜像底层以有效利用 <code>build cache</code></li>
<li>复制文件时，每个文件应独立复制，这确保某个文件变更时，只影响该文件对应的缓存。</li>
</ul>
<p>目标是：易管理、少漏洞、镜像小、层级少、利用缓存</p>
<h3 id="多进程的容器镜像"><a href="#多进程的容器镜像" class="headerlink" title="多进程的容器镜像"></a>多进程的容器镜像</h3><ul>
<li>选择适当的 <code>init</code> 进程<ul>
<li>需要捕获 <code>SIGTERM</code> 信号并完成子进程的优雅终止</li>
<li>负责清理退出的子进程以避免僵尸进程</li>
</ul>
</li>
</ul>
<p>开源项目：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tyYWxsaW4vdGluaSVFRiVCQyU4QyVFOSU4MCU5QSVFOCVCRiU4Nw==">https://github.com/krallin/tini，通过<i class="fa fa-external-link-alt"></i></span> <code>tini</code> 作为初始化进程管理子进程。</p>
<h3 id="Docker-镜像管理"><a href="#Docker-镜像管理" class="headerlink" title="Docker 镜像管理"></a>Docker 镜像管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// save 可以将镜像保存为 tar 包，load可以将 tar 包解压成镜像</span><br><span class="line">docker save/load </span><br><span class="line">// tag 可以给镜像打标签</span><br><span class="line">docker tag </span><br><span class="line">// push将镜像推送到远端镜像仓，pull从远端镜像仓拉取镜像到本地</span><br><span class="line">docker push/pull</span><br></pre></td></tr></table></figure>

<h3 id="基于-Docker-镜像的版本管理"><a href="#基于-Docker-镜像的版本管理" class="headerlink" title="基于 Docker 镜像的版本管理"></a>基于 Docker 镜像的版本管理</h3><ul>
<li><p><code>docker tag</code></p>
<p>命令可以为容器镜像添加标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 0e5574283393 xxx.xxx.com/bbb/httpserver:v1.0</span><br></pre></td></tr></table></figure>

<p><code>xxx.xxx.com</code>：镜像仓库地址，如果不填，则默认为 <code>hub.docker.com</code></p>
<p><code>bbb</code>：代表仓库地址的 <code>repositry</code></p>
<p><code>httpserver</code>：镜像名</p>
<p><code>v1.0</code>：tag，常用来记录版本信息</p>
</li>
</ul>
<h3 id="Docker-tag-与-github-的版本管理合力"><a href="#Docker-tag-与-github-的版本管理合力" class="headerlink" title="Docker tag 与 github 的版本管理合力"></a>Docker tag 与 github 的版本管理合力</h3><p>以 Kubernetes 为例</p>
<ul>
<li>开发分支<ul>
<li><code>git checkout master</code></li>
</ul>
</li>
<li>Release 分支<ul>
<li><code>git checkout -b release-1.21</code></li>
</ul>
</li>
<li>在并星期，所有的变更同时放进 <code>master</code> 和 <code>release branch</code></li>
<li>版本发布<ul>
<li>以 <code>release branch</code> 为基础构建镜像，并为镜像标记版本信息：<code>docker tag 0e5574283393 k8s.io/kubernetes/apiserver:v1.21</code></li>
</ul>
</li>
<li>在 <code>github</code> 中保存 <code>release</code> 代码快照<ul>
<li><code>git tag v1.21</code></li>
</ul>
</li>
</ul>
<p>当内部使用临时测试镜像时，还可以使用 <code>github</code> 的 <code>git</code> 号和提交次数，作为版本号标记。</p>
<h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><p><code>Docker hub</code>：<span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=">https://hub.docker.com/<i class="fa fa-external-link-alt"></i></span></p>
<p>创建私有镜像仓库：<code>docker run -d -p 5000:5000 registry</code></p>
<h1 id="Docker-优势"><a href="#Docker-优势" class="headerlink" title="Docker 优势"></a>Docker 优势</h1><ul>
<li>封装性<ul>
<li>不需要再启动内核，所以应用扩缩容时可以秒速启动</li>
<li>资源利用率高，直接使用宿主机内核调度资源，性能损失小</li>
<li>方便的 <code>CPU</code>、内存资源调整</li>
<li>能实现秒级快速回滚</li>
<li>一键启动所有依赖服务，测试不用为搭建环境犯愁，PE 也不用为建站复杂担心</li>
<li>镜像一次编译，随处使用</li>
<li>测试、生产环境高度一致（数据除外）</li>
</ul>
</li>
<li>镜像增量分发<ul>
<li>由于采用了 <code>Union FS</code>，简单来说，就是支持将不同的目录挂载到同一个虚拟文件系统下，并实现一种 <code>layer</code> 的概念，每次发布只传输变化的部分，节约带宽</li>
</ul>
</li>
<li>隔离性<ul>
<li>应用的运行环境和宿主机环境无关，完全由镜像控制，一台物理机上部署多种环境的镜像测试</li>
<li>多个应用版本可以并存在机器上</li>
</ul>
</li>
<li>社区活跃<ul>
<li>Docker 命令简单、易用，社区十分活跃，且周边组件丰富</li>
</ul>
</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vWGlhb2xpQm95L3AvMTA0MTA2ODYuaHRtbA==">Linux内核CFS调度器<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcHJvY2Vzc19tYW5hZ2VtZW50LzQ1MS5odG1s">CFS调度器（5）-带宽控制<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaXppeHMuY29tLzIwMTcvMDgvMjkvbGludXgtbmFtZXNwYWNlLw==">docker 容器基础技术：linux namespace 简介<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tb2Vsb3ZlLmluZm8vMjAyMS8xMi8xMC8lRTYlOTAlOUUlRTYlODclODIlRTUlQUUlQjklRTUlOTklQTglRTYlOEElODAlRTYlOUMlQUYlRTclOUElODQlRTUlOUYlQkElRTclOUYlQjMtbmFtZXNwYWNlLSVFNCVCOCU4QS8=">搞懂容器技术的基石： namespace （上）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tb2Vsb3ZlLmluZm8vMjAyMS8xMi8xMy8lRTYlOTAlOUUlRTYlODclODIlRTUlQUUlQjklRTUlOTklQTglRTYlOEElODAlRTYlOUMlQUYlRTclOUElODQlRTUlOUYlQkElRTclOUYlQjMtbmFtZXNwYWNlLSVFNCVCOCU4Qi8=">搞懂容器技术的基石： namespace （下）<i class="fa fa-external-link-alt"></i></span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/52fe.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 小夜时雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/52fe.html" class="post-title-link" itemprop="url">channel原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-25 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-25T00:00:00+08:00">2023-12-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-26 09:21:17" itemprop="dateModified" datetime="2023-12-26T09:21:17+08:00">2023-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GoTrainingCamp/" itemprop="url" rel="index"><span itemprop="name">Go训练营</span></a>
        </span>
    </span>

  
    <span id="/post/52fe.html" class="post-meta-item leancloud_visitors" data-flag-title="channel原理" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>通道是 Go 语言中用于协程之间通信的重要机制。通过阻塞和同步的方式，通道实现了安全的数据传递和协程之间的同步操作。通道的实现依赖于调度器和锁机制，通过队列和阻塞机制实现数据的传递。通道在并发编程中具有广泛的应用场景，可以提高程序的可靠性和性能。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/52fe.html">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/ede3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 小夜时雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/ede3.html" class="post-title-link" itemprop="url">Go runtime之 GC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-21 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-21T00:00:00+08:00">2023-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-29 16:11:29" itemprop="dateModified" datetime="2023-12-29T16:11:29+08:00">2023-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GoTrainingCamp/" itemprop="url" rel="index"><span itemprop="name">Go训练营</span></a>
        </span>
    </span>

  
    <span id="/post/ede3.html" class="post-meta-item leancloud_visitors" data-flag-title="Go runtime之 GC" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Go runtime 的垃圾回收（Garbage Collection）是实现自动内存管理的关键组成部分。Go 的垃圾回收器采用了一系列策略和算法，旨在提供高效的内存回收，并减少开发者对内存管理的负担。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/ede3.html">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/ab88.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 小夜时雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/ab88.html" class="post-title-link" itemprop="url">Go runtime之内存分配</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-15 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-15T00:00:00+08:00">2023-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-22 17:03:21" itemprop="dateModified" datetime="2023-12-22T17:03:21+08:00">2023-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GoTrainingCamp/" itemprop="url" rel="index"><span itemprop="name">Go训练营</span></a>
        </span>
    </span>

  
    <span id="/post/ab88.html" class="post-meta-item leancloud_visitors" data-flag-title="Go runtime之内存分配" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Go runtime 的内存分配是其高效性和并发性的关键组成部分之一。Go 在内存分配方面采用了一些策略和算法，以提供快速的内存分配和高效的垃圾回收。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/ab88.html">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/c06b.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 小夜时雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/c06b.html" class="post-title-link" itemprop="url">Go runtime之 Goroutine 原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-13 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-13T00:00:00+08:00">2023-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-22 17:03:26" itemprop="dateModified" datetime="2023-12-22T17:03:26+08:00">2023-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GoTrainingCamp/" itemprop="url" rel="index"><span itemprop="name">Go训练营</span></a>
        </span>
    </span>

  
    <span id="/post/c06b.html" class="post-meta-item leancloud_visitors" data-flag-title="Go runtime之 Goroutine 原理" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Goroutine 是 Go 编程语言中一种轻量级的并发执行单元，它是 Go runtime 的核心特性之一。Goroutine 允许开发者以一种简单、高效且可扩展的方式编写并发代码。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/c06b.html">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/b09f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 小夜时雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/b09f.html" class="post-title-link" itemprop="url">多活</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-11 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-11T00:00:00+08:00">2023-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-12 16:33:33" itemprop="dateModified" datetime="2023-12-12T16:33:33+08:00">2023-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GoTrainingCamp/" itemprop="url" rel="index"><span itemprop="name">Go训练营</span></a>
        </span>
    </span>

  
    <span id="/post/b09f.html" class="post-meta-item leancloud_visitors" data-flag-title="多活" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文将探讨多活（Multi-Region）架构在现代云计算和分布式系统中的重要性和应用。多活是一种设计原则和技术，通过在服务范围内部署多个数据中心或区域，实现高可用性、弹性和容错能力。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/b09f.html">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/9a24.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 小夜时雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/9a24.html" class="post-title-link" itemprop="url">DNS & CND</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-07 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-07T00:00:00+08:00">2023-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-12 16:31:38" itemprop="dateModified" datetime="2023-12-12T16:31:38+08:00">2023-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GoTrainingCamp/" itemprop="url" rel="index"><span itemprop="name">Go训练营</span></a>
        </span>
    </span>

  
    <span id="/post/9a24.html" class="post-meta-item leancloud_visitors" data-flag-title="DNS & CND" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章将探讨DNS（域名系统）和CDN（内容分发网络）的重要性和功能，介绍一些常见的DNS和CDN优化策略，以提高网站的可用性、安全性和性能。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/9a24.html">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/c682.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 小夜时雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/c682.html" class="post-title-link" itemprop="url">微服务可观察性之链路追踪</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-06 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-06T00:00:00+08:00">2023-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-07 10:19:38" itemprop="dateModified" datetime="2023-12-07T10:19:38+08:00">2023-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GoTrainingCamp/" itemprop="url" rel="index"><span itemprop="name">Go训练营</span></a>
        </span>
    </span>

  
    <span id="/post/c682.html" class="post-meta-item leancloud_visitors" data-flag-title="微服务可观察性之链路追踪" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章将探讨微服务架构中关键的可观察性工具之一——链路追踪。我们将深入研究链路追踪的概念，重点介绍它在微服务环境中的作用和优势。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/c682.html">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.xiaoyeshiyu.com/post/cfd3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Mitaka xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小夜时雨">
      <meta itemprop="description" content="Golang开发博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 小夜时雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/cfd3.html" class="post-title-link" itemprop="url">微服务可观察性之日志</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-30 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-30T00:00:00+08:00">2023-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-06 11:51:43" itemprop="dateModified" datetime="2023-12-06T11:51:43+08:00">2023-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/GoTrainingCamp/" itemprop="url" rel="index"><span itemprop="name">Go训练营</span></a>
        </span>
    </span>

  
    <span id="/post/cfd3.html" class="post-meta-item leancloud_visitors" data-flag-title="微服务可观察性之日志" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章将深入探讨微服务架构中的可观察性，着重于日志记录作为关键的监控和调试工具。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/cfd3.html">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mitaka xu</span>
</div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW95ZXNoaXl1" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"TVx6Wkfs8VJGOwYPurtjWY2e-9Nh9j0Va","app_key":"c7VvaRnyF8r3DUIPq1x2KJ7Q","server_url":"https://tvx6wkfs.lc-cn-e1-shared.com","security":true}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"xiaoyeshiyu","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
